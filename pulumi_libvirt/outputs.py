# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'DomainBlockIoTune',
    'DomainBlockIoTuneDevice',
    'DomainClock',
    'DomainClockTimer',
    'DomainClockTimerCatchUp',
    'DomainCpu',
    'DomainCpuCache',
    'DomainCpuFeature',
    'DomainCpuMaxPhysAddr',
    'DomainCpuNuma',
    'DomainCpuNumaCell',
    'DomainCpuNumaCellCach',
    'DomainCpuNumaCellCachLine',
    'DomainCpuNumaCellCachSize',
    'DomainCpuNumaCellDistances',
    'DomainCpuNumaCellDistancesSibling',
    'DomainCpuNumaInterconnects',
    'DomainCpuNumaInterconnectsBandwidth',
    'DomainCpuNumaInterconnectsLatency',
    'DomainCpuTopology',
    'DomainCpuTune',
    'DomainCpuTuneCacheTune',
    'DomainCpuTuneCacheTuneCach',
    'DomainCpuTuneCacheTuneMonitor',
    'DomainCpuTuneEmulatorPin',
    'DomainCpuTuneEmulatorSched',
    'DomainCpuTuneIoThreadPin',
    'DomainCpuTuneIoThreadSched',
    'DomainCpuTuneMemoryTune',
    'DomainCpuTuneMemoryTuneMonitor',
    'DomainCpuTuneMemoryTuneNode',
    'DomainCpuTuneVcpuPin',
    'DomainCpuTuneVcpuSched',
    'DomainCreate',
    'DomainDefaultIoThread',
    'DomainDestroy',
    'DomainDevices',
    'DomainDevicesAudio',
    'DomainDevicesAudioAlsa',
    'DomainDevicesAudioAlsaInput',
    'DomainDevicesAudioAlsaOutput',
    'DomainDevicesAudioCoreAudio',
    'DomainDevicesAudioCoreAudioInput',
    'DomainDevicesAudioCoreAudioOutput',
    'DomainDevicesAudioDbus',
    'DomainDevicesAudioDbusInput',
    'DomainDevicesAudioDbusOutput',
    'DomainDevicesAudioFile',
    'DomainDevicesAudioFileInput',
    'DomainDevicesAudioFileOutput',
    'DomainDevicesAudioJack',
    'DomainDevicesAudioJackInput',
    'DomainDevicesAudioJackOutput',
    'DomainDevicesAudioNone',
    'DomainDevicesAudioNoneInput',
    'DomainDevicesAudioNoneOutput',
    'DomainDevicesAudioOss',
    'DomainDevicesAudioOssInput',
    'DomainDevicesAudioOssOutput',
    'DomainDevicesAudioPipeWire',
    'DomainDevicesAudioPipeWireInput',
    'DomainDevicesAudioPipeWireOutput',
    'DomainDevicesAudioPulseAudio',
    'DomainDevicesAudioPulseAudioInput',
    'DomainDevicesAudioPulseAudioOutput',
    'DomainDevicesAudioSdl',
    'DomainDevicesAudioSdlInput',
    'DomainDevicesAudioSdlOutput',
    'DomainDevicesAudioSpice',
    'DomainDevicesAudioSpiceInput',
    'DomainDevicesAudioSpiceOutput',
    'DomainDevicesChannel',
    'DomainDevicesChannelAcpi',
    'DomainDevicesChannelAddress',
    'DomainDevicesChannelAlias',
    'DomainDevicesChannelLog',
    'DomainDevicesChannelProtocol',
    'DomainDevicesChannelSource',
    'DomainDevicesChannelSourceDbus',
    'DomainDevicesChannelSourceDev',
    'DomainDevicesChannelSourceDevSecLabel',
    'DomainDevicesChannelSourceFile',
    'DomainDevicesChannelSourceFileSecLabel',
    'DomainDevicesChannelSourceNmdm',
    'DomainDevicesChannelSourcePipe',
    'DomainDevicesChannelSourcePipeSecLabel',
    'DomainDevicesChannelSourcePty',
    'DomainDevicesChannelSourcePtySecLabel',
    'DomainDevicesChannelSourceQemuvdAgent',
    'DomainDevicesChannelSourceQemuvdAgentClipBoard',
    'DomainDevicesChannelSourceQemuvdAgentMouse',
    'DomainDevicesChannelSourceSpicePort',
    'DomainDevicesChannelSourceTcp',
    'DomainDevicesChannelSourceTcpReconnect',
    'DomainDevicesChannelSourceUdp',
    'DomainDevicesChannelSourceUnix',
    'DomainDevicesChannelSourceUnixReconnect',
    'DomainDevicesChannelSourceUnixSecLabel',
    'DomainDevicesChannelTarget',
    'DomainDevicesChannelTargetGuestFwd',
    'DomainDevicesChannelTargetVirtIo',
    'DomainDevicesChannelTargetXen',
    'DomainDevicesConsole',
    'DomainDevicesConsoleAcpi',
    'DomainDevicesConsoleAddress',
    'DomainDevicesConsoleAlias',
    'DomainDevicesConsoleLog',
    'DomainDevicesConsoleProtocol',
    'DomainDevicesConsoleSource',
    'DomainDevicesConsoleSourceDbus',
    'DomainDevicesConsoleSourceDev',
    'DomainDevicesConsoleSourceDevSecLabel',
    'DomainDevicesConsoleSourceFile',
    'DomainDevicesConsoleSourceFileSecLabel',
    'DomainDevicesConsoleSourceNmdm',
    'DomainDevicesConsoleSourcePipe',
    'DomainDevicesConsoleSourcePipeSecLabel',
    'DomainDevicesConsoleSourcePty',
    'DomainDevicesConsoleSourcePtySecLabel',
    'DomainDevicesConsoleSourceQemuvdAgent',
    'DomainDevicesConsoleSourceQemuvdAgentClipBoard',
    'DomainDevicesConsoleSourceQemuvdAgentMouse',
    'DomainDevicesConsoleSourceSpicePort',
    'DomainDevicesConsoleSourceTcp',
    'DomainDevicesConsoleSourceTcpReconnect',
    'DomainDevicesConsoleSourceUdp',
    'DomainDevicesConsoleSourceUnix',
    'DomainDevicesConsoleSourceUnixReconnect',
    'DomainDevicesConsoleSourceUnixSecLabel',
    'DomainDevicesConsoleTarget',
    'DomainDevicesController',
    'DomainDevicesControllerAcpi',
    'DomainDevicesControllerAddress',
    'DomainDevicesControllerAlias',
    'DomainDevicesControllerDriver',
    'DomainDevicesControllerDriverIoThreads',
    'DomainDevicesControllerDriverIoThreadsIoThread',
    'DomainDevicesControllerDriverIoThreadsIoThreadQueue',
    'DomainDevicesControllerNvme',
    'DomainDevicesControllerPci',
    'DomainDevicesControllerPciModel',
    'DomainDevicesControllerPciTarget',
    'DomainDevicesControllerUsb',
    'DomainDevicesControllerUsbMaster',
    'DomainDevicesControllerVirtIoSerial',
    'DomainDevicesControllerXenBus',
    'DomainDevicesCrypto',
    'DomainDevicesCryptoAddress',
    'DomainDevicesCryptoAlias',
    'DomainDevicesCryptoBackend',
    'DomainDevicesDisk',
    'DomainDevicesDiskAcpi',
    'DomainDevicesDiskAddress',
    'DomainDevicesDiskAlias',
    'DomainDevicesDiskAuth',
    'DomainDevicesDiskAuthSecret',
    'DomainDevicesDiskBackendDomain',
    'DomainDevicesDiskBackingStore',
    'DomainDevicesDiskBackingStoreFormat',
    'DomainDevicesDiskBackingStoreFormatMetadataCache',
    'DomainDevicesDiskBackingStoreFormatMetadataCacheMaxSize',
    'DomainDevicesDiskBackingStoreSource',
    'DomainDevicesDiskBackingStoreSourceBlock',
    'DomainDevicesDiskBackingStoreSourceBlockSecLabel',
    'DomainDevicesDiskBackingStoreSourceCookies',
    'DomainDevicesDiskBackingStoreSourceCookiesCookie',
    'DomainDevicesDiskBackingStoreSourceDataStore',
    'DomainDevicesDiskBackingStoreSourceDataStoreFormat',
    'DomainDevicesDiskBackingStoreSourceDataStoreFormatMetadataCache',
    'DomainDevicesDiskBackingStoreSourceDataStoreFormatMetadataCacheMaxSize',
    'DomainDevicesDiskBackingStoreSourceDir',
    'DomainDevicesDiskBackingStoreSourceEncryption',
    'DomainDevicesDiskBackingStoreSourceEncryptionSecret',
    'DomainDevicesDiskBackingStoreSourceFile',
    'DomainDevicesDiskBackingStoreSourceFileSecLabel',
    'DomainDevicesDiskBackingStoreSourceNetwork',
    'DomainDevicesDiskBackingStoreSourceNetworkAuth',
    'DomainDevicesDiskBackingStoreSourceNetworkAuthSecret',
    'DomainDevicesDiskBackingStoreSourceNetworkConfig',
    'DomainDevicesDiskBackingStoreSourceNetworkHost',
    'DomainDevicesDiskBackingStoreSourceNetworkIdentity',
    'DomainDevicesDiskBackingStoreSourceNetworkInitiator',
    'DomainDevicesDiskBackingStoreSourceNetworkInitiatorIqn',
    'DomainDevicesDiskBackingStoreSourceNetworkKnownHosts',
    'DomainDevicesDiskBackingStoreSourceNetworkReconnect',
    'DomainDevicesDiskBackingStoreSourceNetworkSnapshot',
    'DomainDevicesDiskBackingStoreSourceNvme',
    'DomainDevicesDiskBackingStoreSourceReadahead',
    'DomainDevicesDiskBackingStoreSourceReservations',
    'DomainDevicesDiskBackingStoreSourceReservationsSource',
    'DomainDevicesDiskBackingStoreSourceReservationsSourceDbus',
    'DomainDevicesDiskBackingStoreSourceReservationsSourceDev',
    'DomainDevicesDiskBackingStoreSourceReservationsSourceDevSecLabel',
    'DomainDevicesDiskBackingStoreSourceReservationsSourceFile',
    'DomainDevicesDiskBackingStoreSourceReservationsSourceFileSecLabel',
    'DomainDevicesDiskBackingStoreSourceReservationsSourceNmdm',
    'DomainDevicesDiskBackingStoreSourceReservationsSourcePipe',
    'DomainDevicesDiskBackingStoreSourceReservationsSourcePipeSecLabel',
    'DomainDevicesDiskBackingStoreSourceReservationsSourcePty',
    'DomainDevicesDiskBackingStoreSourceReservationsSourcePtySecLabel',
    'DomainDevicesDiskBackingStoreSourceReservationsSourceQemuvdAgent',
    'DomainDevicesDiskBackingStoreSourceReservationsSourceQemuvdAgentClipBoard',
    'DomainDevicesDiskBackingStoreSourceReservationsSourceQemuvdAgentMouse',
    'DomainDevicesDiskBackingStoreSourceReservationsSourceSpicePort',
    'DomainDevicesDiskBackingStoreSourceReservationsSourceTcp',
    'DomainDevicesDiskBackingStoreSourceReservationsSourceTcpReconnect',
    'DomainDevicesDiskBackingStoreSourceReservationsSourceUdp',
    'DomainDevicesDiskBackingStoreSourceReservationsSourceUnix',
    'DomainDevicesDiskBackingStoreSourceReservationsSourceUnixReconnect',
    'DomainDevicesDiskBackingStoreSourceReservationsSourceUnixSecLabel',
    'DomainDevicesDiskBackingStoreSourceSlices',
    'DomainDevicesDiskBackingStoreSourceSlicesSlice',
    'DomainDevicesDiskBackingStoreSourceSsl',
    'DomainDevicesDiskBackingStoreSourceTimeout',
    'DomainDevicesDiskBackingStoreSourceVhostUser',
    'DomainDevicesDiskBackingStoreSourceVhostUserDbus',
    'DomainDevicesDiskBackingStoreSourceVhostUserDev',
    'DomainDevicesDiskBackingStoreSourceVhostUserDevSecLabel',
    'DomainDevicesDiskBackingStoreSourceVhostUserFile',
    'DomainDevicesDiskBackingStoreSourceVhostUserFileSecLabel',
    'DomainDevicesDiskBackingStoreSourceVhostUserNmdm',
    'DomainDevicesDiskBackingStoreSourceVhostUserPipe',
    'DomainDevicesDiskBackingStoreSourceVhostUserPipeSecLabel',
    'DomainDevicesDiskBackingStoreSourceVhostUserPty',
    'DomainDevicesDiskBackingStoreSourceVhostUserPtySecLabel',
    'DomainDevicesDiskBackingStoreSourceVhostUserQemuvdAgent',
    'DomainDevicesDiskBackingStoreSourceVhostUserQemuvdAgentClipBoard',
    'DomainDevicesDiskBackingStoreSourceVhostUserQemuvdAgentMouse',
    'DomainDevicesDiskBackingStoreSourceVhostUserSpicePort',
    'DomainDevicesDiskBackingStoreSourceVhostUserTcp',
    'DomainDevicesDiskBackingStoreSourceVhostUserTcpReconnect',
    'DomainDevicesDiskBackingStoreSourceVhostUserUdp',
    'DomainDevicesDiskBackingStoreSourceVhostUserUnix',
    'DomainDevicesDiskBackingStoreSourceVhostUserUnixReconnect',
    'DomainDevicesDiskBackingStoreSourceVhostUserUnixSecLabel',
    'DomainDevicesDiskBackingStoreSourceVhostVdpa',
    'DomainDevicesDiskBackingStoreSourceVolume',
    'DomainDevicesDiskBackingStoreSourceVolumeSecLabel',
    'DomainDevicesDiskBlockIo',
    'DomainDevicesDiskBoot',
    'DomainDevicesDiskDriver',
    'DomainDevicesDiskDriverIoThreads',
    'DomainDevicesDiskDriverIoThreadsIoThread',
    'DomainDevicesDiskDriverIoThreadsIoThreadQueue',
    'DomainDevicesDiskDriverMetadataCache',
    'DomainDevicesDiskDriverMetadataCacheMaxSize',
    'DomainDevicesDiskEncryption',
    'DomainDevicesDiskEncryptionSecret',
    'DomainDevicesDiskGeometry',
    'DomainDevicesDiskIoTune',
    'DomainDevicesDiskMirror',
    'DomainDevicesDiskMirrorBackingStore',
    'DomainDevicesDiskMirrorBackingStoreFormat',
    'DomainDevicesDiskMirrorBackingStoreFormatMetadataCache',
    'DomainDevicesDiskMirrorBackingStoreFormatMetadataCacheMaxSize',
    'DomainDevicesDiskMirrorBackingStoreSource',
    'DomainDevicesDiskMirrorBackingStoreSourceBlock',
    'DomainDevicesDiskMirrorBackingStoreSourceBlockSecLabel',
    'DomainDevicesDiskMirrorBackingStoreSourceCookies',
    'DomainDevicesDiskMirrorBackingStoreSourceCookiesCookie',
    'DomainDevicesDiskMirrorBackingStoreSourceDataStore',
    'DomainDevicesDiskMirrorBackingStoreSourceDataStoreFormat',
    'DomainDevicesDiskMirrorBackingStoreSourceDataStoreFormatMetadataCache',
    'DomainDevicesDiskMirrorBackingStoreSourceDataStoreFormatMetadataCacheMaxSize',
    'DomainDevicesDiskMirrorBackingStoreSourceDir',
    'DomainDevicesDiskMirrorBackingStoreSourceEncryption',
    'DomainDevicesDiskMirrorBackingStoreSourceEncryptionSecret',
    'DomainDevicesDiskMirrorBackingStoreSourceFile',
    'DomainDevicesDiskMirrorBackingStoreSourceFileSecLabel',
    'DomainDevicesDiskMirrorBackingStoreSourceNetwork',
    'DomainDevicesDiskMirrorBackingStoreSourceNetworkAuth',
    'DomainDevicesDiskMirrorBackingStoreSourceNetworkAuthSecret',
    'DomainDevicesDiskMirrorBackingStoreSourceNetworkConfig',
    'DomainDevicesDiskMirrorBackingStoreSourceNetworkHost',
    'DomainDevicesDiskMirrorBackingStoreSourceNetworkIdentity',
    'DomainDevicesDiskMirrorBackingStoreSourceNetworkInitiator',
    'DomainDevicesDiskMirrorBackingStoreSourceNetworkInitiatorIqn',
    'DomainDevicesDiskMirrorBackingStoreSourceNetworkKnownHosts',
    'DomainDevicesDiskMirrorBackingStoreSourceNetworkReconnect',
    'DomainDevicesDiskMirrorBackingStoreSourceNetworkSnapshot',
    'DomainDevicesDiskMirrorBackingStoreSourceNvme',
    'DomainDevicesDiskMirrorBackingStoreSourceReadahead',
    'DomainDevicesDiskMirrorBackingStoreSourceReservations',
    'DomainDevicesDiskMirrorBackingStoreSourceReservationsSource',
    'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceDbus',
    'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceDev',
    'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceDevSecLabel',
    'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceFile',
    'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceFileSecLabel',
    'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceNmdm',
    'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePipe',
    'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePipeSecLabel',
    'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePty',
    'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePtySecLabel',
    'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceQemuvdAgent',
    'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceQemuvdAgentClipBoard',
    'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceQemuvdAgentMouse',
    'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceSpicePort',
    'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceTcp',
    'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceTcpReconnect',
    'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUdp',
    'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUnix',
    'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUnixReconnect',
    'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUnixSecLabel',
    'DomainDevicesDiskMirrorBackingStoreSourceSlices',
    'DomainDevicesDiskMirrorBackingStoreSourceSlicesSlice',
    'DomainDevicesDiskMirrorBackingStoreSourceSsl',
    'DomainDevicesDiskMirrorBackingStoreSourceTimeout',
    'DomainDevicesDiskMirrorBackingStoreSourceVhostUser',
    'DomainDevicesDiskMirrorBackingStoreSourceVhostUserDbus',
    'DomainDevicesDiskMirrorBackingStoreSourceVhostUserDev',
    'DomainDevicesDiskMirrorBackingStoreSourceVhostUserDevSecLabel',
    'DomainDevicesDiskMirrorBackingStoreSourceVhostUserFile',
    'DomainDevicesDiskMirrorBackingStoreSourceVhostUserFileSecLabel',
    'DomainDevicesDiskMirrorBackingStoreSourceVhostUserNmdm',
    'DomainDevicesDiskMirrorBackingStoreSourceVhostUserPipe',
    'DomainDevicesDiskMirrorBackingStoreSourceVhostUserPipeSecLabel',
    'DomainDevicesDiskMirrorBackingStoreSourceVhostUserPty',
    'DomainDevicesDiskMirrorBackingStoreSourceVhostUserPtySecLabel',
    'DomainDevicesDiskMirrorBackingStoreSourceVhostUserQemuvdAgent',
    'DomainDevicesDiskMirrorBackingStoreSourceVhostUserQemuvdAgentClipBoard',
    'DomainDevicesDiskMirrorBackingStoreSourceVhostUserQemuvdAgentMouse',
    'DomainDevicesDiskMirrorBackingStoreSourceVhostUserSpicePort',
    'DomainDevicesDiskMirrorBackingStoreSourceVhostUserTcp',
    'DomainDevicesDiskMirrorBackingStoreSourceVhostUserTcpReconnect',
    'DomainDevicesDiskMirrorBackingStoreSourceVhostUserUdp',
    'DomainDevicesDiskMirrorBackingStoreSourceVhostUserUnix',
    'DomainDevicesDiskMirrorBackingStoreSourceVhostUserUnixReconnect',
    'DomainDevicesDiskMirrorBackingStoreSourceVhostUserUnixSecLabel',
    'DomainDevicesDiskMirrorBackingStoreSourceVhostVdpa',
    'DomainDevicesDiskMirrorBackingStoreSourceVolume',
    'DomainDevicesDiskMirrorBackingStoreSourceVolumeSecLabel',
    'DomainDevicesDiskMirrorFormat',
    'DomainDevicesDiskMirrorFormatMetadataCache',
    'DomainDevicesDiskMirrorFormatMetadataCacheMaxSize',
    'DomainDevicesDiskMirrorSource',
    'DomainDevicesDiskMirrorSourceBlock',
    'DomainDevicesDiskMirrorSourceBlockSecLabel',
    'DomainDevicesDiskMirrorSourceCookies',
    'DomainDevicesDiskMirrorSourceCookiesCookie',
    'DomainDevicesDiskMirrorSourceDataStore',
    'DomainDevicesDiskMirrorSourceDataStoreFormat',
    'DomainDevicesDiskMirrorSourceDataStoreFormatMetadataCache',
    'DomainDevicesDiskMirrorSourceDataStoreFormatMetadataCacheMaxSize',
    'DomainDevicesDiskMirrorSourceDir',
    'DomainDevicesDiskMirrorSourceEncryption',
    'DomainDevicesDiskMirrorSourceEncryptionSecret',
    'DomainDevicesDiskMirrorSourceFile',
    'DomainDevicesDiskMirrorSourceFileSecLabel',
    'DomainDevicesDiskMirrorSourceNetwork',
    'DomainDevicesDiskMirrorSourceNetworkAuth',
    'DomainDevicesDiskMirrorSourceNetworkAuthSecret',
    'DomainDevicesDiskMirrorSourceNetworkConfig',
    'DomainDevicesDiskMirrorSourceNetworkHost',
    'DomainDevicesDiskMirrorSourceNetworkIdentity',
    'DomainDevicesDiskMirrorSourceNetworkInitiator',
    'DomainDevicesDiskMirrorSourceNetworkInitiatorIqn',
    'DomainDevicesDiskMirrorSourceNetworkKnownHosts',
    'DomainDevicesDiskMirrorSourceNetworkReconnect',
    'DomainDevicesDiskMirrorSourceNetworkSnapshot',
    'DomainDevicesDiskMirrorSourceNvme',
    'DomainDevicesDiskMirrorSourceReadahead',
    'DomainDevicesDiskMirrorSourceReservations',
    'DomainDevicesDiskMirrorSourceReservationsSource',
    'DomainDevicesDiskMirrorSourceReservationsSourceDbus',
    'DomainDevicesDiskMirrorSourceReservationsSourceDev',
    'DomainDevicesDiskMirrorSourceReservationsSourceDevSecLabel',
    'DomainDevicesDiskMirrorSourceReservationsSourceFile',
    'DomainDevicesDiskMirrorSourceReservationsSourceFileSecLabel',
    'DomainDevicesDiskMirrorSourceReservationsSourceNmdm',
    'DomainDevicesDiskMirrorSourceReservationsSourcePipe',
    'DomainDevicesDiskMirrorSourceReservationsSourcePipeSecLabel',
    'DomainDevicesDiskMirrorSourceReservationsSourcePty',
    'DomainDevicesDiskMirrorSourceReservationsSourcePtySecLabel',
    'DomainDevicesDiskMirrorSourceReservationsSourceQemuvdAgent',
    'DomainDevicesDiskMirrorSourceReservationsSourceQemuvdAgentClipBoard',
    'DomainDevicesDiskMirrorSourceReservationsSourceQemuvdAgentMouse',
    'DomainDevicesDiskMirrorSourceReservationsSourceSpicePort',
    'DomainDevicesDiskMirrorSourceReservationsSourceTcp',
    'DomainDevicesDiskMirrorSourceReservationsSourceTcpReconnect',
    'DomainDevicesDiskMirrorSourceReservationsSourceUdp',
    'DomainDevicesDiskMirrorSourceReservationsSourceUnix',
    'DomainDevicesDiskMirrorSourceReservationsSourceUnixReconnect',
    'DomainDevicesDiskMirrorSourceReservationsSourceUnixSecLabel',
    'DomainDevicesDiskMirrorSourceSlices',
    'DomainDevicesDiskMirrorSourceSlicesSlice',
    'DomainDevicesDiskMirrorSourceSsl',
    'DomainDevicesDiskMirrorSourceTimeout',
    'DomainDevicesDiskMirrorSourceVhostUser',
    'DomainDevicesDiskMirrorSourceVhostUserDbus',
    'DomainDevicesDiskMirrorSourceVhostUserDev',
    'DomainDevicesDiskMirrorSourceVhostUserDevSecLabel',
    'DomainDevicesDiskMirrorSourceVhostUserFile',
    'DomainDevicesDiskMirrorSourceVhostUserFileSecLabel',
    'DomainDevicesDiskMirrorSourceVhostUserNmdm',
    'DomainDevicesDiskMirrorSourceVhostUserPipe',
    'DomainDevicesDiskMirrorSourceVhostUserPipeSecLabel',
    'DomainDevicesDiskMirrorSourceVhostUserPty',
    'DomainDevicesDiskMirrorSourceVhostUserPtySecLabel',
    'DomainDevicesDiskMirrorSourceVhostUserQemuvdAgent',
    'DomainDevicesDiskMirrorSourceVhostUserQemuvdAgentClipBoard',
    'DomainDevicesDiskMirrorSourceVhostUserQemuvdAgentMouse',
    'DomainDevicesDiskMirrorSourceVhostUserSpicePort',
    'DomainDevicesDiskMirrorSourceVhostUserTcp',
    'DomainDevicesDiskMirrorSourceVhostUserTcpReconnect',
    'DomainDevicesDiskMirrorSourceVhostUserUdp',
    'DomainDevicesDiskMirrorSourceVhostUserUnix',
    'DomainDevicesDiskMirrorSourceVhostUserUnixReconnect',
    'DomainDevicesDiskMirrorSourceVhostUserUnixSecLabel',
    'DomainDevicesDiskMirrorSourceVhostVdpa',
    'DomainDevicesDiskMirrorSourceVolume',
    'DomainDevicesDiskMirrorSourceVolumeSecLabel',
    'DomainDevicesDiskSource',
    'DomainDevicesDiskSourceBlock',
    'DomainDevicesDiskSourceBlockSecLabel',
    'DomainDevicesDiskSourceCookies',
    'DomainDevicesDiskSourceCookiesCookie',
    'DomainDevicesDiskSourceDataStore',
    'DomainDevicesDiskSourceDataStoreFormat',
    'DomainDevicesDiskSourceDataStoreFormatMetadataCache',
    'DomainDevicesDiskSourceDataStoreFormatMetadataCacheMaxSize',
    'DomainDevicesDiskSourceDir',
    'DomainDevicesDiskSourceEncryption',
    'DomainDevicesDiskSourceEncryptionSecret',
    'DomainDevicesDiskSourceFile',
    'DomainDevicesDiskSourceFileSecLabel',
    'DomainDevicesDiskSourceNetwork',
    'DomainDevicesDiskSourceNetworkAuth',
    'DomainDevicesDiskSourceNetworkAuthSecret',
    'DomainDevicesDiskSourceNetworkConfig',
    'DomainDevicesDiskSourceNetworkHost',
    'DomainDevicesDiskSourceNetworkIdentity',
    'DomainDevicesDiskSourceNetworkInitiator',
    'DomainDevicesDiskSourceNetworkInitiatorIqn',
    'DomainDevicesDiskSourceNetworkKnownHosts',
    'DomainDevicesDiskSourceNetworkReconnect',
    'DomainDevicesDiskSourceNetworkSnapshot',
    'DomainDevicesDiskSourceNvme',
    'DomainDevicesDiskSourceReadahead',
    'DomainDevicesDiskSourceReservations',
    'DomainDevicesDiskSourceReservationsSource',
    'DomainDevicesDiskSourceReservationsSourceDbus',
    'DomainDevicesDiskSourceReservationsSourceDev',
    'DomainDevicesDiskSourceReservationsSourceDevSecLabel',
    'DomainDevicesDiskSourceReservationsSourceFile',
    'DomainDevicesDiskSourceReservationsSourceFileSecLabel',
    'DomainDevicesDiskSourceReservationsSourceNmdm',
    'DomainDevicesDiskSourceReservationsSourcePipe',
    'DomainDevicesDiskSourceReservationsSourcePipeSecLabel',
    'DomainDevicesDiskSourceReservationsSourcePty',
    'DomainDevicesDiskSourceReservationsSourcePtySecLabel',
    'DomainDevicesDiskSourceReservationsSourceQemuvdAgent',
    'DomainDevicesDiskSourceReservationsSourceQemuvdAgentClipBoard',
    'DomainDevicesDiskSourceReservationsSourceQemuvdAgentMouse',
    'DomainDevicesDiskSourceReservationsSourceSpicePort',
    'DomainDevicesDiskSourceReservationsSourceTcp',
    'DomainDevicesDiskSourceReservationsSourceTcpReconnect',
    'DomainDevicesDiskSourceReservationsSourceUdp',
    'DomainDevicesDiskSourceReservationsSourceUnix',
    'DomainDevicesDiskSourceReservationsSourceUnixReconnect',
    'DomainDevicesDiskSourceReservationsSourceUnixSecLabel',
    'DomainDevicesDiskSourceSlices',
    'DomainDevicesDiskSourceSlicesSlice',
    'DomainDevicesDiskSourceSsl',
    'DomainDevicesDiskSourceTimeout',
    'DomainDevicesDiskSourceVhostUser',
    'DomainDevicesDiskSourceVhostUserDbus',
    'DomainDevicesDiskSourceVhostUserDev',
    'DomainDevicesDiskSourceVhostUserDevSecLabel',
    'DomainDevicesDiskSourceVhostUserFile',
    'DomainDevicesDiskSourceVhostUserFileSecLabel',
    'DomainDevicesDiskSourceVhostUserNmdm',
    'DomainDevicesDiskSourceVhostUserPipe',
    'DomainDevicesDiskSourceVhostUserPipeSecLabel',
    'DomainDevicesDiskSourceVhostUserPty',
    'DomainDevicesDiskSourceVhostUserPtySecLabel',
    'DomainDevicesDiskSourceVhostUserQemuvdAgent',
    'DomainDevicesDiskSourceVhostUserQemuvdAgentClipBoard',
    'DomainDevicesDiskSourceVhostUserQemuvdAgentMouse',
    'DomainDevicesDiskSourceVhostUserSpicePort',
    'DomainDevicesDiskSourceVhostUserTcp',
    'DomainDevicesDiskSourceVhostUserTcpReconnect',
    'DomainDevicesDiskSourceVhostUserUdp',
    'DomainDevicesDiskSourceVhostUserUnix',
    'DomainDevicesDiskSourceVhostUserUnixReconnect',
    'DomainDevicesDiskSourceVhostUserUnixSecLabel',
    'DomainDevicesDiskSourceVhostVdpa',
    'DomainDevicesDiskSourceVolume',
    'DomainDevicesDiskSourceVolumeSecLabel',
    'DomainDevicesDiskTarget',
    'DomainDevicesDiskThrottleFilters',
    'DomainDevicesDiskThrottleFiltersThrottleFilter',
    'DomainDevicesDiskTransient',
    'DomainDevicesFilesystem',
    'DomainDevicesFilesystemAcpi',
    'DomainDevicesFilesystemAddress',
    'DomainDevicesFilesystemAlias',
    'DomainDevicesFilesystemBinary',
    'DomainDevicesFilesystemBinaryCache',
    'DomainDevicesFilesystemBinaryLock',
    'DomainDevicesFilesystemBinaryOpenFiles',
    'DomainDevicesFilesystemBinarySandbox',
    'DomainDevicesFilesystemBinaryThreadPool',
    'DomainDevicesFilesystemBoot',
    'DomainDevicesFilesystemDriver',
    'DomainDevicesFilesystemIdMap',
    'DomainDevicesFilesystemIdMapGid',
    'DomainDevicesFilesystemIdMapUid',
    'DomainDevicesFilesystemSource',
    'DomainDevicesFilesystemSourceBind',
    'DomainDevicesFilesystemSourceBlock',
    'DomainDevicesFilesystemSourceFile',
    'DomainDevicesFilesystemSourceMount',
    'DomainDevicesFilesystemSourceRam',
    'DomainDevicesFilesystemSourceTemplate',
    'DomainDevicesFilesystemSourceVolume',
    'DomainDevicesFilesystemTarget',
    'DomainDevicesGraphic',
    'DomainDevicesGraphicAudio',
    'DomainDevicesGraphicDbus',
    'DomainDevicesGraphicDbusGl',
    'DomainDevicesGraphicDesktop',
    'DomainDevicesGraphicEglHeadless',
    'DomainDevicesGraphicEglHeadlessGl',
    'DomainDevicesGraphicRdp',
    'DomainDevicesGraphicRdpListener',
    'DomainDevicesGraphicRdpListenerAddress',
    'DomainDevicesGraphicRdpListenerNetwork',
    'DomainDevicesGraphicRdpListenerSocket',
    'DomainDevicesGraphicSdl',
    'DomainDevicesGraphicSdlGl',
    'DomainDevicesGraphicSpice',
    'DomainDevicesGraphicSpiceChannel',
    'DomainDevicesGraphicSpiceClipBoard',
    'DomainDevicesGraphicSpiceFileTransfer',
    'DomainDevicesGraphicSpiceGl',
    'DomainDevicesGraphicSpiceImage',
    'DomainDevicesGraphicSpiceJpeg',
    'DomainDevicesGraphicSpiceListener',
    'DomainDevicesGraphicSpiceListenerAddress',
    'DomainDevicesGraphicSpiceListenerNetwork',
    'DomainDevicesGraphicSpiceListenerSocket',
    'DomainDevicesGraphicSpiceMouse',
    'DomainDevicesGraphicSpicePlayback',
    'DomainDevicesGraphicSpiceStreaming',
    'DomainDevicesGraphicSpiceZlib',
    'DomainDevicesGraphicVnc',
    'DomainDevicesGraphicVncListener',
    'DomainDevicesGraphicVncListenerAddress',
    'DomainDevicesGraphicVncListenerNetwork',
    'DomainDevicesGraphicVncListenerSocket',
    'DomainDevicesHostdev',
    'DomainDevicesHostdevAcpi',
    'DomainDevicesHostdevAddress',
    'DomainDevicesHostdevAlias',
    'DomainDevicesHostdevBoot',
    'DomainDevicesHostdevCapsMisc',
    'DomainDevicesHostdevCapsMiscSource',
    'DomainDevicesHostdevCapsNet',
    'DomainDevicesHostdevCapsNetIp',
    'DomainDevicesHostdevCapsNetRoute',
    'DomainDevicesHostdevCapsNetSource',
    'DomainDevicesHostdevCapsStorage',
    'DomainDevicesHostdevCapsStorageSource',
    'DomainDevicesHostdevRom',
    'DomainDevicesHostdevSubsysMDev',
    'DomainDevicesHostdevSubsysMDevSource',
    'DomainDevicesHostdevSubsysMDevSourceAddress',
    'DomainDevicesHostdevSubsysPci',
    'DomainDevicesHostdevSubsysPciDriver',
    'DomainDevicesHostdevSubsysPciSource',
    'DomainDevicesHostdevSubsysPciSourceAddress',
    'DomainDevicesHostdevSubsysPciSourceAddressZpci',
    'DomainDevicesHostdevSubsysPciTeaming',
    'DomainDevicesHostdevSubsysScsi',
    'DomainDevicesHostdevSubsysScsiHost',
    'DomainDevicesHostdevSubsysScsiHostSource',
    'DomainDevicesHostdevSubsysScsiSource',
    'DomainDevicesHostdevSubsysScsiSourceHost',
    'DomainDevicesHostdevSubsysScsiSourceHostAdapter',
    'DomainDevicesHostdevSubsysScsiSourceHostAddress',
    'DomainDevicesHostdevSubsysScsiSourceIscsi',
    'DomainDevicesHostdevSubsysScsiSourceIscsiAuth',
    'DomainDevicesHostdevSubsysScsiSourceIscsiAuthSecret',
    'DomainDevicesHostdevSubsysScsiSourceIscsiHost',
    'DomainDevicesHostdevSubsysScsiSourceIscsiInitiator',
    'DomainDevicesHostdevSubsysScsiSourceIscsiInitiatorIqn',
    'DomainDevicesHostdevSubsysUsb',
    'DomainDevicesHostdevSubsysUsbSource',
    'DomainDevicesHostdevSubsysUsbSourceAddress',
    'DomainDevicesHostdevSubsysUsbSourceProduct',
    'DomainDevicesHostdevSubsysUsbSourceVendor',
    'DomainDevicesHub',
    'DomainDevicesHubAcpi',
    'DomainDevicesHubAddress',
    'DomainDevicesHubAlias',
    'DomainDevicesInput',
    'DomainDevicesInputAcpi',
    'DomainDevicesInputAddress',
    'DomainDevicesInputAlias',
    'DomainDevicesInputDriver',
    'DomainDevicesInputSource',
    'DomainDevicesInputSourceEvDev',
    'DomainDevicesInputSourcePassthrough',
    'DomainDevicesInterface',
    'DomainDevicesInterfaceAcpi',
    'DomainDevicesInterfaceAddress',
    'DomainDevicesInterfaceAlias',
    'DomainDevicesInterfaceBackend',
    'DomainDevicesInterfaceBackendDomain',
    'DomainDevicesInterfaceBandwidth',
    'DomainDevicesInterfaceBandwidthInbound',
    'DomainDevicesInterfaceBandwidthOutbound',
    'DomainDevicesInterfaceBoot',
    'DomainDevicesInterfaceCoalesce',
    'DomainDevicesInterfaceCoalesceRx',
    'DomainDevicesInterfaceCoalesceRxFrames',
    'DomainDevicesInterfaceDownScript',
    'DomainDevicesInterfaceDriver',
    'DomainDevicesInterfaceDriverGuest',
    'DomainDevicesInterfaceDriverHost',
    'DomainDevicesInterfaceFilterRef',
    'DomainDevicesInterfaceFilterRefParameter',
    'DomainDevicesInterfaceGuest',
    'DomainDevicesInterfaceIp',
    'DomainDevicesInterfaceLink',
    'DomainDevicesInterfaceMac',
    'DomainDevicesInterfaceModel',
    'DomainDevicesInterfaceMtu',
    'DomainDevicesInterfacePortForward',
    'DomainDevicesInterfacePortForwardRange',
    'DomainDevicesInterfacePortOptions',
    'DomainDevicesInterfaceRom',
    'DomainDevicesInterfaceRoute',
    'DomainDevicesInterfaceScript',
    'DomainDevicesInterfaceSource',
    'DomainDevicesInterfaceSourceBridge',
    'DomainDevicesInterfaceSourceClient',
    'DomainDevicesInterfaceSourceClientLocal',
    'DomainDevicesInterfaceSourceDirect',
    'DomainDevicesInterfaceSourceEthernet',
    'DomainDevicesInterfaceSourceEthernetIp',
    'DomainDevicesInterfaceSourceEthernetRoute',
    'DomainDevicesInterfaceSourceHostdev',
    'DomainDevicesInterfaceSourceHostdevPci',
    'DomainDevicesInterfaceSourceHostdevPciAddress',
    'DomainDevicesInterfaceSourceHostdevPciAddressZpci',
    'DomainDevicesInterfaceSourceHostdevUsb',
    'DomainDevicesInterfaceSourceHostdevUsbAddress',
    'DomainDevicesInterfaceSourceHostdevUsbProduct',
    'DomainDevicesInterfaceSourceHostdevUsbVendor',
    'DomainDevicesInterfaceSourceInternal',
    'DomainDevicesInterfaceSourceMcast',
    'DomainDevicesInterfaceSourceMcastLocal',
    'DomainDevicesInterfaceSourceNetwork',
    'DomainDevicesInterfaceSourceServer',
    'DomainDevicesInterfaceSourceServerLocal',
    'DomainDevicesInterfaceSourceUdp',
    'DomainDevicesInterfaceSourceUdpLocal',
    'DomainDevicesInterfaceSourceUser',
    'DomainDevicesInterfaceSourceVdpa',
    'DomainDevicesInterfaceSourceVds',
    'DomainDevicesInterfaceSourceVhostUser',
    'DomainDevicesInterfaceSourceVhostUserChardev',
    'DomainDevicesInterfaceSourceVhostUserChardevDbus',
    'DomainDevicesInterfaceSourceVhostUserChardevDev',
    'DomainDevicesInterfaceSourceVhostUserChardevDevSecLabel',
    'DomainDevicesInterfaceSourceVhostUserChardevFile',
    'DomainDevicesInterfaceSourceVhostUserChardevFileSecLabel',
    'DomainDevicesInterfaceSourceVhostUserChardevNmdm',
    'DomainDevicesInterfaceSourceVhostUserChardevPipe',
    'DomainDevicesInterfaceSourceVhostUserChardevPipeSecLabel',
    'DomainDevicesInterfaceSourceVhostUserChardevPty',
    'DomainDevicesInterfaceSourceVhostUserChardevPtySecLabel',
    'DomainDevicesInterfaceSourceVhostUserChardevQemuvdAgent',
    'DomainDevicesInterfaceSourceVhostUserChardevQemuvdAgentClipBoard',
    'DomainDevicesInterfaceSourceVhostUserChardevQemuvdAgentMouse',
    'DomainDevicesInterfaceSourceVhostUserChardevSpicePort',
    'DomainDevicesInterfaceSourceVhostUserChardevTcp',
    'DomainDevicesInterfaceSourceVhostUserChardevTcpReconnect',
    'DomainDevicesInterfaceSourceVhostUserChardevUdp',
    'DomainDevicesInterfaceSourceVhostUserChardevUnix',
    'DomainDevicesInterfaceSourceVhostUserChardevUnixReconnect',
    'DomainDevicesInterfaceSourceVhostUserChardevUnixSecLabel',
    'DomainDevicesInterfaceTarget',
    'DomainDevicesInterfaceTeaming',
    'DomainDevicesInterfaceTune',
    'DomainDevicesInterfaceVirtualPort',
    'DomainDevicesInterfaceVirtualPortParams',
    'DomainDevicesInterfaceVirtualPortParamsAny',
    'DomainDevicesInterfaceVirtualPortParamsMidoNet',
    'DomainDevicesInterfaceVirtualPortParamsOpenVSwitch',
    'DomainDevicesInterfaceVirtualPortParamsVepa8021qbg',
    'DomainDevicesInterfaceVirtualPortParamsVnTag8011qbh',
    'DomainDevicesInterfaceVlan',
    'DomainDevicesInterfaceVlanTag',
    'DomainDevicesInterfaceWaitForIp',
    'DomainDevicesIommu',
    'DomainDevicesIommuAcpi',
    'DomainDevicesIommuAddress',
    'DomainDevicesIommuAlias',
    'DomainDevicesIommuDriver',
    'DomainDevicesLease',
    'DomainDevicesLeaseTarget',
    'DomainDevicesMemBalloon',
    'DomainDevicesMemBalloonAcpi',
    'DomainDevicesMemBalloonAddress',
    'DomainDevicesMemBalloonAlias',
    'DomainDevicesMemBalloonDriver',
    'DomainDevicesMemBalloonStats',
    'DomainDevicesMemorydev',
    'DomainDevicesMemorydevAcpi',
    'DomainDevicesMemorydevAddress',
    'DomainDevicesMemorydevAlias',
    'DomainDevicesMemorydevSource',
    'DomainDevicesMemorydevTarget',
    'DomainDevicesMemorydevTargetAddress',
    'DomainDevicesMemorydevTargetLabel',
    'DomainDevicesNvram',
    'DomainDevicesNvramAcpi',
    'DomainDevicesNvramAddress',
    'DomainDevicesNvramAlias',
    'DomainDevicesPanic',
    'DomainDevicesPanicAcpi',
    'DomainDevicesPanicAddress',
    'DomainDevicesPanicAlias',
    'DomainDevicesParallel',
    'DomainDevicesParallelAcpi',
    'DomainDevicesParallelAddress',
    'DomainDevicesParallelAlias',
    'DomainDevicesParallelLog',
    'DomainDevicesParallelProtocol',
    'DomainDevicesParallelSource',
    'DomainDevicesParallelSourceDbus',
    'DomainDevicesParallelSourceDev',
    'DomainDevicesParallelSourceDevSecLabel',
    'DomainDevicesParallelSourceFile',
    'DomainDevicesParallelSourceFileSecLabel',
    'DomainDevicesParallelSourceNmdm',
    'DomainDevicesParallelSourcePipe',
    'DomainDevicesParallelSourcePipeSecLabel',
    'DomainDevicesParallelSourcePty',
    'DomainDevicesParallelSourcePtySecLabel',
    'DomainDevicesParallelSourceQemuvdAgent',
    'DomainDevicesParallelSourceQemuvdAgentClipBoard',
    'DomainDevicesParallelSourceQemuvdAgentMouse',
    'DomainDevicesParallelSourceSpicePort',
    'DomainDevicesParallelSourceTcp',
    'DomainDevicesParallelSourceTcpReconnect',
    'DomainDevicesParallelSourceUdp',
    'DomainDevicesParallelSourceUnix',
    'DomainDevicesParallelSourceUnixReconnect',
    'DomainDevicesParallelSourceUnixSecLabel',
    'DomainDevicesParallelTarget',
    'DomainDevicesPstore',
    'DomainDevicesPstoreAcpi',
    'DomainDevicesPstoreAddress',
    'DomainDevicesPstoreAlias',
    'DomainDevicesRedirDev',
    'DomainDevicesRedirDevAcpi',
    'DomainDevicesRedirDevAddress',
    'DomainDevicesRedirDevAlias',
    'DomainDevicesRedirDevBoot',
    'DomainDevicesRedirDevProtocol',
    'DomainDevicesRedirDevSource',
    'DomainDevicesRedirDevSourceDbus',
    'DomainDevicesRedirDevSourceDev',
    'DomainDevicesRedirDevSourceDevSecLabel',
    'DomainDevicesRedirDevSourceFile',
    'DomainDevicesRedirDevSourceFileSecLabel',
    'DomainDevicesRedirDevSourceNmdm',
    'DomainDevicesRedirDevSourcePipe',
    'DomainDevicesRedirDevSourcePipeSecLabel',
    'DomainDevicesRedirDevSourcePty',
    'DomainDevicesRedirDevSourcePtySecLabel',
    'DomainDevicesRedirDevSourceQemuvdAgent',
    'DomainDevicesRedirDevSourceQemuvdAgentClipBoard',
    'DomainDevicesRedirDevSourceQemuvdAgentMouse',
    'DomainDevicesRedirDevSourceSpicePort',
    'DomainDevicesRedirDevSourceTcp',
    'DomainDevicesRedirDevSourceTcpReconnect',
    'DomainDevicesRedirDevSourceUdp',
    'DomainDevicesRedirDevSourceUnix',
    'DomainDevicesRedirDevSourceUnixReconnect',
    'DomainDevicesRedirDevSourceUnixSecLabel',
    'DomainDevicesRedirFilter',
    'DomainDevicesRedirFilterUsb',
    'DomainDevicesRng',
    'DomainDevicesRngAcpi',
    'DomainDevicesRngAddress',
    'DomainDevicesRngAlias',
    'DomainDevicesRngBackend',
    'DomainDevicesRngBackendEgd',
    'DomainDevicesRngBackendEgdProtocol',
    'DomainDevicesRngBackendEgdSource',
    'DomainDevicesRngBackendEgdSourceDbus',
    'DomainDevicesRngBackendEgdSourceDev',
    'DomainDevicesRngBackendEgdSourceDevSecLabel',
    'DomainDevicesRngBackendEgdSourceFile',
    'DomainDevicesRngBackendEgdSourceFileSecLabel',
    'DomainDevicesRngBackendEgdSourceNmdm',
    'DomainDevicesRngBackendEgdSourcePipe',
    'DomainDevicesRngBackendEgdSourcePipeSecLabel',
    'DomainDevicesRngBackendEgdSourcePty',
    'DomainDevicesRngBackendEgdSourcePtySecLabel',
    'DomainDevicesRngBackendEgdSourceQemuvdAgent',
    'DomainDevicesRngBackendEgdSourceQemuvdAgentClipBoard',
    'DomainDevicesRngBackendEgdSourceQemuvdAgentMouse',
    'DomainDevicesRngBackendEgdSourceSpicePort',
    'DomainDevicesRngBackendEgdSourceTcp',
    'DomainDevicesRngBackendEgdSourceTcpReconnect',
    'DomainDevicesRngBackendEgdSourceUdp',
    'DomainDevicesRngBackendEgdSourceUnix',
    'DomainDevicesRngBackendEgdSourceUnixReconnect',
    'DomainDevicesRngBackendEgdSourceUnixSecLabel',
    'DomainDevicesRngDriver',
    'DomainDevicesRngRate',
    'DomainDevicesSerial',
    'DomainDevicesSerialAcpi',
    'DomainDevicesSerialAddress',
    'DomainDevicesSerialAlias',
    'DomainDevicesSerialLog',
    'DomainDevicesSerialProtocol',
    'DomainDevicesSerialSource',
    'DomainDevicesSerialSourceDbus',
    'DomainDevicesSerialSourceDev',
    'DomainDevicesSerialSourceDevSecLabel',
    'DomainDevicesSerialSourceFile',
    'DomainDevicesSerialSourceFileSecLabel',
    'DomainDevicesSerialSourceNmdm',
    'DomainDevicesSerialSourcePipe',
    'DomainDevicesSerialSourcePipeSecLabel',
    'DomainDevicesSerialSourcePty',
    'DomainDevicesSerialSourcePtySecLabel',
    'DomainDevicesSerialSourceQemuvdAgent',
    'DomainDevicesSerialSourceQemuvdAgentClipBoard',
    'DomainDevicesSerialSourceQemuvdAgentMouse',
    'DomainDevicesSerialSourceSpicePort',
    'DomainDevicesSerialSourceTcp',
    'DomainDevicesSerialSourceTcpReconnect',
    'DomainDevicesSerialSourceUdp',
    'DomainDevicesSerialSourceUnix',
    'DomainDevicesSerialSourceUnixReconnect',
    'DomainDevicesSerialSourceUnixSecLabel',
    'DomainDevicesSerialTarget',
    'DomainDevicesSerialTargetModel',
    'DomainDevicesShmem',
    'DomainDevicesShmemAcpi',
    'DomainDevicesShmemAddress',
    'DomainDevicesShmemAlias',
    'DomainDevicesShmemModel',
    'DomainDevicesShmemMsi',
    'DomainDevicesShmemServer',
    'DomainDevicesSmartcard',
    'DomainDevicesSmartcardAcpi',
    'DomainDevicesSmartcardAddress',
    'DomainDevicesSmartcardAlias',
    'DomainDevicesSmartcardHostCert',
    'DomainDevicesSmartcardPassthrough',
    'DomainDevicesSmartcardPassthroughDbus',
    'DomainDevicesSmartcardPassthroughDev',
    'DomainDevicesSmartcardPassthroughDevSecLabel',
    'DomainDevicesSmartcardPassthroughFile',
    'DomainDevicesSmartcardPassthroughFileSecLabel',
    'DomainDevicesSmartcardPassthroughNmdm',
    'DomainDevicesSmartcardPassthroughPipe',
    'DomainDevicesSmartcardPassthroughPipeSecLabel',
    'DomainDevicesSmartcardPassthroughPty',
    'DomainDevicesSmartcardPassthroughPtySecLabel',
    'DomainDevicesSmartcardPassthroughQemuvdAgent',
    'DomainDevicesSmartcardPassthroughQemuvdAgentClipBoard',
    'DomainDevicesSmartcardPassthroughQemuvdAgentMouse',
    'DomainDevicesSmartcardPassthroughSpicePort',
    'DomainDevicesSmartcardPassthroughTcp',
    'DomainDevicesSmartcardPassthroughTcpReconnect',
    'DomainDevicesSmartcardPassthroughUdp',
    'DomainDevicesSmartcardPassthroughUnix',
    'DomainDevicesSmartcardPassthroughUnixReconnect',
    'DomainDevicesSmartcardPassthroughUnixSecLabel',
    'DomainDevicesSmartcardProtocol',
    'DomainDevicesSound',
    'DomainDevicesSoundAcpi',
    'DomainDevicesSoundAddress',
    'DomainDevicesSoundAlias',
    'DomainDevicesSoundAudio',
    'DomainDevicesSoundCodec',
    'DomainDevicesSoundDriver',
    'DomainDevicesTpm',
    'DomainDevicesTpmAcpi',
    'DomainDevicesTpmAddress',
    'DomainDevicesTpmAlias',
    'DomainDevicesTpmBackend',
    'DomainDevicesTpmBackendEmulator',
    'DomainDevicesTpmBackendEmulatorActivePcrBanks',
    'DomainDevicesTpmBackendEmulatorEncryption',
    'DomainDevicesTpmBackendEmulatorProfile',
    'DomainDevicesTpmBackendEmulatorSource',
    'DomainDevicesTpmBackendEmulatorSourceDir',
    'DomainDevicesTpmBackendEmulatorSourceFile',
    'DomainDevicesTpmBackendExternal',
    'DomainDevicesTpmBackendExternalSource',
    'DomainDevicesTpmBackendExternalSourceDbus',
    'DomainDevicesTpmBackendExternalSourceDev',
    'DomainDevicesTpmBackendExternalSourceDevSecLabel',
    'DomainDevicesTpmBackendExternalSourceFile',
    'DomainDevicesTpmBackendExternalSourceFileSecLabel',
    'DomainDevicesTpmBackendExternalSourceNmdm',
    'DomainDevicesTpmBackendExternalSourcePipe',
    'DomainDevicesTpmBackendExternalSourcePipeSecLabel',
    'DomainDevicesTpmBackendExternalSourcePty',
    'DomainDevicesTpmBackendExternalSourcePtySecLabel',
    'DomainDevicesTpmBackendExternalSourceQemuvdAgent',
    'DomainDevicesTpmBackendExternalSourceQemuvdAgentClipBoard',
    'DomainDevicesTpmBackendExternalSourceQemuvdAgentMouse',
    'DomainDevicesTpmBackendExternalSourceSpicePort',
    'DomainDevicesTpmBackendExternalSourceTcp',
    'DomainDevicesTpmBackendExternalSourceTcpReconnect',
    'DomainDevicesTpmBackendExternalSourceUdp',
    'DomainDevicesTpmBackendExternalSourceUnix',
    'DomainDevicesTpmBackendExternalSourceUnixReconnect',
    'DomainDevicesTpmBackendExternalSourceUnixSecLabel',
    'DomainDevicesTpmBackendPassthrough',
    'DomainDevicesTpmBackendPassthroughDevice',
    'DomainDevicesVideo',
    'DomainDevicesVideoAcpi',
    'DomainDevicesVideoAddress',
    'DomainDevicesVideoAlias',
    'DomainDevicesVideoDriver',
    'DomainDevicesVideoModel',
    'DomainDevicesVideoModelAccel',
    'DomainDevicesVideoModelResolution',
    'DomainDevicesVsock',
    'DomainDevicesVsockAcpi',
    'DomainDevicesVsockAddress',
    'DomainDevicesVsockAlias',
    'DomainDevicesVsockCid',
    'DomainDevicesVsockDriver',
    'DomainDevicesWatchdog',
    'DomainDevicesWatchdogAcpi',
    'DomainDevicesWatchdogAddress',
    'DomainDevicesWatchdogAlias',
    'DomainFeatures',
    'DomainFeaturesAia',
    'DomainFeaturesApic',
    'DomainFeaturesAsyncTeardown',
    'DomainFeaturesCapabilities',
    'DomainFeaturesCapabilitiesAuditControl',
    'DomainFeaturesCapabilitiesAuditWrite',
    'DomainFeaturesCapabilitiesBlockSuspend',
    'DomainFeaturesCapabilitiesChown',
    'DomainFeaturesCapabilitiesDacOverride',
    'DomainFeaturesCapabilitiesDacReadSearch',
    'DomainFeaturesCapabilitiesFowner',
    'DomainFeaturesCapabilitiesFsetId',
    'DomainFeaturesCapabilitiesIpcLock',
    'DomainFeaturesCapabilitiesIpcOwner',
    'DomainFeaturesCapabilitiesKill',
    'DomainFeaturesCapabilitiesLease',
    'DomainFeaturesCapabilitiesLinuxImmutable',
    'DomainFeaturesCapabilitiesMacAdmin',
    'DomainFeaturesCapabilitiesMacOverride',
    'DomainFeaturesCapabilitiesMkNod',
    'DomainFeaturesCapabilitiesNetAdmin',
    'DomainFeaturesCapabilitiesNetBindService',
    'DomainFeaturesCapabilitiesNetBroadcast',
    'DomainFeaturesCapabilitiesNetRaw',
    'DomainFeaturesCapabilitiesSetFCap',
    'DomainFeaturesCapabilitiesSetGid',
    'DomainFeaturesCapabilitiesSetPCap',
    'DomainFeaturesCapabilitiesSetUid',
    'DomainFeaturesCapabilitiesSysAdmin',
    'DomainFeaturesCapabilitiesSysBoot',
    'DomainFeaturesCapabilitiesSysChRoot',
    'DomainFeaturesCapabilitiesSysLog',
    'DomainFeaturesCapabilitiesSysModule',
    'DomainFeaturesCapabilitiesSysNice',
    'DomainFeaturesCapabilitiesSysPAcct',
    'DomainFeaturesCapabilitiesSysPTrace',
    'DomainFeaturesCapabilitiesSysRawIo',
    'DomainFeaturesCapabilitiesSysResource',
    'DomainFeaturesCapabilitiesSysTime',
    'DomainFeaturesCapabilitiesSysTtyCnofig',
    'DomainFeaturesCapabilitiesWakeAlarm',
    'DomainFeaturesCcfAssist',
    'DomainFeaturesCfpc',
    'DomainFeaturesGic',
    'DomainFeaturesHap',
    'DomainFeaturesHpt',
    'DomainFeaturesHtm',
    'DomainFeaturesHyperV',
    'DomainFeaturesHyperVAvic',
    'DomainFeaturesHyperVEmsrBitmap',
    'DomainFeaturesHyperVEvmcs',
    'DomainFeaturesHyperVFrequencies',
    'DomainFeaturesHyperVIpi',
    'DomainFeaturesHyperVReEnlightenment',
    'DomainFeaturesHyperVRelaxed',
    'DomainFeaturesHyperVReset',
    'DomainFeaturesHyperVRuntime',
    'DomainFeaturesHyperVSpinlocks',
    'DomainFeaturesHyperVStimer',
    'DomainFeaturesHyperVStimerDirect',
    'DomainFeaturesHyperVSynic',
    'DomainFeaturesHyperVTlbFlush',
    'DomainFeaturesHyperVTlbFlushDirect',
    'DomainFeaturesHyperVTlbFlushExtended',
    'DomainFeaturesHyperVVapic',
    'DomainFeaturesHyperVVendorId',
    'DomainFeaturesHyperVVpIndex',
    'DomainFeaturesHyperVXmmInput',
    'DomainFeaturesIbs',
    'DomainFeaturesIoapic',
    'DomainFeaturesKvm',
    'DomainFeaturesKvmDirtyRing',
    'DomainFeaturesKvmHidden',
    'DomainFeaturesKvmHintDedicated',
    'DomainFeaturesKvmPollControl',
    'DomainFeaturesKvmPvipi',
    'DomainFeaturesMsrs',
    'DomainFeaturesNestedHv',
    'DomainFeaturesPmu',
    'DomainFeaturesPs2',
    'DomainFeaturesPvSpinlock',
    'DomainFeaturesRas',
    'DomainFeaturesSbbc',
    'DomainFeaturesSmm',
    'DomainFeaturesTcg',
    'DomainFeaturesVmCoreInfo',
    'DomainFeaturesVmPort',
    'DomainFeaturesXen',
    'DomainFeaturesXenE820host',
    'DomainFeaturesXenPassthrough',
    'DomainIdMap',
    'DomainIdMapGiD',
    'DomainIdMapUiD',
    'DomainIoThreadIDs',
    'DomainIoThreadIDsIoThread',
    'DomainIoThreadIDsIoThreadPoll',
    'DomainKeyWrap',
    'DomainKeyWrapCipher',
    'DomainLaunchSecurity',
    'DomainLaunchSecuritySev',
    'DomainLaunchSecuritySevsnp',
    'DomainLaunchSecurityTdx',
    'DomainLaunchSecurityTdxQuoteGenerationService',
    'DomainMemoryBacking',
    'DomainMemoryBackingMemoryAccess',
    'DomainMemoryBackingMemoryAllocation',
    'DomainMemoryBackingMemoryHugePages',
    'DomainMemoryBackingMemoryHugePagesHugepage',
    'DomainMemoryBackingMemorySource',
    'DomainMemoryTune',
    'DomainMetadata',
    'DomainNumaTune',
    'DomainNumaTuneMemNode',
    'DomainNumaTuneMemory',
    'DomainOs',
    'DomainOsAcpi',
    'DomainOsAcpiTable',
    'DomainOsBios',
    'DomainOsBootDevice',
    'DomainOsBootMenu',
    'DomainOsFirmwareInfo',
    'DomainOsFirmwareInfoFeature',
    'DomainOsInitEnv',
    'DomainOsNvRam',
    'DomainOsNvRamSource',
    'DomainOsNvRamSourceBlock',
    'DomainOsNvRamSourceBlockSecLabel',
    'DomainOsNvRamSourceCookies',
    'DomainOsNvRamSourceCookiesCookie',
    'DomainOsNvRamSourceDataStore',
    'DomainOsNvRamSourceDataStoreFormat',
    'DomainOsNvRamSourceDataStoreFormatMetadataCache',
    'DomainOsNvRamSourceDataStoreFormatMetadataCacheMaxSize',
    'DomainOsNvRamSourceDir',
    'DomainOsNvRamSourceEncryption',
    'DomainOsNvRamSourceEncryptionSecret',
    'DomainOsNvRamSourceFile',
    'DomainOsNvRamSourceFileSecLabel',
    'DomainOsNvRamSourceNetwork',
    'DomainOsNvRamSourceNetworkAuth',
    'DomainOsNvRamSourceNetworkAuthSecret',
    'DomainOsNvRamSourceNetworkConfig',
    'DomainOsNvRamSourceNetworkHost',
    'DomainOsNvRamSourceNetworkIdentity',
    'DomainOsNvRamSourceNetworkInitiator',
    'DomainOsNvRamSourceNetworkInitiatorIqn',
    'DomainOsNvRamSourceNetworkKnownHosts',
    'DomainOsNvRamSourceNetworkReconnect',
    'DomainOsNvRamSourceNetworkSnapshot',
    'DomainOsNvRamSourceNvme',
    'DomainOsNvRamSourceReadahead',
    'DomainOsNvRamSourceReservations',
    'DomainOsNvRamSourceReservationsSource',
    'DomainOsNvRamSourceReservationsSourceDbus',
    'DomainOsNvRamSourceReservationsSourceDev',
    'DomainOsNvRamSourceReservationsSourceDevSecLabel',
    'DomainOsNvRamSourceReservationsSourceFile',
    'DomainOsNvRamSourceReservationsSourceFileSecLabel',
    'DomainOsNvRamSourceReservationsSourceNmdm',
    'DomainOsNvRamSourceReservationsSourcePipe',
    'DomainOsNvRamSourceReservationsSourcePipeSecLabel',
    'DomainOsNvRamSourceReservationsSourcePty',
    'DomainOsNvRamSourceReservationsSourcePtySecLabel',
    'DomainOsNvRamSourceReservationsSourceQemuvdAgent',
    'DomainOsNvRamSourceReservationsSourceQemuvdAgentClipBoard',
    'DomainOsNvRamSourceReservationsSourceQemuvdAgentMouse',
    'DomainOsNvRamSourceReservationsSourceSpicePort',
    'DomainOsNvRamSourceReservationsSourceTcp',
    'DomainOsNvRamSourceReservationsSourceTcpReconnect',
    'DomainOsNvRamSourceReservationsSourceUdp',
    'DomainOsNvRamSourceReservationsSourceUnix',
    'DomainOsNvRamSourceReservationsSourceUnixReconnect',
    'DomainOsNvRamSourceReservationsSourceUnixSecLabel',
    'DomainOsNvRamSourceSlices',
    'DomainOsNvRamSourceSlicesSlice',
    'DomainOsNvRamSourceSsl',
    'DomainOsNvRamSourceTimeout',
    'DomainOsNvRamSourceVhostUser',
    'DomainOsNvRamSourceVhostUserDbus',
    'DomainOsNvRamSourceVhostUserDev',
    'DomainOsNvRamSourceVhostUserDevSecLabel',
    'DomainOsNvRamSourceVhostUserFile',
    'DomainOsNvRamSourceVhostUserFileSecLabel',
    'DomainOsNvRamSourceVhostUserNmdm',
    'DomainOsNvRamSourceVhostUserPipe',
    'DomainOsNvRamSourceVhostUserPipeSecLabel',
    'DomainOsNvRamSourceVhostUserPty',
    'DomainOsNvRamSourceVhostUserPtySecLabel',
    'DomainOsNvRamSourceVhostUserQemuvdAgent',
    'DomainOsNvRamSourceVhostUserQemuvdAgentClipBoard',
    'DomainOsNvRamSourceVhostUserQemuvdAgentMouse',
    'DomainOsNvRamSourceVhostUserSpicePort',
    'DomainOsNvRamSourceVhostUserTcp',
    'DomainOsNvRamSourceVhostUserTcpReconnect',
    'DomainOsNvRamSourceVhostUserUdp',
    'DomainOsNvRamSourceVhostUserUnix',
    'DomainOsNvRamSourceVhostUserUnixReconnect',
    'DomainOsNvRamSourceVhostUserUnixSecLabel',
    'DomainOsNvRamSourceVhostVdpa',
    'DomainOsNvRamSourceVolume',
    'DomainOsNvRamSourceVolumeSecLabel',
    'DomainOsSmBios',
    'DomainPerf',
    'DomainPerfEvent',
    'DomainPm',
    'DomainPmSuspendToDisk',
    'DomainPmSuspendToMem',
    'DomainResource',
    'DomainResourceFibreChannel',
    'DomainSecLabel',
    'DomainSysInfo',
    'DomainSysInfoFwCfg',
    'DomainSysInfoFwCfgEntry',
    'DomainSysInfoSmbios',
    'DomainSysInfoSmbiosBaseBoard',
    'DomainSysInfoSmbiosBaseBoardEntry',
    'DomainSysInfoSmbiosBios',
    'DomainSysInfoSmbiosBiosEntry',
    'DomainSysInfoSmbiosChassis',
    'DomainSysInfoSmbiosChassisEntry',
    'DomainSysInfoSmbiosMemory',
    'DomainSysInfoSmbiosMemoryEntry',
    'DomainSysInfoSmbiosOemStrings',
    'DomainSysInfoSmbiosProcessor',
    'DomainSysInfoSmbiosProcessorEntry',
    'DomainSysInfoSmbiosSystem',
    'DomainSysInfoSmbiosSystemEntry',
    'DomainThrottleGroups',
    'DomainThrottleGroupsThrottleGroup',
    'DomainVcpus',
    'DomainVcpusVcpus',
    'NetworkBandwidth',
    'NetworkBandwidthInbound',
    'NetworkBandwidthOutbound',
    'NetworkBridge',
    'NetworkDns',
    'NetworkDnsForwarder',
    'NetworkDnsHost',
    'NetworkDnsHostHostname',
    'NetworkDnsSrV',
    'NetworkDnsTxT',
    'NetworkDomain',
    'NetworkForward',
    'NetworkForwardAddress',
    'NetworkForwardAddressPci',
    'NetworkForwardDriver',
    'NetworkForwardInterface',
    'NetworkForwardNat',
    'NetworkForwardNatAddress',
    'NetworkForwardNatPort',
    'NetworkForwardPf',
    'NetworkIp',
    'NetworkIpDhcp',
    'NetworkIpDhcpBootp',
    'NetworkIpDhcpHost',
    'NetworkIpDhcpHostLease',
    'NetworkIpDhcpRange',
    'NetworkIpDhcpRangeLease',
    'NetworkIpTftp',
    'NetworkMac',
    'NetworkMetadata',
    'NetworkMtu',
    'NetworkPortGroup',
    'NetworkPortGroupVirtualPort',
    'NetworkPortGroupVirtualPortParams',
    'NetworkPortGroupVirtualPortParamsAny',
    'NetworkPortGroupVirtualPortParamsMidoNet',
    'NetworkPortGroupVirtualPortParamsOpenVSwitch',
    'NetworkPortGroupVirtualPortParamsVepa8021qbg',
    'NetworkPortGroupVirtualPortParamsVnTag8011qbh',
    'NetworkPortGroupVlan',
    'NetworkPortGroupVlanTag',
    'NetworkPortOptions',
    'NetworkRoute',
    'NetworkVirtualPort',
    'NetworkVirtualPortParams',
    'NetworkVirtualPortParamsAny',
    'NetworkVirtualPortParamsMidoNet',
    'NetworkVirtualPortParamsOpenVSwitch',
    'NetworkVirtualPortParamsVepa8021qbg',
    'NetworkVirtualPortParamsVnTag8011qbh',
    'NetworkVlan',
    'NetworkVlanTag',
    'PoolFeatures',
    'PoolFeaturesCow',
    'PoolRefresh',
    'PoolRefreshVolume',
    'PoolSource',
    'PoolSourceAdapter',
    'PoolSourceAdapterParentAddr',
    'PoolSourceAdapterParentAddrAddress',
    'PoolSourceAuth',
    'PoolSourceAuthSecret',
    'PoolSourceDevice',
    'PoolSourceDeviceFreeExtent',
    'PoolSourceDir',
    'PoolSourceFormat',
    'PoolSourceHost',
    'PoolSourceInitiator',
    'PoolSourceInitiatorIqn',
    'PoolSourceProduct',
    'PoolSourceProtocol',
    'PoolSourceVendor',
    'PoolTarget',
    'PoolTargetEncryption',
    'PoolTargetEncryptionCipher',
    'PoolTargetEncryptionIvgen',
    'PoolTargetEncryptionSecret',
    'PoolTargetPermissions',
    'PoolTargetTimestamps',
    'VolumeBackingStore',
    'VolumeBackingStoreFormat',
    'VolumeBackingStorePermissions',
    'VolumeCreate',
    'VolumeCreateContent',
    'VolumeTarget',
    'VolumeTargetEncryption',
    'VolumeTargetEncryptionCipher',
    'VolumeTargetEncryptionIvgen',
    'VolumeTargetEncryptionSecret',
    'VolumeTargetFeature',
    'VolumeTargetFormat',
    'VolumeTargetPermissions',
    'VolumeTargetTimestamps',
    'GetDomainInterfaceAddressesInterfaceResult',
    'GetDomainInterfaceAddressesInterfaceAddrResult',
    'GetNodeDeviceInfoCapabilityResult',
]

@pulumi.output_type
class DomainBlockIoTune(dict):
    def __init__(__self__, *,
                 devices: Optional[Sequence['outputs.DomainBlockIoTuneDevice']] = None,
                 weight: Optional[_builtins.float] = None):
        """
        :param Sequence['DomainBlockIoTuneDeviceArgs'] devices: Defines per-block-device I/O tuning parameters, each entry targeting a specific backing device by path.
               
               See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        :param _builtins.float weight: Sets the global blkio weight for the domains I/O, as an integer in the valid blkio weight range (typically 1001000), affecting its proportional share relative to other domains.
               
               See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        if devices is not None:
            pulumi.set(__self__, "devices", devices)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def devices(self) -> Optional[Sequence['outputs.DomainBlockIoTuneDevice']]:
        """
        Defines per-block-device I/O tuning parameters, each entry targeting a specific backing device by path.

        See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        return pulumi.get(self, "devices")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.float]:
        """
        Sets the global blkio weight for the domains I/O, as an integer in the valid blkio weight range (typically 1001000), affecting its proportional share relative to other domains.

        See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class DomainBlockIoTuneDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readBytesSec":
            suggest = "read_bytes_sec"
        elif key == "readIopsSec":
            suggest = "read_iops_sec"
        elif key == "writeBytesSec":
            suggest = "write_bytes_sec"
        elif key == "writeIopsSec":
            suggest = "write_iops_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainBlockIoTuneDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainBlockIoTuneDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainBlockIoTuneDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 read_bytes_sec: Optional[_builtins.float] = None,
                 read_iops_sec: Optional[_builtins.float] = None,
                 weight: Optional[_builtins.float] = None,
                 write_bytes_sec: Optional[_builtins.float] = None,
                 write_iops_sec: Optional[_builtins.float] = None):
        """
        :param _builtins.str path: Sets the absolute path of the host block device whose I/O is being tuned (for example `/dev/vda` or `/dev/sda`); this is required for each device entry.
               
               See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        :param _builtins.float read_bytes_sec: Sets an upper limit, in bytes per second, on read bandwidth for this specific device; the value is a positive integer chosen by the user (e.g. `10485760` for 10 MiB/s).
               
               See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        :param _builtins.float read_iops_sec: Sets an upper limit, in I/O operations per second, on reads for this specific device; the value is a positive integer chosen by the user.
               
               See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        :param _builtins.float weight: Sets the relative I/O weight for this specific device, as an integer in the valid blkio weight range (typically 1001000), used for proportional scheduling when multiple guests compete.
               
               See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        :param _builtins.float write_bytes_sec: Sets an upper limit, in bytes per second, on write bandwidth for this specific device; the value is a positive integer chosen by the user.
               
               See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        :param _builtins.float write_iops_sec: Sets an upper limit, in I/O operations per second, on writes for this specific device; the value is a positive integer chosen by the user.
               
               See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        pulumi.set(__self__, "path", path)
        if read_bytes_sec is not None:
            pulumi.set(__self__, "read_bytes_sec", read_bytes_sec)
        if read_iops_sec is not None:
            pulumi.set(__self__, "read_iops_sec", read_iops_sec)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)
        if write_bytes_sec is not None:
            pulumi.set(__self__, "write_bytes_sec", write_bytes_sec)
        if write_iops_sec is not None:
            pulumi.set(__self__, "write_iops_sec", write_iops_sec)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the absolute path of the host block device whose I/O is being tuned (for example `/dev/vda` or `/dev/sda`); this is required for each device entry.

        See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="readBytesSec")
    def read_bytes_sec(self) -> Optional[_builtins.float]:
        """
        Sets an upper limit, in bytes per second, on read bandwidth for this specific device; the value is a positive integer chosen by the user (e.g. `10485760` for 10 MiB/s).

        See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        return pulumi.get(self, "read_bytes_sec")

    @_builtins.property
    @pulumi.getter(name="readIopsSec")
    def read_iops_sec(self) -> Optional[_builtins.float]:
        """
        Sets an upper limit, in I/O operations per second, on reads for this specific device; the value is a positive integer chosen by the user.

        See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        return pulumi.get(self, "read_iops_sec")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.float]:
        """
        Sets the relative I/O weight for this specific device, as an integer in the valid blkio weight range (typically 1001000), used for proportional scheduling when multiple guests compete.

        See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        return pulumi.get(self, "weight")

    @_builtins.property
    @pulumi.getter(name="writeBytesSec")
    def write_bytes_sec(self) -> Optional[_builtins.float]:
        """
        Sets an upper limit, in bytes per second, on write bandwidth for this specific device; the value is a positive integer chosen by the user.

        See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        return pulumi.get(self, "write_bytes_sec")

    @_builtins.property
    @pulumi.getter(name="writeIopsSec")
    def write_iops_sec(self) -> Optional[_builtins.float]:
        """
        Sets an upper limit, in I/O operations per second, on writes for this specific device; the value is a positive integer chosen by the user.

        See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        return pulumi.get(self, "write_iops_sec")


@pulumi.output_type
class DomainClock(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainClock. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainClock.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainClock.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 adjustment: Optional[_builtins.str] = None,
                 basis: Optional[_builtins.str] = None,
                 offset: Optional[_builtins.str] = None,
                 start: Optional[_builtins.float] = None,
                 time_zone: Optional[_builtins.str] = None,
                 timers: Optional[Sequence['outputs.DomainClockTimer']] = None):
        """
        :param _builtins.str adjustment: Sets a numeric time adjustment applied to the guest clock on startup or reset, interpreted in seconds unless a different unit is implied by `basis`; the value is user-provided (e.g. `-3600`).
               
               See: <https://libvirt.org/formatdomain.html#time-keeping>
        :param _builtins.str basis: Selects how `adjustment` is interpreted relative to the base time, with allowed values `utc` or `localtime`; if omitted, libvirt uses its default behavior.
               
               See: <https://libvirt.org/formatdomain.html#time-keeping>
        :param _builtins.str offset: Controls what time the guest sees at boot, with common values `utc`, `localtime`, `timezone`, or `variable` to follow or diverge from the host clock.
               
               See: <https://libvirt.org/formatdomain.html#time-keeping>
        :param _builtins.float start: Specifies when the clock settings take effect, with valid values such as `utc`, `localtime`, or `absolute` depending on mode; the exact allowed values are driver-specific.
               
               See: <https://libvirt.org/formatdomain.html#time-keeping>
        :param _builtins.str time_zone: Sets the IANA time zone name used when `offset` is `timezone`, such as `UTC`, `Europe/Berlin`, or `America/New_York`.
               
               See: <https://libvirt.org/formatdomain.html#time-keeping>
        :param Sequence['DomainClockTimerArgs'] timers: Defines one or more hardware or paravirtualized timers for the guest clock (e.g. HPET, KVM clock), including their policies and catch-up behavior.
               
               See: <https://libvirt.org/formatdomain.html#time-keeping>
        """
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if basis is not None:
            pulumi.set(__self__, "basis", basis)
        if offset is not None:
            pulumi.set(__self__, "offset", offset)
        if start is not None:
            pulumi.set(__self__, "start", start)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if timers is not None:
            pulumi.set(__self__, "timers", timers)

    @_builtins.property
    @pulumi.getter
    def adjustment(self) -> Optional[_builtins.str]:
        """
        Sets a numeric time adjustment applied to the guest clock on startup or reset, interpreted in seconds unless a different unit is implied by `basis`; the value is user-provided (e.g. `-3600`).

        See: <https://libvirt.org/formatdomain.html#time-keeping>
        """
        return pulumi.get(self, "adjustment")

    @_builtins.property
    @pulumi.getter
    def basis(self) -> Optional[_builtins.str]:
        """
        Selects how `adjustment` is interpreted relative to the base time, with allowed values `utc` or `localtime`; if omitted, libvirt uses its default behavior.

        See: <https://libvirt.org/formatdomain.html#time-keeping>
        """
        return pulumi.get(self, "basis")

    @_builtins.property
    @pulumi.getter
    def offset(self) -> Optional[_builtins.str]:
        """
        Controls what time the guest sees at boot, with common values `utc`, `localtime`, `timezone`, or `variable` to follow or diverge from the host clock.

        See: <https://libvirt.org/formatdomain.html#time-keeping>
        """
        return pulumi.get(self, "offset")

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[_builtins.float]:
        """
        Specifies when the clock settings take effect, with valid values such as `utc`, `localtime`, or `absolute` depending on mode; the exact allowed values are driver-specific.

        See: <https://libvirt.org/formatdomain.html#time-keeping>
        """
        return pulumi.get(self, "start")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[_builtins.str]:
        """
        Sets the IANA time zone name used when `offset` is `timezone`, such as `UTC`, `Europe/Berlin`, or `America/New_York`.

        See: <https://libvirt.org/formatdomain.html#time-keeping>
        """
        return pulumi.get(self, "time_zone")

    @_builtins.property
    @pulumi.getter
    def timers(self) -> Optional[Sequence['outputs.DomainClockTimer']]:
        """
        Defines one or more hardware or paravirtualized timers for the guest clock (e.g. HPET, KVM clock), including their policies and catch-up behavior.

        See: <https://libvirt.org/formatdomain.html#time-keeping>
        """
        return pulumi.get(self, "timers")


@pulumi.output_type
class DomainClockTimer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "catchUp":
            suggest = "catch_up"
        elif key == "tickPolicy":
            suggest = "tick_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainClockTimer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainClockTimer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainClockTimer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 catch_up: Optional['outputs.DomainClockTimerCatchUp'] = None,
                 frequency: Optional[_builtins.float] = None,
                 mode: Optional[_builtins.str] = None,
                 present: Optional[_builtins.str] = None,
                 tick_policy: Optional[_builtins.str] = None,
                 track: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Selects which hardware or virtual timer this entry configures (for example "rtc", "pit", "hpet", "tsc", "kvmclock"); value must be a timer name supported by the guest architecture and hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#time-keeping>
        :param 'DomainClockTimerCatchUpArgs' catch_up: Configures how a timer behaves when the guest falls behind real time, enabling or tuning the catchup mechanism instead of an immediate jump.
        :param _builtins.float frequency: Sets the frequency of the given timer device in Hertz; value is user-provided and must be a positive integer (for example 100 or 1000) when overriding the default.
               
               See: <https://libvirt.org/formatdomain.html#time-keeping>
        :param _builtins.str mode: Sets how the timer operates, with typical values including "auto", "native", or "emulate" depending on the timer type; value must be one of the modes supported by the chosen hypervisor/timer.
               
               See: <https://libvirt.org/formatdomain.html#time-keeping>
        :param _builtins.str present: Controls whether the specified timer is exposed to the guest, using "yes" to enable or "no" to omit it.
               
               See: <https://libvirt.org/formatdomain.html#time-keeping>
        :param _builtins.str tick_policy: Sets how missed timer ticks are handled, with valid values including "delay", "catchup", and "merge"; for example "delay" shifts subsequent ticks, while "catchup" speeds the clock up briefly.
               
               See: <https://libvirt.org/formatdomain.html#time-keeping>
        :param _builtins.str track: Controls how the guest timer tracks the host, typically using values such as "boot", "guest", or "wall" depending on the specific timer; value must be one of the tracking modes supported by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#time-keeping>
        """
        pulumi.set(__self__, "name", name)
        if catch_up is not None:
            pulumi.set(__self__, "catch_up", catch_up)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if present is not None:
            pulumi.set(__self__, "present", present)
        if tick_policy is not None:
            pulumi.set(__self__, "tick_policy", tick_policy)
        if track is not None:
            pulumi.set(__self__, "track", track)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Selects which hardware or virtual timer this entry configures (for example "rtc", "pit", "hpet", "tsc", "kvmclock"); value must be a timer name supported by the guest architecture and hypervisor.

        See: <https://libvirt.org/formatdomain.html#time-keeping>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="catchUp")
    def catch_up(self) -> Optional['outputs.DomainClockTimerCatchUp']:
        """
        Configures how a timer behaves when the guest falls behind real time, enabling or tuning the catchup mechanism instead of an immediate jump.
        """
        return pulumi.get(self, "catch_up")

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> Optional[_builtins.float]:
        """
        Sets the frequency of the given timer device in Hertz; value is user-provided and must be a positive integer (for example 100 or 1000) when overriding the default.

        See: <https://libvirt.org/formatdomain.html#time-keeping>
        """
        return pulumi.get(self, "frequency")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets how the timer operates, with typical values including "auto", "native", or "emulate" depending on the timer type; value must be one of the modes supported by the chosen hypervisor/timer.

        See: <https://libvirt.org/formatdomain.html#time-keeping>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def present(self) -> Optional[_builtins.str]:
        """
        Controls whether the specified timer is exposed to the guest, using "yes" to enable or "no" to omit it.

        See: <https://libvirt.org/formatdomain.html#time-keeping>
        """
        return pulumi.get(self, "present")

    @_builtins.property
    @pulumi.getter(name="tickPolicy")
    def tick_policy(self) -> Optional[_builtins.str]:
        """
        Sets how missed timer ticks are handled, with valid values including "delay", "catchup", and "merge"; for example "delay" shifts subsequent ticks, while "catchup" speeds the clock up briefly.

        See: <https://libvirt.org/formatdomain.html#time-keeping>
        """
        return pulumi.get(self, "tick_policy")

    @_builtins.property
    @pulumi.getter
    def track(self) -> Optional[_builtins.str]:
        """
        Controls how the guest timer tracks the host, typically using values such as "boot", "guest", or "wall" depending on the specific timer; value must be one of the tracking modes supported by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#time-keeping>
        """
        return pulumi.get(self, "track")


@pulumi.output_type
class DomainClockTimerCatchUp(dict):
    def __init__(__self__, *,
                 limit: Optional[_builtins.float] = None,
                 slew: Optional[_builtins.float] = None,
                 threshold: Optional[_builtins.float] = None):
        """
        :param _builtins.float limit: Sets the maximum time difference, in seconds, that the catch-up mechanism is allowed to correct before giving up and letting the guest stay behind; the value is a positive integer chosen by the user.
               
               See: <https://libvirt.org/formatdomain.html#time-keeping>
        :param _builtins.float slew: Sets the maximum speed-up factor (relative to real time) used when the guest clock is catching up after being behind the host clock; value is user-provided and typically a positive integer.
               
               See: <https://libvirt.org/formatdomain.html#time-keeping>
        :param _builtins.float threshold: Sets the time difference (in seconds) beyond which the catch-up mechanism is used instead of stepping the guest clock; value is user-provided and usually a positive integer (e.g. 10 or 300).
               
               See: <https://libvirt.org/formatdomain.html#time-keeping>
        """
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if slew is not None:
            pulumi.set(__self__, "slew", slew)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> Optional[_builtins.float]:
        """
        Sets the maximum time difference, in seconds, that the catch-up mechanism is allowed to correct before giving up and letting the guest stay behind; the value is a positive integer chosen by the user.

        See: <https://libvirt.org/formatdomain.html#time-keeping>
        """
        return pulumi.get(self, "limit")

    @_builtins.property
    @pulumi.getter
    def slew(self) -> Optional[_builtins.float]:
        """
        Sets the maximum speed-up factor (relative to real time) used when the guest clock is catching up after being behind the host clock; value is user-provided and typically a positive integer.

        See: <https://libvirt.org/formatdomain.html#time-keeping>
        """
        return pulumi.get(self, "slew")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[_builtins.float]:
        """
        Sets the time difference (in seconds) beyond which the catch-up mechanism is used instead of stepping the guest clock; value is user-provided and usually a positive integer (e.g. 10 or 300).

        See: <https://libvirt.org/formatdomain.html#time-keeping>
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class DomainCpu(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deprecatedFeatures":
            suggest = "deprecated_features"
        elif key == "maxPhysAddr":
            suggest = "max_phys_addr"
        elif key == "modelFallback":
            suggest = "model_fallback"
        elif key == "modelVendorId":
            suggest = "model_vendor_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainCpu. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainCpu.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainCpu.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache: Optional['outputs.DomainCpuCache'] = None,
                 check: Optional[_builtins.str] = None,
                 deprecated_features: Optional[_builtins.str] = None,
                 features: Optional[Sequence['outputs.DomainCpuFeature']] = None,
                 match: Optional[_builtins.str] = None,
                 max_phys_addr: Optional['outputs.DomainCpuMaxPhysAddr'] = None,
                 migratable: Optional[_builtins.bool] = None,
                 mode: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 model_fallback: Optional[_builtins.str] = None,
                 model_vendor_id: Optional[_builtins.str] = None,
                 numa: Optional['outputs.DomainCpuNuma'] = None,
                 topology: Optional['outputs.DomainCpuTopology'] = None,
                 vendor: Optional[_builtins.str] = None):
        """
        :param 'DomainCpuCacheArgs' cache: Configures CPU cache behavior for the guest, such as whether to copy or passthrough host cache information at a specific cache level.
        :param _builtins.str check: Controls how strictly the hypervisor verifies that the requested CPU model and features are supported on the host, with values like "none", "partial", or "full".
               
               See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        :param _builtins.str deprecated_features: Sets whether deprecated CPU features are allowed, typically using values such as "allow", "forbid", or "require" depending on host and hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        :param Sequence['DomainCpuFeatureArgs'] features: Lists additional per-feature overrides to enable, disable, or require specific CPU instruction set features for the guest.
               
               See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        :param _builtins.str match: Selects how the requested CPU model is matched against the host, with valid values including "minimum", "exact", and "strict", affecting migration compatibility and feature guarantees.
               
               See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        :param 'DomainCpuMaxPhysAddrArgs' max_phys_addr: Configures a limit on the physical address width visible to the guest, thereby constraining the maximum guest physical address range.
        :param _builtins.bool migratable: Controls whether the configured CPU model is considered migratable between hosts, using "yes" or "no" string values.
               
               See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        :param _builtins.str mode: Selects the overall CPU model mode for the guest, such as "host-passthrough", "host-model", or "custom", determining how closely the guest CPU matches the host.
               
               See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        :param _builtins.str model: Sets the CPU model name exposed to the guest when using a custom CPU mode, for example "Skylake-Server" or "EPYC".
               
               See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        :param _builtins.str model_fallback: Controls the fallback behavior for applying the requested CPU model (flattened from the cpu.model element), with valid values such as "allow", "forbid", or "legacy" depending on libvirt version.
               
               See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        :param _builtins.str model_vendor_id: Sets a custom CPU vendor ID string for the exposed CPU model (flattened from the cpu.model element), allowing a user-provided vendor_id such as "AuthenticAMD" or "GenuineIntel".
               
               See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        :param 'DomainCpuNumaArgs' numa: Enables detailed NUMA topology specification for the guest CPU, acting as the container for one or more NUMA cells.
        :param 'DomainCpuTopologyArgs' topology: Configures the virtual CPU topology presented to the guest, including the number of sockets, cores, threads, dies, and optional clusters; if omitted, libvirt chooses a topology automatically.
        :param _builtins.str vendor: Specifies the CPU vendor string advertised to the guest (for example, "GenuineIntel" or "AuthenticAMD"); value is user-provided and must be supported by the underlying hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        if cache is not None:
            pulumi.set(__self__, "cache", cache)
        if check is not None:
            pulumi.set(__self__, "check", check)
        if deprecated_features is not None:
            pulumi.set(__self__, "deprecated_features", deprecated_features)
        if features is not None:
            pulumi.set(__self__, "features", features)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if max_phys_addr is not None:
            pulumi.set(__self__, "max_phys_addr", max_phys_addr)
        if migratable is not None:
            pulumi.set(__self__, "migratable", migratable)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if model_fallback is not None:
            pulumi.set(__self__, "model_fallback", model_fallback)
        if model_vendor_id is not None:
            pulumi.set(__self__, "model_vendor_id", model_vendor_id)
        if numa is not None:
            pulumi.set(__self__, "numa", numa)
        if topology is not None:
            pulumi.set(__self__, "topology", topology)
        if vendor is not None:
            pulumi.set(__self__, "vendor", vendor)

    @_builtins.property
    @pulumi.getter
    def cache(self) -> Optional['outputs.DomainCpuCache']:
        """
        Configures CPU cache behavior for the guest, such as whether to copy or passthrough host cache information at a specific cache level.
        """
        return pulumi.get(self, "cache")

    @_builtins.property
    @pulumi.getter
    def check(self) -> Optional[_builtins.str]:
        """
        Controls how strictly the hypervisor verifies that the requested CPU model and features are supported on the host, with values like "none", "partial", or "full".

        See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        return pulumi.get(self, "check")

    @_builtins.property
    @pulumi.getter(name="deprecatedFeatures")
    def deprecated_features(self) -> Optional[_builtins.str]:
        """
        Sets whether deprecated CPU features are allowed, typically using values such as "allow", "forbid", or "require" depending on host and hypervisor support.

        See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        return pulumi.get(self, "deprecated_features")

    @_builtins.property
    @pulumi.getter
    def features(self) -> Optional[Sequence['outputs.DomainCpuFeature']]:
        """
        Lists additional per-feature overrides to enable, disable, or require specific CPU instruction set features for the guest.

        See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        return pulumi.get(self, "features")

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional[_builtins.str]:
        """
        Selects how the requested CPU model is matched against the host, with valid values including "minimum", "exact", and "strict", affecting migration compatibility and feature guarantees.

        See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter(name="maxPhysAddr")
    def max_phys_addr(self) -> Optional['outputs.DomainCpuMaxPhysAddr']:
        """
        Configures a limit on the physical address width visible to the guest, thereby constraining the maximum guest physical address range.
        """
        return pulumi.get(self, "max_phys_addr")

    @_builtins.property
    @pulumi.getter
    def migratable(self) -> Optional[_builtins.bool]:
        """
        Controls whether the configured CPU model is considered migratable between hosts, using "yes" or "no" string values.

        See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        return pulumi.get(self, "migratable")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Selects the overall CPU model mode for the guest, such as "host-passthrough", "host-model", or "custom", determining how closely the guest CPU matches the host.

        See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Sets the CPU model name exposed to the guest when using a custom CPU mode, for example "Skylake-Server" or "EPYC".

        See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter(name="modelFallback")
    def model_fallback(self) -> Optional[_builtins.str]:
        """
        Controls the fallback behavior for applying the requested CPU model (flattened from the cpu.model element), with valid values such as "allow", "forbid", or "legacy" depending on libvirt version.

        See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        return pulumi.get(self, "model_fallback")

    @_builtins.property
    @pulumi.getter(name="modelVendorId")
    def model_vendor_id(self) -> Optional[_builtins.str]:
        """
        Sets a custom CPU vendor ID string for the exposed CPU model (flattened from the cpu.model element), allowing a user-provided vendor_id such as "AuthenticAMD" or "GenuineIntel".

        See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        return pulumi.get(self, "model_vendor_id")

    @_builtins.property
    @pulumi.getter
    def numa(self) -> Optional['outputs.DomainCpuNuma']:
        """
        Enables detailed NUMA topology specification for the guest CPU, acting as the container for one or more NUMA cells.
        """
        return pulumi.get(self, "numa")

    @_builtins.property
    @pulumi.getter
    def topology(self) -> Optional['outputs.DomainCpuTopology']:
        """
        Configures the virtual CPU topology presented to the guest, including the number of sockets, cores, threads, dies, and optional clusters; if omitted, libvirt chooses a topology automatically.
        """
        return pulumi.get(self, "topology")

    @_builtins.property
    @pulumi.getter
    def vendor(self) -> Optional[_builtins.str]:
        """
        Specifies the CPU vendor string advertised to the guest (for example, "GenuineIntel" or "AuthenticAMD"); value is user-provided and must be supported by the underlying hypervisor.

        See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        return pulumi.get(self, "vendor")


@pulumi.output_type
class DomainCpuCache(dict):
    def __init__(__self__, *,
                 mode: _builtins.str,
                 level: Optional[_builtins.float] = None):
        """
        :param _builtins.str mode: Sets the cache configuration mode, with typical values such as "emulate" or "passthrough" depending on hypervisor support; value must be one of the cache modes allowed by libvirt for the selected CPU model.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        :param _builtins.float level: Sets which cache level (for example 1, 2, or 3) the cache configuration applies to; value is a user-provided positive integer corresponding to a CPU cache level.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        pulumi.set(__self__, "mode", mode)
        if level is not None:
            pulumi.set(__self__, "level", level)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets the cache configuration mode, with typical values such as "emulate" or "passthrough" depending on hypervisor support; value must be one of the cache modes allowed by libvirt for the selected CPU model.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[_builtins.float]:
        """
        Sets which cache level (for example 1, 2, or 3) the cache configuration applies to; value is a user-provided positive integer corresponding to a CPU cache level.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class DomainCpuFeature(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 policy: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Names the CPU feature this entry refers to (for example "aes", "vmx", or "sse4.2"); value must be a feature identifier recognized by the underlying CPU model.
               
               See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        :param _builtins.str policy: Sets the policy for the named CPU feature, commonly "force", "require", "optional", "disable", or "forbid", controlling whether the feature must, may, or must not be exposed to the guest.
               
               See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Names the CPU feature this entry refers to (for example "aes", "vmx", or "sse4.2"); value must be a feature identifier recognized by the underlying CPU model.

        See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[_builtins.str]:
        """
        Sets the policy for the named CPU feature, commonly "force", "require", "optional", "disable", or "forbid", controlling whether the feature must, may, or must not be exposed to the guest.

        See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        return pulumi.get(self, "policy")


@pulumi.output_type
class DomainCpuMaxPhysAddr(dict):
    def __init__(__self__, *,
                 mode: _builtins.str,
                 bits: Optional[_builtins.float] = None,
                 limit: Optional[_builtins.float] = None):
        """
        :param _builtins.str mode: Selects how the max physical address limit is applied, with valid values documented by libvirt such as "emulate", "passthrough", or similar driver-specific modes; this attribute is required whenever a max_phys_addr limit is defined.
               
               See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        :param _builtins.float bits: Sets the maximum number of physical address bits exposed to the guest CPU (for example 36, 40, or 48); value must be a positive integer not exceeding the host capability.
               
               See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        :param _builtins.float limit: Sets the maximum guest-visible physical address bit width (e.g. 46) when limiting the CPU's physical address space; the value is user-provided and interpreted according to the selected mode.
               
               See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        pulumi.set(__self__, "mode", mode)
        if bits is not None:
            pulumi.set(__self__, "bits", bits)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Selects how the max physical address limit is applied, with valid values documented by libvirt such as "emulate", "passthrough", or similar driver-specific modes; this attribute is required whenever a max_phys_addr limit is defined.

        See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def bits(self) -> Optional[_builtins.float]:
        """
        Sets the maximum number of physical address bits exposed to the guest CPU (for example 36, 40, or 48); value must be a positive integer not exceeding the host capability.

        See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        return pulumi.get(self, "bits")

    @_builtins.property
    @pulumi.getter
    def limit(self) -> Optional[_builtins.float]:
        """
        Sets the maximum guest-visible physical address bit width (e.g. 46) when limiting the CPU's physical address space; the value is user-provided and interpreted according to the selected mode.

        See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        return pulumi.get(self, "limit")


@pulumi.output_type
class DomainCpuNuma(dict):
    def __init__(__self__, *,
                 cells: Optional[Sequence['outputs.DomainCpuNumaCell']] = None,
                 interconnects: Optional['outputs.DomainCpuNumaInterconnects'] = None):
        """
        :param Sequence['DomainCpuNumaCellArgs'] cells: Defines a single NUMA cell in the guest, including its CPUs, memory, and optional memory-side cache configuration; multiple cells can be specified for multi-node topologies.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        :param 'DomainCpuNumaInterconnectsArgs' interconnects: Configures additional NUMA interconnect properties such as perpair bandwidth and latency between virtual NUMA cells.
        """
        if cells is not None:
            pulumi.set(__self__, "cells", cells)
        if interconnects is not None:
            pulumi.set(__self__, "interconnects", interconnects)

    @_builtins.property
    @pulumi.getter
    def cells(self) -> Optional[Sequence['outputs.DomainCpuNumaCell']]:
        """
        Defines a single NUMA cell in the guest, including its CPUs, memory, and optional memory-side cache configuration; multiple cells can be specified for multi-node topologies.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "cells")

    @_builtins.property
    @pulumi.getter
    def interconnects(self) -> Optional['outputs.DomainCpuNumaInterconnects']:
        """
        Configures additional NUMA interconnect properties such as perpair bandwidth and latency between virtual NUMA cells.
        """
        return pulumi.get(self, "interconnects")


@pulumi.output_type
class DomainCpuNumaCell(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memAccess":
            suggest = "mem_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainCpuNumaCell. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainCpuNumaCell.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainCpuNumaCell.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 memory: _builtins.float,
                 caches: Optional[Sequence['outputs.DomainCpuNumaCellCach']] = None,
                 cpus: Optional[_builtins.str] = None,
                 discard: Optional[_builtins.str] = None,
                 distances: Optional['outputs.DomainCpuNumaCellDistances'] = None,
                 id: Optional[_builtins.float] = None,
                 mem_access: Optional[_builtins.str] = None,
                 unit: Optional[_builtins.str] = None):
        """
        :param _builtins.float memory: Sets the amount of memory assigned to this NUMA cell; value is required and given as a numeric quantity interpreted according to the associated unit.
               
               See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
        :param Sequence['DomainCpuNumaCellCachArgs'] caches: Lists one or more memory-side cache definitions associated with a NUMA cell, describing cache levels and characteristics for heterogeneous memory.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        :param _builtins.str cpus: Specifies which vCPUs belong to a NUMA cell using a CPU list or range syntax accepted by libvirt (e.g. "0-3,8").
               
               See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
        :param _builtins.str discard: Sets whether pages from this NUMA cells memory can be discarded (hinting to the hypervisor that the memory is reclaimable); value is userprovided, typically a yes/no style flag if supported.
               
               See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
        :param 'DomainCpuNumaCellDistancesArgs' distances: Configures percell NUMA distance information for this virtual NUMA cell, defining relative access costs to other cells.
        :param _builtins.float id: Reports the index of this virtual NUMA cell within the domain; it is assigned by libvirt and not userconfigurable.
               
               See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
        :param _builtins.str mem_access: Sets the memory access policy for this NUMA cell (for example, whether memory is preferred, interleaved, or restricted to this node); value is userprovided according to hypervisorsupported policies.
               
               See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
        :param _builtins.str unit: Sets the unit for the NUMA cell memory value (for example "KiB", "MiB", or "GiB"); value is userprovided and must be a libvirtsupported memory unit.
               
               See: <https://libvirt.org/formatdomain.html#memory-allocation>
        """
        pulumi.set(__self__, "memory", memory)
        if caches is not None:
            pulumi.set(__self__, "caches", caches)
        if cpus is not None:
            pulumi.set(__self__, "cpus", cpus)
        if discard is not None:
            pulumi.set(__self__, "discard", discard)
        if distances is not None:
            pulumi.set(__self__, "distances", distances)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mem_access is not None:
            pulumi.set(__self__, "mem_access", mem_access)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.float:
        """
        Sets the amount of memory assigned to this NUMA cell; value is required and given as a numeric quantity interpreted according to the associated unit.

        See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
        """
        return pulumi.get(self, "memory")

    @_builtins.property
    @pulumi.getter
    def caches(self) -> Optional[Sequence['outputs.DomainCpuNumaCellCach']]:
        """
        Lists one or more memory-side cache definitions associated with a NUMA cell, describing cache levels and characteristics for heterogeneous memory.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "caches")

    @_builtins.property
    @pulumi.getter
    def cpus(self) -> Optional[_builtins.str]:
        """
        Specifies which vCPUs belong to a NUMA cell using a CPU list or range syntax accepted by libvirt (e.g. "0-3,8").

        See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
        """
        return pulumi.get(self, "cpus")

    @_builtins.property
    @pulumi.getter
    def discard(self) -> Optional[_builtins.str]:
        """
        Sets whether pages from this NUMA cells memory can be discarded (hinting to the hypervisor that the memory is reclaimable); value is userprovided, typically a yes/no style flag if supported.

        See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
        """
        return pulumi.get(self, "discard")

    @_builtins.property
    @pulumi.getter
    def distances(self) -> Optional['outputs.DomainCpuNumaCellDistances']:
        """
        Configures percell NUMA distance information for this virtual NUMA cell, defining relative access costs to other cells.
        """
        return pulumi.get(self, "distances")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.float]:
        """
        Reports the index of this virtual NUMA cell within the domain; it is assigned by libvirt and not userconfigurable.

        See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="memAccess")
    def mem_access(self) -> Optional[_builtins.str]:
        """
        Sets the memory access policy for this NUMA cell (for example, whether memory is preferred, interleaved, or restricted to this node); value is userprovided according to hypervisorsupported policies.

        See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
        """
        return pulumi.get(self, "mem_access")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        """
        Sets the unit for the NUMA cell memory value (for example "KiB", "MiB", or "GiB"); value is userprovided and must be a libvirtsupported memory unit.

        See: <https://libvirt.org/formatdomain.html#memory-allocation>
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class DomainCpuNumaCellCach(dict):
    def __init__(__self__, *,
                 associativity: _builtins.str,
                 level: _builtins.float,
                 policy: _builtins.str,
                 line: Optional['outputs.DomainCpuNumaCellCachLine'] = None,
                 size: Optional['outputs.DomainCpuNumaCellCachSize'] = None):
        """
        :param _builtins.str associativity: Sets the cache associativity policy (for example "direct", "none", or other user-provided policy names) for a memory-side cache in a NUMA cell.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        :param _builtins.float level: Specifies the cache level (e.g. 1, 2, 3) for a memory-side cache in a NUMA cell, as a user-provided integer indicating hierarchy depth.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        :param _builtins.str policy: Defines the caching policy for a memory-side cache (for example "writeback" or "writethrough") controlling how memory traffic is cached.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        :param 'DomainCpuNumaCellCachLineArgs' line: Configures the cache line size for a memory-side cache in a NUMA cell, via a value and unit pair.
        :param 'DomainCpuNumaCellCachSizeArgs' size: Configures the total size of a memory-side cache in a NUMA cell, via a value and unit pair.
        """
        pulumi.set(__self__, "associativity", associativity)
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "policy", policy)
        if line is not None:
            pulumi.set(__self__, "line", line)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def associativity(self) -> _builtins.str:
        """
        Sets the cache associativity policy (for example "direct", "none", or other user-provided policy names) for a memory-side cache in a NUMA cell.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "associativity")

    @_builtins.property
    @pulumi.getter
    def level(self) -> _builtins.float:
        """
        Specifies the cache level (e.g. 1, 2, 3) for a memory-side cache in a NUMA cell, as a user-provided integer indicating hierarchy depth.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> _builtins.str:
        """
        Defines the caching policy for a memory-side cache (for example "writeback" or "writethrough") controlling how memory traffic is cached.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def line(self) -> Optional['outputs.DomainCpuNumaCellCachLine']:
        """
        Configures the cache line size for a memory-side cache in a NUMA cell, via a value and unit pair.
        """
        return pulumi.get(self, "line")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional['outputs.DomainCpuNumaCellCachSize']:
        """
        Configures the total size of a memory-side cache in a NUMA cell, via a value and unit pair.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class DomainCpuNumaCellCachLine(dict):
    def __init__(__self__, *,
                 unit: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str unit: Sets the unit for the cache line size, typically "bytes" or another libvirt-supported unit string.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        :param _builtins.str value: Sets the numeric cache line size in the given unit, as a user-provided positive integer (for example 64 or 128).
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        """
        Sets the unit for the cache line size, typically "bytes" or another libvirt-supported unit string.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "unit")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Sets the numeric cache line size in the given unit, as a user-provided positive integer (for example 64 or 128).

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainCpuNumaCellCachSize(dict):
    def __init__(__self__, *,
                 unit: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str unit: Sets the unit for the cache size, such as "KiB", "MiB", or "GiB" as supported by libvirt.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        :param _builtins.str value: Sets the numeric cache size in the given unit, as a user-provided positive integer (for example 256 or 1024).
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        """
        Sets the unit for the cache size, such as "KiB", "MiB", or "GiB" as supported by libvirt.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "unit")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Sets the numeric cache size in the given unit, as a user-provided positive integer (for example 256 or 1024).

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainCpuNumaCellDistances(dict):
    def __init__(__self__, *,
                 siblings: Optional[Sequence['outputs.DomainCpuNumaCellDistancesSibling']] = None):
        """
        :param Sequence['DomainCpuNumaCellDistancesSiblingArgs'] siblings: Lists individual NUMA distance entries from this cell to sibling NUMA cells.
               
               See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        if siblings is not None:
            pulumi.set(__self__, "siblings", siblings)

    @_builtins.property
    @pulumi.getter
    def siblings(self) -> Optional[Sequence['outputs.DomainCpuNumaCellDistancesSibling']]:
        """
        Lists individual NUMA distance entries from this cell to sibling NUMA cells.

        See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        return pulumi.get(self, "siblings")


@pulumi.output_type
class DomainCpuNumaCellDistancesSibling(dict):
    def __init__(__self__, *,
                 value: _builtins.float,
                 id: Optional[_builtins.float] = None):
        """
        :param _builtins.float value: Sets the relative NUMA distance (an integer cost metric) from this cell to the referenced sibling cell; value is userprovided, e.g. 10 for local, 20 for remote.
               
               See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        :param _builtins.float id: Reports the sibling NUMA cell ID that this distance entry refers to; this value is computed from the configuration and not set by the user.
               
               See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        pulumi.set(__self__, "value", value)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.float:
        """
        Sets the relative NUMA distance (an integer cost metric) from this cell to the referenced sibling cell; value is userprovided, e.g. 10 for local, 20 for remote.

        See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.float]:
        """
        Reports the sibling NUMA cell ID that this distance entry refers to; this value is computed from the configuration and not set by the user.

        See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class DomainCpuNumaInterconnects(dict):
    def __init__(__self__, *,
                 bandwidths: Optional[Sequence['outputs.DomainCpuNumaInterconnectsBandwidth']] = None,
                 latencies: Optional[Sequence['outputs.DomainCpuNumaInterconnectsLatency']] = None):
        """
        :param Sequence['DomainCpuNumaInterconnectsBandwidthArgs'] bandwidths: Defines one or more bandwidth descriptors for interconnect links between initiator and target NUMA cells.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        :param Sequence['DomainCpuNumaInterconnectsLatencyArgs'] latencies: Defines one or more latency descriptors for interconnect links between initiator and target NUMA cells.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        if bandwidths is not None:
            pulumi.set(__self__, "bandwidths", bandwidths)
        if latencies is not None:
            pulumi.set(__self__, "latencies", latencies)

    @_builtins.property
    @pulumi.getter
    def bandwidths(self) -> Optional[Sequence['outputs.DomainCpuNumaInterconnectsBandwidth']]:
        """
        Defines one or more bandwidth descriptors for interconnect links between initiator and target NUMA cells.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "bandwidths")

    @_builtins.property
    @pulumi.getter
    def latencies(self) -> Optional[Sequence['outputs.DomainCpuNumaInterconnectsLatency']]:
        """
        Defines one or more latency descriptors for interconnect links between initiator and target NUMA cells.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "latencies")


@pulumi.output_type
class DomainCpuNumaInterconnectsBandwidth(dict):
    def __init__(__self__, *,
                 initiator: _builtins.float,
                 target: _builtins.float,
                 type: _builtins.str,
                 unit: _builtins.str,
                 value: _builtins.float,
                 cache: Optional[_builtins.float] = None):
        """
        :param _builtins.float initiator: Sets the ID of the initiator NUMA cell for this bandwidth entry; value is required and must match an existing NUMA cell ID.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        :param _builtins.float target: Sets the ID of the target NUMA cell whose link from the initiator is being described; value is required and must match an existing NUMA cell ID.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        :param _builtins.str type: Sets the bandwidth type being described (for example read, write, or aggregate), as a userprovided string understood by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        :param _builtins.str unit: Sets the unit of the bandwidth value, such as "MB/s"; value is required and must be a libvirtsupported bandwidth unit.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        :param _builtins.float value: Sets the numeric bandwidth for the interconnect between the initiator and target cells in the given unit; value is required and userprovided (e.g. 500 for 500 MB/s).
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        :param _builtins.float cache: Optionally associates the bandwidth measurement with a specific memory side cache level or instance; value is userprovided.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        pulumi.set(__self__, "initiator", initiator)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)
        if cache is not None:
            pulumi.set(__self__, "cache", cache)

    @_builtins.property
    @pulumi.getter
    def initiator(self) -> _builtins.float:
        """
        Sets the ID of the initiator NUMA cell for this bandwidth entry; value is required and must match an existing NUMA cell ID.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "initiator")

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.float:
        """
        Sets the ID of the target NUMA cell whose link from the initiator is being described; value is required and must match an existing NUMA cell ID.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets the bandwidth type being described (for example read, write, or aggregate), as a userprovided string understood by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        """
        Sets the unit of the bandwidth value, such as "MB/s"; value is required and must be a libvirtsupported bandwidth unit.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "unit")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.float:
        """
        Sets the numeric bandwidth for the interconnect between the initiator and target cells in the given unit; value is required and userprovided (e.g. 500 for 500 MB/s).

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def cache(self) -> Optional[_builtins.float]:
        """
        Optionally associates the bandwidth measurement with a specific memory side cache level or instance; value is userprovided.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "cache")


@pulumi.output_type
class DomainCpuNumaInterconnectsLatency(dict):
    def __init__(__self__, *,
                 initiator: _builtins.float,
                 target: _builtins.float,
                 type: _builtins.str,
                 value: _builtins.float,
                 cache: Optional[_builtins.float] = None):
        """
        :param _builtins.float initiator: Sets the ID of the initiator NUMA cell for this latency entry; value is required and must correspond to an existing NUMA cell ID.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        :param _builtins.float target: Sets the target NUMA cell ID for this latency entry, identifying which remote node this latency measurement applies to; value is user-provided and must match an existing NUMA cell index.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        :param _builtins.str type: Sets the type of latency being described between NUMA cells (for example, read, write, or generic access latency); value is user-provided, with allowed tokens defined by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        :param _builtins.float value: Sets the numeric latency value for this NUMA interconnect entry, in the unit implied by the chosen type (for example, nanoseconds); value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        :param _builtins.float cache: Optionally associates the latency measurement with a specific memory side cache; value is userprovided.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        pulumi.set(__self__, "initiator", initiator)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if cache is not None:
            pulumi.set(__self__, "cache", cache)

    @_builtins.property
    @pulumi.getter
    def initiator(self) -> _builtins.float:
        """
        Sets the ID of the initiator NUMA cell for this latency entry; value is required and must correspond to an existing NUMA cell ID.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "initiator")

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.float:
        """
        Sets the target NUMA cell ID for this latency entry, identifying which remote node this latency measurement applies to; value is user-provided and must match an existing NUMA cell index.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets the type of latency being described between NUMA cells (for example, read, write, or generic access latency); value is user-provided, with allowed tokens defined by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.float:
        """
        Sets the numeric latency value for this NUMA interconnect entry, in the unit implied by the chosen type (for example, nanoseconds); value is user-provided.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def cache(self) -> Optional[_builtins.float]:
        """
        Optionally associates the latency measurement with a specific memory side cache; value is userprovided.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "cache")


@pulumi.output_type
class DomainCpuTopology(dict):
    def __init__(__self__, *,
                 clusters: Optional[_builtins.float] = None,
                 cores: Optional[_builtins.float] = None,
                 dies: Optional[_builtins.float] = None,
                 sockets: Optional[_builtins.float] = None,
                 threads: Optional[_builtins.float] = None):
        """
        :param _builtins.float clusters: Sets the number of CPU clusters per die in the guest CPU topology; value is a positive integer and is optional.
               
               See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        :param _builtins.float cores: Sets the number of CPU cores per socket (or per cluster, depending on machine type) in the guest; value is a positive integer and should multiply with sockets, dies, clusters, and threads to match the vCPU count.
               
               See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        :param _builtins.float dies: Sets the number of CPU dies per socket in the guest; value is a positive integer and is optional.
               
               See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        :param _builtins.float sockets: Sets the number of CPU sockets in the guest; value is a positive integer and participates in the overall vCPU count calculation.
               
               See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        :param _builtins.float threads: Sets the number of hardware threads (hyper-threads) per core in the guest; value is a positive integer (commonly 1 or 2).
               
               See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        if clusters is not None:
            pulumi.set(__self__, "clusters", clusters)
        if cores is not None:
            pulumi.set(__self__, "cores", cores)
        if dies is not None:
            pulumi.set(__self__, "dies", dies)
        if sockets is not None:
            pulumi.set(__self__, "sockets", sockets)
        if threads is not None:
            pulumi.set(__self__, "threads", threads)

    @_builtins.property
    @pulumi.getter
    def clusters(self) -> Optional[_builtins.float]:
        """
        Sets the number of CPU clusters per die in the guest CPU topology; value is a positive integer and is optional.

        See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        return pulumi.get(self, "clusters")

    @_builtins.property
    @pulumi.getter
    def cores(self) -> Optional[_builtins.float]:
        """
        Sets the number of CPU cores per socket (or per cluster, depending on machine type) in the guest; value is a positive integer and should multiply with sockets, dies, clusters, and threads to match the vCPU count.

        See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        return pulumi.get(self, "cores")

    @_builtins.property
    @pulumi.getter
    def dies(self) -> Optional[_builtins.float]:
        """
        Sets the number of CPU dies per socket in the guest; value is a positive integer and is optional.

        See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        return pulumi.get(self, "dies")

    @_builtins.property
    @pulumi.getter
    def sockets(self) -> Optional[_builtins.float]:
        """
        Sets the number of CPU sockets in the guest; value is a positive integer and participates in the overall vCPU count calculation.

        See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        return pulumi.get(self, "sockets")

    @_builtins.property
    @pulumi.getter
    def threads(self) -> Optional[_builtins.float]:
        """
        Sets the number of hardware threads (hyper-threads) per core in the guest; value is a positive integer (commonly 1 or 2).

        See: <https://libvirt.org/formatdomain.html#cpu-model-and-topology>
        """
        return pulumi.get(self, "threads")


@pulumi.output_type
class DomainCpuTune(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheTunes":
            suggest = "cache_tunes"
        elif key == "emulatorPeriod":
            suggest = "emulator_period"
        elif key == "emulatorPin":
            suggest = "emulator_pin"
        elif key == "emulatorQuota":
            suggest = "emulator_quota"
        elif key == "emulatorSched":
            suggest = "emulator_sched"
        elif key == "globalPeriod":
            suggest = "global_period"
        elif key == "globalQuota":
            suggest = "global_quota"
        elif key == "ioThreadPeriod":
            suggest = "io_thread_period"
        elif key == "ioThreadPins":
            suggest = "io_thread_pins"
        elif key == "ioThreadQuota":
            suggest = "io_thread_quota"
        elif key == "ioThreadScheds":
            suggest = "io_thread_scheds"
        elif key == "memoryTunes":
            suggest = "memory_tunes"
        elif key == "vcpuPins":
            suggest = "vcpu_pins"
        elif key == "vcpuScheds":
            suggest = "vcpu_scheds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainCpuTune. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainCpuTune.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainCpuTune.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_tunes: Optional[Sequence['outputs.DomainCpuTuneCacheTune']] = None,
                 emulator_period: Optional[_builtins.float] = None,
                 emulator_pin: Optional['outputs.DomainCpuTuneEmulatorPin'] = None,
                 emulator_quota: Optional[_builtins.float] = None,
                 emulator_sched: Optional['outputs.DomainCpuTuneEmulatorSched'] = None,
                 global_period: Optional[_builtins.float] = None,
                 global_quota: Optional[_builtins.float] = None,
                 io_thread_period: Optional[_builtins.float] = None,
                 io_thread_pins: Optional[Sequence['outputs.DomainCpuTuneIoThreadPin']] = None,
                 io_thread_quota: Optional[_builtins.float] = None,
                 io_thread_scheds: Optional[Sequence['outputs.DomainCpuTuneIoThreadSched']] = None,
                 memory_tunes: Optional[Sequence['outputs.DomainCpuTuneMemoryTune']] = None,
                 period: Optional[_builtins.float] = None,
                 quota: Optional[_builtins.float] = None,
                 shares: Optional[_builtins.float] = None,
                 vcpu_pins: Optional[Sequence['outputs.DomainCpuTuneVcpuPin']] = None,
                 vcpu_scheds: Optional[Sequence['outputs.DomainCpuTuneVcpuSched']] = None):
        """
        :param Sequence['DomainCpuTuneCacheTuneArgs'] cache_tunes: Configures cache allocation and partitioning between NUMA cells or vCPUs, allowing you to reserve or limit portions of shared caches.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        :param _builtins.float emulator_period: Sets the CPU time period in microseconds used to calculate cgroup quota for the QEMU emulator thread; value is a positive integer and is user-provided (for example, 100000).
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        :param 'DomainCpuTuneEmulatorPinArgs' emulator_pin: Configures CPU pinning for the QEMU emulator thread, constraining it to a specific set of host CPUs.
        :param _builtins.float emulator_quota: Sets the total CPU time in microseconds that the emulator thread is allowed to consume per scheduling period; value is a user-provided integer, typically positive to enforce a limit or -1 for unlimited where supported.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        :param 'DomainCpuTuneEmulatorSchedArgs' emulator_sched: Configures the scheduler policy and priority for the emulator thread within its cgroup.
        :param _builtins.float global_period: Sets the global CPU period in microseconds used as the base for quota calculations for all vCPUs and emulator threads unless overridden; value is a positive integer and user-provided.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        :param _builtins.float global_quota: Sets the global CPU time quota in microseconds per period for the entire domain, limiting aggregate CPU usage across all vCPUs and emulator threads; value is a user-provided integer, commonly positive or -1 for unlimited where supported.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        :param _builtins.float io_thread_period: Sets the CPU time period in microseconds used to calculate cgroup quota for IOThreads; value is a positive, user-provided integer (for example, 100000).
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        :param Sequence['DomainCpuTuneIoThreadPinArgs'] io_thread_pins: Configures CPU pinning for a specific IOThread, constraining that IOThread to a set of host CPUs.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        :param _builtins.float io_thread_quota: Sets the total CPU time in microseconds that each IOThread is allowed to consume per scheduling period when per-IOThread quotas are enabled; value is a user-provided integer, typically positive or -1 for unlimited where supported.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        :param Sequence['DomainCpuTuneIoThreadSchedArgs'] io_thread_scheds: Configures scheduler policy and priority for one or more IOThreads.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        :param Sequence['DomainCpuTuneMemoryTuneArgs'] memory_tunes: Enables per-vCPU memory bandwidth tuning for the domain, grouping configuration for monitored vCPUs and per-NUMA-node memory bandwidth caps.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        :param _builtins.float period: Sets the CPU cgroup scheduler period in microseconds for all vCPUs, controlling the time window used with `quota` (for example, `100000`).
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        :param _builtins.float quota: Sets the total CPU time in microseconds allowed per `period` for all vCPUs, using a positive integer or `-1` for no limit.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        :param _builtins.float shares: Sets the relative CPU weight (shares) of the domain in the CPU cgroup, typically a positive integer such as `1024` used for proportional scheduling.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        :param Sequence['DomainCpuTuneVcpuPinArgs'] vcpu_pins: Configures one or more pinning rules mapping each virtual CPU to a specific set of host CPUs for execution.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        :param Sequence['DomainCpuTuneVcpuSchedArgs'] vcpu_scheds: Configures scheduler attributes for one or more groups of vCPUs, such as scheduler class and priority.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        if cache_tunes is not None:
            pulumi.set(__self__, "cache_tunes", cache_tunes)
        if emulator_period is not None:
            pulumi.set(__self__, "emulator_period", emulator_period)
        if emulator_pin is not None:
            pulumi.set(__self__, "emulator_pin", emulator_pin)
        if emulator_quota is not None:
            pulumi.set(__self__, "emulator_quota", emulator_quota)
        if emulator_sched is not None:
            pulumi.set(__self__, "emulator_sched", emulator_sched)
        if global_period is not None:
            pulumi.set(__self__, "global_period", global_period)
        if global_quota is not None:
            pulumi.set(__self__, "global_quota", global_quota)
        if io_thread_period is not None:
            pulumi.set(__self__, "io_thread_period", io_thread_period)
        if io_thread_pins is not None:
            pulumi.set(__self__, "io_thread_pins", io_thread_pins)
        if io_thread_quota is not None:
            pulumi.set(__self__, "io_thread_quota", io_thread_quota)
        if io_thread_scheds is not None:
            pulumi.set(__self__, "io_thread_scheds", io_thread_scheds)
        if memory_tunes is not None:
            pulumi.set(__self__, "memory_tunes", memory_tunes)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if quota is not None:
            pulumi.set(__self__, "quota", quota)
        if shares is not None:
            pulumi.set(__self__, "shares", shares)
        if vcpu_pins is not None:
            pulumi.set(__self__, "vcpu_pins", vcpu_pins)
        if vcpu_scheds is not None:
            pulumi.set(__self__, "vcpu_scheds", vcpu_scheds)

    @_builtins.property
    @pulumi.getter(name="cacheTunes")
    def cache_tunes(self) -> Optional[Sequence['outputs.DomainCpuTuneCacheTune']]:
        """
        Configures cache allocation and partitioning between NUMA cells or vCPUs, allowing you to reserve or limit portions of shared caches.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "cache_tunes")

    @_builtins.property
    @pulumi.getter(name="emulatorPeriod")
    def emulator_period(self) -> Optional[_builtins.float]:
        """
        Sets the CPU time period in microseconds used to calculate cgroup quota for the QEMU emulator thread; value is a positive integer and is user-provided (for example, 100000).

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "emulator_period")

    @_builtins.property
    @pulumi.getter(name="emulatorPin")
    def emulator_pin(self) -> Optional['outputs.DomainCpuTuneEmulatorPin']:
        """
        Configures CPU pinning for the QEMU emulator thread, constraining it to a specific set of host CPUs.
        """
        return pulumi.get(self, "emulator_pin")

    @_builtins.property
    @pulumi.getter(name="emulatorQuota")
    def emulator_quota(self) -> Optional[_builtins.float]:
        """
        Sets the total CPU time in microseconds that the emulator thread is allowed to consume per scheduling period; value is a user-provided integer, typically positive to enforce a limit or -1 for unlimited where supported.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "emulator_quota")

    @_builtins.property
    @pulumi.getter(name="emulatorSched")
    def emulator_sched(self) -> Optional['outputs.DomainCpuTuneEmulatorSched']:
        """
        Configures the scheduler policy and priority for the emulator thread within its cgroup.
        """
        return pulumi.get(self, "emulator_sched")

    @_builtins.property
    @pulumi.getter(name="globalPeriod")
    def global_period(self) -> Optional[_builtins.float]:
        """
        Sets the global CPU period in microseconds used as the base for quota calculations for all vCPUs and emulator threads unless overridden; value is a positive integer and user-provided.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "global_period")

    @_builtins.property
    @pulumi.getter(name="globalQuota")
    def global_quota(self) -> Optional[_builtins.float]:
        """
        Sets the global CPU time quota in microseconds per period for the entire domain, limiting aggregate CPU usage across all vCPUs and emulator threads; value is a user-provided integer, commonly positive or -1 for unlimited where supported.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "global_quota")

    @_builtins.property
    @pulumi.getter(name="ioThreadPeriod")
    def io_thread_period(self) -> Optional[_builtins.float]:
        """
        Sets the CPU time period in microseconds used to calculate cgroup quota for IOThreads; value is a positive, user-provided integer (for example, 100000).

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "io_thread_period")

    @_builtins.property
    @pulumi.getter(name="ioThreadPins")
    def io_thread_pins(self) -> Optional[Sequence['outputs.DomainCpuTuneIoThreadPin']]:
        """
        Configures CPU pinning for a specific IOThread, constraining that IOThread to a set of host CPUs.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "io_thread_pins")

    @_builtins.property
    @pulumi.getter(name="ioThreadQuota")
    def io_thread_quota(self) -> Optional[_builtins.float]:
        """
        Sets the total CPU time in microseconds that each IOThread is allowed to consume per scheduling period when per-IOThread quotas are enabled; value is a user-provided integer, typically positive or -1 for unlimited where supported.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "io_thread_quota")

    @_builtins.property
    @pulumi.getter(name="ioThreadScheds")
    def io_thread_scheds(self) -> Optional[Sequence['outputs.DomainCpuTuneIoThreadSched']]:
        """
        Configures scheduler policy and priority for one or more IOThreads.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "io_thread_scheds")

    @_builtins.property
    @pulumi.getter(name="memoryTunes")
    def memory_tunes(self) -> Optional[Sequence['outputs.DomainCpuTuneMemoryTune']]:
        """
        Enables per-vCPU memory bandwidth tuning for the domain, grouping configuration for monitored vCPUs and per-NUMA-node memory bandwidth caps.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "memory_tunes")

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[_builtins.float]:
        """
        Sets the CPU cgroup scheduler period in microseconds for all vCPUs, controlling the time window used with `quota` (for example, `100000`).

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter
    def quota(self) -> Optional[_builtins.float]:
        """
        Sets the total CPU time in microseconds allowed per `period` for all vCPUs, using a positive integer or `-1` for no limit.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "quota")

    @_builtins.property
    @pulumi.getter
    def shares(self) -> Optional[_builtins.float]:
        """
        Sets the relative CPU weight (shares) of the domain in the CPU cgroup, typically a positive integer such as `1024` used for proportional scheduling.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "shares")

    @_builtins.property
    @pulumi.getter(name="vcpuPins")
    def vcpu_pins(self) -> Optional[Sequence['outputs.DomainCpuTuneVcpuPin']]:
        """
        Configures one or more pinning rules mapping each virtual CPU to a specific set of host CPUs for execution.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "vcpu_pins")

    @_builtins.property
    @pulumi.getter(name="vcpuScheds")
    def vcpu_scheds(self) -> Optional[Sequence['outputs.DomainCpuTuneVcpuSched']]:
        """
        Configures scheduler attributes for one or more groups of vCPUs, such as scheduler class and priority.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "vcpu_scheds")


@pulumi.output_type
class DomainCpuTuneCacheTune(dict):
    def __init__(__self__, *,
                 caches: Optional[Sequence['outputs.DomainCpuTuneCacheTuneCach']] = None,
                 id: Optional[_builtins.str] = None,
                 monitors: Optional[Sequence['outputs.DomainCpuTuneCacheTuneMonitor']] = None,
                 vcpus: Optional[_builtins.str] = None):
        """
        :param Sequence['DomainCpuTuneCacheTuneCachArgs'] caches: Defines a single cache allocation entry associated with this cache tuning group, describing size, level, and type of cache reserved for a given cell or vCPU set.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        :param _builtins.str id: Reports an identifier for this cache tuning group as determined by libvirt; this value is computed and not user-settable.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        :param Sequence['DomainCpuTuneCacheTuneMonitorArgs'] monitors: Configures one or more performance monitor associations for this cache tuning group (for example, to track usage of the reserved cache region); values are user-provided and driver-specific.
               
               See: <https://libvirt.org/formatdomain.html#performance-monitoring-events>
        :param _builtins.str vcpus: Specifies the set of vCPUs whose cache allocation is controlled by this cache tuning entry, as a cpuset-style string (for example, "0-3" or "1,3"); the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        if caches is not None:
            pulumi.set(__self__, "caches", caches)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if monitors is not None:
            pulumi.set(__self__, "monitors", monitors)
        if vcpus is not None:
            pulumi.set(__self__, "vcpus", vcpus)

    @_builtins.property
    @pulumi.getter
    def caches(self) -> Optional[Sequence['outputs.DomainCpuTuneCacheTuneCach']]:
        """
        Defines a single cache allocation entry associated with this cache tuning group, describing size, level, and type of cache reserved for a given cell or vCPU set.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "caches")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Reports an identifier for this cache tuning group as determined by libvirt; this value is computed and not user-settable.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def monitors(self) -> Optional[Sequence['outputs.DomainCpuTuneCacheTuneMonitor']]:
        """
        Configures one or more performance monitor associations for this cache tuning group (for example, to track usage of the reserved cache region); values are user-provided and driver-specific.

        See: <https://libvirt.org/formatdomain.html#performance-monitoring-events>
        """
        return pulumi.get(self, "monitors")

    @_builtins.property
    @pulumi.getter
    def vcpus(self) -> Optional[_builtins.str]:
        """
        Specifies the set of vCPUs whose cache allocation is controlled by this cache tuning entry, as a cpuset-style string (for example, "0-3" or "1,3"); the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "vcpus")


@pulumi.output_type
class DomainCpuTuneCacheTuneCach(dict):
    def __init__(__self__, *,
                 level: _builtins.float,
                 size: _builtins.float,
                 type: _builtins.str,
                 unit: _builtins.str,
                 id: Optional[_builtins.float] = None):
        """
        :param _builtins.float level: Sets which cache level this allocation refers to (for example, 3 for L3 cache); value is a positive integer.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        :param _builtins.float size: Sets the size of cache reserved or described by this entry, combined with unit (for example, "4" with unit "MiB"); value is a positive integer.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        :param _builtins.str type: Sets the cache type this entry refers to, such as data, instruction, or unified cache; value is user-provided and must match a type accepted by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        :param _builtins.str unit: Sets the unit used for the cache size value, typically bytes or a binary multiple such as KiB or MiB; value is user-provided but must be a unit recognized by libvirt.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        :param _builtins.float id: Reports an identifier for this cache entry as assigned by libvirt or the hypervisor; this value is computed and not set by the user.
               
               See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "unit", unit)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def level(self) -> _builtins.float:
        """
        Sets which cache level this allocation refers to (for example, 3 for L3 cache); value is a positive integer.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.float:
        """
        Sets the size of cache reserved or described by this entry, combined with unit (for example, "4" with unit "MiB"); value is a positive integer.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets the cache type this entry refers to, such as data, instruction, or unified cache; value is user-provided and must match a type accepted by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        """
        Sets the unit used for the cache size value, typically bytes or a binary multiple such as KiB or MiB; value is user-provided but must be a unit recognized by libvirt.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "unit")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.float]:
        """
        Reports an identifier for this cache entry as assigned by libvirt or the hypervisor; this value is computed and not set by the user.

        See: <https://libvirt.org/formatdomain.html#acpi-heterogeneous-memory-attribute-table>
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class DomainCpuTuneCacheTuneMonitor(dict):
    def __init__(__self__, *,
                 level: Optional[_builtins.float] = None,
                 vcpus: Optional[_builtins.str] = None):
        """
        :param _builtins.float level: Sets the cache hierarchy level that the cache monitoring group applies to, as an integer level number (for example, 1 for L1, 2 for L2); the value is user-provided and must match a cache level supported by the host.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        :param _builtins.str vcpus: Specifies the set of vCPU indexes that belong to this cache monitoring group, using the same comma-separated and range syntax as other cpuset strings (for example, "0,2-3"); the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        if level is not None:
            pulumi.set(__self__, "level", level)
        if vcpus is not None:
            pulumi.set(__self__, "vcpus", vcpus)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[_builtins.float]:
        """
        Sets the cache hierarchy level that the cache monitoring group applies to, as an integer level number (for example, 1 for L1, 2 for L2); the value is user-provided and must match a cache level supported by the host.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter
    def vcpus(self) -> Optional[_builtins.str]:
        """
        Specifies the set of vCPU indexes that belong to this cache monitoring group, using the same comma-separated and range syntax as other cpuset strings (for example, "0,2-3"); the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "vcpus")


@pulumi.output_type
class DomainCpuTuneEmulatorPin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuSet":
            suggest = "cpu_set"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainCpuTuneEmulatorPin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainCpuTuneEmulatorPin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainCpuTuneEmulatorPin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_set: _builtins.str):
        """
        :param _builtins.str cpu_set: Defines the cpuset of host CPUs on which the emulator thread may run, using the standard cpuset syntax such as "0-3" or "1,3,5"; this attribute is required when emulator pinning is configured.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        pulumi.set(__self__, "cpu_set", cpu_set)

    @_builtins.property
    @pulumi.getter(name="cpuSet")
    def cpu_set(self) -> _builtins.str:
        """
        Defines the cpuset of host CPUs on which the emulator thread may run, using the standard cpuset syntax such as "0-3" or "1,3,5"; this attribute is required when emulator pinning is configured.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "cpu_set")


@pulumi.output_type
class DomainCpuTuneEmulatorSched(dict):
    def __init__(__self__, *,
                 priority: Optional[_builtins.float] = None,
                 scheduler: Optional[_builtins.str] = None):
        """
        :param _builtins.float priority: Sets the scheduler priority for the emulator thread; the valid numeric range depends on the chosen scheduler policy and host kernel (value is user-provided).
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        :param _builtins.str scheduler: Selects the scheduler policy for the emulator thread, typically one of "batch", "fifo", "rr", or "idle" where supported; value is user-provided and must match a kernel scheduling class.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if scheduler is not None:
            pulumi.set(__self__, "scheduler", scheduler)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.float]:
        """
        Sets the scheduler priority for the emulator thread; the valid numeric range depends on the chosen scheduler policy and host kernel (value is user-provided).

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def scheduler(self) -> Optional[_builtins.str]:
        """
        Selects the scheduler policy for the emulator thread, typically one of "batch", "fifo", "rr", or "idle" where supported; value is user-provided and must match a kernel scheduling class.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "scheduler")


@pulumi.output_type
class DomainCpuTuneIoThreadPin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuSet":
            suggest = "cpu_set"
        elif key == "ioThread":
            suggest = "io_thread"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainCpuTuneIoThreadPin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainCpuTuneIoThreadPin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainCpuTuneIoThreadPin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_set: _builtins.str,
                 io_thread: _builtins.float):
        """
        :param _builtins.str cpu_set: Defines the cpuset of host CPUs on which the specified IOThread may run, using cpuset syntax like "0,2-3"; this attribute is required for each io_thread_pin entry.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        :param _builtins.float io_thread: Identifies which IOThread is being pinned by index, using the IOThread ID as defined in the domain (for example, 1 or 2); this attribute is required for each io_thread_pin entry.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        pulumi.set(__self__, "cpu_set", cpu_set)
        pulumi.set(__self__, "io_thread", io_thread)

    @_builtins.property
    @pulumi.getter(name="cpuSet")
    def cpu_set(self) -> _builtins.str:
        """
        Defines the cpuset of host CPUs on which the specified IOThread may run, using cpuset syntax like "0,2-3"; this attribute is required for each io_thread_pin entry.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "cpu_set")

    @_builtins.property
    @pulumi.getter(name="ioThread")
    def io_thread(self) -> _builtins.float:
        """
        Identifies which IOThread is being pinned by index, using the IOThread ID as defined in the domain (for example, 1 or 2); this attribute is required for each io_thread_pin entry.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "io_thread")


@pulumi.output_type
class DomainCpuTuneIoThreadSched(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ioThreads":
            suggest = "io_threads"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainCpuTuneIoThreadSched. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainCpuTuneIoThreadSched.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainCpuTuneIoThreadSched.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 io_threads: _builtins.str,
                 priority: Optional[_builtins.float] = None,
                 scheduler: Optional[_builtins.str] = None):
        """
        :param _builtins.str io_threads: Specifies the IOThread or set of IOThreads to which this scheduling configuration applies, usually as a comma-separated list of IOThread IDs (for example, "1" or "1,2"); this attribute is required.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        :param _builtins.float priority: Sets the scheduler priority for the selected IOThreads; valid numeric range depends on the chosen scheduler policy and host kernel, and is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        :param _builtins.str scheduler: Sets the scheduler policy for IOThreads, using one of the supported cgroup scheduler values such as `batch`, `fifo`, `rr`, or `both`; if omitted, the hypervisors default scheduling policy is used.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        pulumi.set(__self__, "io_threads", io_threads)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if scheduler is not None:
            pulumi.set(__self__, "scheduler", scheduler)

    @_builtins.property
    @pulumi.getter(name="ioThreads")
    def io_threads(self) -> _builtins.str:
        """
        Specifies the IOThread or set of IOThreads to which this scheduling configuration applies, usually as a comma-separated list of IOThread IDs (for example, "1" or "1,2"); this attribute is required.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "io_threads")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.float]:
        """
        Sets the scheduler priority for the selected IOThreads; valid numeric range depends on the chosen scheduler policy and host kernel, and is user-provided.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def scheduler(self) -> Optional[_builtins.str]:
        """
        Sets the scheduler policy for IOThreads, using one of the supported cgroup scheduler values such as `batch`, `fifo`, `rr`, or `both`; if omitted, the hypervisors default scheduling policy is used.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "scheduler")


@pulumi.output_type
class DomainCpuTuneMemoryTune(dict):
    def __init__(__self__, *,
                 vcpus: _builtins.str,
                 monitors: Optional[Sequence['outputs.DomainCpuTuneMemoryTuneMonitor']] = None,
                 nodes: Optional[Sequence['outputs.DomainCpuTuneMemoryTuneNode']] = None):
        """
        :param _builtins.str vcpus: Specifies which vCPUs are subject to the memory tuning configuration, using libvirt CPU set syntax (e.g. `0-1`, `1,3`); this is required when memory tuning is defined.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        :param Sequence['DomainCpuTuneMemoryTuneMonitorArgs'] monitors: Configures which vCPUs are monitored for memory bandwidth usage and the hierarchy level at which libvirt tracks memory usage statistics.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        :param Sequence['DomainCpuTuneMemoryTuneNodeArgs'] nodes: Defines one or more NUMA memory nodes for which to apply memory bandwidth limits as part of memory tuning.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        pulumi.set(__self__, "vcpus", vcpus)
        if monitors is not None:
            pulumi.set(__self__, "monitors", monitors)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)

    @_builtins.property
    @pulumi.getter
    def vcpus(self) -> _builtins.str:
        """
        Specifies which vCPUs are subject to the memory tuning configuration, using libvirt CPU set syntax (e.g. `0-1`, `1,3`); this is required when memory tuning is defined.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "vcpus")

    @_builtins.property
    @pulumi.getter
    def monitors(self) -> Optional[Sequence['outputs.DomainCpuTuneMemoryTuneMonitor']]:
        """
        Configures which vCPUs are monitored for memory bandwidth usage and the hierarchy level at which libvirt tracks memory usage statistics.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "monitors")

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Optional[Sequence['outputs.DomainCpuTuneMemoryTuneNode']]:
        """
        Defines one or more NUMA memory nodes for which to apply memory bandwidth limits as part of memory tuning.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "nodes")


@pulumi.output_type
class DomainCpuTuneMemoryTuneMonitor(dict):
    def __init__(__self__, *,
                 level: Optional[_builtins.float] = None,
                 vcpus: Optional[_builtins.str] = None):
        """
        :param _builtins.float level: Sets the monitoring level for memory bandwidth (for example, a cache or memory hierarchy level), as a user-provided string understood by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        :param _builtins.str vcpus: Specifies the set of vCPUs to monitor for memory bandwidth, using the libvirt CPU set syntax (e.g. `0-3`, `0,2,4`).
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        if level is not None:
            pulumi.set(__self__, "level", level)
        if vcpus is not None:
            pulumi.set(__self__, "vcpus", vcpus)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[_builtins.float]:
        """
        Sets the monitoring level for memory bandwidth (for example, a cache or memory hierarchy level), as a user-provided string understood by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter
    def vcpus(self) -> Optional[_builtins.str]:
        """
        Specifies the set of vCPUs to monitor for memory bandwidth, using the libvirt CPU set syntax (e.g. `0-3`, `0,2,4`).

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "vcpus")


@pulumi.output_type
class DomainCpuTuneMemoryTuneNode(dict):
    def __init__(__self__, *,
                 bandwidth: _builtins.float,
                 id: Optional[_builtins.float] = None):
        """
        :param _builtins.float bandwidth: Sets the memory bandwidth limit for this NUMA node in MB/s; this attribute is required for each node entry.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        :param _builtins.float id: Reports the NUMA node ID this memory bandwidth limit applies to; this is computed from the host topology and not set by the user.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        pulumi.set(__self__, "bandwidth", bandwidth)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> _builtins.float:
        """
        Sets the memory bandwidth limit for this NUMA node in MB/s; this attribute is required for each node entry.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.float]:
        """
        Reports the NUMA node ID this memory bandwidth limit applies to; this is computed from the host topology and not set by the user.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class DomainCpuTuneVcpuPin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuSet":
            suggest = "cpu_set"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainCpuTuneVcpuPin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainCpuTuneVcpuPin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainCpuTuneVcpuPin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_set: _builtins.str,
                 vcpu: _builtins.float):
        """
        :param _builtins.str cpu_set: Specifies the host CPU set to which this vCPU is pinned, using libvirt CPU set syntax (e.g. `0-3`, `2,4`); this is required for each pin entry.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        :param _builtins.float vcpu: Identifies the virtual CPU index (starting at 0) that this pinning rule applies to; this is required for each pin entry.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        pulumi.set(__self__, "cpu_set", cpu_set)
        pulumi.set(__self__, "vcpu", vcpu)

    @_builtins.property
    @pulumi.getter(name="cpuSet")
    def cpu_set(self) -> _builtins.str:
        """
        Specifies the host CPU set to which this vCPU is pinned, using libvirt CPU set syntax (e.g. `0-3`, `2,4`); this is required for each pin entry.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "cpu_set")

    @_builtins.property
    @pulumi.getter
    def vcpu(self) -> _builtins.float:
        """
        Identifies the virtual CPU index (starting at 0) that this pinning rule applies to; this is required for each pin entry.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "vcpu")


@pulumi.output_type
class DomainCpuTuneVcpuSched(dict):
    def __init__(__self__, *,
                 vcpus: _builtins.str,
                 priority: Optional[_builtins.float] = None,
                 scheduler: Optional[_builtins.str] = None):
        """
        :param _builtins.str vcpus: Specifies which vCPUs this scheduler configuration applies to, using libvirt CPU set syntax (e.g. `0`, `0-1`, `1,3`); this attribute is required.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        :param _builtins.float priority: Sets the scheduler priority for the selected vCPUs, as an integer whose valid range depends on the chosen scheduler policy and host kernel.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        :param _builtins.str scheduler: Sets the scheduler policy for the selected vCPUs, using one of the supported policies such as `batch`, `fifo`, or `rr`; if omitted, the default policy applies.
               
               See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        pulumi.set(__self__, "vcpus", vcpus)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if scheduler is not None:
            pulumi.set(__self__, "scheduler", scheduler)

    @_builtins.property
    @pulumi.getter
    def vcpus(self) -> _builtins.str:
        """
        Specifies which vCPUs this scheduler configuration applies to, using libvirt CPU set syntax (e.g. `0`, `0-1`, `1,3`); this attribute is required.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "vcpus")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.float]:
        """
        Sets the scheduler priority for the selected vCPUs, as an integer whose valid range depends on the chosen scheduler policy and host kernel.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def scheduler(self) -> Optional[_builtins.str]:
        """
        Sets the scheduler policy for the selected vCPUs, using one of the supported policies such as `batch`, `fifo`, or `rr`; if omitted, the default policy applies.

        See: <https://libvirt.org/formatdomain.html#cpu-tuning>
        """
        return pulumi.get(self, "scheduler")


@pulumi.output_type
class DomainCreate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bypassCache":
            suggest = "bypass_cache"
        elif key == "forceBoot":
            suggest = "force_boot"
        elif key == "resetNvram":
            suggest = "reset_nvram"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainCreate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainCreate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainCreate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autodestroy: Optional[_builtins.bool] = None,
                 bypass_cache: Optional[_builtins.bool] = None,
                 force_boot: Optional[_builtins.bool] = None,
                 paused: Optional[_builtins.bool] = None,
                 reset_nvram: Optional[_builtins.bool] = None,
                 validate: Optional[_builtins.bool] = None):
        if autodestroy is not None:
            pulumi.set(__self__, "autodestroy", autodestroy)
        if bypass_cache is not None:
            pulumi.set(__self__, "bypass_cache", bypass_cache)
        if force_boot is not None:
            pulumi.set(__self__, "force_boot", force_boot)
        if paused is not None:
            pulumi.set(__self__, "paused", paused)
        if reset_nvram is not None:
            pulumi.set(__self__, "reset_nvram", reset_nvram)
        if validate is not None:
            pulumi.set(__self__, "validate", validate)

    @_builtins.property
    @pulumi.getter
    def autodestroy(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "autodestroy")

    @_builtins.property
    @pulumi.getter(name="bypassCache")
    def bypass_cache(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "bypass_cache")

    @_builtins.property
    @pulumi.getter(name="forceBoot")
    def force_boot(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "force_boot")

    @_builtins.property
    @pulumi.getter
    def paused(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "paused")

    @_builtins.property
    @pulumi.getter(name="resetNvram")
    def reset_nvram(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "reset_nvram")

    @_builtins.property
    @pulumi.getter
    def validate(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "validate")


@pulumi.output_type
class DomainDefaultIoThread(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolMax":
            suggest = "pool_max"
        elif key == "poolMin":
            suggest = "pool_min"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDefaultIoThread. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDefaultIoThread.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDefaultIoThread.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pool_max: Optional[_builtins.float] = None,
                 pool_min: Optional[_builtins.float] = None):
        """
        :param _builtins.float pool_max: Sets the maximum number of threads in the default IOThread pool; value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
        :param _builtins.float pool_min: Sets the minimum number of threads in the default IOThread pool; value is user-provided and must be a nonnegative integer not greater than pool_max.
               
               See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
        """
        if pool_max is not None:
            pulumi.set(__self__, "pool_max", pool_max)
        if pool_min is not None:
            pulumi.set(__self__, "pool_min", pool_min)

    @_builtins.property
    @pulumi.getter(name="poolMax")
    def pool_max(self) -> Optional[_builtins.float]:
        """
        Sets the maximum number of threads in the default IOThread pool; value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
        """
        return pulumi.get(self, "pool_max")

    @_builtins.property
    @pulumi.getter(name="poolMin")
    def pool_min(self) -> Optional[_builtins.float]:
        """
        Sets the minimum number of threads in the default IOThread pool; value is user-provided and must be a nonnegative integer not greater than pool_max.

        See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
        """
        return pulumi.get(self, "pool_min")


@pulumi.output_type
class DomainDestroy(dict):
    def __init__(__self__, *,
                 graceful: Optional[_builtins.bool] = None,
                 timeout: Optional[_builtins.float] = None):
        if graceful is not None:
            pulumi.set(__self__, "graceful", graceful)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def graceful(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "graceful")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevices(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memBalloon":
            suggest = "mem_balloon"
        elif key == "redirDevs":
            suggest = "redir_devs"
        elif key == "redirFilters":
            suggest = "redir_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevices. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevices.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevices.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audios: Optional[Sequence['outputs.DomainDevicesAudio']] = None,
                 channels: Optional[Sequence['outputs.DomainDevicesChannel']] = None,
                 consoles: Optional[Sequence['outputs.DomainDevicesConsole']] = None,
                 controllers: Optional[Sequence['outputs.DomainDevicesController']] = None,
                 cryptos: Optional[Sequence['outputs.DomainDevicesCrypto']] = None,
                 disks: Optional[Sequence['outputs.DomainDevicesDisk']] = None,
                 emulator: Optional[_builtins.str] = None,
                 filesystems: Optional[Sequence['outputs.DomainDevicesFilesystem']] = None,
                 graphics: Optional[Sequence['outputs.DomainDevicesGraphic']] = None,
                 hostdevs: Optional[Sequence['outputs.DomainDevicesHostdev']] = None,
                 hubs: Optional[Sequence['outputs.DomainDevicesHub']] = None,
                 inputs: Optional[Sequence['outputs.DomainDevicesInput']] = None,
                 interfaces: Optional[Sequence['outputs.DomainDevicesInterface']] = None,
                 iommu: Optional['outputs.DomainDevicesIommu'] = None,
                 leases: Optional[Sequence['outputs.DomainDevicesLease']] = None,
                 mem_balloon: Optional['outputs.DomainDevicesMemBalloon'] = None,
                 memorydevs: Optional[Sequence['outputs.DomainDevicesMemorydev']] = None,
                 nvram: Optional['outputs.DomainDevicesNvram'] = None,
                 panics: Optional[Sequence['outputs.DomainDevicesPanic']] = None,
                 parallels: Optional[Sequence['outputs.DomainDevicesParallel']] = None,
                 pstore: Optional['outputs.DomainDevicesPstore'] = None,
                 redir_devs: Optional[Sequence['outputs.DomainDevicesRedirDev']] = None,
                 redir_filters: Optional[Sequence['outputs.DomainDevicesRedirFilter']] = None,
                 rngs: Optional[Sequence['outputs.DomainDevicesRng']] = None,
                 serials: Optional[Sequence['outputs.DomainDevicesSerial']] = None,
                 shmems: Optional[Sequence['outputs.DomainDevicesShmem']] = None,
                 smartcards: Optional[Sequence['outputs.DomainDevicesSmartcard']] = None,
                 sounds: Optional[Sequence['outputs.DomainDevicesSound']] = None,
                 tpms: Optional[Sequence['outputs.DomainDevicesTpm']] = None,
                 videos: Optional[Sequence['outputs.DomainDevicesVideo']] = None,
                 vsock: Optional['outputs.DomainDevicesVsock'] = None,
                 watchdogs: Optional[Sequence['outputs.DomainDevicesWatchdog']] = None):
        """
        :param Sequence['DomainDevicesAudioArgs'] audios: Configures one or more audio backend definitions that map virtual sound devices in the guest to host audio backends.
               
               See: <https://libvirt.org/formatdomain.html#audio-backends>
        :param Sequence['DomainDevicesChannelArgs'] channels: Defines one or more guest channel devices, which provide private communication paths between host and guest (for example, virtio channels for agents or SPICE).
               
               See: <https://libvirt.org/formatdomain.html#channel>
        :param Sequence['DomainDevicesConsoleArgs'] consoles: Configures one or more console devices for the guest, defining how serial consoles are exposed and connected.
               
               See: <https://libvirt.org/formatdomain.html#console>
        :param Sequence['DomainDevicesControllerArgs'] controllers: Declares one or more device controllers (PCI, USB, SCSI, virtio-serial, etc.) attached to the guest, controlling how device buses are exposed.
               
               See: <https://libvirt.org/formatdomain.html#controllers>
        :param Sequence['DomainDevicesCryptoArgs'] cryptos: Configures a virtio-based crypto device that offloads cryptographic operations to the host; the device type and backend parameters are specified in its child attributes.
               
               See: <https://libvirt.org/formatdomain.html#crypto>
        :param Sequence['DomainDevicesDiskArgs'] disks: Declares one or more block devices (disks, CD-ROMs, etc.) attached to the guest, each with its own source, target, and optional tuning parameters.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str emulator: Sets the absolute path to the hypervisor emulator binary used to run this domain (for example "/usr/bin/qemu-system-x86_64").
               
               See: <https://libvirt.org/formatdomain.html#devices>
        :param Sequence['DomainDevicesFilesystemArgs'] filesystems: Declares one or more filesystem devices that expose host directories or block devices into the guest.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        :param Sequence['DomainDevicesGraphicArgs'] graphics: Configures one or more graphical framebuffer devices (such as VNC, SPICE, or DBus-based displays) for the guest.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param Sequence['DomainDevicesHostdevArgs'] hostdevs: Defines one or more hostdev entries describing host devices (PCI, USB, SCSI, etc.) that are passed through directly to the guest.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param Sequence['DomainDevicesHubArgs'] hubs: Declares one or more virtual hub devices attached to a guest bus, typically to provide additional USB ports to the guest.
               
               See: <https://libvirt.org/formatdomain.html#hub-devices>
        :param Sequence['DomainDevicesInputArgs'] inputs: Declares one or more guest input devices such as tablets, mice, or keyboards, and configures their type, bus, and optional passthrough settings.
               
               See: <https://libvirt.org/formatdomain.html#input-devices>
        :param Sequence['DomainDevicesInterfaceArgs'] interfaces: Defines one or more network interface devices attached to the guest, including their connection mode, model, addressing, and related options.
               
               See: <https://libvirt.org/formatdomain.html#network-interfaces>
        :param 'DomainDevicesIommuArgs' iommu: Configures an IOMMU device for the guest, enabling emulated or paravirtual IOMMU functionality; requires a model and may include driver and ACPI options.
        :param Sequence['DomainDevicesLeaseArgs'] leases: Configures one or more device leases that must be acquired by the lock manager before the domain can start, each represented as a lease entry.
               
               See: <https://libvirt.org/formatdomain.html#device-leases>
        :param 'DomainDevicesMemBalloonArgs' mem_balloon: Configures the guest memory balloon device, which allows the host to dynamically adjust the guests available memory.
        :param Sequence['DomainDevicesMemorydevArgs'] memorydevs: Defines one or more memory device entries (DIMM, NVDIMM, virtio-mem, etc.) that provide additional, hot-pluggable memory to the guest.
               
               See: <https://libvirt.org/formatdomain.html#memory-devices>
        :param 'DomainDevicesNvramArgs' nvram: Adds an NVRAM device to the domain, allowing firmware or platform-specific non-volatile state to be stored separately from normal disks.
        :param Sequence['DomainDevicesPanicArgs'] panics: Adds one or more panic devices that report guest panic events to the host, allowing external monitoring or automation on guest crashes.
               
               See: <https://libvirt.org/formatdomain.html#panic-device>
        :param Sequence['DomainDevicesParallelArgs'] parallels: Configures one or more parallel port character devices exposed to the guest, each represented by a parallel element with optional address, backend, and logging settings.
               
               See: <https://libvirt.org/formatdomain.html#parallel-port>
        :param 'DomainDevicesPstoreArgs' pstore: Adds a pstore device to the guest for persistent storage of kernel oops/panic logs, mapping to a host backend.
        :param Sequence['DomainDevicesRedirDevArgs'] redir_devs: Configures one or more redirected USB devices exposed to the guest via redirdev, typically used in conjunction with SPICE or similar frontends.
               
               See: <https://libvirt.org/formatdomain.html#redirected-devices>
        :param Sequence['DomainDevicesRedirFilterArgs'] redir_filters: Configures one or more USB redirection filter rules that determine which redirected USB devices are allowed or denied to the guest.
               
               See: <https://libvirt.org/formatdomain.html#redirected-devices>
        :param Sequence['DomainDevicesRngArgs'] rngs: Defines one or more virtual random number generator devices attached to the guest.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesSerialArgs'] serials: Configures one or more virtual serial port devices attached to the guest.
               
               See: <https://libvirt.org/formatdomain.html#serial-port>
        :param Sequence['DomainDevicesShmemArgs'] shmems: Defines one or more shared memory (ivshmem/shmem) devices used to share memory regions between this guest, other guests, and/or the host.
               
               See: <https://libvirt.org/formatdomain.html#shared-memory-device>
        :param Sequence['DomainDevicesSmartcardArgs'] smartcards: Defines one or more virtual smartcard devices attached to the guest.
               
               See: <https://libvirt.org/formatdomain.html#smartcard-devices>
        :param Sequence['DomainDevicesSoundArgs'] sounds: Configures one or more virtual sound devices attached to the guest.
               
               See: <https://libvirt.org/formatdomain.html#sound-devices>
        :param Sequence['DomainDevicesTpmArgs'] tpms: Configures one or more TPM devices attached to the guest, including their backend implementation, addressing, and optional ACPI integration.
               
               See: <https://libvirt.org/formatdomain.html#tpm-device>
        :param Sequence['DomainDevicesVideoArgs'] videos: Defines one or more video devices attached to the guest, each providing a virtual graphics adapter.
               
               See: <https://libvirt.org/formatdomain.html#video-devices>
        :param 'DomainDevicesVsockArgs' vsock: Configures a virtio vsock device that provides a host/guest communication channel using a CID-based socket interface.
        :param Sequence['DomainDevicesWatchdogArgs'] watchdogs: Configures one or more virtual watchdog devices attached to the guest, each controlling timeout behavior and actions on failure.
               
               See: <https://libvirt.org/formatdomain.html#watchdog-devices>
        """
        if audios is not None:
            pulumi.set(__self__, "audios", audios)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if consoles is not None:
            pulumi.set(__self__, "consoles", consoles)
        if controllers is not None:
            pulumi.set(__self__, "controllers", controllers)
        if cryptos is not None:
            pulumi.set(__self__, "cryptos", cryptos)
        if disks is not None:
            pulumi.set(__self__, "disks", disks)
        if emulator is not None:
            pulumi.set(__self__, "emulator", emulator)
        if filesystems is not None:
            pulumi.set(__self__, "filesystems", filesystems)
        if graphics is not None:
            pulumi.set(__self__, "graphics", graphics)
        if hostdevs is not None:
            pulumi.set(__self__, "hostdevs", hostdevs)
        if hubs is not None:
            pulumi.set(__self__, "hubs", hubs)
        if inputs is not None:
            pulumi.set(__self__, "inputs", inputs)
        if interfaces is not None:
            pulumi.set(__self__, "interfaces", interfaces)
        if iommu is not None:
            pulumi.set(__self__, "iommu", iommu)
        if leases is not None:
            pulumi.set(__self__, "leases", leases)
        if mem_balloon is not None:
            pulumi.set(__self__, "mem_balloon", mem_balloon)
        if memorydevs is not None:
            pulumi.set(__self__, "memorydevs", memorydevs)
        if nvram is not None:
            pulumi.set(__self__, "nvram", nvram)
        if panics is not None:
            pulumi.set(__self__, "panics", panics)
        if parallels is not None:
            pulumi.set(__self__, "parallels", parallels)
        if pstore is not None:
            pulumi.set(__self__, "pstore", pstore)
        if redir_devs is not None:
            pulumi.set(__self__, "redir_devs", redir_devs)
        if redir_filters is not None:
            pulumi.set(__self__, "redir_filters", redir_filters)
        if rngs is not None:
            pulumi.set(__self__, "rngs", rngs)
        if serials is not None:
            pulumi.set(__self__, "serials", serials)
        if shmems is not None:
            pulumi.set(__self__, "shmems", shmems)
        if smartcards is not None:
            pulumi.set(__self__, "smartcards", smartcards)
        if sounds is not None:
            pulumi.set(__self__, "sounds", sounds)
        if tpms is not None:
            pulumi.set(__self__, "tpms", tpms)
        if videos is not None:
            pulumi.set(__self__, "videos", videos)
        if vsock is not None:
            pulumi.set(__self__, "vsock", vsock)
        if watchdogs is not None:
            pulumi.set(__self__, "watchdogs", watchdogs)

    @_builtins.property
    @pulumi.getter
    def audios(self) -> Optional[Sequence['outputs.DomainDevicesAudio']]:
        """
        Configures one or more audio backend definitions that map virtual sound devices in the guest to host audio backends.

        See: <https://libvirt.org/formatdomain.html#audio-backends>
        """
        return pulumi.get(self, "audios")

    @_builtins.property
    @pulumi.getter
    def channels(self) -> Optional[Sequence['outputs.DomainDevicesChannel']]:
        """
        Defines one or more guest channel devices, which provide private communication paths between host and guest (for example, virtio channels for agents or SPICE).

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "channels")

    @_builtins.property
    @pulumi.getter
    def consoles(self) -> Optional[Sequence['outputs.DomainDevicesConsole']]:
        """
        Configures one or more console devices for the guest, defining how serial consoles are exposed and connected.

        See: <https://libvirt.org/formatdomain.html#console>
        """
        return pulumi.get(self, "consoles")

    @_builtins.property
    @pulumi.getter
    def controllers(self) -> Optional[Sequence['outputs.DomainDevicesController']]:
        """
        Declares one or more device controllers (PCI, USB, SCSI, virtio-serial, etc.) attached to the guest, controlling how device buses are exposed.

        See: <https://libvirt.org/formatdomain.html#controllers>
        """
        return pulumi.get(self, "controllers")

    @_builtins.property
    @pulumi.getter
    def cryptos(self) -> Optional[Sequence['outputs.DomainDevicesCrypto']]:
        """
        Configures a virtio-based crypto device that offloads cryptographic operations to the host; the device type and backend parameters are specified in its child attributes.

        See: <https://libvirt.org/formatdomain.html#crypto>
        """
        return pulumi.get(self, "cryptos")

    @_builtins.property
    @pulumi.getter
    def disks(self) -> Optional[Sequence['outputs.DomainDevicesDisk']]:
        """
        Declares one or more block devices (disks, CD-ROMs, etc.) attached to the guest, each with its own source, target, and optional tuning parameters.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "disks")

    @_builtins.property
    @pulumi.getter
    def emulator(self) -> Optional[_builtins.str]:
        """
        Sets the absolute path to the hypervisor emulator binary used to run this domain (for example "/usr/bin/qemu-system-x86_64").

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "emulator")

    @_builtins.property
    @pulumi.getter
    def filesystems(self) -> Optional[Sequence['outputs.DomainDevicesFilesystem']]:
        """
        Declares one or more filesystem devices that expose host directories or block devices into the guest.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "filesystems")

    @_builtins.property
    @pulumi.getter
    def graphics(self) -> Optional[Sequence['outputs.DomainDevicesGraphic']]:
        """
        Configures one or more graphical framebuffer devices (such as VNC, SPICE, or DBus-based displays) for the guest.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "graphics")

    @_builtins.property
    @pulumi.getter
    def hostdevs(self) -> Optional[Sequence['outputs.DomainDevicesHostdev']]:
        """
        Defines one or more hostdev entries describing host devices (PCI, USB, SCSI, etc.) that are passed through directly to the guest.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "hostdevs")

    @_builtins.property
    @pulumi.getter
    def hubs(self) -> Optional[Sequence['outputs.DomainDevicesHub']]:
        """
        Declares one or more virtual hub devices attached to a guest bus, typically to provide additional USB ports to the guest.

        See: <https://libvirt.org/formatdomain.html#hub-devices>
        """
        return pulumi.get(self, "hubs")

    @_builtins.property
    @pulumi.getter
    def inputs(self) -> Optional[Sequence['outputs.DomainDevicesInput']]:
        """
        Declares one or more guest input devices such as tablets, mice, or keyboards, and configures their type, bus, and optional passthrough settings.

        See: <https://libvirt.org/formatdomain.html#input-devices>
        """
        return pulumi.get(self, "inputs")

    @_builtins.property
    @pulumi.getter
    def interfaces(self) -> Optional[Sequence['outputs.DomainDevicesInterface']]:
        """
        Defines one or more network interface devices attached to the guest, including their connection mode, model, addressing, and related options.

        See: <https://libvirt.org/formatdomain.html#network-interfaces>
        """
        return pulumi.get(self, "interfaces")

    @_builtins.property
    @pulumi.getter
    def iommu(self) -> Optional['outputs.DomainDevicesIommu']:
        """
        Configures an IOMMU device for the guest, enabling emulated or paravirtual IOMMU functionality; requires a model and may include driver and ACPI options.
        """
        return pulumi.get(self, "iommu")

    @_builtins.property
    @pulumi.getter
    def leases(self) -> Optional[Sequence['outputs.DomainDevicesLease']]:
        """
        Configures one or more device leases that must be acquired by the lock manager before the domain can start, each represented as a lease entry.

        See: <https://libvirt.org/formatdomain.html#device-leases>
        """
        return pulumi.get(self, "leases")

    @_builtins.property
    @pulumi.getter(name="memBalloon")
    def mem_balloon(self) -> Optional['outputs.DomainDevicesMemBalloon']:
        """
        Configures the guest memory balloon device, which allows the host to dynamically adjust the guests available memory.
        """
        return pulumi.get(self, "mem_balloon")

    @_builtins.property
    @pulumi.getter
    def memorydevs(self) -> Optional[Sequence['outputs.DomainDevicesMemorydev']]:
        """
        Defines one or more memory device entries (DIMM, NVDIMM, virtio-mem, etc.) that provide additional, hot-pluggable memory to the guest.

        See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        return pulumi.get(self, "memorydevs")

    @_builtins.property
    @pulumi.getter
    def nvram(self) -> Optional['outputs.DomainDevicesNvram']:
        """
        Adds an NVRAM device to the domain, allowing firmware or platform-specific non-volatile state to be stored separately from normal disks.
        """
        return pulumi.get(self, "nvram")

    @_builtins.property
    @pulumi.getter
    def panics(self) -> Optional[Sequence['outputs.DomainDevicesPanic']]:
        """
        Adds one or more panic devices that report guest panic events to the host, allowing external monitoring or automation on guest crashes.

        See: <https://libvirt.org/formatdomain.html#panic-device>
        """
        return pulumi.get(self, "panics")

    @_builtins.property
    @pulumi.getter
    def parallels(self) -> Optional[Sequence['outputs.DomainDevicesParallel']]:
        """
        Configures one or more parallel port character devices exposed to the guest, each represented by a parallel element with optional address, backend, and logging settings.

        See: <https://libvirt.org/formatdomain.html#parallel-port>
        """
        return pulumi.get(self, "parallels")

    @_builtins.property
    @pulumi.getter
    def pstore(self) -> Optional['outputs.DomainDevicesPstore']:
        """
        Adds a pstore device to the guest for persistent storage of kernel oops/panic logs, mapping to a host backend.
        """
        return pulumi.get(self, "pstore")

    @_builtins.property
    @pulumi.getter(name="redirDevs")
    def redir_devs(self) -> Optional[Sequence['outputs.DomainDevicesRedirDev']]:
        """
        Configures one or more redirected USB devices exposed to the guest via redirdev, typically used in conjunction with SPICE or similar frontends.

        See: <https://libvirt.org/formatdomain.html#redirected-devices>
        """
        return pulumi.get(self, "redir_devs")

    @_builtins.property
    @pulumi.getter(name="redirFilters")
    def redir_filters(self) -> Optional[Sequence['outputs.DomainDevicesRedirFilter']]:
        """
        Configures one or more USB redirection filter rules that determine which redirected USB devices are allowed or denied to the guest.

        See: <https://libvirt.org/formatdomain.html#redirected-devices>
        """
        return pulumi.get(self, "redir_filters")

    @_builtins.property
    @pulumi.getter
    def rngs(self) -> Optional[Sequence['outputs.DomainDevicesRng']]:
        """
        Defines one or more virtual random number generator devices attached to the guest.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "rngs")

    @_builtins.property
    @pulumi.getter
    def serials(self) -> Optional[Sequence['outputs.DomainDevicesSerial']]:
        """
        Configures one or more virtual serial port devices attached to the guest.

        See: <https://libvirt.org/formatdomain.html#serial-port>
        """
        return pulumi.get(self, "serials")

    @_builtins.property
    @pulumi.getter
    def shmems(self) -> Optional[Sequence['outputs.DomainDevicesShmem']]:
        """
        Defines one or more shared memory (ivshmem/shmem) devices used to share memory regions between this guest, other guests, and/or the host.

        See: <https://libvirt.org/formatdomain.html#shared-memory-device>
        """
        return pulumi.get(self, "shmems")

    @_builtins.property
    @pulumi.getter
    def smartcards(self) -> Optional[Sequence['outputs.DomainDevicesSmartcard']]:
        """
        Defines one or more virtual smartcard devices attached to the guest.

        See: <https://libvirt.org/formatdomain.html#smartcard-devices>
        """
        return pulumi.get(self, "smartcards")

    @_builtins.property
    @pulumi.getter
    def sounds(self) -> Optional[Sequence['outputs.DomainDevicesSound']]:
        """
        Configures one or more virtual sound devices attached to the guest.

        See: <https://libvirt.org/formatdomain.html#sound-devices>
        """
        return pulumi.get(self, "sounds")

    @_builtins.property
    @pulumi.getter
    def tpms(self) -> Optional[Sequence['outputs.DomainDevicesTpm']]:
        """
        Configures one or more TPM devices attached to the guest, including their backend implementation, addressing, and optional ACPI integration.

        See: <https://libvirt.org/formatdomain.html#tpm-device>
        """
        return pulumi.get(self, "tpms")

    @_builtins.property
    @pulumi.getter
    def videos(self) -> Optional[Sequence['outputs.DomainDevicesVideo']]:
        """
        Defines one or more video devices attached to the guest, each providing a virtual graphics adapter.

        See: <https://libvirt.org/formatdomain.html#video-devices>
        """
        return pulumi.get(self, "videos")

    @_builtins.property
    @pulumi.getter
    def vsock(self) -> Optional['outputs.DomainDevicesVsock']:
        """
        Configures a virtio vsock device that provides a host/guest communication channel using a CID-based socket interface.
        """
        return pulumi.get(self, "vsock")

    @_builtins.property
    @pulumi.getter
    def watchdogs(self) -> Optional[Sequence['outputs.DomainDevicesWatchdog']]:
        """
        Configures one or more virtual watchdog devices attached to the guest, each controlling timeout behavior and actions on failure.

        See: <https://libvirt.org/formatdomain.html#watchdog-devices>
        """
        return pulumi.get(self, "watchdogs")


@pulumi.output_type
class DomainDevicesAudio(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coreAudio":
            suggest = "core_audio"
        elif key == "pipeWire":
            suggest = "pipe_wire"
        elif key == "pulseAudio":
            suggest = "pulse_audio"
        elif key == "timerPeriod":
            suggest = "timer_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesAudio. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesAudio.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesAudio.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alsa: Optional['outputs.DomainDevicesAudioAlsa'] = None,
                 core_audio: Optional['outputs.DomainDevicesAudioCoreAudio'] = None,
                 dbus: Optional['outputs.DomainDevicesAudioDbus'] = None,
                 file: Optional['outputs.DomainDevicesAudioFile'] = None,
                 id: Optional[_builtins.float] = None,
                 jack: Optional['outputs.DomainDevicesAudioJack'] = None,
                 none: Optional['outputs.DomainDevicesAudioNone'] = None,
                 oss: Optional['outputs.DomainDevicesAudioOss'] = None,
                 pipe_wire: Optional['outputs.DomainDevicesAudioPipeWire'] = None,
                 pulse_audio: Optional['outputs.DomainDevicesAudioPulseAudio'] = None,
                 sdl: Optional['outputs.DomainDevicesAudioSdl'] = None,
                 spice: Optional['outputs.DomainDevicesAudioSpice'] = None,
                 timer_period: Optional[_builtins.float] = None):
        """
        :param 'DomainDevicesAudioAlsaArgs' alsa: Configures an ALSA audio backend, delegating guest audio I/O to the host ALSA framework.
        :param 'DomainDevicesAudioCoreAudioArgs' core_audio: Configures a CoreAudio audio backend, delegating guest audio I/O to the macOS CoreAudio framework.
        :param 'DomainDevicesAudioDbusArgs' dbus: Configures a DBus audio backend, which exposes audio via DBus rather than a host audio framework.
        :param 'DomainDevicesAudioFileArgs' file: Configures the file-based audio backend, which records guest audio streams to a host file instead of a real audio device.
        :param _builtins.float id: Exposes the libvirt-assigned ID of the audio device; this is computed by libvirt and cannot be set by the user.
               
               See: <https://libvirt.org/formatdomain.html#audio-backends>
        :param 'DomainDevicesAudioJackArgs' jack: Configures the Jack audio backend, delegating guest audio I/O to a Jack daemon.
        :param 'DomainDevicesAudioNoneArgs' none: Configures the dummy `"none"` audio backend, which does not use any host audio framework but still allows remote desktop protocols to carry audio.
        :param 'DomainDevicesAudioOssArgs' oss: Configures the OSS audio backend, delegating guest audio I/O to the host OSS framework and allowing additional OSS-specific options on the audio element.
        :param 'DomainDevicesAudioPipeWireArgs' pipe_wire: Enables and configures a PipeWire audio backend for the guest, delegating audio I/O to a PipeWire daemon with optional per-stream settings.
        :param 'DomainDevicesAudioPulseAudioArgs' pulse_audio: Enables configuration of a PulseAudio audio backend attached to the domain, allowing you to specify connection and stream properties for PulseAudio input/output.
        :param 'DomainDevicesAudioSdlArgs' sdl: Enables configuration of an SDL-based audio backend for the domain, allowing you to tune the underlying SDL audio driver and buffer settings.
        :param 'DomainDevicesAudioSpiceArgs' spice: Enables configuration of a SPICE-only audio backend, which routes audio exclusively through a SPICE server without using a host audio framework.
        :param _builtins.float timer_period: Sets the audio backend timer period in milliseconds, controlling how often audio buffers are processed; the value is user-provided and should be a positive integer supported by the chosen backend.
               
               See: <https://libvirt.org/formatdomain.html#audio-backends>
        """
        if alsa is not None:
            pulumi.set(__self__, "alsa", alsa)
        if core_audio is not None:
            pulumi.set(__self__, "core_audio", core_audio)
        if dbus is not None:
            pulumi.set(__self__, "dbus", dbus)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if jack is not None:
            pulumi.set(__self__, "jack", jack)
        if none is not None:
            pulumi.set(__self__, "none", none)
        if oss is not None:
            pulumi.set(__self__, "oss", oss)
        if pipe_wire is not None:
            pulumi.set(__self__, "pipe_wire", pipe_wire)
        if pulse_audio is not None:
            pulumi.set(__self__, "pulse_audio", pulse_audio)
        if sdl is not None:
            pulumi.set(__self__, "sdl", sdl)
        if spice is not None:
            pulumi.set(__self__, "spice", spice)
        if timer_period is not None:
            pulumi.set(__self__, "timer_period", timer_period)

    @_builtins.property
    @pulumi.getter
    def alsa(self) -> Optional['outputs.DomainDevicesAudioAlsa']:
        """
        Configures an ALSA audio backend, delegating guest audio I/O to the host ALSA framework.
        """
        return pulumi.get(self, "alsa")

    @_builtins.property
    @pulumi.getter(name="coreAudio")
    def core_audio(self) -> Optional['outputs.DomainDevicesAudioCoreAudio']:
        """
        Configures a CoreAudio audio backend, delegating guest audio I/O to the macOS CoreAudio framework.
        """
        return pulumi.get(self, "core_audio")

    @_builtins.property
    @pulumi.getter
    def dbus(self) -> Optional['outputs.DomainDevicesAudioDbus']:
        """
        Configures a DBus audio backend, which exposes audio via DBus rather than a host audio framework.
        """
        return pulumi.get(self, "dbus")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.DomainDevicesAudioFile']:
        """
        Configures the file-based audio backend, which records guest audio streams to a host file instead of a real audio device.
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.float]:
        """
        Exposes the libvirt-assigned ID of the audio device; this is computed by libvirt and cannot be set by the user.

        See: <https://libvirt.org/formatdomain.html#audio-backends>
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def jack(self) -> Optional['outputs.DomainDevicesAudioJack']:
        """
        Configures the Jack audio backend, delegating guest audio I/O to a Jack daemon.
        """
        return pulumi.get(self, "jack")

    @_builtins.property
    @pulumi.getter
    def none(self) -> Optional['outputs.DomainDevicesAudioNone']:
        """
        Configures the dummy `"none"` audio backend, which does not use any host audio framework but still allows remote desktop protocols to carry audio.
        """
        return pulumi.get(self, "none")

    @_builtins.property
    @pulumi.getter
    def oss(self) -> Optional['outputs.DomainDevicesAudioOss']:
        """
        Configures the OSS audio backend, delegating guest audio I/O to the host OSS framework and allowing additional OSS-specific options on the audio element.
        """
        return pulumi.get(self, "oss")

    @_builtins.property
    @pulumi.getter(name="pipeWire")
    def pipe_wire(self) -> Optional['outputs.DomainDevicesAudioPipeWire']:
        """
        Enables and configures a PipeWire audio backend for the guest, delegating audio I/O to a PipeWire daemon with optional per-stream settings.
        """
        return pulumi.get(self, "pipe_wire")

    @_builtins.property
    @pulumi.getter(name="pulseAudio")
    def pulse_audio(self) -> Optional['outputs.DomainDevicesAudioPulseAudio']:
        """
        Enables configuration of a PulseAudio audio backend attached to the domain, allowing you to specify connection and stream properties for PulseAudio input/output.
        """
        return pulumi.get(self, "pulse_audio")

    @_builtins.property
    @pulumi.getter
    def sdl(self) -> Optional['outputs.DomainDevicesAudioSdl']:
        """
        Enables configuration of an SDL-based audio backend for the domain, allowing you to tune the underlying SDL audio driver and buffer settings.
        """
        return pulumi.get(self, "sdl")

    @_builtins.property
    @pulumi.getter
    def spice(self) -> Optional['outputs.DomainDevicesAudioSpice']:
        """
        Enables configuration of a SPICE-only audio backend, which routes audio exclusively through a SPICE server without using a host audio framework.
        """
        return pulumi.get(self, "spice")

    @_builtins.property
    @pulumi.getter(name="timerPeriod")
    def timer_period(self) -> Optional[_builtins.float]:
        """
        Sets the audio backend timer period in milliseconds, controlling how often audio buffers are processed; the value is user-provided and should be a positive integer supported by the chosen backend.

        See: <https://libvirt.org/formatdomain.html#audio-backends>
        """
        return pulumi.get(self, "timer_period")


@pulumi.output_type
class DomainDevicesAudioAlsa(dict):
    def __init__(__self__, *,
                 input: Optional['outputs.DomainDevicesAudioAlsaInput'] = None,
                 output: Optional['outputs.DomainDevicesAudioAlsaOutput'] = None):
        """
        :param 'DomainDevicesAudioAlsaInputArgs' input: Configures ALSA output (playback) settings for the audio backend.
        :param 'DomainDevicesAudioAlsaOutputArgs' output: Configures ALSA output (playback) settings for the audio backend.
        """
        if input is not None:
            pulumi.set(__self__, "input", input)
        if output is not None:
            pulumi.set(__self__, "output", output)

    @_builtins.property
    @pulumi.getter
    def input(self) -> Optional['outputs.DomainDevicesAudioAlsaInput']:
        """
        Configures ALSA output (playback) settings for the audio backend.
        """
        return pulumi.get(self, "input")

    @_builtins.property
    @pulumi.getter
    def output(self) -> Optional['outputs.DomainDevicesAudioAlsaOutput']:
        """
        Configures ALSA output (playback) settings for the audio backend.
        """
        return pulumi.get(self, "output")


@pulumi.output_type
class DomainDevicesAudioAlsaInput(dict):
    def __init__(__self__, *,
                 dev: Optional[_builtins.str] = None):
        """
        :param _builtins.str dev: Sets the ALSA device node used for audio output, as a host path string such as /dev/snd/pcmC0D0p.
               
               See: <https://libvirt.org/formatdomain.html#alsa-audio-backend>
        """
        if dev is not None:
            pulumi.set(__self__, "dev", dev)

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional[_builtins.str]:
        """
        Sets the ALSA device node used for audio output, as a host path string such as /dev/snd/pcmC0D0p.

        See: <https://libvirt.org/formatdomain.html#alsa-audio-backend>
        """
        return pulumi.get(self, "dev")


@pulumi.output_type
class DomainDevicesAudioAlsaOutput(dict):
    def __init__(__self__, *,
                 dev: Optional[_builtins.str] = None):
        """
        :param _builtins.str dev: Sets the ALSA device node used for audio output, as a host path string such as /dev/snd/pcmC0D0p.
               
               See: <https://libvirt.org/formatdomain.html#alsa-audio-backend>
        """
        if dev is not None:
            pulumi.set(__self__, "dev", dev)

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional[_builtins.str]:
        """
        Sets the ALSA device node used for audio output, as a host path string such as /dev/snd/pcmC0D0p.

        See: <https://libvirt.org/formatdomain.html#alsa-audio-backend>
        """
        return pulumi.get(self, "dev")


@pulumi.output_type
class DomainDevicesAudioCoreAudio(dict):
    def __init__(__self__, *,
                 input: Optional['outputs.DomainDevicesAudioCoreAudioInput'] = None,
                 output: Optional['outputs.DomainDevicesAudioCoreAudioOutput'] = None):
        """
        :param 'DomainDevicesAudioCoreAudioInputArgs' input: Configures CoreAudio output (playback) parameters for the audio backend.
        :param 'DomainDevicesAudioCoreAudioOutputArgs' output: Configures CoreAudio output (playback) parameters for the audio backend.
        """
        if input is not None:
            pulumi.set(__self__, "input", input)
        if output is not None:
            pulumi.set(__self__, "output", output)

    @_builtins.property
    @pulumi.getter
    def input(self) -> Optional['outputs.DomainDevicesAudioCoreAudioInput']:
        """
        Configures CoreAudio output (playback) parameters for the audio backend.
        """
        return pulumi.get(self, "input")

    @_builtins.property
    @pulumi.getter
    def output(self) -> Optional['outputs.DomainDevicesAudioCoreAudioOutput']:
        """
        Configures CoreAudio output (playback) parameters for the audio backend.
        """
        return pulumi.get(self, "output")


@pulumi.output_type
class DomainDevicesAudioCoreAudioInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bufferCount":
            suggest = "buffer_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesAudioCoreAudioInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesAudioCoreAudioInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesAudioCoreAudioInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 buffer_count: Optional[_builtins.float] = None):
        """
        :param _builtins.float buffer_count: Sets the number of audio buffers CoreAudio uses for output; value is a userprovided nonnegative integer (for example 4 or 8).
               
               See: <https://libvirt.org/formatdomain.html#coreaudio-audio-backend>
        """
        if buffer_count is not None:
            pulumi.set(__self__, "buffer_count", buffer_count)

    @_builtins.property
    @pulumi.getter(name="bufferCount")
    def buffer_count(self) -> Optional[_builtins.float]:
        """
        Sets the number of audio buffers CoreAudio uses for output; value is a userprovided nonnegative integer (for example 4 or 8).

        See: <https://libvirt.org/formatdomain.html#coreaudio-audio-backend>
        """
        return pulumi.get(self, "buffer_count")


@pulumi.output_type
class DomainDevicesAudioCoreAudioOutput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bufferCount":
            suggest = "buffer_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesAudioCoreAudioOutput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesAudioCoreAudioOutput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesAudioCoreAudioOutput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 buffer_count: Optional[_builtins.float] = None):
        """
        :param _builtins.float buffer_count: Sets the number of audio buffers CoreAudio uses for output; value is a userprovided nonnegative integer (for example 4 or 8).
               
               See: <https://libvirt.org/formatdomain.html#coreaudio-audio-backend>
        """
        if buffer_count is not None:
            pulumi.set(__self__, "buffer_count", buffer_count)

    @_builtins.property
    @pulumi.getter(name="bufferCount")
    def buffer_count(self) -> Optional[_builtins.float]:
        """
        Sets the number of audio buffers CoreAudio uses for output; value is a userprovided nonnegative integer (for example 4 or 8).

        See: <https://libvirt.org/formatdomain.html#coreaudio-audio-backend>
        """
        return pulumi.get(self, "buffer_count")


@pulumi.output_type
class DomainDevicesAudioDbus(dict):
    def __init__(__self__, *,
                 input: Optional['outputs.DomainDevicesAudioDbusInput'] = None,
                 output: Optional['outputs.DomainDevicesAudioDbusOutput'] = None):
        """
        :param 'DomainDevicesAudioDbusInputArgs' input: Enables and configures output (playback) for the DBus audio backend; no additional attributes are defined beyond presence.
        :param 'DomainDevicesAudioDbusOutputArgs' output: Enables and configures output (playback) for the DBus audio backend; no additional attributes are defined beyond presence.
        """
        if input is not None:
            pulumi.set(__self__, "input", input)
        if output is not None:
            pulumi.set(__self__, "output", output)

    @_builtins.property
    @pulumi.getter
    def input(self) -> Optional['outputs.DomainDevicesAudioDbusInput']:
        """
        Enables and configures output (playback) for the DBus audio backend; no additional attributes are defined beyond presence.
        """
        return pulumi.get(self, "input")

    @_builtins.property
    @pulumi.getter
    def output(self) -> Optional['outputs.DomainDevicesAudioDbusOutput']:
        """
        Enables and configures output (playback) for the DBus audio backend; no additional attributes are defined beyond presence.
        """
        return pulumi.get(self, "output")


@pulumi.output_type
class DomainDevicesAudioDbusInput(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesAudioDbusOutput(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesAudioFile(dict):
    def __init__(__self__, *,
                 input: Optional['outputs.DomainDevicesAudioFileInput'] = None,
                 output: Optional['outputs.DomainDevicesAudioFileOutput'] = None,
                 path: Optional[_builtins.str] = None):
        """
        :param 'DomainDevicesAudioFileInputArgs' input: Enables and configures the output (playback) side of the file audio backend; presence controls whether guest output audio is written to file.
        :param 'DomainDevicesAudioFileOutputArgs' output: Enables and configures the output (playback) side of the file audio backend; presence controls whether guest output audio is written to file.
        :param _builtins.str path: Sets the host file path used by the file audio backend to store the recorded audio stream; the value is a user-provided filesystem path (for example, `/var/lib/libvirt/sound.wav`).
               
               See: <https://libvirt.org/formatdomain.html#file-audio-backend>
        """
        if input is not None:
            pulumi.set(__self__, "input", input)
        if output is not None:
            pulumi.set(__self__, "output", output)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def input(self) -> Optional['outputs.DomainDevicesAudioFileInput']:
        """
        Enables and configures the output (playback) side of the file audio backend; presence controls whether guest output audio is written to file.
        """
        return pulumi.get(self, "input")

    @_builtins.property
    @pulumi.getter
    def output(self) -> Optional['outputs.DomainDevicesAudioFileOutput']:
        """
        Enables and configures the output (playback) side of the file audio backend; presence controls whether guest output audio is written to file.
        """
        return pulumi.get(self, "output")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Sets the host file path used by the file audio backend to store the recorded audio stream; the value is a user-provided filesystem path (for example, `/var/lib/libvirt/sound.wav`).

        See: <https://libvirt.org/formatdomain.html#file-audio-backend>
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DomainDevicesAudioFileInput(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesAudioFileOutput(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesAudioJack(dict):
    def __init__(__self__, *,
                 input: Optional['outputs.DomainDevicesAudioJackInput'] = None,
                 output: Optional['outputs.DomainDevicesAudioJackOutput'] = None):
        """
        :param 'DomainDevicesAudioJackInputArgs' input: Enables and configures the output (playback) side of the Jack audio backend.
        :param 'DomainDevicesAudioJackOutputArgs' output: Enables and configures the output (playback) side of the Jack audio backend.
        """
        if input is not None:
            pulumi.set(__self__, "input", input)
        if output is not None:
            pulumi.set(__self__, "output", output)

    @_builtins.property
    @pulumi.getter
    def input(self) -> Optional['outputs.DomainDevicesAudioJackInput']:
        """
        Enables and configures the output (playback) side of the Jack audio backend.
        """
        return pulumi.get(self, "input")

    @_builtins.property
    @pulumi.getter
    def output(self) -> Optional['outputs.DomainDevicesAudioJackOutput']:
        """
        Enables and configures the output (playback) side of the Jack audio backend.
        """
        return pulumi.get(self, "output")


@pulumi.output_type
class DomainDevicesAudioJackInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientName":
            suggest = "client_name"
        elif key == "connectPorts":
            suggest = "connect_ports"
        elif key == "exactName":
            suggest = "exact_name"
        elif key == "serverName":
            suggest = "server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesAudioJackInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesAudioJackInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesAudioJackInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_name: Optional[_builtins.str] = None,
                 connect_ports: Optional[_builtins.str] = None,
                 exact_name: Optional[_builtins.str] = None,
                 server_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_name: Sets the Jack client name used for the output stream; the value is user-provided and identifies the Jack client.
               
               See: <https://libvirt.org/formatdomain.html#jack-audio-backend>
        :param _builtins.str connect_ports: Controls whether the Jack backend automatically connects the output stream to Jack ports (`"yes"` or `"no"`).
               
               See: <https://libvirt.org/formatdomain.html#jack-audio-backend>
        :param _builtins.str exact_name: Specifies whether the Jack client name for output must match exactly (`"yes"` or `"no"`), influencing how Jack selects the client.
               
               See: <https://libvirt.org/formatdomain.html#jack-audio-backend>
        :param _builtins.str server_name: Sets the Jack server name to which the output stream connects; the value is user-provided and must correspond to a running Jack server.
               
               See: <https://libvirt.org/formatdomain.html#jack-audio-backend>
        """
        if client_name is not None:
            pulumi.set(__self__, "client_name", client_name)
        if connect_ports is not None:
            pulumi.set(__self__, "connect_ports", connect_ports)
        if exact_name is not None:
            pulumi.set(__self__, "exact_name", exact_name)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)

    @_builtins.property
    @pulumi.getter(name="clientName")
    def client_name(self) -> Optional[_builtins.str]:
        """
        Sets the Jack client name used for the output stream; the value is user-provided and identifies the Jack client.

        See: <https://libvirt.org/formatdomain.html#jack-audio-backend>
        """
        return pulumi.get(self, "client_name")

    @_builtins.property
    @pulumi.getter(name="connectPorts")
    def connect_ports(self) -> Optional[_builtins.str]:
        """
        Controls whether the Jack backend automatically connects the output stream to Jack ports (`"yes"` or `"no"`).

        See: <https://libvirt.org/formatdomain.html#jack-audio-backend>
        """
        return pulumi.get(self, "connect_ports")

    @_builtins.property
    @pulumi.getter(name="exactName")
    def exact_name(self) -> Optional[_builtins.str]:
        """
        Specifies whether the Jack client name for output must match exactly (`"yes"` or `"no"`), influencing how Jack selects the client.

        See: <https://libvirt.org/formatdomain.html#jack-audio-backend>
        """
        return pulumi.get(self, "exact_name")

    @_builtins.property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[_builtins.str]:
        """
        Sets the Jack server name to which the output stream connects; the value is user-provided and must correspond to a running Jack server.

        See: <https://libvirt.org/formatdomain.html#jack-audio-backend>
        """
        return pulumi.get(self, "server_name")


@pulumi.output_type
class DomainDevicesAudioJackOutput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientName":
            suggest = "client_name"
        elif key == "connectPorts":
            suggest = "connect_ports"
        elif key == "exactName":
            suggest = "exact_name"
        elif key == "serverName":
            suggest = "server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesAudioJackOutput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesAudioJackOutput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesAudioJackOutput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_name: Optional[_builtins.str] = None,
                 connect_ports: Optional[_builtins.str] = None,
                 exact_name: Optional[_builtins.str] = None,
                 server_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_name: Sets the Jack client name used for the output stream; the value is user-provided and identifies the Jack client.
               
               See: <https://libvirt.org/formatdomain.html#jack-audio-backend>
        :param _builtins.str connect_ports: Controls whether the Jack backend automatically connects the output stream to Jack ports (`"yes"` or `"no"`).
               
               See: <https://libvirt.org/formatdomain.html#jack-audio-backend>
        :param _builtins.str exact_name: Specifies whether the Jack client name for output must match exactly (`"yes"` or `"no"`), influencing how Jack selects the client.
               
               See: <https://libvirt.org/formatdomain.html#jack-audio-backend>
        :param _builtins.str server_name: Sets the Jack server name to which the output stream connects; the value is user-provided and must correspond to a running Jack server.
               
               See: <https://libvirt.org/formatdomain.html#jack-audio-backend>
        """
        if client_name is not None:
            pulumi.set(__self__, "client_name", client_name)
        if connect_ports is not None:
            pulumi.set(__self__, "connect_ports", connect_ports)
        if exact_name is not None:
            pulumi.set(__self__, "exact_name", exact_name)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)

    @_builtins.property
    @pulumi.getter(name="clientName")
    def client_name(self) -> Optional[_builtins.str]:
        """
        Sets the Jack client name used for the output stream; the value is user-provided and identifies the Jack client.

        See: <https://libvirt.org/formatdomain.html#jack-audio-backend>
        """
        return pulumi.get(self, "client_name")

    @_builtins.property
    @pulumi.getter(name="connectPorts")
    def connect_ports(self) -> Optional[_builtins.str]:
        """
        Controls whether the Jack backend automatically connects the output stream to Jack ports (`"yes"` or `"no"`).

        See: <https://libvirt.org/formatdomain.html#jack-audio-backend>
        """
        return pulumi.get(self, "connect_ports")

    @_builtins.property
    @pulumi.getter(name="exactName")
    def exact_name(self) -> Optional[_builtins.str]:
        """
        Specifies whether the Jack client name for output must match exactly (`"yes"` or `"no"`), influencing how Jack selects the client.

        See: <https://libvirt.org/formatdomain.html#jack-audio-backend>
        """
        return pulumi.get(self, "exact_name")

    @_builtins.property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[_builtins.str]:
        """
        Sets the Jack server name to which the output stream connects; the value is user-provided and must correspond to a running Jack server.

        See: <https://libvirt.org/formatdomain.html#jack-audio-backend>
        """
        return pulumi.get(self, "server_name")


@pulumi.output_type
class DomainDevicesAudioNone(dict):
    def __init__(__self__, *,
                 input: Optional['outputs.DomainDevicesAudioNoneInput'] = None,
                 output: Optional['outputs.DomainDevicesAudioNoneOutput'] = None):
        """
        :param 'DomainDevicesAudioNoneInputArgs' input: Enables a logical output side for the `"none"` audio backend; presence is for symmetry and does not connect to a real host output device.
        :param 'DomainDevicesAudioNoneOutputArgs' output: Enables a logical output side for the `"none"` audio backend; presence is for symmetry and does not connect to a real host output device.
        """
        if input is not None:
            pulumi.set(__self__, "input", input)
        if output is not None:
            pulumi.set(__self__, "output", output)

    @_builtins.property
    @pulumi.getter
    def input(self) -> Optional['outputs.DomainDevicesAudioNoneInput']:
        """
        Enables a logical output side for the `"none"` audio backend; presence is for symmetry and does not connect to a real host output device.
        """
        return pulumi.get(self, "input")

    @_builtins.property
    @pulumi.getter
    def output(self) -> Optional['outputs.DomainDevicesAudioNoneOutput']:
        """
        Enables a logical output side for the `"none"` audio backend; presence is for symmetry and does not connect to a real host output device.
        """
        return pulumi.get(self, "output")


@pulumi.output_type
class DomainDevicesAudioNoneInput(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesAudioNoneOutput(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesAudioOss(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dspPolicy":
            suggest = "dsp_policy"
        elif key == "tryMMap":
            suggest = "try_m_map"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesAudioOss. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesAudioOss.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesAudioOss.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dsp_policy: Optional[_builtins.float] = None,
                 exclusive: Optional[_builtins.str] = None,
                 input: Optional['outputs.DomainDevicesAudioOssInput'] = None,
                 output: Optional['outputs.DomainDevicesAudioOssOutput'] = None,
                 try_m_map: Optional[_builtins.str] = None):
        """
        :param _builtins.float dsp_policy: Configures the OSS backend DSP scheduling policy used for the guest audio device; the value is user-provided and passed through to the OSS layer (for example, an integer priority or policy code as expected by the host OSS implementation).
               
               See: <https://libvirt.org/formatdomain.html#oss-audio-backend>
        :param _builtins.str exclusive: Controls whether the OSS backend opens the host audio device in exclusive mode, typically as a yes/no boolean string accepted by QEMU (for example, "on"/"off" or "yes"/"no").
               
               See: <https://libvirt.org/formatdomain.html#oss-audio-backend>
        :param 'DomainDevicesAudioOssInputArgs' input: Enables and configures the OSS audio output (playback) stream for the guest; presence of this block turns on playback via OSS with the specified attributes.
        :param 'DomainDevicesAudioOssOutputArgs' output: Enables and configures the OSS audio output (playback) stream for the guest; presence of this block turns on playback via OSS with the specified attributes.
        :param _builtins.str try_m_map: Controls whether the OSS backend attempts to use mmap(2)-based data transfer to the host OSS device, typically as a yes/no boolean string accepted by QEMU.
               
               See: <https://libvirt.org/formatdomain.html#oss-audio-backend>
        """
        if dsp_policy is not None:
            pulumi.set(__self__, "dsp_policy", dsp_policy)
        if exclusive is not None:
            pulumi.set(__self__, "exclusive", exclusive)
        if input is not None:
            pulumi.set(__self__, "input", input)
        if output is not None:
            pulumi.set(__self__, "output", output)
        if try_m_map is not None:
            pulumi.set(__self__, "try_m_map", try_m_map)

    @_builtins.property
    @pulumi.getter(name="dspPolicy")
    def dsp_policy(self) -> Optional[_builtins.float]:
        """
        Configures the OSS backend DSP scheduling policy used for the guest audio device; the value is user-provided and passed through to the OSS layer (for example, an integer priority or policy code as expected by the host OSS implementation).

        See: <https://libvirt.org/formatdomain.html#oss-audio-backend>
        """
        return pulumi.get(self, "dsp_policy")

    @_builtins.property
    @pulumi.getter
    def exclusive(self) -> Optional[_builtins.str]:
        """
        Controls whether the OSS backend opens the host audio device in exclusive mode, typically as a yes/no boolean string accepted by QEMU (for example, "on"/"off" or "yes"/"no").

        See: <https://libvirt.org/formatdomain.html#oss-audio-backend>
        """
        return pulumi.get(self, "exclusive")

    @_builtins.property
    @pulumi.getter
    def input(self) -> Optional['outputs.DomainDevicesAudioOssInput']:
        """
        Enables and configures the OSS audio output (playback) stream for the guest; presence of this block turns on playback via OSS with the specified attributes.
        """
        return pulumi.get(self, "input")

    @_builtins.property
    @pulumi.getter
    def output(self) -> Optional['outputs.DomainDevicesAudioOssOutput']:
        """
        Enables and configures the OSS audio output (playback) stream for the guest; presence of this block turns on playback via OSS with the specified attributes.
        """
        return pulumi.get(self, "output")

    @_builtins.property
    @pulumi.getter(name="tryMMap")
    def try_m_map(self) -> Optional[_builtins.str]:
        """
        Controls whether the OSS backend attempts to use mmap(2)-based data transfer to the host OSS device, typically as a yes/no boolean string accepted by QEMU.

        See: <https://libvirt.org/formatdomain.html#oss-audio-backend>
        """
        return pulumi.get(self, "try_m_map")


@pulumi.output_type
class DomainDevicesAudioOssInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bufferCount":
            suggest = "buffer_count"
        elif key == "tryPoll":
            suggest = "try_poll"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesAudioOssInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesAudioOssInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesAudioOssInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 buffer_count: Optional[_builtins.float] = None,
                 dev: Optional[_builtins.str] = None,
                 try_poll: Optional[_builtins.str] = None):
        """
        :param _builtins.float buffer_count: Sets the number of audio buffers used by the OSS output stream; the value is a user-provided positive integer controlling playback latency versus smoothness.
               
               See: <https://libvirt.org/formatdomain.html#oss-audio-backend>
        :param _builtins.str dev: Sets the OSS device node used for audio output, as a user-provided path such as "/dev/dsp" or another OSS playback device.
               
               See: <https://libvirt.org/formatdomain.html#oss-audio-backend>
        :param _builtins.str try_poll: Controls whether the OSS output stream attempts to use poll-based I/O instead of blocking I/O, typically as a yes/no boolean string accepted by QEMU.
               
               See: <https://libvirt.org/formatdomain.html#oss-audio-backend>
        """
        if buffer_count is not None:
            pulumi.set(__self__, "buffer_count", buffer_count)
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if try_poll is not None:
            pulumi.set(__self__, "try_poll", try_poll)

    @_builtins.property
    @pulumi.getter(name="bufferCount")
    def buffer_count(self) -> Optional[_builtins.float]:
        """
        Sets the number of audio buffers used by the OSS output stream; the value is a user-provided positive integer controlling playback latency versus smoothness.

        See: <https://libvirt.org/formatdomain.html#oss-audio-backend>
        """
        return pulumi.get(self, "buffer_count")

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional[_builtins.str]:
        """
        Sets the OSS device node used for audio output, as a user-provided path such as "/dev/dsp" or another OSS playback device.

        See: <https://libvirt.org/formatdomain.html#oss-audio-backend>
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter(name="tryPoll")
    def try_poll(self) -> Optional[_builtins.str]:
        """
        Controls whether the OSS output stream attempts to use poll-based I/O instead of blocking I/O, typically as a yes/no boolean string accepted by QEMU.

        See: <https://libvirt.org/formatdomain.html#oss-audio-backend>
        """
        return pulumi.get(self, "try_poll")


@pulumi.output_type
class DomainDevicesAudioOssOutput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bufferCount":
            suggest = "buffer_count"
        elif key == "tryPoll":
            suggest = "try_poll"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesAudioOssOutput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesAudioOssOutput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesAudioOssOutput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 buffer_count: Optional[_builtins.float] = None,
                 dev: Optional[_builtins.str] = None,
                 try_poll: Optional[_builtins.str] = None):
        """
        :param _builtins.float buffer_count: Sets the number of audio buffers used by the OSS output stream; the value is a user-provided positive integer controlling playback latency versus smoothness.
               
               See: <https://libvirt.org/formatdomain.html#oss-audio-backend>
        :param _builtins.str dev: Sets the OSS device node used for audio output, as a user-provided path such as "/dev/dsp" or another OSS playback device.
               
               See: <https://libvirt.org/formatdomain.html#oss-audio-backend>
        :param _builtins.str try_poll: Controls whether the OSS output stream attempts to use poll-based I/O instead of blocking I/O, typically as a yes/no boolean string accepted by QEMU.
               
               See: <https://libvirt.org/formatdomain.html#oss-audio-backend>
        """
        if buffer_count is not None:
            pulumi.set(__self__, "buffer_count", buffer_count)
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if try_poll is not None:
            pulumi.set(__self__, "try_poll", try_poll)

    @_builtins.property
    @pulumi.getter(name="bufferCount")
    def buffer_count(self) -> Optional[_builtins.float]:
        """
        Sets the number of audio buffers used by the OSS output stream; the value is a user-provided positive integer controlling playback latency versus smoothness.

        See: <https://libvirt.org/formatdomain.html#oss-audio-backend>
        """
        return pulumi.get(self, "buffer_count")

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional[_builtins.str]:
        """
        Sets the OSS device node used for audio output, as a user-provided path such as "/dev/dsp" or another OSS playback device.

        See: <https://libvirt.org/formatdomain.html#oss-audio-backend>
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter(name="tryPoll")
    def try_poll(self) -> Optional[_builtins.str]:
        """
        Controls whether the OSS output stream attempts to use poll-based I/O instead of blocking I/O, typically as a yes/no boolean string accepted by QEMU.

        See: <https://libvirt.org/formatdomain.html#oss-audio-backend>
        """
        return pulumi.get(self, "try_poll")


@pulumi.output_type
class DomainDevicesAudioPipeWire(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "runtimeDir":
            suggest = "runtime_dir"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesAudioPipeWire. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesAudioPipeWire.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesAudioPipeWire.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input: Optional['outputs.DomainDevicesAudioPipeWireInput'] = None,
                 output: Optional['outputs.DomainDevicesAudioPipeWireOutput'] = None,
                 runtime_dir: Optional[_builtins.str] = None):
        """
        :param 'DomainDevicesAudioPipeWireInputArgs' input: Enables and configures the PipeWire output (playback) stream for the guest, allowing selection of sink name, stream name, and latency.
        :param 'DomainDevicesAudioPipeWireOutputArgs' output: Enables and configures the PipeWire output (playback) stream for the guest, allowing selection of sink name, stream name, and latency.
        :param _builtins.str runtime_dir: Sets the directory path used for locating the PipeWire runtime socket and related resources for the PipeWire audio backend; the value is a user-provided filesystem path (for example `/run/user/1000`).
               
               See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
        """
        if input is not None:
            pulumi.set(__self__, "input", input)
        if output is not None:
            pulumi.set(__self__, "output", output)
        if runtime_dir is not None:
            pulumi.set(__self__, "runtime_dir", runtime_dir)

    @_builtins.property
    @pulumi.getter
    def input(self) -> Optional['outputs.DomainDevicesAudioPipeWireInput']:
        """
        Enables and configures the PipeWire output (playback) stream for the guest, allowing selection of sink name, stream name, and latency.
        """
        return pulumi.get(self, "input")

    @_builtins.property
    @pulumi.getter
    def output(self) -> Optional['outputs.DomainDevicesAudioPipeWireOutput']:
        """
        Enables and configures the PipeWire output (playback) stream for the guest, allowing selection of sink name, stream name, and latency.
        """
        return pulumi.get(self, "output")

    @_builtins.property
    @pulumi.getter(name="runtimeDir")
    def runtime_dir(self) -> Optional[_builtins.str]:
        """
        Sets the directory path used for locating the PipeWire runtime socket and related resources for the PipeWire audio backend; the value is a user-provided filesystem path (for example `/run/user/1000`).

        See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
        """
        return pulumi.get(self, "runtime_dir")


@pulumi.output_type
class DomainDevicesAudioPipeWireInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "streamName":
            suggest = "stream_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesAudioPipeWireInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesAudioPipeWireInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesAudioPipeWireInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 latency: Optional[_builtins.float] = None,
                 name: Optional[_builtins.str] = None,
                 stream_name: Optional[_builtins.str] = None):
        """
        :param _builtins.float latency: Sets the desired latency for the PipeWire output stream as a user-provided value (for example, in microseconds or milliseconds as supported by QEMU/PipeWire).
               
               See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
        :param _builtins.str name: Sets the PipeWire sink name that the guest output stream should connect to, as a user-provided string matching a PipeWire node (for example, "alsa_output.pci-0000_00_1b.0").
               
               See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
        :param _builtins.str stream_name: Sets the logical stream name used for the PipeWire output stream, as a user-provided label shown in PipeWire clients (for example, "vm-audio").
               
               See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
        """
        if latency is not None:
            pulumi.set(__self__, "latency", latency)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if stream_name is not None:
            pulumi.set(__self__, "stream_name", stream_name)

    @_builtins.property
    @pulumi.getter
    def latency(self) -> Optional[_builtins.float]:
        """
        Sets the desired latency for the PipeWire output stream as a user-provided value (for example, in microseconds or milliseconds as supported by QEMU/PipeWire).

        See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
        """
        return pulumi.get(self, "latency")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the PipeWire sink name that the guest output stream should connect to, as a user-provided string matching a PipeWire node (for example, "alsa_output.pci-0000_00_1b.0").

        See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> Optional[_builtins.str]:
        """
        Sets the logical stream name used for the PipeWire output stream, as a user-provided label shown in PipeWire clients (for example, "vm-audio").

        See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
        """
        return pulumi.get(self, "stream_name")


@pulumi.output_type
class DomainDevicesAudioPipeWireOutput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "streamName":
            suggest = "stream_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesAudioPipeWireOutput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesAudioPipeWireOutput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesAudioPipeWireOutput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 latency: Optional[_builtins.float] = None,
                 name: Optional[_builtins.str] = None,
                 stream_name: Optional[_builtins.str] = None):
        """
        :param _builtins.float latency: Sets the desired latency for the PipeWire output stream as a user-provided value (for example, in microseconds or milliseconds as supported by QEMU/PipeWire).
               
               See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
        :param _builtins.str name: Sets the PipeWire sink name that the guest output stream should connect to, as a user-provided string matching a PipeWire node (for example, "alsa_output.pci-0000_00_1b.0").
               
               See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
        :param _builtins.str stream_name: Sets the logical stream name used for the PipeWire output stream, as a user-provided label shown in PipeWire clients (for example, "vm-audio").
               
               See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
        """
        if latency is not None:
            pulumi.set(__self__, "latency", latency)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if stream_name is not None:
            pulumi.set(__self__, "stream_name", stream_name)

    @_builtins.property
    @pulumi.getter
    def latency(self) -> Optional[_builtins.float]:
        """
        Sets the desired latency for the PipeWire output stream as a user-provided value (for example, in microseconds or milliseconds as supported by QEMU/PipeWire).

        See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
        """
        return pulumi.get(self, "latency")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the PipeWire sink name that the guest output stream should connect to, as a user-provided string matching a PipeWire node (for example, "alsa_output.pci-0000_00_1b.0").

        See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> Optional[_builtins.str]:
        """
        Sets the logical stream name used for the PipeWire output stream, as a user-provided label shown in PipeWire clients (for example, "vm-audio").

        See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
        """
        return pulumi.get(self, "stream_name")


@pulumi.output_type
class DomainDevicesAudioPulseAudio(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverName":
            suggest = "server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesAudioPulseAudio. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesAudioPulseAudio.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesAudioPulseAudio.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input: Optional['outputs.DomainDevicesAudioPulseAudioInput'] = None,
                 output: Optional['outputs.DomainDevicesAudioPulseAudioOutput'] = None,
                 server_name: Optional[_builtins.str] = None):
        """
        :param 'DomainDevicesAudioPulseAudioInputArgs' input: Enables and configures the PipeWire output (playback) stream for the guest, allowing selection of sink name, stream name, and latency.
        :param 'DomainDevicesAudioPulseAudioOutputArgs' output: Enables and configures the PipeWire output (playback) stream for the guest, allowing selection of sink name, stream name, and latency.
        :param _builtins.str server_name: Sets the hostname or address of the PulseAudio server the domain should connect to; if omitted, PulseAudios default server discovery is used.
               
               See: <https://libvirt.org/formatdomain.html#pulseaudio-audio-backend>
        """
        if input is not None:
            pulumi.set(__self__, "input", input)
        if output is not None:
            pulumi.set(__self__, "output", output)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)

    @_builtins.property
    @pulumi.getter
    def input(self) -> Optional['outputs.DomainDevicesAudioPulseAudioInput']:
        """
        Enables and configures the PipeWire output (playback) stream for the guest, allowing selection of sink name, stream name, and latency.
        """
        return pulumi.get(self, "input")

    @_builtins.property
    @pulumi.getter
    def output(self) -> Optional['outputs.DomainDevicesAudioPulseAudioOutput']:
        """
        Enables and configures the PipeWire output (playback) stream for the guest, allowing selection of sink name, stream name, and latency.
        """
        return pulumi.get(self, "output")

    @_builtins.property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[_builtins.str]:
        """
        Sets the hostname or address of the PulseAudio server the domain should connect to; if omitted, PulseAudios default server discovery is used.

        See: <https://libvirt.org/formatdomain.html#pulseaudio-audio-backend>
        """
        return pulumi.get(self, "server_name")


@pulumi.output_type
class DomainDevicesAudioPulseAudioInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "streamName":
            suggest = "stream_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesAudioPulseAudioInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesAudioPulseAudioInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesAudioPulseAudioInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 latency: Optional[_builtins.float] = None,
                 name: Optional[_builtins.str] = None,
                 stream_name: Optional[_builtins.str] = None):
        """
        :param _builtins.float latency: Sets the desired latency for the PipeWire output stream as a user-provided value (for example, in microseconds or milliseconds as supported by QEMU/PipeWire).
               
               See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
        :param _builtins.str name: Sets the PipeWire sink name that the guest output stream should connect to, as a user-provided string matching a PipeWire node (for example, "alsa_output.pci-0000_00_1b.0").
               
               See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
        :param _builtins.str stream_name: Sets the logical stream name used for the PipeWire output stream, as a user-provided label shown in PipeWire clients (for example, "vm-audio").
               
               See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
        """
        if latency is not None:
            pulumi.set(__self__, "latency", latency)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if stream_name is not None:
            pulumi.set(__self__, "stream_name", stream_name)

    @_builtins.property
    @pulumi.getter
    def latency(self) -> Optional[_builtins.float]:
        """
        Sets the desired latency for the PipeWire output stream as a user-provided value (for example, in microseconds or milliseconds as supported by QEMU/PipeWire).

        See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
        """
        return pulumi.get(self, "latency")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the PipeWire sink name that the guest output stream should connect to, as a user-provided string matching a PipeWire node (for example, "alsa_output.pci-0000_00_1b.0").

        See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> Optional[_builtins.str]:
        """
        Sets the logical stream name used for the PipeWire output stream, as a user-provided label shown in PipeWire clients (for example, "vm-audio").

        See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
        """
        return pulumi.get(self, "stream_name")


@pulumi.output_type
class DomainDevicesAudioPulseAudioOutput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "streamName":
            suggest = "stream_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesAudioPulseAudioOutput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesAudioPulseAudioOutput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesAudioPulseAudioOutput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 latency: Optional[_builtins.float] = None,
                 name: Optional[_builtins.str] = None,
                 stream_name: Optional[_builtins.str] = None):
        """
        :param _builtins.float latency: Sets the desired latency for the PipeWire output stream as a user-provided value (for example, in microseconds or milliseconds as supported by QEMU/PipeWire).
               
               See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
        :param _builtins.str name: Sets the PipeWire sink name that the guest output stream should connect to, as a user-provided string matching a PipeWire node (for example, "alsa_output.pci-0000_00_1b.0").
               
               See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
        :param _builtins.str stream_name: Sets the logical stream name used for the PipeWire output stream, as a user-provided label shown in PipeWire clients (for example, "vm-audio").
               
               See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
        """
        if latency is not None:
            pulumi.set(__self__, "latency", latency)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if stream_name is not None:
            pulumi.set(__self__, "stream_name", stream_name)

    @_builtins.property
    @pulumi.getter
    def latency(self) -> Optional[_builtins.float]:
        """
        Sets the desired latency for the PipeWire output stream as a user-provided value (for example, in microseconds or milliseconds as supported by QEMU/PipeWire).

        See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
        """
        return pulumi.get(self, "latency")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the PipeWire sink name that the guest output stream should connect to, as a user-provided string matching a PipeWire node (for example, "alsa_output.pci-0000_00_1b.0").

        See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> Optional[_builtins.str]:
        """
        Sets the logical stream name used for the PipeWire output stream, as a user-provided label shown in PipeWire clients (for example, "vm-audio").

        See: <https://libvirt.org/formatdomain.html#pipewire-audio-backend>
        """
        return pulumi.get(self, "stream_name")


@pulumi.output_type
class DomainDevicesAudioSdl(dict):
    def __init__(__self__, *,
                 driver: Optional[_builtins.str] = None,
                 input: Optional['outputs.DomainDevicesAudioSdlInput'] = None,
                 output: Optional['outputs.DomainDevicesAudioSdlOutput'] = None):
        """
        :param _builtins.str driver: Sets the SDL audio driver name to use (mapped to the `SDL_AUDIODRIVER` value); the string is user-provided and should match a valid SDL audio driver on the host (for example `alsa` or `pulseaudio`).
               
               See: <https://libvirt.org/formatdomain.html#sdl-audio-backend>
        :param 'DomainDevicesAudioSdlInputArgs' input: Configures output (playback) options for the SDL audio backend, including buffer sizing for the output stream.
        :param 'DomainDevicesAudioSdlOutputArgs' output: Configures output (playback) options for the SDL audio backend, including buffer sizing for the output stream.
        """
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if input is not None:
            pulumi.set(__self__, "input", input)
        if output is not None:
            pulumi.set(__self__, "output", output)

    @_builtins.property
    @pulumi.getter
    def driver(self) -> Optional[_builtins.str]:
        """
        Sets the SDL audio driver name to use (mapped to the `SDL_AUDIODRIVER` value); the string is user-provided and should match a valid SDL audio driver on the host (for example `alsa` or `pulseaudio`).

        See: <https://libvirt.org/formatdomain.html#sdl-audio-backend>
        """
        return pulumi.get(self, "driver")

    @_builtins.property
    @pulumi.getter
    def input(self) -> Optional['outputs.DomainDevicesAudioSdlInput']:
        """
        Configures output (playback) options for the SDL audio backend, including buffer sizing for the output stream.
        """
        return pulumi.get(self, "input")

    @_builtins.property
    @pulumi.getter
    def output(self) -> Optional['outputs.DomainDevicesAudioSdlOutput']:
        """
        Configures output (playback) options for the SDL audio backend, including buffer sizing for the output stream.
        """
        return pulumi.get(self, "output")


@pulumi.output_type
class DomainDevicesAudioSdlInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bufferCount":
            suggest = "buffer_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesAudioSdlInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesAudioSdlInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesAudioSdlInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 buffer_count: Optional[_builtins.float] = None):
        """
        :param _builtins.float buffer_count: Sets the number of audio buffers used for SDL output; the value is a user-provided non-negative integer controlling playback buffering depth.
               
               See: <https://libvirt.org/formatdomain.html#sdl-audio-backend>
        """
        if buffer_count is not None:
            pulumi.set(__self__, "buffer_count", buffer_count)

    @_builtins.property
    @pulumi.getter(name="bufferCount")
    def buffer_count(self) -> Optional[_builtins.float]:
        """
        Sets the number of audio buffers used for SDL output; the value is a user-provided non-negative integer controlling playback buffering depth.

        See: <https://libvirt.org/formatdomain.html#sdl-audio-backend>
        """
        return pulumi.get(self, "buffer_count")


@pulumi.output_type
class DomainDevicesAudioSdlOutput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bufferCount":
            suggest = "buffer_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesAudioSdlOutput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesAudioSdlOutput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesAudioSdlOutput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 buffer_count: Optional[_builtins.float] = None):
        """
        :param _builtins.float buffer_count: Sets the number of audio buffers used for SDL output; the value is a user-provided non-negative integer controlling playback buffering depth.
               
               See: <https://libvirt.org/formatdomain.html#sdl-audio-backend>
        """
        if buffer_count is not None:
            pulumi.set(__self__, "buffer_count", buffer_count)

    @_builtins.property
    @pulumi.getter(name="bufferCount")
    def buffer_count(self) -> Optional[_builtins.float]:
        """
        Sets the number of audio buffers used for SDL output; the value is a user-provided non-negative integer controlling playback buffering depth.

        See: <https://libvirt.org/formatdomain.html#sdl-audio-backend>
        """
        return pulumi.get(self, "buffer_count")


@pulumi.output_type
class DomainDevicesAudioSpice(dict):
    def __init__(__self__, *,
                 input: Optional['outputs.DomainDevicesAudioSpiceInput'] = None,
                 output: Optional['outputs.DomainDevicesAudioSpiceOutput'] = None):
        """
        :param 'DomainDevicesAudioSpiceInputArgs' input: Declares an output (playback) stream for the SPICE audio backend; presence of this block enables SPICE audio playback with default stream properties.
        :param 'DomainDevicesAudioSpiceOutputArgs' output: Declares an output (playback) stream for the SPICE audio backend; presence of this block enables SPICE audio playback with default stream properties.
        """
        if input is not None:
            pulumi.set(__self__, "input", input)
        if output is not None:
            pulumi.set(__self__, "output", output)

    @_builtins.property
    @pulumi.getter
    def input(self) -> Optional['outputs.DomainDevicesAudioSpiceInput']:
        """
        Declares an output (playback) stream for the SPICE audio backend; presence of this block enables SPICE audio playback with default stream properties.
        """
        return pulumi.get(self, "input")

    @_builtins.property
    @pulumi.getter
    def output(self) -> Optional['outputs.DomainDevicesAudioSpiceOutput']:
        """
        Declares an output (playback) stream for the SPICE audio backend; presence of this block enables SPICE audio playback with default stream properties.
        """
        return pulumi.get(self, "output")


@pulumi.output_type
class DomainDevicesAudioSpiceInput(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesAudioSpiceOutput(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesChannel(dict):
    def __init__(__self__, *,
                 acpi: Optional['outputs.DomainDevicesChannelAcpi'] = None,
                 address: Optional['outputs.DomainDevicesChannelAddress'] = None,
                 alias: Optional['outputs.DomainDevicesChannelAlias'] = None,
                 log: Optional['outputs.DomainDevicesChannelLog'] = None,
                 protocol: Optional['outputs.DomainDevicesChannelProtocol'] = None,
                 source: Optional['outputs.DomainDevicesChannelSource'] = None,
                 target: Optional['outputs.DomainDevicesChannelTarget'] = None):
        """
        :param 'DomainDevicesChannelAcpiArgs' acpi: Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        :param 'DomainDevicesChannelAddressArgs' address: Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        :param 'DomainDevicesChannelAliasArgs' alias: Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        :param 'DomainDevicesChannelLogArgs' log: Enables logging of data sent through the channel to a host file and configures how that logging behaves.
        :param 'DomainDevicesChannelProtocolArgs' protocol: Configures the transport protocol used by the EGD backend connection.
        :param 'DomainDevicesChannelSourceArgs' source: Defines the source endpoint for the EGD backend, such as a socket path or network address, depending on the chosen protocol.
        :param 'DomainDevicesChannelTargetArgs' target: Configures the guest-side target for the channel, selecting how the guest sees and uses the channel (e.g. virtio, xen, guestfwd).
        """
        if acpi is not None:
            pulumi.set(__self__, "acpi", acpi)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if log is not None:
            pulumi.set(__self__, "log", log)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def acpi(self) -> Optional['outputs.DomainDevicesChannelAcpi']:
        """
        Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        """
        return pulumi.get(self, "acpi")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesChannelAddress']:
        """
        Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional['outputs.DomainDevicesChannelAlias']:
        """
        Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def log(self) -> Optional['outputs.DomainDevicesChannelLog']:
        """
        Enables logging of data sent through the channel to a host file and configures how that logging behaves.
        """
        return pulumi.get(self, "log")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional['outputs.DomainDevicesChannelProtocol']:
        """
        Configures the transport protocol used by the EGD backend connection.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainDevicesChannelSource']:
        """
        Defines the source endpoint for the EGD backend, such as a socket path or network address, depending on the chosen protocol.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional['outputs.DomainDevicesChannelTarget']:
        """
        Configures the guest-side target for the channel, selecting how the guest sees and uses the channel (e.g. virtio, xen, guestfwd).
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class DomainDevicesChannelAcpi(dict):
    def __init__(__self__, *,
                 index: Optional[_builtins.float] = None):
        """
        :param _builtins.float index: Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        """
        if index is not None:
            pulumi.set(__self__, "index", index)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "index")


@pulumi.output_type
class DomainDevicesChannelAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesChannelAlias(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
               
               See: <https://libvirt.org/formatdomain.html#devices>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesChannelLog(dict):
    def __init__(__self__, *,
                 file: _builtins.str,
                 append: Optional[_builtins.str] = None):
        """
        :param _builtins.str file: Sets the absolute or relative path of the host file where channel I/O is logged.
               
               See: <https://libvirt.org/formatdomain.html#device-logfile>
        :param _builtins.str append: Controls whether the channel log file is appended to (`"yes"`) or truncated (`"no"`) on start; this is a yes/no string flag.
               
               See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        pulumi.set(__self__, "file", file)
        if append is not None:
            pulumi.set(__self__, "append", append)

    @_builtins.property
    @pulumi.getter
    def file(self) -> _builtins.str:
        """
        Sets the absolute or relative path of the host file where channel I/O is logged.

        See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def append(self) -> Optional[_builtins.str]:
        """
        Controls whether the channel log file is appended to (`"yes"`) or truncated (`"no"`) on start; this is a yes/no string flag.

        See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        return pulumi.get(self, "append")


@pulumi.output_type
class DomainDevicesChannelProtocol(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: Sets the EGD transport type, such as "tcp" or "unix"; value is a user-provided string supported by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets the EGD transport type, such as "tcp" or "unix"; value is a user-provided string supported by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainDevicesChannelSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "qemuvdAgent":
            suggest = "qemuvd_agent"
        elif key == "spicePort":
            suggest = "spice_port"
        elif key == "spiceVmc":
            suggest = "spice_vmc"
        elif key == "stdIo":
            suggest = "std_io"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesChannelSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesChannelSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesChannelSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbus: Optional['outputs.DomainDevicesChannelSourceDbus'] = None,
                 dev: Optional['outputs.DomainDevicesChannelSourceDev'] = None,
                 file: Optional['outputs.DomainDevicesChannelSourceFile'] = None,
                 nmdm: Optional['outputs.DomainDevicesChannelSourceNmdm'] = None,
                 null: Optional[_builtins.bool] = None,
                 pipe: Optional['outputs.DomainDevicesChannelSourcePipe'] = None,
                 pty: Optional['outputs.DomainDevicesChannelSourcePty'] = None,
                 qemuvd_agent: Optional['outputs.DomainDevicesChannelSourceQemuvdAgent'] = None,
                 spice_port: Optional['outputs.DomainDevicesChannelSourceSpicePort'] = None,
                 spice_vmc: Optional[_builtins.bool] = None,
                 std_io: Optional[_builtins.bool] = None,
                 tcp: Optional['outputs.DomainDevicesChannelSourceTcp'] = None,
                 udp: Optional['outputs.DomainDevicesChannelSourceUdp'] = None,
                 unix: Optional['outputs.DomainDevicesChannelSourceUnix'] = None,
                 vc: Optional[_builtins.bool] = None):
        """
        :param 'DomainDevicesChannelSourceDbusArgs' dbus: Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        :param 'DomainDevicesChannelSourceDevArgs' dev: Configures an EGD RNG backend that reads entropy from a host character device node.
        :param 'DomainDevicesChannelSourceFileArgs' file: Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        :param 'DomainDevicesChannelSourceNmdmArgs' nmdm: Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        :param _builtins.bool null: Enables use of a null backend for the EGD RNG source, discarding all data written and providing no entropy; when this boolean is true the <Null> source is emitted, and when false or unset it is omitted.
        :param 'DomainDevicesChannelSourcePipeArgs' pipe: Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        :param 'DomainDevicesChannelSourcePtyArgs' pty: Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        :param 'DomainDevicesChannelSourceQemuvdAgentArgs' qemuvd_agent: Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        :param 'DomainDevicesChannelSourceSpicePortArgs' spice_port: Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        :param _builtins.bool spice_vmc: Enables using a SPICE virtio serial management channel (spicevmc) as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.bool std_io: Enables using the QEMU process standard I/O stream as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesChannelSourceTcpArgs' tcp: Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        :param 'DomainDevicesChannelSourceUdpArgs' udp: Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        :param 'DomainDevicesChannelSourceUnixArgs' unix: Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        :param _builtins.bool vc: Enables use of a virtual console device as the entropy source for the EGD RNG backend when set (presence-only element; omitting it disables this source).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if dbus is not None:
            pulumi.set(__self__, "dbus", dbus)
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if nmdm is not None:
            pulumi.set(__self__, "nmdm", nmdm)
        if null is not None:
            pulumi.set(__self__, "null", null)
        if pipe is not None:
            pulumi.set(__self__, "pipe", pipe)
        if pty is not None:
            pulumi.set(__self__, "pty", pty)
        if qemuvd_agent is not None:
            pulumi.set(__self__, "qemuvd_agent", qemuvd_agent)
        if spice_port is not None:
            pulumi.set(__self__, "spice_port", spice_port)
        if spice_vmc is not None:
            pulumi.set(__self__, "spice_vmc", spice_vmc)
        if std_io is not None:
            pulumi.set(__self__, "std_io", std_io)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)
        if unix is not None:
            pulumi.set(__self__, "unix", unix)
        if vc is not None:
            pulumi.set(__self__, "vc", vc)

    @_builtins.property
    @pulumi.getter
    def dbus(self) -> Optional['outputs.DomainDevicesChannelSourceDbus']:
        """
        Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        """
        return pulumi.get(self, "dbus")

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional['outputs.DomainDevicesChannelSourceDev']:
        """
        Configures an EGD RNG backend that reads entropy from a host character device node.
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.DomainDevicesChannelSourceFile']:
        """
        Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def nmdm(self) -> Optional['outputs.DomainDevicesChannelSourceNmdm']:
        """
        Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        """
        return pulumi.get(self, "nmdm")

    @_builtins.property
    @pulumi.getter
    def null(self) -> Optional[_builtins.bool]:
        """
        Enables use of a null backend for the EGD RNG source, discarding all data written and providing no entropy; when this boolean is true the <Null> source is emitted, and when false or unset it is omitted.
        """
        return pulumi.get(self, "null")

    @_builtins.property
    @pulumi.getter
    def pipe(self) -> Optional['outputs.DomainDevicesChannelSourcePipe']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        """
        return pulumi.get(self, "pipe")

    @_builtins.property
    @pulumi.getter
    def pty(self) -> Optional['outputs.DomainDevicesChannelSourcePty']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        """
        return pulumi.get(self, "pty")

    @_builtins.property
    @pulumi.getter(name="qemuvdAgent")
    def qemuvd_agent(self) -> Optional['outputs.DomainDevicesChannelSourceQemuvdAgent']:
        """
        Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        """
        return pulumi.get(self, "qemuvd_agent")

    @_builtins.property
    @pulumi.getter(name="spicePort")
    def spice_port(self) -> Optional['outputs.DomainDevicesChannelSourceSpicePort']:
        """
        Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        """
        return pulumi.get(self, "spice_port")

    @_builtins.property
    @pulumi.getter(name="spiceVmc")
    def spice_vmc(self) -> Optional[_builtins.bool]:
        """
        Enables using a SPICE virtio serial management channel (spicevmc) as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "spice_vmc")

    @_builtins.property
    @pulumi.getter(name="stdIo")
    def std_io(self) -> Optional[_builtins.bool]:
        """
        Enables using the QEMU process standard I/O stream as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "std_io")

    @_builtins.property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.DomainDevicesChannelSourceTcp']:
        """
        Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        """
        return pulumi.get(self, "tcp")

    @_builtins.property
    @pulumi.getter
    def udp(self) -> Optional['outputs.DomainDevicesChannelSourceUdp']:
        """
        Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        """
        return pulumi.get(self, "udp")

    @_builtins.property
    @pulumi.getter
    def unix(self) -> Optional['outputs.DomainDevicesChannelSourceUnix']:
        """
        Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        """
        return pulumi.get(self, "unix")

    @_builtins.property
    @pulumi.getter
    def vc(self) -> Optional[_builtins.bool]:
        """
        Enables use of a virtual console device as the entropy source for the EGD RNG backend when set (presence-only element; omitting it disables this source).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "vc")


@pulumi.output_type
class DomainDevicesChannelSourceDbus(dict):
    def __init__(__self__, *,
                 channel: Optional[_builtins.str] = None):
        """
        :param _builtins.str channel: Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.str]:
        """
        Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesChannelSourceDev(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesChannelSourceDev. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesChannelSourceDev.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesChannelSourceDev.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesChannelSourceDevSecLabel']] = None):
        """
        :param _builtins.str path: Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesChannelSourceDevSecLabelArgs'] sec_labels: Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesChannelSourceDevSecLabel']]:
        """
        Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesChannelSourceDevSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesChannelSourceDevSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesChannelSourceDevSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesChannelSourceDevSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesChannelSourceFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesChannelSourceFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesChannelSourceFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesChannelSourceFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 append: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesChannelSourceFileSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str append: Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
               
               See: <https://libvirt.org/formatdomain.html#device-logfile>
        :param Sequence['DomainDevicesChannelSourceFileSecLabelArgs'] sec_labels: Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def append(self) -> Optional[_builtins.str]:
        """
        Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.

        See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        return pulumi.get(self, "append")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesChannelSourceFileSecLabel']]:
        """
        Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesChannelSourceFileSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesChannelSourceFileSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesChannelSourceFileSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesChannelSourceFileSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesChannelSourceNmdm(dict):
    def __init__(__self__, *,
                 master: _builtins.str,
                 slave: _builtins.str):
        """
        :param _builtins.str master: Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        :param _builtins.str slave: Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        pulumi.set(__self__, "master", master)
        pulumi.set(__self__, "slave", slave)

    @_builtins.property
    @pulumi.getter
    def master(self) -> _builtins.str:
        """
        Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "master")

    @_builtins.property
    @pulumi.getter
    def slave(self) -> _builtins.str:
        """
        Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "slave")


@pulumi.output_type
class DomainDevicesChannelSourcePipe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesChannelSourcePipe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesChannelSourcePipe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesChannelSourcePipe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesChannelSourcePipeSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesChannelSourcePipeSecLabelArgs'] sec_labels: Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesChannelSourcePipeSecLabel']]:
        """
        Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesChannelSourcePipeSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesChannelSourcePipeSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesChannelSourcePipeSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesChannelSourcePipeSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesChannelSourcePty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesChannelSourcePty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesChannelSourcePty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesChannelSourcePty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesChannelSourcePtySecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesChannelSourcePtySecLabelArgs'] sec_labels: Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesChannelSourcePtySecLabel']]:
        """
        Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesChannelSourcePtySecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesChannelSourcePtySecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesChannelSourcePtySecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesChannelSourcePtySecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesChannelSourceQemuvdAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clipBoard":
            suggest = "clip_board"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesChannelSourceQemuvdAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesChannelSourceQemuvdAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesChannelSourceQemuvdAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clip_board: Optional['outputs.DomainDevicesChannelSourceQemuvdAgentClipBoard'] = None,
                 mouse: Optional['outputs.DomainDevicesChannelSourceQemuvdAgentMouse'] = None):
        """
        :param 'DomainDevicesChannelSourceQemuvdAgentClipBoardArgs' clip_board: Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        :param 'DomainDevicesChannelSourceQemuvdAgentMouseArgs' mouse: Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        if clip_board is not None:
            pulumi.set(__self__, "clip_board", clip_board)
        if mouse is not None:
            pulumi.set(__self__, "mouse", mouse)

    @_builtins.property
    @pulumi.getter(name="clipBoard")
    def clip_board(self) -> Optional['outputs.DomainDevicesChannelSourceQemuvdAgentClipBoard']:
        """
        Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        """
        return pulumi.get(self, "clip_board")

    @_builtins.property
    @pulumi.getter
    def mouse(self) -> Optional['outputs.DomainDevicesChannelSourceQemuvdAgentMouse']:
        """
        Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        return pulumi.get(self, "mouse")


@pulumi.output_type
class DomainDevicesChannelSourceQemuvdAgentClipBoard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyPaste":
            suggest = "copy_paste"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesChannelSourceQemuvdAgentClipBoard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesChannelSourceQemuvdAgentClipBoard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesChannelSourceQemuvdAgentClipBoard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_paste: _builtins.str):
        """
        :param _builtins.str copy_paste: Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "copy_paste", copy_paste)

    @_builtins.property
    @pulumi.getter(name="copyPaste")
    def copy_paste(self) -> _builtins.str:
        """
        Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "copy_paste")


@pulumi.output_type
class DomainDevicesChannelSourceQemuvdAgentMouse(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DomainDevicesChannelSourceSpicePort(dict):
    def __init__(__self__, *,
                 channel: _builtins.str):
        """
        :param _builtins.str channel: Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesChannelSourceTcp(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesChannelSourceTcpReconnect'] = None,
                 service: Optional[_builtins.str] = None,
                 tls: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str mode: Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesChannelSourceTcpReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param _builtins.str service: Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str tls: Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesChannelSourceTcpReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[_builtins.str]:
        """
        Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class DomainDevicesChannelSourceTcpReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesChannelSourceUdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindHost":
            suggest = "bind_host"
        elif key == "bindService":
            suggest = "bind_service"
        elif key == "connectHost":
            suggest = "connect_host"
        elif key == "connectService":
            suggest = "connect_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesChannelSourceUdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesChannelSourceUdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesChannelSourceUdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bind_host: _builtins.str,
                 bind_service: _builtins.str,
                 connect_host: _builtins.str,
                 connect_service: _builtins.str):
        """
        :param _builtins.str bind_host: Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str bind_service: Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_host: Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_service: Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "bind_host", bind_host)
        pulumi.set(__self__, "bind_service", bind_service)
        pulumi.set(__self__, "connect_host", connect_host)
        pulumi.set(__self__, "connect_service", connect_service)

    @_builtins.property
    @pulumi.getter(name="bindHost")
    def bind_host(self) -> _builtins.str:
        """
        Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_host")

    @_builtins.property
    @pulumi.getter(name="bindService")
    def bind_service(self) -> _builtins.str:
        """
        Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_service")

    @_builtins.property
    @pulumi.getter(name="connectHost")
    def connect_host(self) -> _builtins.str:
        """
        Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_host")

    @_builtins.property
    @pulumi.getter(name="connectService")
    def connect_service(self) -> _builtins.str:
        """
        Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_service")


@pulumi.output_type
class DomainDevicesChannelSourceUnix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesChannelSourceUnix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesChannelSourceUnix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesChannelSourceUnix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesChannelSourceUnixReconnect'] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesChannelSourceUnixSecLabel']] = None):
        """
        :param _builtins.str mode: Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str path: Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesChannelSourceUnixReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param Sequence['DomainDevicesChannelSourceUnixSecLabelArgs'] sec_labels: Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesChannelSourceUnixReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesChannelSourceUnixSecLabel']]:
        """
        Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesChannelSourceUnixReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesChannelSourceUnixSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesChannelSourceUnixSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesChannelSourceUnixSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesChannelSourceUnixSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesChannelTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "guestFwd":
            suggest = "guest_fwd"
        elif key == "virtIo":
            suggest = "virt_io"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesChannelTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesChannelTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesChannelTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 guest_fwd: Optional['outputs.DomainDevicesChannelTargetGuestFwd'] = None,
                 virt_io: Optional['outputs.DomainDevicesChannelTargetVirtIo'] = None,
                 xen: Optional['outputs.DomainDevicesChannelTargetXen'] = None):
        """
        :param 'DomainDevicesChannelTargetGuestFwdArgs' guest_fwd: Configures a guestfwd-style channel target that forwards guest TCP connections to a host-side TCP endpoint.
        :param 'DomainDevicesChannelTargetVirtIoArgs' virt_io: Configures a virtio-based channel target, making the channel visible as a virtio-serial device in the guest.
        :param 'DomainDevicesChannelTargetXenArgs' xen: Configures a Xen-style channel target, exposing the channel via the Xen guest interface mechanism.
        """
        if guest_fwd is not None:
            pulumi.set(__self__, "guest_fwd", guest_fwd)
        if virt_io is not None:
            pulumi.set(__self__, "virt_io", virt_io)
        if xen is not None:
            pulumi.set(__self__, "xen", xen)

    @_builtins.property
    @pulumi.getter(name="guestFwd")
    def guest_fwd(self) -> Optional['outputs.DomainDevicesChannelTargetGuestFwd']:
        """
        Configures a guestfwd-style channel target that forwards guest TCP connections to a host-side TCP endpoint.
        """
        return pulumi.get(self, "guest_fwd")

    @_builtins.property
    @pulumi.getter(name="virtIo")
    def virt_io(self) -> Optional['outputs.DomainDevicesChannelTargetVirtIo']:
        """
        Configures a virtio-based channel target, making the channel visible as a virtio-serial device in the guest.
        """
        return pulumi.get(self, "virt_io")

    @_builtins.property
    @pulumi.getter
    def xen(self) -> Optional['outputs.DomainDevicesChannelTargetXen']:
        """
        Configures a Xen-style channel target, exposing the channel via the Xen guest interface mechanism.
        """
        return pulumi.get(self, "xen")


@pulumi.output_type
class DomainDevicesChannelTargetGuestFwd(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: Sets the host IP address or hostname that the guestfwd channel forwards traffic to; value is user-provided (e.g. "127.0.0.1").
               
               See: <https://libvirt.org/formatdomain.html#channel>
        :param _builtins.str port: Sets the TCP port number on the host that the guestfwd channel forwards traffic to; must be a valid TCP port (165535).
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Sets the host IP address or hostname that the guestfwd channel forwards traffic to; value is user-provided (e.g. "127.0.0.1").

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        """
        Sets the TCP port number on the host that the guestfwd channel forwards traffic to; must be a valid TCP port (165535).

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DomainDevicesChannelTargetVirtIo(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Sets the virtio channel name exposed inside the guest (for example "org.qemu.guest_agent.0"); value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#channel>
        :param _builtins.str state: Sets the initial connection state of the virtio channel target; typically "connected" or "disconnected" when supported, value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the virtio channel name exposed inside the guest (for example "org.qemu.guest_agent.0"); value is user-provided.

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the initial connection state of the virtio channel target; typically "connected" or "disconnected" when supported, value is user-provided.

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainDevicesChannelTargetXen(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Sets the Xen guest channel name used inside the guest to identify this channel; value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#channel>
        :param _builtins.str state: Sets the initial connection state of the Xen channel target; typically "connected" or "disconnected" when supported, value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the Xen guest channel name used inside the guest to identify this channel; value is user-provided.

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the initial connection state of the Xen channel target; typically "connected" or "disconnected" when supported, value is user-provided.

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainDevicesConsole(dict):
    def __init__(__self__, *,
                 acpi: Optional['outputs.DomainDevicesConsoleAcpi'] = None,
                 address: Optional['outputs.DomainDevicesConsoleAddress'] = None,
                 alias: Optional['outputs.DomainDevicesConsoleAlias'] = None,
                 log: Optional['outputs.DomainDevicesConsoleLog'] = None,
                 protocol: Optional['outputs.DomainDevicesConsoleProtocol'] = None,
                 source: Optional['outputs.DomainDevicesConsoleSource'] = None,
                 target: Optional['outputs.DomainDevicesConsoleTarget'] = None,
                 tty: Optional[_builtins.str] = None):
        """
        :param 'DomainDevicesConsoleAcpiArgs' acpi: Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        :param 'DomainDevicesConsoleAddressArgs' address: Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        :param 'DomainDevicesConsoleAliasArgs' alias: Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        :param 'DomainDevicesConsoleLogArgs' log: Enables logging of data sent through the channel to a host file and configures how that logging behaves.
        :param 'DomainDevicesConsoleProtocolArgs' protocol: Configures the transport protocol used by the EGD backend connection.
        :param 'DomainDevicesConsoleSourceArgs' source: Defines the source endpoint for the EGD backend, such as a socket path or network address, depending on the chosen protocol.
        :param 'DomainDevicesConsoleTargetArgs' target: Configures how the console appears inside the guest (e.g. which guest console/serial port it is attached to).
        :param _builtins.str tty: Records or overrides the host-side TTY or device path associated with this console (for example "/dev/pts/3"); value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#pseudo-tty>
        """
        if acpi is not None:
            pulumi.set(__self__, "acpi", acpi)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if log is not None:
            pulumi.set(__self__, "log", log)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if tty is not None:
            pulumi.set(__self__, "tty", tty)

    @_builtins.property
    @pulumi.getter
    def acpi(self) -> Optional['outputs.DomainDevicesConsoleAcpi']:
        """
        Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        """
        return pulumi.get(self, "acpi")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesConsoleAddress']:
        """
        Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional['outputs.DomainDevicesConsoleAlias']:
        """
        Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def log(self) -> Optional['outputs.DomainDevicesConsoleLog']:
        """
        Enables logging of data sent through the channel to a host file and configures how that logging behaves.
        """
        return pulumi.get(self, "log")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional['outputs.DomainDevicesConsoleProtocol']:
        """
        Configures the transport protocol used by the EGD backend connection.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainDevicesConsoleSource']:
        """
        Defines the source endpoint for the EGD backend, such as a socket path or network address, depending on the chosen protocol.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional['outputs.DomainDevicesConsoleTarget']:
        """
        Configures how the console appears inside the guest (e.g. which guest console/serial port it is attached to).
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def tty(self) -> Optional[_builtins.str]:
        """
        Records or overrides the host-side TTY or device path associated with this console (for example "/dev/pts/3"); value is user-provided.

        See: <https://libvirt.org/formatdomain.html#pseudo-tty>
        """
        return pulumi.get(self, "tty")


@pulumi.output_type
class DomainDevicesConsoleAcpi(dict):
    def __init__(__self__, *,
                 index: Optional[_builtins.float] = None):
        """
        :param _builtins.float index: Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        """
        if index is not None:
            pulumi.set(__self__, "index", index)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "index")


@pulumi.output_type
class DomainDevicesConsoleAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesConsoleAlias(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
               
               See: <https://libvirt.org/formatdomain.html#devices>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesConsoleLog(dict):
    def __init__(__self__, *,
                 file: _builtins.str,
                 append: Optional[_builtins.str] = None):
        """
        :param _builtins.str file: Sets the absolute or relative path of the host file where channel I/O is logged.
               
               See: <https://libvirt.org/formatdomain.html#device-logfile>
        :param _builtins.str append: Controls whether the channel log file is appended to (`"yes"`) or truncated (`"no"`) on start; this is a yes/no string flag.
               
               See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        pulumi.set(__self__, "file", file)
        if append is not None:
            pulumi.set(__self__, "append", append)

    @_builtins.property
    @pulumi.getter
    def file(self) -> _builtins.str:
        """
        Sets the absolute or relative path of the host file where channel I/O is logged.

        See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def append(self) -> Optional[_builtins.str]:
        """
        Controls whether the channel log file is appended to (`"yes"`) or truncated (`"no"`) on start; this is a yes/no string flag.

        See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        return pulumi.get(self, "append")


@pulumi.output_type
class DomainDevicesConsoleProtocol(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: Sets the EGD transport type, such as "tcp" or "unix"; value is a user-provided string supported by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets the EGD transport type, such as "tcp" or "unix"; value is a user-provided string supported by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainDevicesConsoleSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "qemuvdAgent":
            suggest = "qemuvd_agent"
        elif key == "spicePort":
            suggest = "spice_port"
        elif key == "spiceVmc":
            suggest = "spice_vmc"
        elif key == "stdIo":
            suggest = "std_io"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesConsoleSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesConsoleSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesConsoleSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbus: Optional['outputs.DomainDevicesConsoleSourceDbus'] = None,
                 dev: Optional['outputs.DomainDevicesConsoleSourceDev'] = None,
                 file: Optional['outputs.DomainDevicesConsoleSourceFile'] = None,
                 nmdm: Optional['outputs.DomainDevicesConsoleSourceNmdm'] = None,
                 null: Optional[_builtins.bool] = None,
                 pipe: Optional['outputs.DomainDevicesConsoleSourcePipe'] = None,
                 pty: Optional['outputs.DomainDevicesConsoleSourcePty'] = None,
                 qemuvd_agent: Optional['outputs.DomainDevicesConsoleSourceQemuvdAgent'] = None,
                 spice_port: Optional['outputs.DomainDevicesConsoleSourceSpicePort'] = None,
                 spice_vmc: Optional[_builtins.bool] = None,
                 std_io: Optional[_builtins.bool] = None,
                 tcp: Optional['outputs.DomainDevicesConsoleSourceTcp'] = None,
                 udp: Optional['outputs.DomainDevicesConsoleSourceUdp'] = None,
                 unix: Optional['outputs.DomainDevicesConsoleSourceUnix'] = None,
                 vc: Optional[_builtins.bool] = None):
        """
        :param 'DomainDevicesConsoleSourceDbusArgs' dbus: Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        :param 'DomainDevicesConsoleSourceDevArgs' dev: Configures an EGD RNG backend that reads entropy from a host character device node.
        :param 'DomainDevicesConsoleSourceFileArgs' file: Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        :param 'DomainDevicesConsoleSourceNmdmArgs' nmdm: Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        :param _builtins.bool null: Enables use of a null backend for the EGD RNG source, discarding all data written and providing no entropy; when this boolean is true the <Null> source is emitted, and when false or unset it is omitted.
        :param 'DomainDevicesConsoleSourcePipeArgs' pipe: Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        :param 'DomainDevicesConsoleSourcePtyArgs' pty: Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        :param 'DomainDevicesConsoleSourceQemuvdAgentArgs' qemuvd_agent: Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        :param 'DomainDevicesConsoleSourceSpicePortArgs' spice_port: Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        :param _builtins.bool spice_vmc: Enables using a SPICE virtio serial management channel (spicevmc) as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.bool std_io: Enables using the QEMU process standard I/O stream as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesConsoleSourceTcpArgs' tcp: Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        :param 'DomainDevicesConsoleSourceUdpArgs' udp: Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        :param 'DomainDevicesConsoleSourceUnixArgs' unix: Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        :param _builtins.bool vc: Enables use of a virtual console device as the entropy source for the EGD RNG backend when set (presence-only element; omitting it disables this source).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if dbus is not None:
            pulumi.set(__self__, "dbus", dbus)
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if nmdm is not None:
            pulumi.set(__self__, "nmdm", nmdm)
        if null is not None:
            pulumi.set(__self__, "null", null)
        if pipe is not None:
            pulumi.set(__self__, "pipe", pipe)
        if pty is not None:
            pulumi.set(__self__, "pty", pty)
        if qemuvd_agent is not None:
            pulumi.set(__self__, "qemuvd_agent", qemuvd_agent)
        if spice_port is not None:
            pulumi.set(__self__, "spice_port", spice_port)
        if spice_vmc is not None:
            pulumi.set(__self__, "spice_vmc", spice_vmc)
        if std_io is not None:
            pulumi.set(__self__, "std_io", std_io)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)
        if unix is not None:
            pulumi.set(__self__, "unix", unix)
        if vc is not None:
            pulumi.set(__self__, "vc", vc)

    @_builtins.property
    @pulumi.getter
    def dbus(self) -> Optional['outputs.DomainDevicesConsoleSourceDbus']:
        """
        Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        """
        return pulumi.get(self, "dbus")

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional['outputs.DomainDevicesConsoleSourceDev']:
        """
        Configures an EGD RNG backend that reads entropy from a host character device node.
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.DomainDevicesConsoleSourceFile']:
        """
        Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def nmdm(self) -> Optional['outputs.DomainDevicesConsoleSourceNmdm']:
        """
        Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        """
        return pulumi.get(self, "nmdm")

    @_builtins.property
    @pulumi.getter
    def null(self) -> Optional[_builtins.bool]:
        """
        Enables use of a null backend for the EGD RNG source, discarding all data written and providing no entropy; when this boolean is true the <Null> source is emitted, and when false or unset it is omitted.
        """
        return pulumi.get(self, "null")

    @_builtins.property
    @pulumi.getter
    def pipe(self) -> Optional['outputs.DomainDevicesConsoleSourcePipe']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        """
        return pulumi.get(self, "pipe")

    @_builtins.property
    @pulumi.getter
    def pty(self) -> Optional['outputs.DomainDevicesConsoleSourcePty']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        """
        return pulumi.get(self, "pty")

    @_builtins.property
    @pulumi.getter(name="qemuvdAgent")
    def qemuvd_agent(self) -> Optional['outputs.DomainDevicesConsoleSourceQemuvdAgent']:
        """
        Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        """
        return pulumi.get(self, "qemuvd_agent")

    @_builtins.property
    @pulumi.getter(name="spicePort")
    def spice_port(self) -> Optional['outputs.DomainDevicesConsoleSourceSpicePort']:
        """
        Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        """
        return pulumi.get(self, "spice_port")

    @_builtins.property
    @pulumi.getter(name="spiceVmc")
    def spice_vmc(self) -> Optional[_builtins.bool]:
        """
        Enables using a SPICE virtio serial management channel (spicevmc) as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "spice_vmc")

    @_builtins.property
    @pulumi.getter(name="stdIo")
    def std_io(self) -> Optional[_builtins.bool]:
        """
        Enables using the QEMU process standard I/O stream as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "std_io")

    @_builtins.property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.DomainDevicesConsoleSourceTcp']:
        """
        Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        """
        return pulumi.get(self, "tcp")

    @_builtins.property
    @pulumi.getter
    def udp(self) -> Optional['outputs.DomainDevicesConsoleSourceUdp']:
        """
        Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        """
        return pulumi.get(self, "udp")

    @_builtins.property
    @pulumi.getter
    def unix(self) -> Optional['outputs.DomainDevicesConsoleSourceUnix']:
        """
        Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        """
        return pulumi.get(self, "unix")

    @_builtins.property
    @pulumi.getter
    def vc(self) -> Optional[_builtins.bool]:
        """
        Enables use of a virtual console device as the entropy source for the EGD RNG backend when set (presence-only element; omitting it disables this source).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "vc")


@pulumi.output_type
class DomainDevicesConsoleSourceDbus(dict):
    def __init__(__self__, *,
                 channel: Optional[_builtins.str] = None):
        """
        :param _builtins.str channel: Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.str]:
        """
        Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesConsoleSourceDev(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesConsoleSourceDev. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesConsoleSourceDev.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesConsoleSourceDev.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesConsoleSourceDevSecLabel']] = None):
        """
        :param _builtins.str path: Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesConsoleSourceDevSecLabelArgs'] sec_labels: Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesConsoleSourceDevSecLabel']]:
        """
        Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesConsoleSourceDevSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesConsoleSourceDevSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesConsoleSourceDevSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesConsoleSourceDevSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesConsoleSourceFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesConsoleSourceFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesConsoleSourceFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesConsoleSourceFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 append: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesConsoleSourceFileSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str append: Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
               
               See: <https://libvirt.org/formatdomain.html#device-logfile>
        :param Sequence['DomainDevicesConsoleSourceFileSecLabelArgs'] sec_labels: Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def append(self) -> Optional[_builtins.str]:
        """
        Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.

        See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        return pulumi.get(self, "append")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesConsoleSourceFileSecLabel']]:
        """
        Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesConsoleSourceFileSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesConsoleSourceFileSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesConsoleSourceFileSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesConsoleSourceFileSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesConsoleSourceNmdm(dict):
    def __init__(__self__, *,
                 master: _builtins.str,
                 slave: _builtins.str):
        """
        :param _builtins.str master: Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        :param _builtins.str slave: Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        pulumi.set(__self__, "master", master)
        pulumi.set(__self__, "slave", slave)

    @_builtins.property
    @pulumi.getter
    def master(self) -> _builtins.str:
        """
        Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "master")

    @_builtins.property
    @pulumi.getter
    def slave(self) -> _builtins.str:
        """
        Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "slave")


@pulumi.output_type
class DomainDevicesConsoleSourcePipe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesConsoleSourcePipe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesConsoleSourcePipe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesConsoleSourcePipe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesConsoleSourcePipeSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesConsoleSourcePipeSecLabelArgs'] sec_labels: Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesConsoleSourcePipeSecLabel']]:
        """
        Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesConsoleSourcePipeSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesConsoleSourcePipeSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesConsoleSourcePipeSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesConsoleSourcePipeSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesConsoleSourcePty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesConsoleSourcePty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesConsoleSourcePty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesConsoleSourcePty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesConsoleSourcePtySecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesConsoleSourcePtySecLabelArgs'] sec_labels: Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesConsoleSourcePtySecLabel']]:
        """
        Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesConsoleSourcePtySecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesConsoleSourcePtySecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesConsoleSourcePtySecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesConsoleSourcePtySecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesConsoleSourceQemuvdAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clipBoard":
            suggest = "clip_board"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesConsoleSourceQemuvdAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesConsoleSourceQemuvdAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesConsoleSourceQemuvdAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clip_board: Optional['outputs.DomainDevicesConsoleSourceQemuvdAgentClipBoard'] = None,
                 mouse: Optional['outputs.DomainDevicesConsoleSourceQemuvdAgentMouse'] = None):
        """
        :param 'DomainDevicesConsoleSourceQemuvdAgentClipBoardArgs' clip_board: Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        :param 'DomainDevicesConsoleSourceQemuvdAgentMouseArgs' mouse: Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        if clip_board is not None:
            pulumi.set(__self__, "clip_board", clip_board)
        if mouse is not None:
            pulumi.set(__self__, "mouse", mouse)

    @_builtins.property
    @pulumi.getter(name="clipBoard")
    def clip_board(self) -> Optional['outputs.DomainDevicesConsoleSourceQemuvdAgentClipBoard']:
        """
        Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        """
        return pulumi.get(self, "clip_board")

    @_builtins.property
    @pulumi.getter
    def mouse(self) -> Optional['outputs.DomainDevicesConsoleSourceQemuvdAgentMouse']:
        """
        Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        return pulumi.get(self, "mouse")


@pulumi.output_type
class DomainDevicesConsoleSourceQemuvdAgentClipBoard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyPaste":
            suggest = "copy_paste"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesConsoleSourceQemuvdAgentClipBoard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesConsoleSourceQemuvdAgentClipBoard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesConsoleSourceQemuvdAgentClipBoard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_paste: _builtins.str):
        """
        :param _builtins.str copy_paste: Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "copy_paste", copy_paste)

    @_builtins.property
    @pulumi.getter(name="copyPaste")
    def copy_paste(self) -> _builtins.str:
        """
        Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "copy_paste")


@pulumi.output_type
class DomainDevicesConsoleSourceQemuvdAgentMouse(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DomainDevicesConsoleSourceSpicePort(dict):
    def __init__(__self__, *,
                 channel: _builtins.str):
        """
        :param _builtins.str channel: Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesConsoleSourceTcp(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesConsoleSourceTcpReconnect'] = None,
                 service: Optional[_builtins.str] = None,
                 tls: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str mode: Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesConsoleSourceTcpReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param _builtins.str service: Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str tls: Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesConsoleSourceTcpReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[_builtins.str]:
        """
        Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class DomainDevicesConsoleSourceTcpReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesConsoleSourceUdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindHost":
            suggest = "bind_host"
        elif key == "bindService":
            suggest = "bind_service"
        elif key == "connectHost":
            suggest = "connect_host"
        elif key == "connectService":
            suggest = "connect_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesConsoleSourceUdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesConsoleSourceUdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesConsoleSourceUdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bind_host: _builtins.str,
                 bind_service: _builtins.str,
                 connect_host: _builtins.str,
                 connect_service: _builtins.str):
        """
        :param _builtins.str bind_host: Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str bind_service: Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_host: Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_service: Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "bind_host", bind_host)
        pulumi.set(__self__, "bind_service", bind_service)
        pulumi.set(__self__, "connect_host", connect_host)
        pulumi.set(__self__, "connect_service", connect_service)

    @_builtins.property
    @pulumi.getter(name="bindHost")
    def bind_host(self) -> _builtins.str:
        """
        Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_host")

    @_builtins.property
    @pulumi.getter(name="bindService")
    def bind_service(self) -> _builtins.str:
        """
        Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_service")

    @_builtins.property
    @pulumi.getter(name="connectHost")
    def connect_host(self) -> _builtins.str:
        """
        Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_host")

    @_builtins.property
    @pulumi.getter(name="connectService")
    def connect_service(self) -> _builtins.str:
        """
        Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_service")


@pulumi.output_type
class DomainDevicesConsoleSourceUnix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesConsoleSourceUnix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesConsoleSourceUnix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesConsoleSourceUnix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesConsoleSourceUnixReconnect'] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesConsoleSourceUnixSecLabel']] = None):
        """
        :param _builtins.str mode: Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str path: Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesConsoleSourceUnixReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param Sequence['DomainDevicesConsoleSourceUnixSecLabelArgs'] sec_labels: Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesConsoleSourceUnixReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesConsoleSourceUnixSecLabel']]:
        """
        Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesConsoleSourceUnixReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesConsoleSourceUnixSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesConsoleSourceUnixSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesConsoleSourceUnixSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesConsoleSourceUnixSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesConsoleTarget(dict):
    def __init__(__self__, *,
                 port: Optional[_builtins.float] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.float port: Sets the guest-side console port number, starting from 0; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#guest-interface>
        :param _builtins.str type: Sets the target device type for the console within the guest (e.g. "serial", "virtio", "xen", "sclp"); the value must match a libvirt-supported console type.
               
               See: <https://libvirt.org/formatdomain.html#guest-interface>
        """
        if port is not None:
            pulumi.set(__self__, "port", port)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.float]:
        """
        Sets the guest-side console port number, starting from 0; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#guest-interface>
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Sets the target device type for the console within the guest (e.g. "serial", "virtio", "xen", "sclp"); the value must match a libvirt-supported console type.

        See: <https://libvirt.org/formatdomain.html#guest-interface>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainDevicesController(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "virtIoSerial":
            suggest = "virt_io_serial"
        elif key == "xenBus":
            suggest = "xen_bus"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesController. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesController.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesController.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 acpi: Optional['outputs.DomainDevicesControllerAcpi'] = None,
                 address: Optional['outputs.DomainDevicesControllerAddress'] = None,
                 alias: Optional['outputs.DomainDevicesControllerAlias'] = None,
                 driver: Optional['outputs.DomainDevicesControllerDriver'] = None,
                 index: Optional[_builtins.float] = None,
                 model: Optional[_builtins.str] = None,
                 nvme: Optional['outputs.DomainDevicesControllerNvme'] = None,
                 pci: Optional['outputs.DomainDevicesControllerPci'] = None,
                 usb: Optional['outputs.DomainDevicesControllerUsb'] = None,
                 virt_io_serial: Optional['outputs.DomainDevicesControllerVirtIoSerial'] = None,
                 xen_bus: Optional['outputs.DomainDevicesControllerXenBus'] = None):
        """
        :param _builtins.str type: Sets the controller type for this entry; must be one of the supported controller buses such as "pci", "usb", "virtio-serial", "scsi", "ide", "nvme", or "xenbus" depending on usage.
               
               See: <https://libvirt.org/formatdomain.html#controllers>
        :param 'DomainDevicesControllerAcpiArgs' acpi: Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        :param 'DomainDevicesControllerAddressArgs' address: Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        :param 'DomainDevicesControllerAliasArgs' alias: Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        :param 'DomainDevicesControllerDriverArgs' driver: Configures driver-specific options for the controller, such as virtio transport features and queue parameters; all child attributes are optional and user-defined within hypervisor constraints.
        :param _builtins.float index: Sets the controller index number used to distinguish multiple controllers of the same type; value is a non-negative integer and must be unique per controller type.
               
               See: <https://libvirt.org/formatdomain.html#controllers>
        :param _builtins.str model: Selects the controller model (for example "virtio-scsi", "pci-root", "pcie-root-port", "ide", "usb") as supported by the hypervisor and guest; value is a user-provided model name that must be valid for the chosen controller type.
               
               See: <https://libvirt.org/formatdomain.html#controllers>
        :param 'DomainDevicesControllerNvmeArgs' nvme: Configures an NVMe controller device for the guest, allowing you to add and customize an NVMe bus for NVMe disks.
        :param 'DomainDevicesControllerPciArgs' pci: Configures a PCI or PCIe controller, controlling how PCI buses are exposed to the guest for attaching PCI devices.
        :param 'DomainDevicesControllerUsbArgs' usb: Configures a USB controller for the guest, defining how USB ports and hubs are exposed.
        :param 'DomainDevicesControllerVirtIoSerialArgs' virt_io_serial: Configures a virtio-serial controller, which provides multiple virtio-based serial or channel ports to the guest.
        :param 'DomainDevicesControllerXenBusArgs' xen_bus: Configures a Xen bus controller, which provides bus resources for Xen paravirtualized devices.
        """
        pulumi.set(__self__, "type", type)
        if acpi is not None:
            pulumi.set(__self__, "acpi", acpi)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if nvme is not None:
            pulumi.set(__self__, "nvme", nvme)
        if pci is not None:
            pulumi.set(__self__, "pci", pci)
        if usb is not None:
            pulumi.set(__self__, "usb", usb)
        if virt_io_serial is not None:
            pulumi.set(__self__, "virt_io_serial", virt_io_serial)
        if xen_bus is not None:
            pulumi.set(__self__, "xen_bus", xen_bus)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets the controller type for this entry; must be one of the supported controller buses such as "pci", "usb", "virtio-serial", "scsi", "ide", "nvme", or "xenbus" depending on usage.

        See: <https://libvirt.org/formatdomain.html#controllers>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def acpi(self) -> Optional['outputs.DomainDevicesControllerAcpi']:
        """
        Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        """
        return pulumi.get(self, "acpi")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesControllerAddress']:
        """
        Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional['outputs.DomainDevicesControllerAlias']:
        """
        Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def driver(self) -> Optional['outputs.DomainDevicesControllerDriver']:
        """
        Configures driver-specific options for the controller, such as virtio transport features and queue parameters; all child attributes are optional and user-defined within hypervisor constraints.
        """
        return pulumi.get(self, "driver")

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the controller index number used to distinguish multiple controllers of the same type; value is a non-negative integer and must be unique per controller type.

        See: <https://libvirt.org/formatdomain.html#controllers>
        """
        return pulumi.get(self, "index")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the controller model (for example "virtio-scsi", "pci-root", "pcie-root-port", "ide", "usb") as supported by the hypervisor and guest; value is a user-provided model name that must be valid for the chosen controller type.

        See: <https://libvirt.org/formatdomain.html#controllers>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def nvme(self) -> Optional['outputs.DomainDevicesControllerNvme']:
        """
        Configures an NVMe controller device for the guest, allowing you to add and customize an NVMe bus for NVMe disks.
        """
        return pulumi.get(self, "nvme")

    @_builtins.property
    @pulumi.getter
    def pci(self) -> Optional['outputs.DomainDevicesControllerPci']:
        """
        Configures a PCI or PCIe controller, controlling how PCI buses are exposed to the guest for attaching PCI devices.
        """
        return pulumi.get(self, "pci")

    @_builtins.property
    @pulumi.getter
    def usb(self) -> Optional['outputs.DomainDevicesControllerUsb']:
        """
        Configures a USB controller for the guest, defining how USB ports and hubs are exposed.
        """
        return pulumi.get(self, "usb")

    @_builtins.property
    @pulumi.getter(name="virtIoSerial")
    def virt_io_serial(self) -> Optional['outputs.DomainDevicesControllerVirtIoSerial']:
        """
        Configures a virtio-serial controller, which provides multiple virtio-based serial or channel ports to the guest.
        """
        return pulumi.get(self, "virt_io_serial")

    @_builtins.property
    @pulumi.getter(name="xenBus")
    def xen_bus(self) -> Optional['outputs.DomainDevicesControllerXenBus']:
        """
        Configures a Xen bus controller, which provides bus resources for Xen paravirtualized devices.
        """
        return pulumi.get(self, "xen_bus")


@pulumi.output_type
class DomainDevicesControllerAcpi(dict):
    def __init__(__self__, *,
                 index: Optional[_builtins.float] = None):
        """
        :param _builtins.float index: Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        """
        if index is not None:
            pulumi.set(__self__, "index", index)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "index")


@pulumi.output_type
class DomainDevicesControllerAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesControllerAlias(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
               
               See: <https://libvirt.org/formatdomain.html#devices>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesControllerDriver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cmdPerLun":
            suggest = "cmd_per_lun"
        elif key == "ioEventFd":
            suggest = "io_event_fd"
        elif key == "ioThread":
            suggest = "io_thread"
        elif key == "ioThreads":
            suggest = "io_threads"
        elif key == "maxSectors":
            suggest = "max_sectors"
        elif key == "pagePerVq":
            suggest = "page_per_vq"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesControllerDriver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesControllerDriver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesControllerDriver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ats: Optional[_builtins.str] = None,
                 cmd_per_lun: Optional[_builtins.float] = None,
                 io_event_fd: Optional[_builtins.str] = None,
                 io_thread: Optional[_builtins.float] = None,
                 io_threads: Optional['outputs.DomainDevicesControllerDriverIoThreads'] = None,
                 iommu: Optional[_builtins.str] = None,
                 max_sectors: Optional[_builtins.float] = None,
                 packed: Optional[_builtins.str] = None,
                 page_per_vq: Optional[_builtins.str] = None,
                 queues: Optional[_builtins.float] = None):
        """
        :param _builtins.str ats: Controls whether Address Translation Service (ATS) support is enabled for a virtio controller when used with an emulated IOMMU; this is a yes/no style boolean (e.g. "on"/"off" or "yes"/"no") depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.float cmd_per_lun: Sets the maximum number of outstanding commands per LUN for SCSI/virtio-scsi controllers; value is a positive integer defining the per-LUN queue depth (for example 128, 256).
               
               See: <https://libvirt.org/formatdomain.html#controllers>
        :param _builtins.str io_event_fd: Controls whether ioeventfd is used for the controller to reduce exits between guest and host on I/O operations; value is a yes/no style boolean (for example "on"/"off").
               
               See: <https://libvirt.org/formatdomain.html#controllers>
        :param _builtins.float io_thread: Assigns the controller to use a specific IOThread by referencing an existing iothread id; value is a positive integer matching an IOThread defined in the domain.
               
               See: <https://libvirt.org/formatdomain.html#controllers>
        :param 'DomainDevicesControllerDriverIoThreadsArgs' io_threads: Defines per-IOThread configuration for the controller, allowing multiple IOThreads each with their own queue assignments; contents are user-provided and must match defined IOThread ids.
        :param _builtins.str iommu: Enables or disables use of an emulated IOMMU by the controllers virtio devices; value is a yes/no style boolean (for example "on"/"off") and is only meaningful when an IOMMU device is present.
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.float max_sectors: Sets the maximum number of 512-byte sectors that can be transferred in a single I/O request through this controller; value is a positive integer tuned for performance and host constraints.
               
               See: <https://libvirt.org/formatdomain.html#controllers>
        :param _builtins.str packed: Controls whether the virtio packed ring layout is used for queues on this controller; value is a yes/no style boolean (for example "on"/"off") and requires guest/host support.
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.str page_per_vq: Controls whether each virtqueue uses its own memory page (page-per-vq) on this controller; value is a yes/no style boolean and is primarily a tuning/compatibility option.
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.float queues: Specifies the total number of hardware queues for the controller (for example for virtio-scsi or virtio-blk controllers); value is a positive integer, often matching the number of vCPUs or IOThreads.
               
               See: <https://libvirt.org/formatdomain.html#controllers>
        """
        if ats is not None:
            pulumi.set(__self__, "ats", ats)
        if cmd_per_lun is not None:
            pulumi.set(__self__, "cmd_per_lun", cmd_per_lun)
        if io_event_fd is not None:
            pulumi.set(__self__, "io_event_fd", io_event_fd)
        if io_thread is not None:
            pulumi.set(__self__, "io_thread", io_thread)
        if io_threads is not None:
            pulumi.set(__self__, "io_threads", io_threads)
        if iommu is not None:
            pulumi.set(__self__, "iommu", iommu)
        if max_sectors is not None:
            pulumi.set(__self__, "max_sectors", max_sectors)
        if packed is not None:
            pulumi.set(__self__, "packed", packed)
        if page_per_vq is not None:
            pulumi.set(__self__, "page_per_vq", page_per_vq)
        if queues is not None:
            pulumi.set(__self__, "queues", queues)

    @_builtins.property
    @pulumi.getter
    def ats(self) -> Optional[_builtins.str]:
        """
        Controls whether Address Translation Service (ATS) support is enabled for a virtio controller when used with an emulated IOMMU; this is a yes/no style boolean (e.g. "on"/"off" or "yes"/"no") depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "ats")

    @_builtins.property
    @pulumi.getter(name="cmdPerLun")
    def cmd_per_lun(self) -> Optional[_builtins.float]:
        """
        Sets the maximum number of outstanding commands per LUN for SCSI/virtio-scsi controllers; value is a positive integer defining the per-LUN queue depth (for example 128, 256).

        See: <https://libvirt.org/formatdomain.html#controllers>
        """
        return pulumi.get(self, "cmd_per_lun")

    @_builtins.property
    @pulumi.getter(name="ioEventFd")
    def io_event_fd(self) -> Optional[_builtins.str]:
        """
        Controls whether ioeventfd is used for the controller to reduce exits between guest and host on I/O operations; value is a yes/no style boolean (for example "on"/"off").

        See: <https://libvirt.org/formatdomain.html#controllers>
        """
        return pulumi.get(self, "io_event_fd")

    @_builtins.property
    @pulumi.getter(name="ioThread")
    def io_thread(self) -> Optional[_builtins.float]:
        """
        Assigns the controller to use a specific IOThread by referencing an existing iothread id; value is a positive integer matching an IOThread defined in the domain.

        See: <https://libvirt.org/formatdomain.html#controllers>
        """
        return pulumi.get(self, "io_thread")

    @_builtins.property
    @pulumi.getter(name="ioThreads")
    def io_threads(self) -> Optional['outputs.DomainDevicesControllerDriverIoThreads']:
        """
        Defines per-IOThread configuration for the controller, allowing multiple IOThreads each with their own queue assignments; contents are user-provided and must match defined IOThread ids.
        """
        return pulumi.get(self, "io_threads")

    @_builtins.property
    @pulumi.getter
    def iommu(self) -> Optional[_builtins.str]:
        """
        Enables or disables use of an emulated IOMMU by the controllers virtio devices; value is a yes/no style boolean (for example "on"/"off") and is only meaningful when an IOMMU device is present.

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "iommu")

    @_builtins.property
    @pulumi.getter(name="maxSectors")
    def max_sectors(self) -> Optional[_builtins.float]:
        """
        Sets the maximum number of 512-byte sectors that can be transferred in a single I/O request through this controller; value is a positive integer tuned for performance and host constraints.

        See: <https://libvirt.org/formatdomain.html#controllers>
        """
        return pulumi.get(self, "max_sectors")

    @_builtins.property
    @pulumi.getter
    def packed(self) -> Optional[_builtins.str]:
        """
        Controls whether the virtio packed ring layout is used for queues on this controller; value is a yes/no style boolean (for example "on"/"off") and requires guest/host support.

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "packed")

    @_builtins.property
    @pulumi.getter(name="pagePerVq")
    def page_per_vq(self) -> Optional[_builtins.str]:
        """
        Controls whether each virtqueue uses its own memory page (page-per-vq) on this controller; value is a yes/no style boolean and is primarily a tuning/compatibility option.

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "page_per_vq")

    @_builtins.property
    @pulumi.getter
    def queues(self) -> Optional[_builtins.float]:
        """
        Specifies the total number of hardware queues for the controller (for example for virtio-scsi or virtio-blk controllers); value is a positive integer, often matching the number of vCPUs or IOThreads.

        See: <https://libvirt.org/formatdomain.html#controllers>
        """
        return pulumi.get(self, "queues")


@pulumi.output_type
class DomainDevicesControllerDriverIoThreads(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ioThreads":
            suggest = "io_threads"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesControllerDriverIoThreads. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesControllerDriverIoThreads.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesControllerDriverIoThreads.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 io_threads: Optional[Sequence['outputs.DomainDevicesControllerDriverIoThreadsIoThread']] = None):
        """
        :param Sequence['DomainDevicesControllerDriverIoThreadsIoThreadArgs'] io_threads: Describes a single IOThread used by the controller, optionally including an explicit id and associated queues.
               
               See: <https://libvirt.org/formatdomain.html#controllers>
        """
        if io_threads is not None:
            pulumi.set(__self__, "io_threads", io_threads)

    @_builtins.property
    @pulumi.getter(name="ioThreads")
    def io_threads(self) -> Optional[Sequence['outputs.DomainDevicesControllerDriverIoThreadsIoThread']]:
        """
        Describes a single IOThread used by the controller, optionally including an explicit id and associated queues.

        See: <https://libvirt.org/formatdomain.html#controllers>
        """
        return pulumi.get(self, "io_threads")


@pulumi.output_type
class DomainDevicesControllerDriverIoThreadsIoThread(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.float] = None,
                 queues: Optional[Sequence['outputs.DomainDevicesControllerDriverIoThreadsIoThreadQueue']] = None):
        """
        :param _builtins.float id: Identifies the IOThread instance used by this controller entry; when omitted libvirt computes/assigns it, and when set it must match a valid IOThread id for the domain.
               
               See: <https://libvirt.org/formatdomain.html#controllers>
        :param Sequence['DomainDevicesControllerDriverIoThreadsIoThreadQueueArgs'] queues: Defines one or more queues handled by this IOThread for the controller, allowing fine-grained mapping of queue ids to threads.
               
               See: <https://libvirt.org/formatdomain.html#controllers>
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if queues is not None:
            pulumi.set(__self__, "queues", queues)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.float]:
        """
        Identifies the IOThread instance used by this controller entry; when omitted libvirt computes/assigns it, and when set it must match a valid IOThread id for the domain.

        See: <https://libvirt.org/formatdomain.html#controllers>
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def queues(self) -> Optional[Sequence['outputs.DomainDevicesControllerDriverIoThreadsIoThreadQueue']]:
        """
        Defines one or more queues handled by this IOThread for the controller, allowing fine-grained mapping of queue ids to threads.

        See: <https://libvirt.org/formatdomain.html#controllers>
        """
        return pulumi.get(self, "queues")


@pulumi.output_type
class DomainDevicesControllerDriverIoThreadsIoThreadQueue(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.float] = None):
        """
        :param _builtins.float id: Identifies a specific queue assigned to this IOThread; when omitted libvirt computes/assigns the id, and when set it must reference a valid queue index for the controller.
               
               See: <https://libvirt.org/formatdomain.html#controllers>
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.float]:
        """
        Identifies a specific queue assigned to this IOThread; when omitted libvirt computes/assigns the id, and when set it must reference a valid queue index for the controller.

        See: <https://libvirt.org/formatdomain.html#controllers>
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class DomainDevicesControllerNvme(dict):
    def __init__(__self__, *,
                 serial: Optional[_builtins.str] = None):
        """
        :param _builtins.str serial: Sets the NVMe controller serial identifier exposed to the guest; the value is user-provided and typically an ASCII string (for example, "nvme0-ctrl1").
               
               See: <https://libvirt.org/formatdomain.html#controllers>
        """
        if serial is not None:
            pulumi.set(__self__, "serial", serial)

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[_builtins.str]:
        """
        Sets the NVMe controller serial identifier exposed to the guest; the value is user-provided and typically an ASCII string (for example, "nvme0-ctrl1").

        See: <https://libvirt.org/formatdomain.html#controllers>
        """
        return pulumi.get(self, "serial")


@pulumi.output_type
class DomainDevicesControllerPci(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hole64Unit":
            suggest = "hole64_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesControllerPci. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesControllerPci.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesControllerPci.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hole64: Optional[_builtins.float] = None,
                 hole64_unit: Optional[_builtins.str] = None,
                 model: Optional['outputs.DomainDevicesControllerPciModel'] = None,
                 target: Optional['outputs.DomainDevicesControllerPciTarget'] = None):
        """
        :param _builtins.float hole64: Sets the size of the 64bit PCI memory hole available to guest PCI devices; value is user-provided and interpreted together with hole64_unit.
               
               See: <https://libvirt.org/formatdomain.html#controllers>
        :param _builtins.str hole64_unit: Specifies the unit for the pci.hole64 size (for example, "KiB", "MiB", "GiB"), paired with the hole64 value to define the 64bit PCI memory hole size.
               
               See: <https://libvirt.org/formatdomain.html#controllers>
        :param 'DomainDevicesControllerPciModelArgs' model: Configures the PCI/PCIe controller model, determining the controller implementation used by the guest (for example, "pci-root" or "pcie-root-port").
        :param 'DomainDevicesControllerPciTargetArgs' target: Configures additional PCI controller target parameters such as bus or port indices that control how the controller is placed in the guest topology; values are user-provided.
        """
        if hole64 is not None:
            pulumi.set(__self__, "hole64", hole64)
        if hole64_unit is not None:
            pulumi.set(__self__, "hole64_unit", hole64_unit)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def hole64(self) -> Optional[_builtins.float]:
        """
        Sets the size of the 64bit PCI memory hole available to guest PCI devices; value is user-provided and interpreted together with hole64_unit.

        See: <https://libvirt.org/formatdomain.html#controllers>
        """
        return pulumi.get(self, "hole64")

    @_builtins.property
    @pulumi.getter(name="hole64Unit")
    def hole64_unit(self) -> Optional[_builtins.str]:
        """
        Specifies the unit for the pci.hole64 size (for example, "KiB", "MiB", "GiB"), paired with the hole64 value to define the 64bit PCI memory hole size.

        See: <https://libvirt.org/formatdomain.html#controllers>
        """
        return pulumi.get(self, "hole64_unit")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional['outputs.DomainDevicesControllerPciModel']:
        """
        Configures the PCI/PCIe controller model, determining the controller implementation used by the guest (for example, "pci-root" or "pcie-root-port").
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional['outputs.DomainDevicesControllerPciTarget']:
        """
        Configures additional PCI controller target parameters such as bus or port indices that control how the controller is placed in the guest topology; values are user-provided.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class DomainDevicesControllerPciModel(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the model name of the PCI controller; must be one of the controller models supported by the chosen machine type (for example, "pci-root", "pcie-root-port", "pci-bridge").
               
               See: <https://libvirt.org/formatdomain.html#controllers>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the model name of the PCI controller; must be one of the controller models supported by the chosen machine type (for example, "pci-root", "pcie-root-port", "pci-bridge").

        See: <https://libvirt.org/formatdomain.html#controllers>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesControllerPciTarget(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesControllerUsb(dict):
    def __init__(__self__, *,
                 master: Optional['outputs.DomainDevicesControllerUsbMaster'] = None,
                 port: Optional[_builtins.float] = None):
        """
        :param 'DomainDevicesControllerUsbMasterArgs' master: Configures the master USB controller relationship, defining how this USB controller is chained or grouped with others.
        :param _builtins.float port: Sets the total number of USB ports exposed by this controller; value is a user-provided positive integer.
               
               See: <https://libvirt.org/formatdomain.html#controllers>
        """
        if master is not None:
            pulumi.set(__self__, "master", master)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def master(self) -> Optional['outputs.DomainDevicesControllerUsbMaster']:
        """
        Configures the master USB controller relationship, defining how this USB controller is chained or grouped with others.
        """
        return pulumi.get(self, "master")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.float]:
        """
        Sets the total number of USB ports exposed by this controller; value is a user-provided positive integer.

        See: <https://libvirt.org/formatdomain.html#controllers>
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DomainDevicesControllerUsbMaster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startPort":
            suggest = "start_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesControllerUsbMaster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesControllerUsbMaster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesControllerUsbMaster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 start_port: _builtins.float):
        """
        :param _builtins.float start_port: Sets the starting port number on the master USB controller that this controller manages; value is a required non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#controllers>
        """
        pulumi.set(__self__, "start_port", start_port)

    @_builtins.property
    @pulumi.getter(name="startPort")
    def start_port(self) -> _builtins.float:
        """
        Sets the starting port number on the master USB controller that this controller manages; value is a required non-negative integer.

        See: <https://libvirt.org/formatdomain.html#controllers>
        """
        return pulumi.get(self, "start_port")


@pulumi.output_type
class DomainDevicesControllerVirtIoSerial(dict):
    def __init__(__self__, *,
                 ports: Optional[_builtins.float] = None,
                 vectors: Optional[_builtins.float] = None):
        """
        :param _builtins.float ports: Sets the maximum number of virtio-serial ports that this controller can provide; value is a user-provided positive integer.
               
               See: <https://libvirt.org/formatdomain.html#controllers>
        :param _builtins.float vectors: Sets the number of MSI/MSIX vectors used by the virtio-serial controller for interrupts; value is a user-provided positive integer.
               
               See: <https://libvirt.org/formatdomain.html#controllers>
        """
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if vectors is not None:
            pulumi.set(__self__, "vectors", vectors)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[_builtins.float]:
        """
        Sets the maximum number of virtio-serial ports that this controller can provide; value is a user-provided positive integer.

        See: <https://libvirt.org/formatdomain.html#controllers>
        """
        return pulumi.get(self, "ports")

    @_builtins.property
    @pulumi.getter
    def vectors(self) -> Optional[_builtins.float]:
        """
        Sets the number of MSI/MSIX vectors used by the virtio-serial controller for interrupts; value is a user-provided positive integer.

        See: <https://libvirt.org/formatdomain.html#controllers>
        """
        return pulumi.get(self, "vectors")


@pulumi.output_type
class DomainDevicesControllerXenBus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxEventChannels":
            suggest = "max_event_channels"
        elif key == "maxGrantFrames":
            suggest = "max_grant_frames"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesControllerXenBus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesControllerXenBus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesControllerXenBus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_event_channels: Optional[_builtins.float] = None,
                 max_grant_frames: Optional[_builtins.float] = None):
        """
        :param _builtins.float max_event_channels: Sets the maximum number of Xen event channels available via this Xen bus controller; value is a user-provided positive integer.
               
               See: <https://libvirt.org/formatdomain.html#controllers>
        :param _builtins.float max_grant_frames: Sets the maximum number of grant frames for shared memory operations on this Xen bus controller; value is a user-provided positive integer.
               
               See: <https://libvirt.org/formatdomain.html#controllers>
        """
        if max_event_channels is not None:
            pulumi.set(__self__, "max_event_channels", max_event_channels)
        if max_grant_frames is not None:
            pulumi.set(__self__, "max_grant_frames", max_grant_frames)

    @_builtins.property
    @pulumi.getter(name="maxEventChannels")
    def max_event_channels(self) -> Optional[_builtins.float]:
        """
        Sets the maximum number of Xen event channels available via this Xen bus controller; value is a user-provided positive integer.

        See: <https://libvirt.org/formatdomain.html#controllers>
        """
        return pulumi.get(self, "max_event_channels")

    @_builtins.property
    @pulumi.getter(name="maxGrantFrames")
    def max_grant_frames(self) -> Optional[_builtins.float]:
        """
        Sets the maximum number of grant frames for shared memory operations on this Xen bus controller; value is a user-provided positive integer.

        See: <https://libvirt.org/formatdomain.html#controllers>
        """
        return pulumi.get(self, "max_grant_frames")


@pulumi.output_type
class DomainDevicesCrypto(dict):
    def __init__(__self__, *,
                 address: Optional['outputs.DomainDevicesCryptoAddress'] = None,
                 alias: Optional['outputs.DomainDevicesCryptoAlias'] = None,
                 backend: Optional['outputs.DomainDevicesCryptoBackend'] = None,
                 model: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param 'DomainDevicesCryptoAddressArgs' address: Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        :param 'DomainDevicesCryptoAliasArgs' alias: Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        :param 'DomainDevicesCryptoBackendArgs' backend: Configures the backend implementation details for the crypto device, such as whether it is built-in or uses the LKCF kernel framework.
        :param _builtins.str model: Selects the crypto device model; for recent libvirt/QEMU this must be a virtio variant such as "virtio", "virtio-transitional", or "virtio-non-transitional".
               
               See: <https://libvirt.org/formatdomain.html#crypto>
        :param _builtins.str type: Selects the crypto device type/implementation, which currently supports "qemu"; the value is user-provided but must be supported by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#crypto>
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if backend is not None:
            pulumi.set(__self__, "backend", backend)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesCryptoAddress']:
        """
        Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional['outputs.DomainDevicesCryptoAlias']:
        """
        Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def backend(self) -> Optional['outputs.DomainDevicesCryptoBackend']:
        """
        Configures the backend implementation details for the crypto device, such as whether it is built-in or uses the LKCF kernel framework.
        """
        return pulumi.get(self, "backend")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the crypto device model; for recent libvirt/QEMU this must be a virtio variant such as "virtio", "virtio-transitional", or "virtio-non-transitional".

        See: <https://libvirt.org/formatdomain.html#crypto>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Selects the crypto device type/implementation, which currently supports "qemu"; the value is user-provided but must be supported by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#crypto>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainDevicesCryptoAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesCryptoAlias(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
               
               See: <https://libvirt.org/formatdomain.html#devices>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesCryptoBackend(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "builtIn":
            suggest = "built_in"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesCryptoBackend. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesCryptoBackend.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesCryptoBackend.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 built_in: Optional[_builtins.bool] = None,
                 lkcf: Optional[_builtins.bool] = None,
                 queues: Optional[_builtins.float] = None):
        """
        :param _builtins.bool built_in: Enables the built-in backend for the crypto device when set; this is a presence-only flag, so omitting or setting it to false leaves the element out.
               
               See: <https://libvirt.org/formatdomain.html#crypto>
        :param _builtins.bool lkcf: Enables the LKCF-based backend for the crypto device when set; this is a presence-only flag, so omitting or setting it to false leaves the element out.
               
               See: <https://libvirt.org/formatdomain.html#crypto>
        :param _builtins.float queues: Sets the number of queues used by the crypto backend; the value is a user-provided non-negative integer tuned for performance.
               
               See: <https://libvirt.org/formatdomain.html#crypto>
        """
        if built_in is not None:
            pulumi.set(__self__, "built_in", built_in)
        if lkcf is not None:
            pulumi.set(__self__, "lkcf", lkcf)
        if queues is not None:
            pulumi.set(__self__, "queues", queues)

    @_builtins.property
    @pulumi.getter(name="builtIn")
    def built_in(self) -> Optional[_builtins.bool]:
        """
        Enables the built-in backend for the crypto device when set; this is a presence-only flag, so omitting or setting it to false leaves the element out.

        See: <https://libvirt.org/formatdomain.html#crypto>
        """
        return pulumi.get(self, "built_in")

    @_builtins.property
    @pulumi.getter
    def lkcf(self) -> Optional[_builtins.bool]:
        """
        Enables the LKCF-based backend for the crypto device when set; this is a presence-only flag, so omitting or setting it to false leaves the element out.

        See: <https://libvirt.org/formatdomain.html#crypto>
        """
        return pulumi.get(self, "lkcf")

    @_builtins.property
    @pulumi.getter
    def queues(self) -> Optional[_builtins.float]:
        """
        Sets the number of queues used by the crypto backend; the value is a user-provided non-negative integer tuned for performance.

        See: <https://libvirt.org/formatdomain.html#crypto>
        """
        return pulumi.get(self, "queues")


@pulumi.output_type
class DomainDevicesDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendDomain":
            suggest = "backend_domain"
        elif key == "backingStore":
            suggest = "backing_store"
        elif key == "blockIo":
            suggest = "block_io"
        elif key == "ioTune":
            suggest = "io_tune"
        elif key == "rawIo":
            suggest = "raw_io"
        elif key == "readOnly":
            suggest = "read_only"
        elif key == "throttleFilters":
            suggest = "throttle_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acpi: Optional['outputs.DomainDevicesDiskAcpi'] = None,
                 address: Optional['outputs.DomainDevicesDiskAddress'] = None,
                 alias: Optional['outputs.DomainDevicesDiskAlias'] = None,
                 auth: Optional['outputs.DomainDevicesDiskAuth'] = None,
                 backend_domain: Optional['outputs.DomainDevicesDiskBackendDomain'] = None,
                 backing_store: Optional['outputs.DomainDevicesDiskBackingStore'] = None,
                 block_io: Optional['outputs.DomainDevicesDiskBlockIo'] = None,
                 boot: Optional['outputs.DomainDevicesDiskBoot'] = None,
                 device: Optional[_builtins.str] = None,
                 driver: Optional['outputs.DomainDevicesDiskDriver'] = None,
                 encryption: Optional['outputs.DomainDevicesDiskEncryption'] = None,
                 geometry: Optional['outputs.DomainDevicesDiskGeometry'] = None,
                 io_tune: Optional['outputs.DomainDevicesDiskIoTune'] = None,
                 mirror: Optional['outputs.DomainDevicesDiskMirror'] = None,
                 model: Optional[_builtins.str] = None,
                 product: Optional[_builtins.str] = None,
                 raw_io: Optional[_builtins.str] = None,
                 read_only: Optional[_builtins.bool] = None,
                 serial: Optional[_builtins.str] = None,
                 sgio: Optional[_builtins.str] = None,
                 shareable: Optional[_builtins.bool] = None,
                 snapshot: Optional[_builtins.str] = None,
                 source: Optional['outputs.DomainDevicesDiskSource'] = None,
                 target: Optional['outputs.DomainDevicesDiskTarget'] = None,
                 throttle_filters: Optional['outputs.DomainDevicesDiskThrottleFilters'] = None,
                 transient: Optional['outputs.DomainDevicesDiskTransient'] = None,
                 vendor: Optional[_builtins.str] = None,
                 wwn: Optional[_builtins.str] = None):
        """
        :param 'DomainDevicesDiskAcpiArgs' acpi: Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        :param 'DomainDevicesDiskAddressArgs' address: Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        :param 'DomainDevicesDiskAliasArgs' alias: Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        :param 'DomainDevicesDiskAuthArgs' auth: Configures CHAP authentication parameters for the iSCSI source backing an assigned SCSI host device; include this block only when the target requires authentication.
        :param 'DomainDevicesDiskBackendDomainArgs' backend_domain: Attaches the interfaces network backend to a separate driver/backend domain instead of the main host, enabling driver-domain networking setups.
        :param 'DomainDevicesDiskBackingStoreArgs' backing_store: Defines the backing store chain for the mirrored disk image, describing one layer of the underlying image stack used by the mirror target.
        :param 'DomainDevicesDiskBlockIoArgs' block_io: Configures per-disk block I/O characteristics such as logical/physical sector sizes and discard granularity as presented to the guest.
        :param 'DomainDevicesDiskBootArgs' boot: Enables boot-order control for this redirected device, allowing it to participate in the device boot sequence.
        :param _builtins.str device: Selects the high-level device type for this disk, typically "disk", "cdrom", "floppy", or "lun"; the value is user-provided and must be a valid libvirt disk device type.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainDevicesDiskDriverArgs' driver: Configures driver-specific options for this disk, such as the hypervisor driver name, cache mode, discard behavior, or I/O bus features.
        :param 'DomainDevicesDiskEncryptionArgs' encryption: Enables disk image encryption configuration for this disk and groups attributes defining the encryption engine, format, and secrets.
        :param 'DomainDevicesDiskGeometryArgs' geometry: Configures the legacy CHS (cylinders/heads/sectors) geometry that the guest sees for this disk, typically for compatibility with older guests or tools.
        :param 'DomainDevicesDiskIoTuneArgs' io_tune: Configures per-disk block I/O throttling parameters (bandwidth and IOPS limits, and optional burst limits) for this disk device; omit this block to leave disk I/O unthrottled.
        :param 'DomainDevicesDiskMirrorArgs' mirror: Configures an online block device mirror for the disk, defining the target image and its properties used during block copy or active commit operations.
        :param _builtins.str model: Specifies the emulated disk device model (e.g. "virtio", "scsi", "ide") or a driver-specific model string passed to the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str product: Sets an optional user-provided product identifier string for the disk device, exposed to the guest similar to a SCSI product field.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str raw_io: Enables or disables raw I/O access for the disk device when supported by the driver; typically a "yes"/"no" style flag, value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.bool read_only: Controls whether the disk is exposed as read-only to the guest; when set to true the <readonly> element is emitted, and when false or unset the disk is writable.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str serial: Sets the user-provided serial number reported to the guest for this disk device (for example, to match a physical disk's serial).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str sgio: Sets the SCSI generic I/O behavior for the disk using a user-provided value accepted by libvirt (e.g. modes controlling filtered vs unfiltered SG_IO).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.bool shareable: Controls whether the disk is marked as shareable between multiple guests; when set to true the <shareable> element is emitted, otherwise it is omitted.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str snapshot: Sets the disk snapshot behavior policy with a user-provided string value supported by libvirt (for example, controlling how the disk participates in domain snapshots).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainDevicesDiskSourceArgs' source: Defines the data source for the mirror backing store, such as a block device or file path.
        :param 'DomainDevicesDiskTargetArgs' target: Configures the guest-visible block device target for this disk, including bus type, device name, and related attributes.
        :param 'DomainDevicesDiskThrottleFiltersArgs' throttle_filters: Groups one or more disk throttle filter references used to apply shared throttling policies via throttle groups.
        :param 'DomainDevicesDiskTransientArgs' transient: Marks this disk as transient, meaning it is not persisted in domain configuration and exists only for the lifetime of the running guest.
        :param _builtins.str vendor: Sets the vendor identification string reported by this disk to the guest; value is user-provided (commonly up to 8 ASCII characters).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str wwn: Sets the world wide name (WWN) reported for this disk, typically as a 16-hex-digit string (for example "500123456789abcd").
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if acpi is not None:
            pulumi.set(__self__, "acpi", acpi)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if backend_domain is not None:
            pulumi.set(__self__, "backend_domain", backend_domain)
        if backing_store is not None:
            pulumi.set(__self__, "backing_store", backing_store)
        if block_io is not None:
            pulumi.set(__self__, "block_io", block_io)
        if boot is not None:
            pulumi.set(__self__, "boot", boot)
        if device is not None:
            pulumi.set(__self__, "device", device)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if encryption is not None:
            pulumi.set(__self__, "encryption", encryption)
        if geometry is not None:
            pulumi.set(__self__, "geometry", geometry)
        if io_tune is not None:
            pulumi.set(__self__, "io_tune", io_tune)
        if mirror is not None:
            pulumi.set(__self__, "mirror", mirror)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if product is not None:
            pulumi.set(__self__, "product", product)
        if raw_io is not None:
            pulumi.set(__self__, "raw_io", raw_io)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)
        if sgio is not None:
            pulumi.set(__self__, "sgio", sgio)
        if shareable is not None:
            pulumi.set(__self__, "shareable", shareable)
        if snapshot is not None:
            pulumi.set(__self__, "snapshot", snapshot)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if throttle_filters is not None:
            pulumi.set(__self__, "throttle_filters", throttle_filters)
        if transient is not None:
            pulumi.set(__self__, "transient", transient)
        if vendor is not None:
            pulumi.set(__self__, "vendor", vendor)
        if wwn is not None:
            pulumi.set(__self__, "wwn", wwn)

    @_builtins.property
    @pulumi.getter
    def acpi(self) -> Optional['outputs.DomainDevicesDiskAcpi']:
        """
        Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        """
        return pulumi.get(self, "acpi")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesDiskAddress']:
        """
        Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional['outputs.DomainDevicesDiskAlias']:
        """
        Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional['outputs.DomainDevicesDiskAuth']:
        """
        Configures CHAP authentication parameters for the iSCSI source backing an assigned SCSI host device; include this block only when the target requires authentication.
        """
        return pulumi.get(self, "auth")

    @_builtins.property
    @pulumi.getter(name="backendDomain")
    def backend_domain(self) -> Optional['outputs.DomainDevicesDiskBackendDomain']:
        """
        Attaches the interfaces network backend to a separate driver/backend domain instead of the main host, enabling driver-domain networking setups.
        """
        return pulumi.get(self, "backend_domain")

    @_builtins.property
    @pulumi.getter(name="backingStore")
    def backing_store(self) -> Optional['outputs.DomainDevicesDiskBackingStore']:
        """
        Defines the backing store chain for the mirrored disk image, describing one layer of the underlying image stack used by the mirror target.
        """
        return pulumi.get(self, "backing_store")

    @_builtins.property
    @pulumi.getter(name="blockIo")
    def block_io(self) -> Optional['outputs.DomainDevicesDiskBlockIo']:
        """
        Configures per-disk block I/O characteristics such as logical/physical sector sizes and discard granularity as presented to the guest.
        """
        return pulumi.get(self, "block_io")

    @_builtins.property
    @pulumi.getter
    def boot(self) -> Optional['outputs.DomainDevicesDiskBoot']:
        """
        Enables boot-order control for this redirected device, allowing it to participate in the device boot sequence.
        """
        return pulumi.get(self, "boot")

    @_builtins.property
    @pulumi.getter
    def device(self) -> Optional[_builtins.str]:
        """
        Selects the high-level device type for this disk, typically "disk", "cdrom", "floppy", or "lun"; the value is user-provided and must be a valid libvirt disk device type.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "device")

    @_builtins.property
    @pulumi.getter
    def driver(self) -> Optional['outputs.DomainDevicesDiskDriver']:
        """
        Configures driver-specific options for this disk, such as the hypervisor driver name, cache mode, discard behavior, or I/O bus features.
        """
        return pulumi.get(self, "driver")

    @_builtins.property
    @pulumi.getter
    def encryption(self) -> Optional['outputs.DomainDevicesDiskEncryption']:
        """
        Enables disk image encryption configuration for this disk and groups attributes defining the encryption engine, format, and secrets.
        """
        return pulumi.get(self, "encryption")

    @_builtins.property
    @pulumi.getter
    def geometry(self) -> Optional['outputs.DomainDevicesDiskGeometry']:
        """
        Configures the legacy CHS (cylinders/heads/sectors) geometry that the guest sees for this disk, typically for compatibility with older guests or tools.
        """
        return pulumi.get(self, "geometry")

    @_builtins.property
    @pulumi.getter(name="ioTune")
    def io_tune(self) -> Optional['outputs.DomainDevicesDiskIoTune']:
        """
        Configures per-disk block I/O throttling parameters (bandwidth and IOPS limits, and optional burst limits) for this disk device; omit this block to leave disk I/O unthrottled.
        """
        return pulumi.get(self, "io_tune")

    @_builtins.property
    @pulumi.getter
    def mirror(self) -> Optional['outputs.DomainDevicesDiskMirror']:
        """
        Configures an online block device mirror for the disk, defining the target image and its properties used during block copy or active commit operations.
        """
        return pulumi.get(self, "mirror")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Specifies the emulated disk device model (e.g. "virtio", "scsi", "ide") or a driver-specific model string passed to the hypervisor.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def product(self) -> Optional[_builtins.str]:
        """
        Sets an optional user-provided product identifier string for the disk device, exposed to the guest similar to a SCSI product field.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "product")

    @_builtins.property
    @pulumi.getter(name="rawIo")
    def raw_io(self) -> Optional[_builtins.str]:
        """
        Enables or disables raw I/O access for the disk device when supported by the driver; typically a "yes"/"no" style flag, value is user-provided.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "raw_io")

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[_builtins.bool]:
        """
        Controls whether the disk is exposed as read-only to the guest; when set to true the <readonly> element is emitted, and when false or unset the disk is writable.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "read_only")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[_builtins.str]:
        """
        Sets the user-provided serial number reported to the guest for this disk device (for example, to match a physical disk's serial).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter
    def sgio(self) -> Optional[_builtins.str]:
        """
        Sets the SCSI generic I/O behavior for the disk using a user-provided value accepted by libvirt (e.g. modes controlling filtered vs unfiltered SG_IO).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "sgio")

    @_builtins.property
    @pulumi.getter
    def shareable(self) -> Optional[_builtins.bool]:
        """
        Controls whether the disk is marked as shareable between multiple guests; when set to true the <shareable> element is emitted, otherwise it is omitted.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "shareable")

    @_builtins.property
    @pulumi.getter
    def snapshot(self) -> Optional[_builtins.str]:
        """
        Sets the disk snapshot behavior policy with a user-provided string value supported by libvirt (for example, controlling how the disk participates in domain snapshots).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "snapshot")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainDevicesDiskSource']:
        """
        Defines the data source for the mirror backing store, such as a block device or file path.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional['outputs.DomainDevicesDiskTarget']:
        """
        Configures the guest-visible block device target for this disk, including bus type, device name, and related attributes.
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter(name="throttleFilters")
    def throttle_filters(self) -> Optional['outputs.DomainDevicesDiskThrottleFilters']:
        """
        Groups one or more disk throttle filter references used to apply shared throttling policies via throttle groups.
        """
        return pulumi.get(self, "throttle_filters")

    @_builtins.property
    @pulumi.getter
    def transient(self) -> Optional['outputs.DomainDevicesDiskTransient']:
        """
        Marks this disk as transient, meaning it is not persisted in domain configuration and exists only for the lifetime of the running guest.
        """
        return pulumi.get(self, "transient")

    @_builtins.property
    @pulumi.getter
    def vendor(self) -> Optional[_builtins.str]:
        """
        Sets the vendor identification string reported by this disk to the guest; value is user-provided (commonly up to 8 ASCII characters).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "vendor")

    @_builtins.property
    @pulumi.getter
    def wwn(self) -> Optional[_builtins.str]:
        """
        Sets the world wide name (WWN) reported for this disk, typically as a 16-hex-digit string (for example "500123456789abcd").

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "wwn")


@pulumi.output_type
class DomainDevicesDiskAcpi(dict):
    def __init__(__self__, *,
                 index: Optional[_builtins.float] = None):
        """
        :param _builtins.float index: Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        """
        if index is not None:
            pulumi.set(__self__, "index", index)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "index")


@pulumi.output_type
class DomainDevicesDiskAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesDiskAlias(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
               
               See: <https://libvirt.org/formatdomain.html#devices>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesDiskAuth(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.DomainDevicesDiskAuthSecret'] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param 'DomainDevicesDiskAuthSecretArgs' secret: Configures the libvirt secret object used to hold the iSCSI authentication password for this hostdev; this references an existing libvirt secret, not the clear-text secret.
        :param _builtins.str username: Sets the CHAP username used when authenticating to the iSCSI target for this SCSI hostdev; the value is user-provided (for example, "chapuser1").
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.DomainDevicesDiskAuthSecret']:
        """
        Configures the libvirt secret object used to hold the iSCSI authentication password for this hostdev; this references an existing libvirt secret, not the clear-text secret.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        Sets the CHAP username used when authenticating to the iSCSI target for this SCSI hostdev; the value is user-provided (for example, "chapuser1").

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class DomainDevicesDiskAuthSecret(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 usage: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str usage: Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str uuid: Exposes the UUID of the libvirt secret used for iSCSI authentication; this is computed from the referenced secret rather than configured directly.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def usage(self) -> Optional[_builtins.str]:
        """
        Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "usage")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        Exposes the UUID of the libvirt secret used for iSCSI authentication; this is computed from the referenced secret rather than configured directly.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class DomainDevicesDiskBackendDomain(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the name of the backend (driver) domain that will host the network backend for this interface; value must match an existing domain name.
               
               See: <https://libvirt.org/formatdomain.html#setting-up-a-network-backend-in-a-driver-domain>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the name of the backend (driver) domain that will host the network backend for this interface; value must match an existing domain name.

        See: <https://libvirt.org/formatdomain.html#setting-up-a-network-backend-in-a-driver-domain>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesDiskBackingStore(dict):
    def __init__(__self__, *,
                 format: Optional['outputs.DomainDevicesDiskBackingStoreFormat'] = None,
                 index: Optional[_builtins.float] = None,
                 source: Optional['outputs.DomainDevicesDiskBackingStoreSource'] = None):
        """
        :param 'DomainDevicesDiskBackingStoreFormatArgs' format: Configures the on-disk format settings for the mirrored backing stores data store, including format type and optional metadata cache tuning.
        :param _builtins.float index: Sets the index of this backing store within the mirrors backing chain, as an integer used to order multiple backingStore entries.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainDevicesDiskBackingStoreSourceArgs' source: Defines the data source for the mirror backing store, such as a block device or file path.
        """
        if format is not None:
            pulumi.set(__self__, "format", format)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional['outputs.DomainDevicesDiskBackingStoreFormat']:
        """
        Configures the on-disk format settings for the mirrored backing stores data store, including format type and optional metadata cache tuning.
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the index of this backing store within the mirrors backing chain, as an integer used to order multiple backingStore entries.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "index")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSource']:
        """
        Defines the data source for the mirror backing store, such as a block device or file path.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class DomainDevicesDiskBackingStoreFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataCache":
            suggest = "metadata_cache"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 metadata_cache: Optional['outputs.DomainDevicesDiskBackingStoreFormatMetadataCache'] = None):
        """
        :param _builtins.str type: Sets the data store format type for the mirrored backing store (for example, "qcow2" or "raw"); the value is user-provided and must be a valid libvirt disk format name.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainDevicesDiskBackingStoreFormatMetadataCacheArgs' metadata_cache: Configures metadata cache behavior for the mirrored backing stores data store format (for example, limiting the size of cached metadata).
        """
        pulumi.set(__self__, "type", type)
        if metadata_cache is not None:
            pulumi.set(__self__, "metadata_cache", metadata_cache)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets the data store format type for the mirrored backing store (for example, "qcow2" or "raw"); the value is user-provided and must be a valid libvirt disk format name.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="metadataCache")
    def metadata_cache(self) -> Optional['outputs.DomainDevicesDiskBackingStoreFormatMetadataCache']:
        """
        Configures metadata cache behavior for the mirrored backing stores data store format (for example, limiting the size of cached metadata).
        """
        return pulumi.get(self, "metadata_cache")


@pulumi.output_type
class DomainDevicesDiskBackingStoreFormatMetadataCache(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSize":
            suggest = "max_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreFormatMetadataCache. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreFormatMetadataCache.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreFormatMetadataCache.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_size: Optional['outputs.DomainDevicesDiskBackingStoreFormatMetadataCacheMaxSize'] = None):
        """
        :param 'DomainDevicesDiskBackingStoreFormatMetadataCacheMaxSizeArgs' max_size: Sets the maximum size of the metadata cache used by the data store format; value and unit together define the limit (for example, 64 MiB).
        """
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional['outputs.DomainDevicesDiskBackingStoreFormatMetadataCacheMaxSize']:
        """
        Sets the maximum size of the metadata cache used by the data store format; value and unit together define the limit (for example, 64 MiB).
        """
        return pulumi.get(self, "max_size")


@pulumi.output_type
class DomainDevicesDiskBackingStoreFormatMetadataCacheMaxSize(dict):
    def __init__(__self__, *,
                 value: _builtins.float,
                 unit: Optional[_builtins.str] = None):
        """
        :param _builtins.float value: Sets the numeric value for the metadata cache maximum size in the specified unit; this must be a positive integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str unit: Sets the unit used for the metadata cache maximum size; valid units follow libvirt size units such as "B", "KiB", "MiB", "GiB" and are user-chosen.
               
               See: <https://libvirt.org/formatdomain.html#memory-allocation>
        """
        pulumi.set(__self__, "value", value)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.float:
        """
        Sets the numeric value for the metadata cache maximum size in the specified unit; this must be a positive integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        """
        Sets the unit used for the metadata cache maximum size; valid units follow libvirt size units such as "B", "KiB", "MiB", "GiB" and are user-chosen.

        See: <https://libvirt.org/formatdomain.html#memory-allocation>
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataStore":
            suggest = "data_store"
        elif key == "startupPolicy":
            suggest = "startup_policy"
        elif key == "vhostUser":
            suggest = "vhost_user"
        elif key == "vhostVdpa":
            suggest = "vhost_vdpa"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block: Optional['outputs.DomainDevicesDiskBackingStoreSourceBlock'] = None,
                 cookies: Optional['outputs.DomainDevicesDiskBackingStoreSourceCookies'] = None,
                 data_store: Optional['outputs.DomainDevicesDiskBackingStoreSourceDataStore'] = None,
                 dir: Optional['outputs.DomainDevicesDiskBackingStoreSourceDir'] = None,
                 encryption: Optional['outputs.DomainDevicesDiskBackingStoreSourceEncryption'] = None,
                 file: Optional['outputs.DomainDevicesDiskBackingStoreSourceFile'] = None,
                 index: Optional[_builtins.float] = None,
                 network: Optional['outputs.DomainDevicesDiskBackingStoreSourceNetwork'] = None,
                 nvme: Optional['outputs.DomainDevicesDiskBackingStoreSourceNvme'] = None,
                 readahead: Optional['outputs.DomainDevicesDiskBackingStoreSourceReadahead'] = None,
                 reservations: Optional['outputs.DomainDevicesDiskBackingStoreSourceReservations'] = None,
                 slices: Optional['outputs.DomainDevicesDiskBackingStoreSourceSlices'] = None,
                 ssl: Optional['outputs.DomainDevicesDiskBackingStoreSourceSsl'] = None,
                 startup_policy: Optional[_builtins.str] = None,
                 timeout: Optional['outputs.DomainDevicesDiskBackingStoreSourceTimeout'] = None,
                 vhost_user: Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUser'] = None,
                 vhost_vdpa: Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostVdpa'] = None,
                 volume: Optional['outputs.DomainDevicesDiskBackingStoreSourceVolume'] = None):
        """
        :param 'DomainDevicesDiskBackingStoreSourceBlockArgs' block: Describes a block device used as the source for the mirror backing store.
        :param 'DomainDevicesDiskBackingStoreSourceCookiesArgs' cookies: Provides optional cookie data associated with the mirror backing store source (for example, auth or session data), with content treated as user-provided.
        :param 'DomainDevicesDiskBackingStoreSourceDataStoreArgs' data_store: Configures a data store descriptor for the mirrored backing store, typically used with networked or advanced storage backends that expose format-specific options.
        :param 'DomainDevicesDiskBackingStoreSourceDirArgs' dir: Configures a directory-based source for the mirrored backing store, pointing to a host directory used by the backing image.
        :param 'DomainDevicesDiskBackingStoreSourceEncryptionArgs' encryption: Enables disk image encryption configuration for this disk and groups attributes defining the encryption engine, format, and secrets.
        :param 'DomainDevicesDiskBackingStoreSourceFileArgs' file: Configures a file-based backing store source for the disk mirror, defining how the backing image is accessed from the host filesystem.
        :param _builtins.float index: Sets the index of this backing store within a backing chain, used when multiple backing layers are present; value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainDevicesDiskBackingStoreSourceNetworkArgs' network: Configures a network-based backing store source (such as NBD, iSCSI, or RBD) for the disk mirror, including authentication and host endpoints.
        :param 'DomainDevicesDiskBackingStoreSourceNvmeArgs' nvme: Enables using an NVMe-backed source for the mirrored disks backing store; when present, it selects an NVMe device or namespace as the source, with details defined by libvirt/QEMU for NVMe disks.
        :param 'DomainDevicesDiskBackingStoreSourceReadaheadArgs' readahead: Configures read-ahead behavior for the mirrored disks backing-store source, allowing tuning of how much data is pre-fetched from the backend.
        :param 'DomainDevicesDiskBackingStoreSourceReservationsArgs' reservations: Configures SCSI-style reservations or similar persistent reservation management for the mirrored disks backing-store source, controlling how access is coordinated across nodes.
        :param 'DomainDevicesDiskBackingStoreSourceSlicesArgs' slices: Configures optional slice or segment information for the backing store source (for example, to describe which logical slices of a device are used); content is user-provided.
        :param 'DomainDevicesDiskBackingStoreSourceSslArgs' ssl: Enables SSL/TLS parameters for accessing the mirrored backing-store source when it is provided over a secure transport.
        :param _builtins.str startup_policy: Specifies how strictly the mirrored backing-store source must be available during domain startup; valid values include "mandatory", "requisite", "optional" (userprovided string matched by libvirt).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainDevicesDiskBackingStoreSourceTimeoutArgs' timeout: Configures a timeout for connecting to or initializing the mirrored backing-store source.
        :param 'DomainDevicesDiskBackingStoreSourceVhostUserArgs' vhost_user: Selects a vhost-user backend as the transport for the mirrored backing-store source, allowing it to be provided via a userspace process.
        :param 'DomainDevicesDiskBackingStoreSourceVhostVdpaArgs' vhost_vdpa: Selects a vhost-vDPA backend for the disk mirror backing store, allowing acceleration via a vDPA device; additional details are determined by libvirt and device configuration.
        :param 'DomainDevicesDiskBackingStoreSourceVolumeArgs' volume: Configures the backingStore source as a libvirt storage volume reference instead of a raw file/block path for the mirrored disk.
        """
        if block is not None:
            pulumi.set(__self__, "block", block)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if data_store is not None:
            pulumi.set(__self__, "data_store", data_store)
        if dir is not None:
            pulumi.set(__self__, "dir", dir)
        if encryption is not None:
            pulumi.set(__self__, "encryption", encryption)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if nvme is not None:
            pulumi.set(__self__, "nvme", nvme)
        if readahead is not None:
            pulumi.set(__self__, "readahead", readahead)
        if reservations is not None:
            pulumi.set(__self__, "reservations", reservations)
        if slices is not None:
            pulumi.set(__self__, "slices", slices)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if startup_policy is not None:
            pulumi.set(__self__, "startup_policy", startup_policy)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if vhost_user is not None:
            pulumi.set(__self__, "vhost_user", vhost_user)
        if vhost_vdpa is not None:
            pulumi.set(__self__, "vhost_vdpa", vhost_vdpa)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceBlock']:
        """
        Describes a block device used as the source for the mirror backing store.
        """
        return pulumi.get(self, "block")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceCookies']:
        """
        Provides optional cookie data associated with the mirror backing store source (for example, auth or session data), with content treated as user-provided.
        """
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="dataStore")
    def data_store(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceDataStore']:
        """
        Configures a data store descriptor for the mirrored backing store, typically used with networked or advanced storage backends that expose format-specific options.
        """
        return pulumi.get(self, "data_store")

    @_builtins.property
    @pulumi.getter
    def dir(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceDir']:
        """
        Configures a directory-based source for the mirrored backing store, pointing to a host directory used by the backing image.
        """
        return pulumi.get(self, "dir")

    @_builtins.property
    @pulumi.getter
    def encryption(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceEncryption']:
        """
        Enables disk image encryption configuration for this disk and groups attributes defining the encryption engine, format, and secrets.
        """
        return pulumi.get(self, "encryption")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceFile']:
        """
        Configures a file-based backing store source for the disk mirror, defining how the backing image is accessed from the host filesystem.
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the index of this backing store within a backing chain, used when multiple backing layers are present; value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "index")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceNetwork']:
        """
        Configures a network-based backing store source (such as NBD, iSCSI, or RBD) for the disk mirror, including authentication and host endpoints.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def nvme(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceNvme']:
        """
        Enables using an NVMe-backed source for the mirrored disks backing store; when present, it selects an NVMe device or namespace as the source, with details defined by libvirt/QEMU for NVMe disks.
        """
        return pulumi.get(self, "nvme")

    @_builtins.property
    @pulumi.getter
    def readahead(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceReadahead']:
        """
        Configures read-ahead behavior for the mirrored disks backing-store source, allowing tuning of how much data is pre-fetched from the backend.
        """
        return pulumi.get(self, "readahead")

    @_builtins.property
    @pulumi.getter
    def reservations(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceReservations']:
        """
        Configures SCSI-style reservations or similar persistent reservation management for the mirrored disks backing-store source, controlling how access is coordinated across nodes.
        """
        return pulumi.get(self, "reservations")

    @_builtins.property
    @pulumi.getter
    def slices(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceSlices']:
        """
        Configures optional slice or segment information for the backing store source (for example, to describe which logical slices of a device are used); content is user-provided.
        """
        return pulumi.get(self, "slices")

    @_builtins.property
    @pulumi.getter
    def ssl(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceSsl']:
        """
        Enables SSL/TLS parameters for accessing the mirrored backing-store source when it is provided over a secure transport.
        """
        return pulumi.get(self, "ssl")

    @_builtins.property
    @pulumi.getter(name="startupPolicy")
    def startup_policy(self) -> Optional[_builtins.str]:
        """
        Specifies how strictly the mirrored backing-store source must be available during domain startup; valid values include "mandatory", "requisite", "optional" (userprovided string matched by libvirt).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "startup_policy")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceTimeout']:
        """
        Configures a timeout for connecting to or initializing the mirrored backing-store source.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="vhostUser")
    def vhost_user(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUser']:
        """
        Selects a vhost-user backend as the transport for the mirrored backing-store source, allowing it to be provided via a userspace process.
        """
        return pulumi.get(self, "vhost_user")

    @_builtins.property
    @pulumi.getter(name="vhostVdpa")
    def vhost_vdpa(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostVdpa']:
        """
        Selects a vhost-vDPA backend for the disk mirror backing store, allowing acceleration via a vDPA device; additional details are determined by libvirt and device configuration.
        """
        return pulumi.get(self, "vhost_vdpa")

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceVolume']:
        """
        Configures the backingStore source as a libvirt storage volume reference instead of a raw file/block path for the mirrored disk.
        """
        return pulumi.get(self, "volume")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceBlock(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceBlock. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceBlock.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceBlock.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dev: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceBlockSecLabel']] = None):
        """
        :param _builtins.str dev: Sets the host block device path used as the mirror backing store source (for example "/dev/sdb1"); the value is user-provided and must reference an existing block device.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param Sequence['DomainDevicesDiskBackingStoreSourceBlockSecLabelArgs'] sec_labels: Configures an optional security label for the block-device backing store of the mirror, controlling how security drivers label this source.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional[_builtins.str]:
        """
        Sets the host block device path used as the mirror backing store source (for example "/dev/sdb1"); the value is user-provided and must reference an existing block device.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceBlockSecLabel']]:
        """
        Configures an optional security label for the block-device backing store of the mirror, controlling how security drivers label this source.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceBlockSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceBlockSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceBlockSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceBlockSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceCookies(dict):
    def __init__(__self__, *,
                 cookies: Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceCookiesCookie']] = None):
        """
        :param Sequence['DomainDevicesDiskBackingStoreSourceCookiesCookieArgs'] cookies: Configures one or more HTTP cookies to be sent when accessing the mirrored backing store over a network protocol that supports cookies (for example, HTTPS or HTTP-based storage).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceCookiesCookie']]:
        """
        Configures one or more HTTP cookies to be sent when accessing the mirrored backing store over a network protocol that supports cookies (for example, HTTPS or HTTP-based storage).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "cookies")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceCookiesCookie(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Sets the cookie name for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "sessionid").
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str value: Sets the cookie value for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "abc123").
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the cookie name for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "sessionid").

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Sets the cookie value for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "abc123").

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceDataStore(dict):
    def __init__(__self__, *,
                 format: Optional['outputs.DomainDevicesDiskBackingStoreSourceDataStoreFormat'] = None):
        """
        :param 'DomainDevicesDiskBackingStoreSourceDataStoreFormatArgs' format: Configures the on-disk format settings for the mirrored backing stores data store, including format type and optional metadata cache tuning.
        """
        if format is not None:
            pulumi.set(__self__, "format", format)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceDataStoreFormat']:
        """
        Configures the on-disk format settings for the mirrored backing stores data store, including format type and optional metadata cache tuning.
        """
        return pulumi.get(self, "format")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceDataStoreFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataCache":
            suggest = "metadata_cache"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceDataStoreFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceDataStoreFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceDataStoreFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 metadata_cache: Optional['outputs.DomainDevicesDiskBackingStoreSourceDataStoreFormatMetadataCache'] = None):
        """
        :param _builtins.str type: Sets the data store format type for the mirrored backing store (for example, "qcow2" or "raw"); the value is user-provided and must be a valid libvirt disk format name.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainDevicesDiskBackingStoreSourceDataStoreFormatMetadataCacheArgs' metadata_cache: Configures metadata cache behavior for the mirrored backing stores data store format (for example, limiting the size of cached metadata).
        """
        pulumi.set(__self__, "type", type)
        if metadata_cache is not None:
            pulumi.set(__self__, "metadata_cache", metadata_cache)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets the data store format type for the mirrored backing store (for example, "qcow2" or "raw"); the value is user-provided and must be a valid libvirt disk format name.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="metadataCache")
    def metadata_cache(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceDataStoreFormatMetadataCache']:
        """
        Configures metadata cache behavior for the mirrored backing stores data store format (for example, limiting the size of cached metadata).
        """
        return pulumi.get(self, "metadata_cache")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceDataStoreFormatMetadataCache(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSize":
            suggest = "max_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceDataStoreFormatMetadataCache. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceDataStoreFormatMetadataCache.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceDataStoreFormatMetadataCache.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_size: Optional['outputs.DomainDevicesDiskBackingStoreSourceDataStoreFormatMetadataCacheMaxSize'] = None):
        """
        :param 'DomainDevicesDiskBackingStoreSourceDataStoreFormatMetadataCacheMaxSizeArgs' max_size: Sets the maximum size of the metadata cache used by the data store format; value and unit together define the limit (for example, 64 MiB).
        """
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceDataStoreFormatMetadataCacheMaxSize']:
        """
        Sets the maximum size of the metadata cache used by the data store format; value and unit together define the limit (for example, 64 MiB).
        """
        return pulumi.get(self, "max_size")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceDataStoreFormatMetadataCacheMaxSize(dict):
    def __init__(__self__, *,
                 value: _builtins.float,
                 unit: Optional[_builtins.str] = None):
        """
        :param _builtins.float value: Sets the numeric value for the metadata cache maximum size in the specified unit; this must be a positive integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str unit: Sets the unit used for the metadata cache maximum size; valid units follow libvirt size units such as "B", "KiB", "MiB", "GiB" and are user-chosen.
               
               See: <https://libvirt.org/formatdomain.html#memory-allocation>
        """
        pulumi.set(__self__, "value", value)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.float:
        """
        Sets the numeric value for the metadata cache maximum size in the specified unit; this must be a positive integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        """
        Sets the unit used for the metadata cache maximum size; valid units follow libvirt size units such as "B", "KiB", "MiB", "GiB" and are user-chosen.

        See: <https://libvirt.org/formatdomain.html#memory-allocation>
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceDir(dict):
    def __init__(__self__, *,
                 dir: Optional[_builtins.str] = None):
        """
        :param _builtins.str dir: Sets the host directory path used as the mirrored backing store source; this must be an absolute path on the host (for example, "/var/lib/libvirt/images").
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if dir is not None:
            pulumi.set(__self__, "dir", dir)

    @_builtins.property
    @pulumi.getter
    def dir(self) -> Optional[_builtins.str]:
        """
        Sets the host directory path used as the mirrored backing store source; this must be an absolute path on the host (for example, "/var/lib/libvirt/images").

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "dir")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceEncryption(dict):
    def __init__(__self__, *,
                 engine: Optional[_builtins.str] = None,
                 format: Optional[_builtins.str] = None,
                 secrets: Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceEncryptionSecret']] = None):
        """
        :param _builtins.str engine: Sets the encryption engine/provider to use for the disk (user-provided string, e.g. implementation-specific engine name).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str format: Sets the disk encryption format, such as "luks" or another user-provided scheme supported by libvirt/qemu.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param Sequence['DomainDevicesDiskBackingStoreSourceEncryptionSecretArgs'] secrets: Defines one or more secret references used to access the encrypted disk, each describing how libvirt locates the secret material.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if engine is not None:
            pulumi.set(__self__, "engine", engine)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def engine(self) -> Optional[_builtins.str]:
        """
        Sets the encryption engine/provider to use for the disk (user-provided string, e.g. implementation-specific engine name).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "engine")

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[_builtins.str]:
        """
        Sets the disk encryption format, such as "luks" or another user-provided scheme supported by libvirt/qemu.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceEncryptionSecret']]:
        """
        Defines one or more secret references used to access the encrypted disk, each describing how libvirt locates the secret material.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceEncryptionSecret(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 usage: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str usage: Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str uuid: Exposes the UUID of the libvirt secret used for iSCSI authentication; this is computed from the referenced secret rather than configured directly.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def usage(self) -> Optional[_builtins.str]:
        """
        Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "usage")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        Exposes the UUID of the libvirt secret used for iSCSI authentication; this is computed from the referenced secret rather than configured directly.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fdGroup":
            suggest = "fd_group"
        elif key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fd_group: Optional[_builtins.str] = None,
                 file: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceFileSecLabel']] = None):
        """
        :param _builtins.str fd_group: Sets the name of an fdgroup whose pre-opened file descriptor is used for this backing store instead of opening the file path directly; value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str file: Sets the absolute path on the host to the backing file used as the source for this mirrored disk (for example, /var/lib/libvirt/images/base.qcow2).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param Sequence['DomainDevicesDiskBackingStoreSourceFileSecLabelArgs'] sec_labels: Configures an explicit security label for the file backing store, overriding default security driver labeling for this file.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if fd_group is not None:
            pulumi.set(__self__, "fd_group", fd_group)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter(name="fdGroup")
    def fd_group(self) -> Optional[_builtins.str]:
        """
        Sets the name of an fdgroup whose pre-opened file descriptor is used for this backing store instead of opening the file path directly; value is user-provided.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "fd_group")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional[_builtins.str]:
        """
        Sets the absolute path on the host to the backing file used as the source for this mirrored disk (for example, /var/lib/libvirt/images/base.qcow2).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceFileSecLabel']]:
        """
        Configures an explicit security label for the file backing store, overriding default security driver labeling for this file.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceFileSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceFileSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceFileSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceFileSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "knownHosts":
            suggest = "known_hosts"
        elif key == "tlsHostname":
            suggest = "tls_hostname"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth: Optional['outputs.DomainDevicesDiskBackingStoreSourceNetworkAuth'] = None,
                 config: Optional['outputs.DomainDevicesDiskBackingStoreSourceNetworkConfig'] = None,
                 hosts: Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceNetworkHost']] = None,
                 identity: Optional['outputs.DomainDevicesDiskBackingStoreSourceNetworkIdentity'] = None,
                 initiator: Optional['outputs.DomainDevicesDiskBackingStoreSourceNetworkInitiator'] = None,
                 known_hosts: Optional['outputs.DomainDevicesDiskBackingStoreSourceNetworkKnownHosts'] = None,
                 name: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 query: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesDiskBackingStoreSourceNetworkReconnect'] = None,
                 snapshot: Optional['outputs.DomainDevicesDiskBackingStoreSourceNetworkSnapshot'] = None,
                 tls: Optional[_builtins.str] = None,
                 tls_hostname: Optional[_builtins.str] = None):
        """
        :param 'DomainDevicesDiskBackingStoreSourceNetworkAuthArgs' auth: Configures CHAP authentication parameters for the iSCSI source backing an assigned SCSI host device; include this block only when the target requires authentication.
        :param 'DomainDevicesDiskBackingStoreSourceNetworkConfigArgs' config: Points to an external configuration source for the network backing store (for example, an RBD or Ceph config file) that libvirt passes to the backend.
        :param Sequence['DomainDevicesDiskBackingStoreSourceNetworkHostArgs'] hosts: Declares one or more network endpoints (hosts) for the backing store server, each with its own name/address and possibly additional attributes.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainDevicesDiskBackingStoreSourceNetworkIdentityArgs' identity: Configures authentication/identity parameters used when accessing the mirrored backing store over a network, such as user, group, keyfile, or agent socket, depending on the protocol.
        :param 'DomainDevicesDiskBackingStoreSourceNetworkInitiatorArgs' initiator: Configures initiator identity information (typically for iSCSI-like protocols) used when accessing the mirrored network backing store.
        :param 'DomainDevicesDiskBackingStoreSourceNetworkKnownHostsArgs' known_hosts: Enables use of a known-hosts file to validate the remote hosts identity when connecting to the mirrored network backing store.
        :param _builtins.str name: Sets a name for the network source of the mirrored backing store, typically used by certain protocols (such as RBD pool or NBD export names); value is user-provided and protocol-specific.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str protocol: Sets the network storage protocol used for the mirrored backing store; value is user-provided but must be a protocol supported by libvirt for network disks (for example, rbd, sheepdog, gluster, nbd).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str query: Sets an optional query string or subresource specifier for the network storage URL of the mirrored backing store; value is user-provided and protocol-specific.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainDevicesDiskBackingStoreSourceNetworkReconnectArgs' reconnect: Configures automatic reconnection behavior for the mirrored network backing store after a connection loss.
        :param 'DomainDevicesDiskBackingStoreSourceNetworkSnapshotArgs' snapshot: Configures snapshot-related behavior for the network-based mirrored backing store, with semantics depending on the underlying protocol and storage implementation.
        :param _builtins.str tls: Controls whether TLS is used for the mirrored disks network backing-store connection; value is user-provided and typically enabled only when the chosen protocol and backend support TLS.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str tls_hostname: Sets the expected TLS hostname for the mirrored disks network backing-store connection, used for certificate verification; value is user-provided and should match the server certificates hostname (for example, "storage.example.com").
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if initiator is not None:
            pulumi.set(__self__, "initiator", initiator)
        if known_hosts is not None:
            pulumi.set(__self__, "known_hosts", known_hosts)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if snapshot is not None:
            pulumi.set(__self__, "snapshot", snapshot)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if tls_hostname is not None:
            pulumi.set(__self__, "tls_hostname", tls_hostname)

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceNetworkAuth']:
        """
        Configures CHAP authentication parameters for the iSCSI source backing an assigned SCSI host device; include this block only when the target requires authentication.
        """
        return pulumi.get(self, "auth")

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceNetworkConfig']:
        """
        Points to an external configuration source for the network backing store (for example, an RBD or Ceph config file) that libvirt passes to the backend.
        """
        return pulumi.get(self, "config")

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceNetworkHost']]:
        """
        Declares one or more network endpoints (hosts) for the backing store server, each with its own name/address and possibly additional attributes.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter
    def identity(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceNetworkIdentity']:
        """
        Configures authentication/identity parameters used when accessing the mirrored backing store over a network, such as user, group, keyfile, or agent socket, depending on the protocol.
        """
        return pulumi.get(self, "identity")

    @_builtins.property
    @pulumi.getter
    def initiator(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceNetworkInitiator']:
        """
        Configures initiator identity information (typically for iSCSI-like protocols) used when accessing the mirrored network backing store.
        """
        return pulumi.get(self, "initiator")

    @_builtins.property
    @pulumi.getter(name="knownHosts")
    def known_hosts(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceNetworkKnownHosts']:
        """
        Enables use of a known-hosts file to validate the remote hosts identity when connecting to the mirrored network backing store.
        """
        return pulumi.get(self, "known_hosts")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets a name for the network source of the mirrored backing store, typically used by certain protocols (such as RBD pool or NBD export names); value is user-provided and protocol-specific.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        Sets the network storage protocol used for the mirrored backing store; value is user-provided but must be a protocol supported by libvirt for network disks (for example, rbd, sheepdog, gluster, nbd).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional[_builtins.str]:
        """
        Sets an optional query string or subresource specifier for the network storage URL of the mirrored backing store; value is user-provided and protocol-specific.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "query")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceNetworkReconnect']:
        """
        Configures automatic reconnection behavior for the mirrored network backing store after a connection loss.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter
    def snapshot(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceNetworkSnapshot']:
        """
        Configures snapshot-related behavior for the network-based mirrored backing store, with semantics depending on the underlying protocol and storage implementation.
        """
        return pulumi.get(self, "snapshot")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[_builtins.str]:
        """
        Controls whether TLS is used for the mirrored disks network backing-store connection; value is user-provided and typically enabled only when the chosen protocol and backend support TLS.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "tls")

    @_builtins.property
    @pulumi.getter(name="tlsHostname")
    def tls_hostname(self) -> Optional[_builtins.str]:
        """
        Sets the expected TLS hostname for the mirrored disks network backing-store connection, used for certificate verification; value is user-provided and should match the server certificates hostname (for example, "storage.example.com").

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "tls_hostname")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceNetworkAuth(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.DomainDevicesDiskBackingStoreSourceNetworkAuthSecret'] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param 'DomainDevicesDiskBackingStoreSourceNetworkAuthSecretArgs' secret: Configures the libvirt secret object used to hold the iSCSI authentication password for this hostdev; this references an existing libvirt secret, not the clear-text secret.
        :param _builtins.str username: Sets the CHAP username used when authenticating to the iSCSI target for this SCSI hostdev; the value is user-provided (for example, "chapuser1").
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceNetworkAuthSecret']:
        """
        Configures the libvirt secret object used to hold the iSCSI authentication password for this hostdev; this references an existing libvirt secret, not the clear-text secret.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        Sets the CHAP username used when authenticating to the iSCSI target for this SCSI hostdev; the value is user-provided (for example, "chapuser1").

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceNetworkAuthSecret(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 usage: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str usage: Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str uuid: Exposes the UUID of the libvirt secret used for iSCSI authentication; this is computed from the referenced secret rather than configured directly.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def usage(self) -> Optional[_builtins.str]:
        """
        Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "usage")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        Exposes the UUID of the libvirt secret used for iSCSI authentication; this is computed from the referenced secret rather than configured directly.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceNetworkConfig(dict):
    def __init__(__self__, *,
                 file: _builtins.str):
        """
        :param _builtins.str file: Sets the path to the configuration file used for the network backing store connection, such as a Ceph configuration file (/etc/ceph/ceph.conf).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "file", file)

    @_builtins.property
    @pulumi.getter
    def file(self) -> _builtins.str:
        """
        Sets the path to the configuration file used for the network backing store connection, such as a Ceph configuration file (/etc/ceph/ceph.conf).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "file")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceNetworkHost(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 socket: Optional[_builtins.str] = None,
                 transport: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Sets the hostname or IP address of the iSCSI target portal (for example, "10.0.0.10" or "iscsi.example.com").
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str port: Sets the TCP port of the iSCSI target portal; if omitted, libvirt/driver defaults (commonly 3260) are used.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str socket: Sets a UNIX domain socket path to connect to an iSCSI target via a local socket instead of TCP; value is a user-provided filesystem path.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str transport: Sets the transport type used to reach the iSCSI target portal; valid values are user-provided strings as supported by the environment (for example, "tcp" or "iser").
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if socket is not None:
            pulumi.set(__self__, "socket", socket)
        if transport is not None:
            pulumi.set(__self__, "transport", transport)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the hostname or IP address of the iSCSI target portal (for example, "10.0.0.10" or "iscsi.example.com").

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        """
        Sets the TCP port of the iSCSI target portal; if omitted, libvirt/driver defaults (commonly 3260) are used.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def socket(self) -> Optional[_builtins.str]:
        """
        Sets a UNIX domain socket path to connect to an iSCSI target via a local socket instead of TCP; value is a user-provided filesystem path.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "socket")

    @_builtins.property
    @pulumi.getter
    def transport(self) -> Optional[_builtins.str]:
        """
        Sets the transport type used to reach the iSCSI target portal; valid values are user-provided strings as supported by the environment (for example, "tcp" or "iser").

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "transport")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceNetworkIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentSock":
            suggest = "agent_sock"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceNetworkIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceNetworkIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceNetworkIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_sock: Optional[_builtins.str] = None,
                 group: Optional[_builtins.str] = None,
                 keyfile: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str agent_sock: Sets the path to a local agent socket used for external authentication (for example, SASL or SSH agent) when connecting to the network backing store; value is a user-provided Unix socket path.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str group: Sets the group name to use for authentication or access control when connecting to the network backing store; value is user-provided and protocol-specific.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str keyfile: Sets the path to a private key file used for authenticating to the network backing store (for example, an SSH or TLS key); value is a user-provided filesystem path.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str user: Sets the user identifier used for authentication to the network backing store; value is user-provided and typically matches a remote account name.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str user_name: Sets an explicit username string used for authentication to the network backing store, separate from any other user identity settings; value is user-provided (for example, "backupuser").
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if agent_sock is not None:
            pulumi.set(__self__, "agent_sock", agent_sock)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if keyfile is not None:
            pulumi.set(__self__, "keyfile", keyfile)
        if user is not None:
            pulumi.set(__self__, "user", user)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="agentSock")
    def agent_sock(self) -> Optional[_builtins.str]:
        """
        Sets the path to a local agent socket used for external authentication (for example, SASL or SSH agent) when connecting to the network backing store; value is a user-provided Unix socket path.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "agent_sock")

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[_builtins.str]:
        """
        Sets the group name to use for authentication or access control when connecting to the network backing store; value is user-provided and protocol-specific.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter
    def keyfile(self) -> Optional[_builtins.str]:
        """
        Sets the path to a private key file used for authenticating to the network backing store (for example, an SSH or TLS key); value is a user-provided filesystem path.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "keyfile")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        Sets the user identifier used for authentication to the network backing store; value is user-provided and typically matches a remote account name.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "user")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        """
        Sets an explicit username string used for authentication to the network backing store, separate from any other user identity settings; value is user-provided (for example, "backupuser").

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceNetworkInitiator(dict):
    def __init__(__self__, *,
                 iqn: Optional['outputs.DomainDevicesDiskBackingStoreSourceNetworkInitiatorIqn'] = None):
        """
        :param 'DomainDevicesDiskBackingStoreSourceNetworkInitiatorIqnArgs' iqn: Configures the iSCSI initiator IQN block for the mirrored network backing store, defining the initiator name presented to the target.
        """
        if iqn is not None:
            pulumi.set(__self__, "iqn", iqn)

    @_builtins.property
    @pulumi.getter
    def iqn(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceNetworkInitiatorIqn']:
        """
        Configures the iSCSI initiator IQN block for the mirrored network backing store, defining the initiator name presented to the target.
        """
        return pulumi.get(self, "iqn")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceNetworkInitiatorIqn(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Sets the initiator IQN string used when logging into an iSCSI target backing the mirrored disk; value must be a valid IQN (for example, iqn.2020-01.com.example:host1).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the initiator IQN string used when logging into an iSCSI target backing the mirrored disk; value must be a valid IQN (for example, iqn.2020-01.com.example:host1).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceNetworkKnownHosts(dict):
    def __init__(__self__, *,
                 path: _builtins.str):
        """
        :param _builtins.str path: Sets the path to the known-hosts file used to verify the identity of the remote storage host; value is a required user-provided filesystem path (for example, /etc/libvirt/known_hosts).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the path to the known-hosts file used to verify the identity of the remote storage host; value is a required user-provided filesystem path (for example, /etc/libvirt/known_hosts).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceNetworkReconnect(dict):
    def __init__(__self__, *,
                 delay: _builtins.str):
        """
        :param _builtins.str delay: Sets the reconnection delay (in seconds) before retrying a failed connection to the mirrored network backing store; value is a required user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "delay", delay)

    @_builtins.property
    @pulumi.getter
    def delay(self) -> _builtins.str:
        """
        Sets the reconnection delay (in seconds) before retrying a failed connection to the mirrored network backing store; value is a required user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "delay")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceNetworkSnapshot(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the name of the network snapshot to use as the backing store for the mirrored disks network source; value is user-provided and must match an existing snapshot identifier on the storage backend.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the name of the network snapshot to use as the backing store for the mirrored disks network source; value is user-provided and must match an existing snapshot identifier on the storage backend.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceNvme(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceReadahead(dict):
    def __init__(__self__, *,
                 size: _builtins.str):
        """
        :param _builtins.str size: Sets the read-ahead size for the mirrored disks backing store; value is a user-provided positive integer in bytes (for example, 65536 for 64 KiB).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        """
        Sets the read-ahead size for the mirrored disks backing store; value is a user-provided positive integer in bytes (for example, 65536 for 64 KiB).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceReservations(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.str] = None,
                 managed: Optional[_builtins.bool] = None,
                 source: Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSource'] = None):
        """
        :param _builtins.str enabled: Controls whether persistent reservations are enabled for the mirrored disks backing-store source; value is user-provided and typically expects "yes" or "no" semantics per libvirt.
        :param _builtins.bool managed: Indicates whether reservations are managed by libvirt ("yes") or externally ("no"); value is provided as a string and translated to a boolean, with "yes" meaning true and "no" meaning false.
        :param 'DomainDevicesDiskBackingStoreSourceReservationsSourceArgs' source: Selects the mechanism used to provide reservation control for the mirrored backing-store source, such as a D-Bus service or a device/file endpoint.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if managed is not None:
            pulumi.set(__self__, "managed", managed)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.str]:
        """
        Controls whether persistent reservations are enabled for the mirrored disks backing-store source; value is user-provided and typically expects "yes" or "no" semantics per libvirt.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def managed(self) -> Optional[_builtins.bool]:
        """
        Indicates whether reservations are managed by libvirt ("yes") or externally ("no"); value is provided as a string and translated to a boolean, with "yes" meaning true and "no" meaning false.
        """
        return pulumi.get(self, "managed")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSource']:
        """
        Selects the mechanism used to provide reservation control for the mirrored backing-store source, such as a D-Bus service or a device/file endpoint.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceReservationsSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "qemuvdAgent":
            suggest = "qemuvd_agent"
        elif key == "spicePort":
            suggest = "spice_port"
        elif key == "spiceVmc":
            suggest = "spice_vmc"
        elif key == "stdIo":
            suggest = "std_io"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceReservationsSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceReservationsSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceReservationsSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbus: Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceDbus'] = None,
                 dev: Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceDev'] = None,
                 file: Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceFile'] = None,
                 nmdm: Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceNmdm'] = None,
                 null: Optional[_builtins.bool] = None,
                 pipe: Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourcePipe'] = None,
                 pty: Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourcePty'] = None,
                 qemuvd_agent: Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceQemuvdAgent'] = None,
                 spice_port: Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceSpicePort'] = None,
                 spice_vmc: Optional[_builtins.bool] = None,
                 std_io: Optional[_builtins.bool] = None,
                 tcp: Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceTcp'] = None,
                 udp: Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceUdp'] = None,
                 unix: Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceUnix'] = None,
                 vc: Optional[_builtins.bool] = None):
        """
        :param 'DomainDevicesDiskBackingStoreSourceReservationsSourceDbusArgs' dbus: Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        :param 'DomainDevicesDiskBackingStoreSourceReservationsSourceDevArgs' dev: Configures an EGD RNG backend that reads entropy from a host character device node.
        :param 'DomainDevicesDiskBackingStoreSourceReservationsSourceFileArgs' file: Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        :param 'DomainDevicesDiskBackingStoreSourceReservationsSourceNmdmArgs' nmdm: Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        :param _builtins.bool null: Enables use of a null character device as the reservation backing source; when this boolean is true, a Null source is emitted and all written data is discarded.
               
               See: <https://libvirt.org/formatdomain.html#null-device>
        :param 'DomainDevicesDiskBackingStoreSourceReservationsSourcePipeArgs' pipe: Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        :param 'DomainDevicesDiskBackingStoreSourceReservationsSourcePtyArgs' pty: Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        :param 'DomainDevicesDiskBackingStoreSourceReservationsSourceQemuvdAgentArgs' qemuvd_agent: Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        :param 'DomainDevicesDiskBackingStoreSourceReservationsSourceSpicePortArgs' spice_port: Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        :param _builtins.bool spice_vmc: Enables a SPICE VMC (SPICE management channel) backend for this backing-store source; when set true the element is emitted, when false or null it is omitted.
               
               See: <https://libvirt.org/formatdomain.html#spice-channel>
        :param _builtins.bool std_io: Connects the backing-store sources character channel to the domains standard I/O (stdin/stdout/stderr); when true the element is emitted, when false or null it is omitted.
               
               See: <https://libvirt.org/formatdomain.html#host-interface>
        :param 'DomainDevicesDiskBackingStoreSourceReservationsSourceTcpArgs' tcp: Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        :param 'DomainDevicesDiskBackingStoreSourceReservationsSourceUdpArgs' udp: Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        :param 'DomainDevicesDiskBackingStoreSourceReservationsSourceUnixArgs' unix: Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        :param _builtins.bool vc: Enables use of a VC (virtual cluster or vendor-specific) reservation source when set; since this is presence-based, setting it to true emits the element and false/null omits it.
        """
        if dbus is not None:
            pulumi.set(__self__, "dbus", dbus)
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if nmdm is not None:
            pulumi.set(__self__, "nmdm", nmdm)
        if null is not None:
            pulumi.set(__self__, "null", null)
        if pipe is not None:
            pulumi.set(__self__, "pipe", pipe)
        if pty is not None:
            pulumi.set(__self__, "pty", pty)
        if qemuvd_agent is not None:
            pulumi.set(__self__, "qemuvd_agent", qemuvd_agent)
        if spice_port is not None:
            pulumi.set(__self__, "spice_port", spice_port)
        if spice_vmc is not None:
            pulumi.set(__self__, "spice_vmc", spice_vmc)
        if std_io is not None:
            pulumi.set(__self__, "std_io", std_io)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)
        if unix is not None:
            pulumi.set(__self__, "unix", unix)
        if vc is not None:
            pulumi.set(__self__, "vc", vc)

    @_builtins.property
    @pulumi.getter
    def dbus(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceDbus']:
        """
        Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        """
        return pulumi.get(self, "dbus")

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceDev']:
        """
        Configures an EGD RNG backend that reads entropy from a host character device node.
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceFile']:
        """
        Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def nmdm(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceNmdm']:
        """
        Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        """
        return pulumi.get(self, "nmdm")

    @_builtins.property
    @pulumi.getter
    def null(self) -> Optional[_builtins.bool]:
        """
        Enables use of a null character device as the reservation backing source; when this boolean is true, a Null source is emitted and all written data is discarded.

        See: <https://libvirt.org/formatdomain.html#null-device>
        """
        return pulumi.get(self, "null")

    @_builtins.property
    @pulumi.getter
    def pipe(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourcePipe']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        """
        return pulumi.get(self, "pipe")

    @_builtins.property
    @pulumi.getter
    def pty(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourcePty']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        """
        return pulumi.get(self, "pty")

    @_builtins.property
    @pulumi.getter(name="qemuvdAgent")
    def qemuvd_agent(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceQemuvdAgent']:
        """
        Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        """
        return pulumi.get(self, "qemuvd_agent")

    @_builtins.property
    @pulumi.getter(name="spicePort")
    def spice_port(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceSpicePort']:
        """
        Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        """
        return pulumi.get(self, "spice_port")

    @_builtins.property
    @pulumi.getter(name="spiceVmc")
    def spice_vmc(self) -> Optional[_builtins.bool]:
        """
        Enables a SPICE VMC (SPICE management channel) backend for this backing-store source; when set true the element is emitted, when false or null it is omitted.

        See: <https://libvirt.org/formatdomain.html#spice-channel>
        """
        return pulumi.get(self, "spice_vmc")

    @_builtins.property
    @pulumi.getter(name="stdIo")
    def std_io(self) -> Optional[_builtins.bool]:
        """
        Connects the backing-store sources character channel to the domains standard I/O (stdin/stdout/stderr); when true the element is emitted, when false or null it is omitted.

        See: <https://libvirt.org/formatdomain.html#host-interface>
        """
        return pulumi.get(self, "std_io")

    @_builtins.property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceTcp']:
        """
        Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        """
        return pulumi.get(self, "tcp")

    @_builtins.property
    @pulumi.getter
    def udp(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceUdp']:
        """
        Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        """
        return pulumi.get(self, "udp")

    @_builtins.property
    @pulumi.getter
    def unix(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceUnix']:
        """
        Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        """
        return pulumi.get(self, "unix")

    @_builtins.property
    @pulumi.getter
    def vc(self) -> Optional[_builtins.bool]:
        """
        Enables use of a VC (virtual cluster or vendor-specific) reservation source when set; since this is presence-based, setting it to true emits the element and false/null omits it.
        """
        return pulumi.get(self, "vc")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceReservationsSourceDbus(dict):
    def __init__(__self__, *,
                 channel: Optional[_builtins.str] = None):
        """
        :param _builtins.str channel: Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.str]:
        """
        Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceReservationsSourceDev(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceReservationsSourceDev. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceReservationsSourceDev.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceReservationsSourceDev.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceDevSecLabel']] = None):
        """
        :param _builtins.str path: Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesDiskBackingStoreSourceReservationsSourceDevSecLabelArgs'] sec_labels: Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceDevSecLabel']]:
        """
        Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceReservationsSourceDevSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceReservationsSourceDevSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceReservationsSourceDevSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceReservationsSourceDevSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceReservationsSourceFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceReservationsSourceFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceReservationsSourceFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceReservationsSourceFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 append: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceFileSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str append: Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
               
               See: <https://libvirt.org/formatdomain.html#device-logfile>
        :param Sequence['DomainDevicesDiskBackingStoreSourceReservationsSourceFileSecLabelArgs'] sec_labels: Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def append(self) -> Optional[_builtins.str]:
        """
        Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.

        See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        return pulumi.get(self, "append")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceFileSecLabel']]:
        """
        Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceReservationsSourceFileSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceReservationsSourceFileSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceReservationsSourceFileSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceReservationsSourceFileSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceReservationsSourceNmdm(dict):
    def __init__(__self__, *,
                 master: _builtins.str,
                 slave: _builtins.str):
        """
        :param _builtins.str master: Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        :param _builtins.str slave: Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        pulumi.set(__self__, "master", master)
        pulumi.set(__self__, "slave", slave)

    @_builtins.property
    @pulumi.getter
    def master(self) -> _builtins.str:
        """
        Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "master")

    @_builtins.property
    @pulumi.getter
    def slave(self) -> _builtins.str:
        """
        Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "slave")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceReservationsSourcePipe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceReservationsSourcePipe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceReservationsSourcePipe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceReservationsSourcePipe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourcePipeSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesDiskBackingStoreSourceReservationsSourcePipeSecLabelArgs'] sec_labels: Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourcePipeSecLabel']]:
        """
        Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceReservationsSourcePipeSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceReservationsSourcePipeSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceReservationsSourcePipeSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceReservationsSourcePipeSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceReservationsSourcePty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceReservationsSourcePty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceReservationsSourcePty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceReservationsSourcePty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourcePtySecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesDiskBackingStoreSourceReservationsSourcePtySecLabelArgs'] sec_labels: Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourcePtySecLabel']]:
        """
        Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceReservationsSourcePtySecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceReservationsSourcePtySecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceReservationsSourcePtySecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceReservationsSourcePtySecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceReservationsSourceQemuvdAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clipBoard":
            suggest = "clip_board"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceReservationsSourceQemuvdAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceReservationsSourceQemuvdAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceReservationsSourceQemuvdAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clip_board: Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceQemuvdAgentClipBoard'] = None,
                 mouse: Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceQemuvdAgentMouse'] = None):
        """
        :param 'DomainDevicesDiskBackingStoreSourceReservationsSourceQemuvdAgentClipBoardArgs' clip_board: Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        :param 'DomainDevicesDiskBackingStoreSourceReservationsSourceQemuvdAgentMouseArgs' mouse: Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        if clip_board is not None:
            pulumi.set(__self__, "clip_board", clip_board)
        if mouse is not None:
            pulumi.set(__self__, "mouse", mouse)

    @_builtins.property
    @pulumi.getter(name="clipBoard")
    def clip_board(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceQemuvdAgentClipBoard']:
        """
        Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        """
        return pulumi.get(self, "clip_board")

    @_builtins.property
    @pulumi.getter
    def mouse(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceQemuvdAgentMouse']:
        """
        Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        return pulumi.get(self, "mouse")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceReservationsSourceQemuvdAgentClipBoard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyPaste":
            suggest = "copy_paste"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceReservationsSourceQemuvdAgentClipBoard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceReservationsSourceQemuvdAgentClipBoard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceReservationsSourceQemuvdAgentClipBoard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_paste: _builtins.str):
        """
        :param _builtins.str copy_paste: Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "copy_paste", copy_paste)

    @_builtins.property
    @pulumi.getter(name="copyPaste")
    def copy_paste(self) -> _builtins.str:
        """
        Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "copy_paste")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceReservationsSourceQemuvdAgentMouse(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceReservationsSourceSpicePort(dict):
    def __init__(__self__, *,
                 channel: _builtins.str):
        """
        :param _builtins.str channel: Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceReservationsSourceTcp(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceTcpReconnect'] = None,
                 service: Optional[_builtins.str] = None,
                 tls: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str mode: Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesDiskBackingStoreSourceReservationsSourceTcpReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param _builtins.str service: Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str tls: Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceTcpReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[_builtins.str]:
        """
        Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceReservationsSourceTcpReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceReservationsSourceUdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindHost":
            suggest = "bind_host"
        elif key == "bindService":
            suggest = "bind_service"
        elif key == "connectHost":
            suggest = "connect_host"
        elif key == "connectService":
            suggest = "connect_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceReservationsSourceUdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceReservationsSourceUdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceReservationsSourceUdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bind_host: _builtins.str,
                 bind_service: _builtins.str,
                 connect_host: _builtins.str,
                 connect_service: _builtins.str):
        """
        :param _builtins.str bind_host: Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str bind_service: Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_host: Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_service: Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "bind_host", bind_host)
        pulumi.set(__self__, "bind_service", bind_service)
        pulumi.set(__self__, "connect_host", connect_host)
        pulumi.set(__self__, "connect_service", connect_service)

    @_builtins.property
    @pulumi.getter(name="bindHost")
    def bind_host(self) -> _builtins.str:
        """
        Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_host")

    @_builtins.property
    @pulumi.getter(name="bindService")
    def bind_service(self) -> _builtins.str:
        """
        Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_service")

    @_builtins.property
    @pulumi.getter(name="connectHost")
    def connect_host(self) -> _builtins.str:
        """
        Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_host")

    @_builtins.property
    @pulumi.getter(name="connectService")
    def connect_service(self) -> _builtins.str:
        """
        Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_service")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceReservationsSourceUnix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceReservationsSourceUnix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceReservationsSourceUnix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceReservationsSourceUnix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceUnixReconnect'] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceUnixSecLabel']] = None):
        """
        :param _builtins.str mode: Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str path: Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesDiskBackingStoreSourceReservationsSourceUnixReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param Sequence['DomainDevicesDiskBackingStoreSourceReservationsSourceUnixSecLabelArgs'] sec_labels: Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceUnixReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceReservationsSourceUnixSecLabel']]:
        """
        Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceReservationsSourceUnixReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceReservationsSourceUnixSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceReservationsSourceUnixSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceReservationsSourceUnixSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceReservationsSourceUnixSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceSlices(dict):
    def __init__(__self__, *,
                 slices: Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceSlicesSlice']] = None):
        """
        :param Sequence['DomainDevicesDiskBackingStoreSourceSlicesSliceArgs'] slices: Configures one or more slices of the backing-store source, each describing a contiguous portion of the underlying device or file that is exposed through this mirror backing store.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if slices is not None:
            pulumi.set(__self__, "slices", slices)

    @_builtins.property
    @pulumi.getter
    def slices(self) -> Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceSlicesSlice']]:
        """
        Configures one or more slices of the backing-store source, each describing a contiguous portion of the underlying device or file that is exposed through this mirror backing store.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "slices")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceSlicesSlice(dict):
    def __init__(__self__, *,
                 offset: _builtins.float,
                 size: _builtins.float,
                 type: _builtins.str):
        """
        :param _builtins.float offset: Sets the starting offset (in bytes) of this slice within the underlying backing-store source; must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.float size: Sets the size (in bytes) of this slice within the underlying backing-store source; must be a positive integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str type: Specifies the type of slice mapping to use for this range; the value is userprovided and must match a type supported by the hypervisor (for example, a particular mapping or layout scheme).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def offset(self) -> _builtins.float:
        """
        Sets the starting offset (in bytes) of this slice within the underlying backing-store source; must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "offset")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.float:
        """
        Sets the size (in bytes) of this slice within the underlying backing-store source; must be a positive integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of slice mapping to use for this range; the value is userprovided and must match a type supported by the hypervisor (for example, a particular mapping or layout scheme).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceSsl(dict):
    def __init__(__self__, *,
                 verify: _builtins.str):
        """
        :param _builtins.str verify: Controls certificate verification for SSL/TLS access to the mirrored backing-store source; typical values are "yes" or "no" to enable or disable verification.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "verify", verify)

    @_builtins.property
    @pulumi.getter
    def verify(self) -> _builtins.str:
        """
        Controls certificate verification for SSL/TLS access to the mirrored backing-store source; typical values are "yes" or "no" to enable or disable verification.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "verify")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceTimeout(dict):
    def __init__(__self__, *,
                 seconds: _builtins.str):
        """
        :param _builtins.str seconds: Sets the timeout duration in seconds for accessing the mirrored backing-store source; must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.str:
        """
        Sets the timeout duration in seconds for accessing the mirrored backing-store source; must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceVhostUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "qemuvdAgent":
            suggest = "qemuvd_agent"
        elif key == "spicePort":
            suggest = "spice_port"
        elif key == "spiceVmc":
            suggest = "spice_vmc"
        elif key == "stdIo":
            suggest = "std_io"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceVhostUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceVhostUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceVhostUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbus: Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserDbus'] = None,
                 dev: Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserDev'] = None,
                 file: Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserFile'] = None,
                 nmdm: Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserNmdm'] = None,
                 null: Optional[_builtins.bool] = None,
                 pipe: Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserPipe'] = None,
                 pty: Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserPty'] = None,
                 qemuvd_agent: Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserQemuvdAgent'] = None,
                 spice_port: Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserSpicePort'] = None,
                 spice_vmc: Optional[_builtins.bool] = None,
                 std_io: Optional[_builtins.bool] = None,
                 tcp: Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserTcp'] = None,
                 udp: Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserUdp'] = None,
                 unix: Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserUnix'] = None,
                 vc: Optional[_builtins.bool] = None):
        """
        :param 'DomainDevicesDiskBackingStoreSourceVhostUserDbusArgs' dbus: Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        :param 'DomainDevicesDiskBackingStoreSourceVhostUserDevArgs' dev: Configures an EGD RNG backend that reads entropy from a host character device node.
        :param 'DomainDevicesDiskBackingStoreSourceVhostUserFileArgs' file: Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        :param 'DomainDevicesDiskBackingStoreSourceVhostUserNmdmArgs' nmdm: Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        :param _builtins.bool null: When set to true, uses a null character device as the vhost-user backing-store source, discarding all output and providing no input; when false or unset, the null device is not used.
               
               See: <https://libvirt.org/formatdomain.html#null-device>
        :param 'DomainDevicesDiskBackingStoreSourceVhostUserPipeArgs' pipe: Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        :param 'DomainDevicesDiskBackingStoreSourceVhostUserPtyArgs' pty: Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        :param 'DomainDevicesDiskBackingStoreSourceVhostUserQemuvdAgentArgs' qemuvd_agent: Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        :param 'DomainDevicesDiskBackingStoreSourceVhostUserSpicePortArgs' spice_port: Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        :param _builtins.bool spice_vmc: When set to true, exposes the vhost-user backing through a SPICE virtio-serial management channel (SpiceVMC); when false or unset, the element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#spice-channel>
        :param _builtins.bool std_io: When set to true, connects the vhost-user backing to the domains standard I/O character device; when false or unset, the StdIO element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#host-interface>
        :param 'DomainDevicesDiskBackingStoreSourceVhostUserTcpArgs' tcp: Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        :param 'DomainDevicesDiskBackingStoreSourceVhostUserUdpArgs' udp: Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        :param 'DomainDevicesDiskBackingStoreSourceVhostUserUnixArgs' unix: Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        :param _builtins.bool vc: Enables use of a vhost-user communication mechanism compatible with a VC-style (versioned capability) endpoint for the disk mirror backing store; when set true the VC element is emitted, when false or null it is omitted.
        """
        if dbus is not None:
            pulumi.set(__self__, "dbus", dbus)
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if nmdm is not None:
            pulumi.set(__self__, "nmdm", nmdm)
        if null is not None:
            pulumi.set(__self__, "null", null)
        if pipe is not None:
            pulumi.set(__self__, "pipe", pipe)
        if pty is not None:
            pulumi.set(__self__, "pty", pty)
        if qemuvd_agent is not None:
            pulumi.set(__self__, "qemuvd_agent", qemuvd_agent)
        if spice_port is not None:
            pulumi.set(__self__, "spice_port", spice_port)
        if spice_vmc is not None:
            pulumi.set(__self__, "spice_vmc", spice_vmc)
        if std_io is not None:
            pulumi.set(__self__, "std_io", std_io)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)
        if unix is not None:
            pulumi.set(__self__, "unix", unix)
        if vc is not None:
            pulumi.set(__self__, "vc", vc)

    @_builtins.property
    @pulumi.getter
    def dbus(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserDbus']:
        """
        Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        """
        return pulumi.get(self, "dbus")

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserDev']:
        """
        Configures an EGD RNG backend that reads entropy from a host character device node.
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserFile']:
        """
        Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def nmdm(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserNmdm']:
        """
        Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        """
        return pulumi.get(self, "nmdm")

    @_builtins.property
    @pulumi.getter
    def null(self) -> Optional[_builtins.bool]:
        """
        When set to true, uses a null character device as the vhost-user backing-store source, discarding all output and providing no input; when false or unset, the null device is not used.

        See: <https://libvirt.org/formatdomain.html#null-device>
        """
        return pulumi.get(self, "null")

    @_builtins.property
    @pulumi.getter
    def pipe(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserPipe']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        """
        return pulumi.get(self, "pipe")

    @_builtins.property
    @pulumi.getter
    def pty(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserPty']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        """
        return pulumi.get(self, "pty")

    @_builtins.property
    @pulumi.getter(name="qemuvdAgent")
    def qemuvd_agent(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserQemuvdAgent']:
        """
        Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        """
        return pulumi.get(self, "qemuvd_agent")

    @_builtins.property
    @pulumi.getter(name="spicePort")
    def spice_port(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserSpicePort']:
        """
        Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        """
        return pulumi.get(self, "spice_port")

    @_builtins.property
    @pulumi.getter(name="spiceVmc")
    def spice_vmc(self) -> Optional[_builtins.bool]:
        """
        When set to true, exposes the vhost-user backing through a SPICE virtio-serial management channel (SpiceVMC); when false or unset, the element is omitted.

        See: <https://libvirt.org/formatdomain.html#spice-channel>
        """
        return pulumi.get(self, "spice_vmc")

    @_builtins.property
    @pulumi.getter(name="stdIo")
    def std_io(self) -> Optional[_builtins.bool]:
        """
        When set to true, connects the vhost-user backing to the domains standard I/O character device; when false or unset, the StdIO element is omitted.

        See: <https://libvirt.org/formatdomain.html#host-interface>
        """
        return pulumi.get(self, "std_io")

    @_builtins.property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserTcp']:
        """
        Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        """
        return pulumi.get(self, "tcp")

    @_builtins.property
    @pulumi.getter
    def udp(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserUdp']:
        """
        Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        """
        return pulumi.get(self, "udp")

    @_builtins.property
    @pulumi.getter
    def unix(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserUnix']:
        """
        Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        """
        return pulumi.get(self, "unix")

    @_builtins.property
    @pulumi.getter
    def vc(self) -> Optional[_builtins.bool]:
        """
        Enables use of a vhost-user communication mechanism compatible with a VC-style (versioned capability) endpoint for the disk mirror backing store; when set true the VC element is emitted, when false or null it is omitted.
        """
        return pulumi.get(self, "vc")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceVhostUserDbus(dict):
    def __init__(__self__, *,
                 channel: Optional[_builtins.str] = None):
        """
        :param _builtins.str channel: Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.str]:
        """
        Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceVhostUserDev(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceVhostUserDev. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceVhostUserDev.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceVhostUserDev.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceVhostUserDevSecLabel']] = None):
        """
        :param _builtins.str path: Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesDiskBackingStoreSourceVhostUserDevSecLabelArgs'] sec_labels: Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceVhostUserDevSecLabel']]:
        """
        Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceVhostUserDevSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceVhostUserDevSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceVhostUserDevSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceVhostUserDevSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceVhostUserFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceVhostUserFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceVhostUserFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceVhostUserFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 append: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceVhostUserFileSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str append: Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
               
               See: <https://libvirt.org/formatdomain.html#device-logfile>
        :param Sequence['DomainDevicesDiskBackingStoreSourceVhostUserFileSecLabelArgs'] sec_labels: Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def append(self) -> Optional[_builtins.str]:
        """
        Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.

        See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        return pulumi.get(self, "append")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceVhostUserFileSecLabel']]:
        """
        Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceVhostUserFileSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceVhostUserFileSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceVhostUserFileSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceVhostUserFileSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceVhostUserNmdm(dict):
    def __init__(__self__, *,
                 master: _builtins.str,
                 slave: _builtins.str):
        """
        :param _builtins.str master: Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        :param _builtins.str slave: Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        pulumi.set(__self__, "master", master)
        pulumi.set(__self__, "slave", slave)

    @_builtins.property
    @pulumi.getter
    def master(self) -> _builtins.str:
        """
        Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "master")

    @_builtins.property
    @pulumi.getter
    def slave(self) -> _builtins.str:
        """
        Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "slave")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceVhostUserPipe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceVhostUserPipe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceVhostUserPipe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceVhostUserPipe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceVhostUserPipeSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesDiskBackingStoreSourceVhostUserPipeSecLabelArgs'] sec_labels: Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceVhostUserPipeSecLabel']]:
        """
        Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceVhostUserPipeSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceVhostUserPipeSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceVhostUserPipeSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceVhostUserPipeSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceVhostUserPty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceVhostUserPty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceVhostUserPty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceVhostUserPty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceVhostUserPtySecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesDiskBackingStoreSourceVhostUserPtySecLabelArgs'] sec_labels: Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceVhostUserPtySecLabel']]:
        """
        Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceVhostUserPtySecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceVhostUserPtySecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceVhostUserPtySecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceVhostUserPtySecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceVhostUserQemuvdAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clipBoard":
            suggest = "clip_board"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceVhostUserQemuvdAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceVhostUserQemuvdAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceVhostUserQemuvdAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clip_board: Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserQemuvdAgentClipBoard'] = None,
                 mouse: Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserQemuvdAgentMouse'] = None):
        """
        :param 'DomainDevicesDiskBackingStoreSourceVhostUserQemuvdAgentClipBoardArgs' clip_board: Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        :param 'DomainDevicesDiskBackingStoreSourceVhostUserQemuvdAgentMouseArgs' mouse: Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        if clip_board is not None:
            pulumi.set(__self__, "clip_board", clip_board)
        if mouse is not None:
            pulumi.set(__self__, "mouse", mouse)

    @_builtins.property
    @pulumi.getter(name="clipBoard")
    def clip_board(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserQemuvdAgentClipBoard']:
        """
        Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        """
        return pulumi.get(self, "clip_board")

    @_builtins.property
    @pulumi.getter
    def mouse(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserQemuvdAgentMouse']:
        """
        Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        return pulumi.get(self, "mouse")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceVhostUserQemuvdAgentClipBoard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyPaste":
            suggest = "copy_paste"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceVhostUserQemuvdAgentClipBoard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceVhostUserQemuvdAgentClipBoard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceVhostUserQemuvdAgentClipBoard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_paste: _builtins.str):
        """
        :param _builtins.str copy_paste: Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "copy_paste", copy_paste)

    @_builtins.property
    @pulumi.getter(name="copyPaste")
    def copy_paste(self) -> _builtins.str:
        """
        Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "copy_paste")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceVhostUserQemuvdAgentMouse(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceVhostUserSpicePort(dict):
    def __init__(__self__, *,
                 channel: _builtins.str):
        """
        :param _builtins.str channel: Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceVhostUserTcp(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserTcpReconnect'] = None,
                 service: Optional[_builtins.str] = None,
                 tls: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str mode: Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesDiskBackingStoreSourceVhostUserTcpReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param _builtins.str service: Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str tls: Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserTcpReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[_builtins.str]:
        """
        Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceVhostUserTcpReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceVhostUserUdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindHost":
            suggest = "bind_host"
        elif key == "bindService":
            suggest = "bind_service"
        elif key == "connectHost":
            suggest = "connect_host"
        elif key == "connectService":
            suggest = "connect_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceVhostUserUdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceVhostUserUdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceVhostUserUdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bind_host: _builtins.str,
                 bind_service: _builtins.str,
                 connect_host: _builtins.str,
                 connect_service: _builtins.str):
        """
        :param _builtins.str bind_host: Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str bind_service: Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_host: Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_service: Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "bind_host", bind_host)
        pulumi.set(__self__, "bind_service", bind_service)
        pulumi.set(__self__, "connect_host", connect_host)
        pulumi.set(__self__, "connect_service", connect_service)

    @_builtins.property
    @pulumi.getter(name="bindHost")
    def bind_host(self) -> _builtins.str:
        """
        Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_host")

    @_builtins.property
    @pulumi.getter(name="bindService")
    def bind_service(self) -> _builtins.str:
        """
        Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_service")

    @_builtins.property
    @pulumi.getter(name="connectHost")
    def connect_host(self) -> _builtins.str:
        """
        Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_host")

    @_builtins.property
    @pulumi.getter(name="connectService")
    def connect_service(self) -> _builtins.str:
        """
        Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_service")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceVhostUserUnix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceVhostUserUnix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceVhostUserUnix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceVhostUserUnix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserUnixReconnect'] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceVhostUserUnixSecLabel']] = None):
        """
        :param _builtins.str mode: Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str path: Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesDiskBackingStoreSourceVhostUserUnixReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param Sequence['DomainDevicesDiskBackingStoreSourceVhostUserUnixSecLabelArgs'] sec_labels: Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesDiskBackingStoreSourceVhostUserUnixReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceVhostUserUnixSecLabel']]:
        """
        Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceVhostUserUnixReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceVhostUserUnixSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceVhostUserUnixSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceVhostUserUnixSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceVhostUserUnixSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceVhostVdpa(dict):
    def __init__(__self__, *,
                 dev: _builtins.str):
        """
        :param _builtins.str dev: Sets the host vDPA character device path used as the backingStore source for the mirrored disk when using a vhost-vdpa backend; the value is user-provided and must reference an existing device node (for example, /dev/vhost-vdpa0).
        """
        pulumi.set(__self__, "dev", dev)

    @_builtins.property
    @pulumi.getter
    def dev(self) -> _builtins.str:
        """
        Sets the host vDPA character device path used as the backingStore source for the mirrored disk when using a vhost-vdpa backend; the value is user-provided and must reference an existing device node (for example, /dev/vhost-vdpa0).
        """
        return pulumi.get(self, "dev")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 pool: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceVolumeSecLabel']] = None,
                 volume: Optional[_builtins.str] = None):
        """
        :param _builtins.str mode: Sets the access mode with which the storage volume is used as the backingStore source (for example, "readOnly" or "readWrite" depending on driver support); the value is user-provided.
        :param _builtins.str pool: Names the storage pool that contains the backing storage volume used as the mirror backingStore source; must match an existing libvirt storage pool name.
        :param Sequence['DomainDevicesDiskBackingStoreSourceVolumeSecLabelArgs'] sec_labels: Configures an optional security label override applied to the backing storage volume used as the mirror backingStore source.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str volume: Sets the name of the storage volume within the specified pool that is used as the backingStore source for the mirrored disk.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if pool is not None:
            pulumi.set(__self__, "pool", pool)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the access mode with which the storage volume is used as the backingStore source (for example, "readOnly" or "readWrite" depending on driver support); the value is user-provided.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def pool(self) -> Optional[_builtins.str]:
        """
        Names the storage pool that contains the backing storage volume used as the mirror backingStore source; must match an existing libvirt storage pool name.
        """
        return pulumi.get(self, "pool")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskBackingStoreSourceVolumeSecLabel']]:
        """
        Configures an optional security label override applied to the backing storage volume used as the mirror backingStore source.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional[_builtins.str]:
        """
        Sets the name of the storage volume within the specified pool that is used as the backingStore source for the mirrored disk.
        """
        return pulumi.get(self, "volume")


@pulumi.output_type
class DomainDevicesDiskBackingStoreSourceVolumeSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBackingStoreSourceVolumeSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBackingStoreSourceVolumeSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBackingStoreSourceVolumeSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskBlockIo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "discardGranularity":
            suggest = "discard_granularity"
        elif key == "logicalBlockSize":
            suggest = "logical_block_size"
        elif key == "physicalBlockSize":
            suggest = "physical_block_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBlockIo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBlockIo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBlockIo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 discard_granularity: Optional[_builtins.float] = None,
                 logical_block_size: Optional[_builtins.float] = None,
                 physical_block_size: Optional[_builtins.float] = None):
        """
        :param _builtins.float discard_granularity: Sets the discard (TRIM/UNMAP) granularity in bytes for this disk as seen by the guest; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.float logical_block_size: Sets the logical block size in bytes that the guest sees for this disk; the value is a user-provided positive integer, commonly 512 or 4096.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.float physical_block_size: Sets the physical block size in bytes that the guest sees for this disk, typically matching the underlying storages hardware sector size; the value is a user-provided positive integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if discard_granularity is not None:
            pulumi.set(__self__, "discard_granularity", discard_granularity)
        if logical_block_size is not None:
            pulumi.set(__self__, "logical_block_size", logical_block_size)
        if physical_block_size is not None:
            pulumi.set(__self__, "physical_block_size", physical_block_size)

    @_builtins.property
    @pulumi.getter(name="discardGranularity")
    def discard_granularity(self) -> Optional[_builtins.float]:
        """
        Sets the discard (TRIM/UNMAP) granularity in bytes for this disk as seen by the guest; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "discard_granularity")

    @_builtins.property
    @pulumi.getter(name="logicalBlockSize")
    def logical_block_size(self) -> Optional[_builtins.float]:
        """
        Sets the logical block size in bytes that the guest sees for this disk; the value is a user-provided positive integer, commonly 512 or 4096.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "logical_block_size")

    @_builtins.property
    @pulumi.getter(name="physicalBlockSize")
    def physical_block_size(self) -> Optional[_builtins.float]:
        """
        Sets the physical block size in bytes that the guest sees for this disk, typically matching the underlying storages hardware sector size; the value is a user-provided positive integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "physical_block_size")


@pulumi.output_type
class DomainDevicesDiskBoot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadParm":
            suggest = "load_parm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskBoot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskBoot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskBoot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 order: _builtins.float,
                 load_parm: Optional[_builtins.str] = None):
        """
        :param _builtins.float order: Sets the boot priority for this redirected device, as a positive integer where lower values are tried earlier during guest boot (for example, 1 for first, 2 for second).
               
               See: <https://libvirt.org/formatdomain.html#specifying-boot-order>
        :param _builtins.str load_parm: Sets an optional firmware load parameter string associated with booting from this redirected device, passed to firmware on platforms that support loadparm (e.g. s390x).
               
               See: <https://libvirt.org/formatdomain.html#specifying-boot-order>
        """
        pulumi.set(__self__, "order", order)
        if load_parm is not None:
            pulumi.set(__self__, "load_parm", load_parm)

    @_builtins.property
    @pulumi.getter
    def order(self) -> _builtins.float:
        """
        Sets the boot priority for this redirected device, as a positive integer where lower values are tried earlier during guest boot (for example, 1 for first, 2 for second).

        See: <https://libvirt.org/formatdomain.html#specifying-boot-order>
        """
        return pulumi.get(self, "order")

    @_builtins.property
    @pulumi.getter(name="loadParm")
    def load_parm(self) -> Optional[_builtins.str]:
        """
        Sets an optional firmware load parameter string associated with booting from this redirected device, passed to firmware on platforms that support loadparm (e.g. s390x).

        See: <https://libvirt.org/formatdomain.html#specifying-boot-order>
        """
        return pulumi.get(self, "load_parm")


@pulumi.output_type
class DomainDevicesDiskDriver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyOnRead":
            suggest = "copy_on_read"
        elif key == "detectZeros":
            suggest = "detect_zeros"
        elif key == "discardNoUnref":
            suggest = "discard_no_unref"
        elif key == "errorPolicy":
            suggest = "error_policy"
        elif key == "eventIdx":
            suggest = "event_idx"
        elif key == "ioEventFd":
            suggest = "io_event_fd"
        elif key == "ioThread":
            suggest = "io_thread"
        elif key == "ioThreads":
            suggest = "io_threads"
        elif key == "metadataCache":
            suggest = "metadata_cache"
        elif key == "pagePerVq":
            suggest = "page_per_vq"
        elif key == "queueSize":
            suggest = "queue_size"
        elif key == "rerrorPolicy":
            suggest = "rerror_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskDriver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskDriver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskDriver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ats: Optional[_builtins.str] = None,
                 cache: Optional[_builtins.str] = None,
                 copy_on_read: Optional[_builtins.str] = None,
                 detect_zeros: Optional[_builtins.str] = None,
                 discard: Optional[_builtins.str] = None,
                 discard_no_unref: Optional[_builtins.str] = None,
                 error_policy: Optional[_builtins.str] = None,
                 event_idx: Optional[_builtins.str] = None,
                 io: Optional[_builtins.str] = None,
                 io_event_fd: Optional[_builtins.str] = None,
                 io_thread: Optional[_builtins.float] = None,
                 io_threads: Optional['outputs.DomainDevicesDiskDriverIoThreads'] = None,
                 iommu: Optional[_builtins.str] = None,
                 metadata_cache: Optional['outputs.DomainDevicesDiskDriverMetadataCache'] = None,
                 name: Optional[_builtins.str] = None,
                 packed: Optional[_builtins.str] = None,
                 page_per_vq: Optional[_builtins.str] = None,
                 queue_size: Optional[_builtins.float] = None,
                 queues: Optional[_builtins.float] = None,
                 rerror_policy: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str ats: Configures whether the virtio disk uses Address Translation Service (ATS) on the virtio transport; accepts "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.str cache: Sets the host-side cache mode for the disk I/O, using libvirt/QEMU cache policies such as "none", "writeback", or "writethrough"; the exact string is user-provided but must be a valid cache mode for the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str copy_on_read: Controls the disk copy-on-read behavior (e.g. forcing data into cache when read) using a yes/no style value such as "on"/"off"; the exact string is user-provided but must be supported by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str detect_zeros: Sets how the disk driver handles writes of zero blocks (e.g. "on", "off", or "unmap") to allow optimization or discard; the string must be one of the modes supported by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str discard: Configures whether and how discard/TRIM requests are passed from the guest to the backing storage (for example "unmap" or "ignore"); the value must be a discard mode supported by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str discard_no_unref: Controls whether discard operations avoid the QEMU "unref" optimization, using a driver-specific yes/no style flag; the exact value is user-provided but must be supported by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str error_policy: Sets the action taken by the hypervisor on I/O errors for this disk (for example "stop", "ignore", "enospace", or "report"); the string must be one of the error policies supported by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str event_idx: Enables or disables the virtio "event_idx" optimization for the disk, using a yes/no style value such as "on"/"off".
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str io: Selects the I/O mode for accessing the disk (for example "threads" or "native"); the value is user-provided but must match a valid I/O mode supported by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str io_event_fd: Controls whether ioeventfd is used for this disk device to optimize I/O notification, using a yes/no style value such as "on"/"off".
               
               See: <https://libvirt.org/formatdomain.html#devices>
        :param _builtins.float io_thread: Assigns the disk to a specific IOThread by numeric id, matching an IOThread defined in the domain; the value is user-provided and must reference an existing IOThread.
               
               See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
        :param 'DomainDevicesDiskDriverIoThreadsArgs' io_threads: Defines per-disk IOThread mapping information, allowing this disk to use one or more dedicated IOThreads instead of the default I/O path.
        :param _builtins.str iommu: Enables or disables use of an emulated IOMMU for this disk device on the virtio transport, using "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param 'DomainDevicesDiskDriverMetadataCacheArgs' metadata_cache: Configures metadata cache behavior for the mirrored backing stores data store format (for example, limiting the size of cached metadata).
        :param _builtins.str name: Sets the underlying disk driver implementation name, typically a string such as "qemu" to control which backend handles the disk.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str packed: Controls whether the virtio-blk device uses packed virtqueue layout; accepts "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.str page_per_vq: Controls whether the virtio device uses a separate page per virtqueue for virtqueue descriptors; accepts "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.float queue_size: Sets the virtqueue size (number of entries) for this disks virtio queue as a positive integer, if supported by the driver.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.float queues: Sets the number of virtio I/O queues for this disk, as a positive integer, to enable multiqueue operation.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str rerror_policy: Sets the policy for handling read errors on the disk, typically one of "ignore", "stop", or driver-specific values.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str type: Sets the on-disk image format for the disk driver, such as "raw", "qcow2", or other user-provided format strings supported by qemu.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if ats is not None:
            pulumi.set(__self__, "ats", ats)
        if cache is not None:
            pulumi.set(__self__, "cache", cache)
        if copy_on_read is not None:
            pulumi.set(__self__, "copy_on_read", copy_on_read)
        if detect_zeros is not None:
            pulumi.set(__self__, "detect_zeros", detect_zeros)
        if discard is not None:
            pulumi.set(__self__, "discard", discard)
        if discard_no_unref is not None:
            pulumi.set(__self__, "discard_no_unref", discard_no_unref)
        if error_policy is not None:
            pulumi.set(__self__, "error_policy", error_policy)
        if event_idx is not None:
            pulumi.set(__self__, "event_idx", event_idx)
        if io is not None:
            pulumi.set(__self__, "io", io)
        if io_event_fd is not None:
            pulumi.set(__self__, "io_event_fd", io_event_fd)
        if io_thread is not None:
            pulumi.set(__self__, "io_thread", io_thread)
        if io_threads is not None:
            pulumi.set(__self__, "io_threads", io_threads)
        if iommu is not None:
            pulumi.set(__self__, "iommu", iommu)
        if metadata_cache is not None:
            pulumi.set(__self__, "metadata_cache", metadata_cache)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if packed is not None:
            pulumi.set(__self__, "packed", packed)
        if page_per_vq is not None:
            pulumi.set(__self__, "page_per_vq", page_per_vq)
        if queue_size is not None:
            pulumi.set(__self__, "queue_size", queue_size)
        if queues is not None:
            pulumi.set(__self__, "queues", queues)
        if rerror_policy is not None:
            pulumi.set(__self__, "rerror_policy", rerror_policy)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def ats(self) -> Optional[_builtins.str]:
        """
        Configures whether the virtio disk uses Address Translation Service (ATS) on the virtio transport; accepts "on" or "off".

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "ats")

    @_builtins.property
    @pulumi.getter
    def cache(self) -> Optional[_builtins.str]:
        """
        Sets the host-side cache mode for the disk I/O, using libvirt/QEMU cache policies such as "none", "writeback", or "writethrough"; the exact string is user-provided but must be a valid cache mode for the hypervisor.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "cache")

    @_builtins.property
    @pulumi.getter(name="copyOnRead")
    def copy_on_read(self) -> Optional[_builtins.str]:
        """
        Controls the disk copy-on-read behavior (e.g. forcing data into cache when read) using a yes/no style value such as "on"/"off"; the exact string is user-provided but must be supported by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "copy_on_read")

    @_builtins.property
    @pulumi.getter(name="detectZeros")
    def detect_zeros(self) -> Optional[_builtins.str]:
        """
        Sets how the disk driver handles writes of zero blocks (e.g. "on", "off", or "unmap") to allow optimization or discard; the string must be one of the modes supported by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "detect_zeros")

    @_builtins.property
    @pulumi.getter
    def discard(self) -> Optional[_builtins.str]:
        """
        Configures whether and how discard/TRIM requests are passed from the guest to the backing storage (for example "unmap" or "ignore"); the value must be a discard mode supported by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "discard")

    @_builtins.property
    @pulumi.getter(name="discardNoUnref")
    def discard_no_unref(self) -> Optional[_builtins.str]:
        """
        Controls whether discard operations avoid the QEMU "unref" optimization, using a driver-specific yes/no style flag; the exact value is user-provided but must be supported by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "discard_no_unref")

    @_builtins.property
    @pulumi.getter(name="errorPolicy")
    def error_policy(self) -> Optional[_builtins.str]:
        """
        Sets the action taken by the hypervisor on I/O errors for this disk (for example "stop", "ignore", "enospace", or "report"); the string must be one of the error policies supported by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "error_policy")

    @_builtins.property
    @pulumi.getter(name="eventIdx")
    def event_idx(self) -> Optional[_builtins.str]:
        """
        Enables or disables the virtio "event_idx" optimization for the disk, using a yes/no style value such as "on"/"off".

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "event_idx")

    @_builtins.property
    @pulumi.getter
    def io(self) -> Optional[_builtins.str]:
        """
        Selects the I/O mode for accessing the disk (for example "threads" or "native"); the value is user-provided but must match a valid I/O mode supported by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "io")

    @_builtins.property
    @pulumi.getter(name="ioEventFd")
    def io_event_fd(self) -> Optional[_builtins.str]:
        """
        Controls whether ioeventfd is used for this disk device to optimize I/O notification, using a yes/no style value such as "on"/"off".

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "io_event_fd")

    @_builtins.property
    @pulumi.getter(name="ioThread")
    def io_thread(self) -> Optional[_builtins.float]:
        """
        Assigns the disk to a specific IOThread by numeric id, matching an IOThread defined in the domain; the value is user-provided and must reference an existing IOThread.

        See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
        """
        return pulumi.get(self, "io_thread")

    @_builtins.property
    @pulumi.getter(name="ioThreads")
    def io_threads(self) -> Optional['outputs.DomainDevicesDiskDriverIoThreads']:
        """
        Defines per-disk IOThread mapping information, allowing this disk to use one or more dedicated IOThreads instead of the default I/O path.
        """
        return pulumi.get(self, "io_threads")

    @_builtins.property
    @pulumi.getter
    def iommu(self) -> Optional[_builtins.str]:
        """
        Enables or disables use of an emulated IOMMU for this disk device on the virtio transport, using "on" or "off".

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "iommu")

    @_builtins.property
    @pulumi.getter(name="metadataCache")
    def metadata_cache(self) -> Optional['outputs.DomainDevicesDiskDriverMetadataCache']:
        """
        Configures metadata cache behavior for the mirrored backing stores data store format (for example, limiting the size of cached metadata).
        """
        return pulumi.get(self, "metadata_cache")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the underlying disk driver implementation name, typically a string such as "qemu" to control which backend handles the disk.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def packed(self) -> Optional[_builtins.str]:
        """
        Controls whether the virtio-blk device uses packed virtqueue layout; accepts "on" or "off".

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "packed")

    @_builtins.property
    @pulumi.getter(name="pagePerVq")
    def page_per_vq(self) -> Optional[_builtins.str]:
        """
        Controls whether the virtio device uses a separate page per virtqueue for virtqueue descriptors; accepts "on" or "off".

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "page_per_vq")

    @_builtins.property
    @pulumi.getter(name="queueSize")
    def queue_size(self) -> Optional[_builtins.float]:
        """
        Sets the virtqueue size (number of entries) for this disks virtio queue as a positive integer, if supported by the driver.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "queue_size")

    @_builtins.property
    @pulumi.getter
    def queues(self) -> Optional[_builtins.float]:
        """
        Sets the number of virtio I/O queues for this disk, as a positive integer, to enable multiqueue operation.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "queues")

    @_builtins.property
    @pulumi.getter(name="rerrorPolicy")
    def rerror_policy(self) -> Optional[_builtins.str]:
        """
        Sets the policy for handling read errors on the disk, typically one of "ignore", "stop", or driver-specific values.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "rerror_policy")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Sets the on-disk image format for the disk driver, such as "raw", "qcow2", or other user-provided format strings supported by qemu.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainDevicesDiskDriverIoThreads(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ioThreads":
            suggest = "io_threads"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskDriverIoThreads. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskDriverIoThreads.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskDriverIoThreads.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 io_threads: Optional[Sequence['outputs.DomainDevicesDiskDriverIoThreadsIoThread']] = None):
        """
        :param Sequence['DomainDevicesDiskDriverIoThreadsIoThreadArgs'] io_threads: Describes a single IOThread mapping entry for this disk, potentially distributing disk queues across IOThreads.
               
               See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
        """
        if io_threads is not None:
            pulumi.set(__self__, "io_threads", io_threads)

    @_builtins.property
    @pulumi.getter(name="ioThreads")
    def io_threads(self) -> Optional[Sequence['outputs.DomainDevicesDiskDriverIoThreadsIoThread']]:
        """
        Describes a single IOThread mapping entry for this disk, potentially distributing disk queues across IOThreads.

        See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
        """
        return pulumi.get(self, "io_threads")


@pulumi.output_type
class DomainDevicesDiskDriverIoThreadsIoThread(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.float] = None,
                 queues: Optional[Sequence['outputs.DomainDevicesDiskDriverIoThreadsIoThreadQueue']] = None):
        """
        :param _builtins.float id: Reports the IOThread id associated with this mapping entry; it is computed from the existing IOThread configuration and not set by the user.
               
               See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
        :param Sequence['DomainDevicesDiskDriverIoThreadsIoThreadQueueArgs'] queues: Lists one or more queue elements to bind specific disk queues to this IOThread; the values are user-provided queue identifiers.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if queues is not None:
            pulumi.set(__self__, "queues", queues)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.float]:
        """
        Reports the IOThread id associated with this mapping entry; it is computed from the existing IOThread configuration and not set by the user.

        See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def queues(self) -> Optional[Sequence['outputs.DomainDevicesDiskDriverIoThreadsIoThreadQueue']]:
        """
        Lists one or more queue elements to bind specific disk queues to this IOThread; the values are user-provided queue identifiers.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "queues")


@pulumi.output_type
class DomainDevicesDiskDriverIoThreadsIoThreadQueue(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.float] = None):
        """
        :param _builtins.float id: Reports the identifier of a disk queue associated with this IOThread; it is computed and not directly set by the user.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.float]:
        """
        Reports the identifier of a disk queue associated with this IOThread; it is computed and not directly set by the user.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class DomainDevicesDiskDriverMetadataCache(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSize":
            suggest = "max_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskDriverMetadataCache. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskDriverMetadataCache.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskDriverMetadataCache.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_size: Optional['outputs.DomainDevicesDiskDriverMetadataCacheMaxSize'] = None):
        """
        :param 'DomainDevicesDiskDriverMetadataCacheMaxSizeArgs' max_size: Sets the maximum size of the metadata cache used by the data store format; value and unit together define the limit (for example, 64 MiB).
        """
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional['outputs.DomainDevicesDiskDriverMetadataCacheMaxSize']:
        """
        Sets the maximum size of the metadata cache used by the data store format; value and unit together define the limit (for example, 64 MiB).
        """
        return pulumi.get(self, "max_size")


@pulumi.output_type
class DomainDevicesDiskDriverMetadataCacheMaxSize(dict):
    def __init__(__self__, *,
                 value: _builtins.float,
                 unit: Optional[_builtins.str] = None):
        """
        :param _builtins.float value: Sets the numeric value for the metadata cache maximum size in the specified unit; this must be a positive integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str unit: Sets the unit used for the metadata cache maximum size; valid units follow libvirt size units such as "B", "KiB", "MiB", "GiB" and are user-chosen.
               
               See: <https://libvirt.org/formatdomain.html#memory-allocation>
        """
        pulumi.set(__self__, "value", value)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.float:
        """
        Sets the numeric value for the metadata cache maximum size in the specified unit; this must be a positive integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        """
        Sets the unit used for the metadata cache maximum size; valid units follow libvirt size units such as "B", "KiB", "MiB", "GiB" and are user-chosen.

        See: <https://libvirt.org/formatdomain.html#memory-allocation>
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class DomainDevicesDiskEncryption(dict):
    def __init__(__self__, *,
                 engine: Optional[_builtins.str] = None,
                 format: Optional[_builtins.str] = None,
                 secrets: Optional[Sequence['outputs.DomainDevicesDiskEncryptionSecret']] = None):
        """
        :param _builtins.str engine: Sets the encryption engine/provider to use for the disk (user-provided string, e.g. implementation-specific engine name).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str format: Sets the disk encryption format, such as "luks" or another user-provided scheme supported by libvirt/qemu.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param Sequence['DomainDevicesDiskEncryptionSecretArgs'] secrets: Defines one or more secret references used to access the encrypted disk, each describing how libvirt locates the secret material.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if engine is not None:
            pulumi.set(__self__, "engine", engine)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def engine(self) -> Optional[_builtins.str]:
        """
        Sets the encryption engine/provider to use for the disk (user-provided string, e.g. implementation-specific engine name).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "engine")

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[_builtins.str]:
        """
        Sets the disk encryption format, such as "luks" or another user-provided scheme supported by libvirt/qemu.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[Sequence['outputs.DomainDevicesDiskEncryptionSecret']]:
        """
        Defines one or more secret references used to access the encrypted disk, each describing how libvirt locates the secret material.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class DomainDevicesDiskEncryptionSecret(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 usage: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str usage: Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str uuid: Exposes the UUID of the libvirt secret used for iSCSI authentication; this is computed from the referenced secret rather than configured directly.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def usage(self) -> Optional[_builtins.str]:
        """
        Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "usage")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        Exposes the UUID of the libvirt secret used for iSCSI authentication; this is computed from the referenced secret rather than configured directly.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class DomainDevicesDiskGeometry(dict):
    def __init__(__self__, *,
                 cylinders: _builtins.float,
                 headers: _builtins.float,
                 sectors: _builtins.float,
                 trans: Optional[_builtins.str] = None):
        """
        :param _builtins.float cylinders: Sets the number of cylinders in the emulated disk geometry as a positive integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.float headers: Sets the number of heads in the emulated disk geometry as a positive integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.float sectors: Sets the number of sectors per track in the emulated disk geometry as a positive integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str trans: Sets the translation mode for mapping logical CHS geometry to physical layout, with user-provided values such as "auto", "none", or hypervisor-specific modes.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "cylinders", cylinders)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "sectors", sectors)
        if trans is not None:
            pulumi.set(__self__, "trans", trans)

    @_builtins.property
    @pulumi.getter
    def cylinders(self) -> _builtins.float:
        """
        Sets the number of cylinders in the emulated disk geometry as a positive integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "cylinders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> _builtins.float:
        """
        Sets the number of heads in the emulated disk geometry as a positive integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter
    def sectors(self) -> _builtins.float:
        """
        Sets the number of sectors per track in the emulated disk geometry as a positive integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "sectors")

    @_builtins.property
    @pulumi.getter
    def trans(self) -> Optional[_builtins.str]:
        """
        Sets the translation mode for mapping logical CHS geometry to physical layout, with user-provided values such as "auto", "none", or hypervisor-specific modes.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "trans")


@pulumi.output_type
class DomainDevicesDiskIoTune(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupName":
            suggest = "group_name"
        elif key == "readBytesSec":
            suggest = "read_bytes_sec"
        elif key == "readBytesSecMax":
            suggest = "read_bytes_sec_max"
        elif key == "readBytesSecMaxLength":
            suggest = "read_bytes_sec_max_length"
        elif key == "readIopsSec":
            suggest = "read_iops_sec"
        elif key == "readIopsSecMax":
            suggest = "read_iops_sec_max"
        elif key == "readIopsSecMaxLength":
            suggest = "read_iops_sec_max_length"
        elif key == "sizeIopsSec":
            suggest = "size_iops_sec"
        elif key == "totalBytesSec":
            suggest = "total_bytes_sec"
        elif key == "totalBytesSecMax":
            suggest = "total_bytes_sec_max"
        elif key == "totalBytesSecMaxLength":
            suggest = "total_bytes_sec_max_length"
        elif key == "totalIopsSec":
            suggest = "total_iops_sec"
        elif key == "totalIopsSecMax":
            suggest = "total_iops_sec_max"
        elif key == "totalIopsSecMaxLength":
            suggest = "total_iops_sec_max_length"
        elif key == "writeBytesSec":
            suggest = "write_bytes_sec"
        elif key == "writeBytesSecMax":
            suggest = "write_bytes_sec_max"
        elif key == "writeBytesSecMaxLength":
            suggest = "write_bytes_sec_max_length"
        elif key == "writeIopsSec":
            suggest = "write_iops_sec"
        elif key == "writeIopsSecMax":
            suggest = "write_iops_sec_max"
        elif key == "writeIopsSecMaxLength":
            suggest = "write_iops_sec_max_length"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskIoTune. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskIoTune.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskIoTune.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_name: Optional[_builtins.str] = None,
                 read_bytes_sec: Optional[_builtins.float] = None,
                 read_bytes_sec_max: Optional[_builtins.float] = None,
                 read_bytes_sec_max_length: Optional[_builtins.float] = None,
                 read_iops_sec: Optional[_builtins.float] = None,
                 read_iops_sec_max: Optional[_builtins.float] = None,
                 read_iops_sec_max_length: Optional[_builtins.float] = None,
                 size_iops_sec: Optional[_builtins.float] = None,
                 total_bytes_sec: Optional[_builtins.float] = None,
                 total_bytes_sec_max: Optional[_builtins.float] = None,
                 total_bytes_sec_max_length: Optional[_builtins.float] = None,
                 total_iops_sec: Optional[_builtins.float] = None,
                 total_iops_sec_max: Optional[_builtins.float] = None,
                 total_iops_sec_max_length: Optional[_builtins.float] = None,
                 write_bytes_sec: Optional[_builtins.float] = None,
                 write_bytes_sec_max: Optional[_builtins.float] = None,
                 write_bytes_sec_max_length: Optional[_builtins.float] = None,
                 write_iops_sec: Optional[_builtins.float] = None,
                 write_iops_sec_max: Optional[_builtins.float] = None,
                 write_iops_sec_max_length: Optional[_builtins.float] = None):
        """
        :param _builtins.str group_name: Sets the name of the libvirt disk throttle group that this disks I/O limits belong to, allowing multiple disks to share combined throttling; the value is user-provided and must match a defined throttle group if used.
               
               See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        :param _builtins.float read_bytes_sec: Sets the sustained limit, in bytes per second, for read operations on this disk; value is a user-provided nonnegative integer (e.g. 10485760 for 10 MiB/s).
               
               See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        :param _builtins.float read_bytes_sec_max: Sets the maximum burst read bandwidth limit, in bytes per second, that can be used when bursting above the sustained read_bytes_sec rate; value is a user-provided nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        :param _builtins.float read_bytes_sec_max_length: Sets the duration, in seconds, over which the read_bytes_sec_max burst bandwidth may be applied; value is a user-provided nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        :param _builtins.float read_iops_sec: Sets the sustained limit, in I/O operations per second, for read operations on this disk; value is a user-provided nonnegative integer (e.g. 1000 for 1000 read IOPS).
               
               See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        :param _builtins.float read_iops_sec_max: Sets the maximum burst read IOPS limit, in operations per second, that can be used when bursting above the sustained read_iops_sec rate; value is a user-provided nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        :param _builtins.float read_iops_sec_max_length: Sets the duration, in seconds, over which the read_iops_sec_max burst IOPS may be applied; value is a user-provided nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        :param _builtins.float size_iops_sec: Sets the minimum request size, in bytes, that counts as a single I/O when enforcing IOPS limits (smaller requests may be aggregated); value is a user-provided nonnegative integer (e.g. 4096 for 4 KiB).
               
               See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        :param _builtins.float total_bytes_sec: Sets the sustained combined limit, in bytes per second, for both read and write operations on this disk; value is a user-provided nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        :param _builtins.float total_bytes_sec_max: Sets the maximum burst combined bandwidth limit, in bytes per second, for both reads and writes when bursting above total_bytes_sec; value is a user-provided nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        :param _builtins.float total_bytes_sec_max_length: Sets the duration, in seconds, over which the total_bytes_sec_max burst combined bandwidth may be applied; value is a user-provided nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        :param _builtins.float total_iops_sec: Sets the sustained combined limit, in I/O operations per second, for both read and write operations on this disk; value is a user-provided nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        :param _builtins.float total_iops_sec_max: Sets the maximum burst combined IOPS limit, in operations per second, for both reads and writes when bursting above total_iops_sec; value is a user-provided nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        :param _builtins.float total_iops_sec_max_length: Sets the duration, in seconds, over which the total_iops_sec_max burst combined IOPS may be applied; value is a user-provided nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        :param _builtins.float write_bytes_sec: Sets the sustained limit, in bytes per second, for write operations on this disk; value is a user-provided nonnegative integer (e.g. 5242880 for 5 MiB/s).
               
               See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        :param _builtins.float write_bytes_sec_max: Sets the maximum burst write bandwidth limit, in bytes per second, that can be used when bursting above the sustained write_bytes_sec rate; value is a user-provided nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        :param _builtins.float write_bytes_sec_max_length: Sets the duration, in seconds, over which the write_bytes_sec_max burst bandwidth may be applied; value is a user-provided nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        :param _builtins.float write_iops_sec: Sets the sustained limit, in I/O operations per second, for write operations on this disk; value is a user-provided nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        :param _builtins.float write_iops_sec_max: Sets the maximum burst write IOPS limit, in operations per second, that can be used when bursting above the sustained write_iops_sec rate; value is a user-provided nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        :param _builtins.float write_iops_sec_max_length: Sets the maximum length of a temporary burst period for the write IOPS limit, in seconds, used together with write_iops_sec_max to control short-term spikes in disk write operations.
               
               See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if read_bytes_sec is not None:
            pulumi.set(__self__, "read_bytes_sec", read_bytes_sec)
        if read_bytes_sec_max is not None:
            pulumi.set(__self__, "read_bytes_sec_max", read_bytes_sec_max)
        if read_bytes_sec_max_length is not None:
            pulumi.set(__self__, "read_bytes_sec_max_length", read_bytes_sec_max_length)
        if read_iops_sec is not None:
            pulumi.set(__self__, "read_iops_sec", read_iops_sec)
        if read_iops_sec_max is not None:
            pulumi.set(__self__, "read_iops_sec_max", read_iops_sec_max)
        if read_iops_sec_max_length is not None:
            pulumi.set(__self__, "read_iops_sec_max_length", read_iops_sec_max_length)
        if size_iops_sec is not None:
            pulumi.set(__self__, "size_iops_sec", size_iops_sec)
        if total_bytes_sec is not None:
            pulumi.set(__self__, "total_bytes_sec", total_bytes_sec)
        if total_bytes_sec_max is not None:
            pulumi.set(__self__, "total_bytes_sec_max", total_bytes_sec_max)
        if total_bytes_sec_max_length is not None:
            pulumi.set(__self__, "total_bytes_sec_max_length", total_bytes_sec_max_length)
        if total_iops_sec is not None:
            pulumi.set(__self__, "total_iops_sec", total_iops_sec)
        if total_iops_sec_max is not None:
            pulumi.set(__self__, "total_iops_sec_max", total_iops_sec_max)
        if total_iops_sec_max_length is not None:
            pulumi.set(__self__, "total_iops_sec_max_length", total_iops_sec_max_length)
        if write_bytes_sec is not None:
            pulumi.set(__self__, "write_bytes_sec", write_bytes_sec)
        if write_bytes_sec_max is not None:
            pulumi.set(__self__, "write_bytes_sec_max", write_bytes_sec_max)
        if write_bytes_sec_max_length is not None:
            pulumi.set(__self__, "write_bytes_sec_max_length", write_bytes_sec_max_length)
        if write_iops_sec is not None:
            pulumi.set(__self__, "write_iops_sec", write_iops_sec)
        if write_iops_sec_max is not None:
            pulumi.set(__self__, "write_iops_sec_max", write_iops_sec_max)
        if write_iops_sec_max_length is not None:
            pulumi.set(__self__, "write_iops_sec_max_length", write_iops_sec_max_length)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[_builtins.str]:
        """
        Sets the name of the libvirt disk throttle group that this disks I/O limits belong to, allowing multiple disks to share combined throttling; the value is user-provided and must match a defined throttle group if used.

        See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        """
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter(name="readBytesSec")
    def read_bytes_sec(self) -> Optional[_builtins.float]:
        """
        Sets the sustained limit, in bytes per second, for read operations on this disk; value is a user-provided nonnegative integer (e.g. 10485760 for 10 MiB/s).

        See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        return pulumi.get(self, "read_bytes_sec")

    @_builtins.property
    @pulumi.getter(name="readBytesSecMax")
    def read_bytes_sec_max(self) -> Optional[_builtins.float]:
        """
        Sets the maximum burst read bandwidth limit, in bytes per second, that can be used when bursting above the sustained read_bytes_sec rate; value is a user-provided nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        return pulumi.get(self, "read_bytes_sec_max")

    @_builtins.property
    @pulumi.getter(name="readBytesSecMaxLength")
    def read_bytes_sec_max_length(self) -> Optional[_builtins.float]:
        """
        Sets the duration, in seconds, over which the read_bytes_sec_max burst bandwidth may be applied; value is a user-provided nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        return pulumi.get(self, "read_bytes_sec_max_length")

    @_builtins.property
    @pulumi.getter(name="readIopsSec")
    def read_iops_sec(self) -> Optional[_builtins.float]:
        """
        Sets the sustained limit, in I/O operations per second, for read operations on this disk; value is a user-provided nonnegative integer (e.g. 1000 for 1000 read IOPS).

        See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        return pulumi.get(self, "read_iops_sec")

    @_builtins.property
    @pulumi.getter(name="readIopsSecMax")
    def read_iops_sec_max(self) -> Optional[_builtins.float]:
        """
        Sets the maximum burst read IOPS limit, in operations per second, that can be used when bursting above the sustained read_iops_sec rate; value is a user-provided nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        return pulumi.get(self, "read_iops_sec_max")

    @_builtins.property
    @pulumi.getter(name="readIopsSecMaxLength")
    def read_iops_sec_max_length(self) -> Optional[_builtins.float]:
        """
        Sets the duration, in seconds, over which the read_iops_sec_max burst IOPS may be applied; value is a user-provided nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        return pulumi.get(self, "read_iops_sec_max_length")

    @_builtins.property
    @pulumi.getter(name="sizeIopsSec")
    def size_iops_sec(self) -> Optional[_builtins.float]:
        """
        Sets the minimum request size, in bytes, that counts as a single I/O when enforcing IOPS limits (smaller requests may be aggregated); value is a user-provided nonnegative integer (e.g. 4096 for 4 KiB).

        See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        return pulumi.get(self, "size_iops_sec")

    @_builtins.property
    @pulumi.getter(name="totalBytesSec")
    def total_bytes_sec(self) -> Optional[_builtins.float]:
        """
        Sets the sustained combined limit, in bytes per second, for both read and write operations on this disk; value is a user-provided nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        return pulumi.get(self, "total_bytes_sec")

    @_builtins.property
    @pulumi.getter(name="totalBytesSecMax")
    def total_bytes_sec_max(self) -> Optional[_builtins.float]:
        """
        Sets the maximum burst combined bandwidth limit, in bytes per second, for both reads and writes when bursting above total_bytes_sec; value is a user-provided nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        return pulumi.get(self, "total_bytes_sec_max")

    @_builtins.property
    @pulumi.getter(name="totalBytesSecMaxLength")
    def total_bytes_sec_max_length(self) -> Optional[_builtins.float]:
        """
        Sets the duration, in seconds, over which the total_bytes_sec_max burst combined bandwidth may be applied; value is a user-provided nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        return pulumi.get(self, "total_bytes_sec_max_length")

    @_builtins.property
    @pulumi.getter(name="totalIopsSec")
    def total_iops_sec(self) -> Optional[_builtins.float]:
        """
        Sets the sustained combined limit, in I/O operations per second, for both read and write operations on this disk; value is a user-provided nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        return pulumi.get(self, "total_iops_sec")

    @_builtins.property
    @pulumi.getter(name="totalIopsSecMax")
    def total_iops_sec_max(self) -> Optional[_builtins.float]:
        """
        Sets the maximum burst combined IOPS limit, in operations per second, for both reads and writes when bursting above total_iops_sec; value is a user-provided nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        return pulumi.get(self, "total_iops_sec_max")

    @_builtins.property
    @pulumi.getter(name="totalIopsSecMaxLength")
    def total_iops_sec_max_length(self) -> Optional[_builtins.float]:
        """
        Sets the duration, in seconds, over which the total_iops_sec_max burst combined IOPS may be applied; value is a user-provided nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        return pulumi.get(self, "total_iops_sec_max_length")

    @_builtins.property
    @pulumi.getter(name="writeBytesSec")
    def write_bytes_sec(self) -> Optional[_builtins.float]:
        """
        Sets the sustained limit, in bytes per second, for write operations on this disk; value is a user-provided nonnegative integer (e.g. 5242880 for 5 MiB/s).

        See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        return pulumi.get(self, "write_bytes_sec")

    @_builtins.property
    @pulumi.getter(name="writeBytesSecMax")
    def write_bytes_sec_max(self) -> Optional[_builtins.float]:
        """
        Sets the maximum burst write bandwidth limit, in bytes per second, that can be used when bursting above the sustained write_bytes_sec rate; value is a user-provided nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        return pulumi.get(self, "write_bytes_sec_max")

    @_builtins.property
    @pulumi.getter(name="writeBytesSecMaxLength")
    def write_bytes_sec_max_length(self) -> Optional[_builtins.float]:
        """
        Sets the duration, in seconds, over which the write_bytes_sec_max burst bandwidth may be applied; value is a user-provided nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        return pulumi.get(self, "write_bytes_sec_max_length")

    @_builtins.property
    @pulumi.getter(name="writeIopsSec")
    def write_iops_sec(self) -> Optional[_builtins.float]:
        """
        Sets the sustained limit, in I/O operations per second, for write operations on this disk; value is a user-provided nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        return pulumi.get(self, "write_iops_sec")

    @_builtins.property
    @pulumi.getter(name="writeIopsSecMax")
    def write_iops_sec_max(self) -> Optional[_builtins.float]:
        """
        Sets the maximum burst write IOPS limit, in operations per second, that can be used when bursting above the sustained write_iops_sec rate; value is a user-provided nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        return pulumi.get(self, "write_iops_sec_max")

    @_builtins.property
    @pulumi.getter(name="writeIopsSecMaxLength")
    def write_iops_sec_max_length(self) -> Optional[_builtins.float]:
        """
        Sets the maximum length of a temporary burst period for the write IOPS limit, in seconds, used together with write_iops_sec_max to control short-term spikes in disk write operations.

        See: <https://libvirt.org/formatdomain.html#block-i-o-tuning>
        """
        return pulumi.get(self, "write_iops_sec_max_length")


@pulumi.output_type
class DomainDevicesDiskMirror(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backingStore":
            suggest = "backing_store"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirror. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirror.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirror.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backing_store: Optional['outputs.DomainDevicesDiskMirrorBackingStore'] = None,
                 format: Optional['outputs.DomainDevicesDiskMirrorFormat'] = None,
                 job: Optional[_builtins.str] = None,
                 ready: Optional[_builtins.str] = None,
                 source: Optional['outputs.DomainDevicesDiskMirrorSource'] = None):
        """
        :param 'DomainDevicesDiskMirrorBackingStoreArgs' backing_store: Defines the backing store chain for the mirrored disk image, describing one layer of the underlying image stack used by the mirror target.
        :param 'DomainDevicesDiskMirrorFormatArgs' format: Configures the on-disk format settings for the mirrored backing stores data store, including format type and optional metadata cache tuning.
        :param _builtins.str job: Selects the mirroring job mode, such as whether the mirror should be a persistent replacement or a transient copy; the value is user-provided and must match a libvirt-supported job type.
        :param _builtins.str ready: Indicates whether the mirror is marked as ready to be switched to or used (typically a yes/no flag as a string, such as "yes" or "no").
        :param 'DomainDevicesDiskMirrorSourceArgs' source: Defines the data source for the mirror backing store, such as a block device or file path.
        """
        if backing_store is not None:
            pulumi.set(__self__, "backing_store", backing_store)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if job is not None:
            pulumi.set(__self__, "job", job)
        if ready is not None:
            pulumi.set(__self__, "ready", ready)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="backingStore")
    def backing_store(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStore']:
        """
        Defines the backing store chain for the mirrored disk image, describing one layer of the underlying image stack used by the mirror target.
        """
        return pulumi.get(self, "backing_store")

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional['outputs.DomainDevicesDiskMirrorFormat']:
        """
        Configures the on-disk format settings for the mirrored backing stores data store, including format type and optional metadata cache tuning.
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter
    def job(self) -> Optional[_builtins.str]:
        """
        Selects the mirroring job mode, such as whether the mirror should be a persistent replacement or a transient copy; the value is user-provided and must match a libvirt-supported job type.
        """
        return pulumi.get(self, "job")

    @_builtins.property
    @pulumi.getter
    def ready(self) -> Optional[_builtins.str]:
        """
        Indicates whether the mirror is marked as ready to be switched to or used (typically a yes/no flag as a string, such as "yes" or "no").
        """
        return pulumi.get(self, "ready")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainDevicesDiskMirrorSource']:
        """
        Defines the data source for the mirror backing store, such as a block device or file path.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStore(dict):
    def __init__(__self__, *,
                 format: Optional['outputs.DomainDevicesDiskMirrorBackingStoreFormat'] = None,
                 index: Optional[_builtins.float] = None,
                 source: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSource'] = None):
        """
        :param 'DomainDevicesDiskMirrorBackingStoreFormatArgs' format: Configures the on-disk format settings for the mirrored backing stores data store, including format type and optional metadata cache tuning.
        :param _builtins.float index: Sets the index of this backing store within the mirrors backing chain, as an integer used to order multiple backingStore entries.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainDevicesDiskMirrorBackingStoreSourceArgs' source: Defines the data source for the mirror backing store, such as a block device or file path.
        """
        if format is not None:
            pulumi.set(__self__, "format", format)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreFormat']:
        """
        Configures the on-disk format settings for the mirrored backing stores data store, including format type and optional metadata cache tuning.
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the index of this backing store within the mirrors backing chain, as an integer used to order multiple backingStore entries.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "index")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSource']:
        """
        Defines the data source for the mirror backing store, such as a block device or file path.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataCache":
            suggest = "metadata_cache"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 metadata_cache: Optional['outputs.DomainDevicesDiskMirrorBackingStoreFormatMetadataCache'] = None):
        """
        :param _builtins.str type: Sets the data store format type for the mirrored backing store (for example, "qcow2" or "raw"); the value is user-provided and must be a valid libvirt disk format name.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainDevicesDiskMirrorBackingStoreFormatMetadataCacheArgs' metadata_cache: Configures metadata cache behavior for the mirrored backing stores data store format (for example, limiting the size of cached metadata).
        """
        pulumi.set(__self__, "type", type)
        if metadata_cache is not None:
            pulumi.set(__self__, "metadata_cache", metadata_cache)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets the data store format type for the mirrored backing store (for example, "qcow2" or "raw"); the value is user-provided and must be a valid libvirt disk format name.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="metadataCache")
    def metadata_cache(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreFormatMetadataCache']:
        """
        Configures metadata cache behavior for the mirrored backing stores data store format (for example, limiting the size of cached metadata).
        """
        return pulumi.get(self, "metadata_cache")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreFormatMetadataCache(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSize":
            suggest = "max_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreFormatMetadataCache. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreFormatMetadataCache.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreFormatMetadataCache.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_size: Optional['outputs.DomainDevicesDiskMirrorBackingStoreFormatMetadataCacheMaxSize'] = None):
        """
        :param 'DomainDevicesDiskMirrorBackingStoreFormatMetadataCacheMaxSizeArgs' max_size: Sets the maximum size of the metadata cache used by the data store format; value and unit together define the limit (for example, 64 MiB).
        """
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreFormatMetadataCacheMaxSize']:
        """
        Sets the maximum size of the metadata cache used by the data store format; value and unit together define the limit (for example, 64 MiB).
        """
        return pulumi.get(self, "max_size")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreFormatMetadataCacheMaxSize(dict):
    def __init__(__self__, *,
                 value: _builtins.float,
                 unit: Optional[_builtins.str] = None):
        """
        :param _builtins.float value: Sets the numeric value for the metadata cache maximum size in the specified unit; this must be a positive integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str unit: Sets the unit used for the metadata cache maximum size; valid units follow libvirt size units such as "B", "KiB", "MiB", "GiB" and are user-chosen.
               
               See: <https://libvirt.org/formatdomain.html#memory-allocation>
        """
        pulumi.set(__self__, "value", value)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.float:
        """
        Sets the numeric value for the metadata cache maximum size in the specified unit; this must be a positive integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        """
        Sets the unit used for the metadata cache maximum size; valid units follow libvirt size units such as "B", "KiB", "MiB", "GiB" and are user-chosen.

        See: <https://libvirt.org/formatdomain.html#memory-allocation>
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataStore":
            suggest = "data_store"
        elif key == "startupPolicy":
            suggest = "startup_policy"
        elif key == "vhostUser":
            suggest = "vhost_user"
        elif key == "vhostVdpa":
            suggest = "vhost_vdpa"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceBlock'] = None,
                 cookies: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceCookies'] = None,
                 data_store: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceDataStore'] = None,
                 dir: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceDir'] = None,
                 encryption: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceEncryption'] = None,
                 file: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceFile'] = None,
                 index: Optional[_builtins.float] = None,
                 network: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceNetwork'] = None,
                 nvme: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceNvme'] = None,
                 readahead: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReadahead'] = None,
                 reservations: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservations'] = None,
                 slices: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceSlices'] = None,
                 ssl: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceSsl'] = None,
                 startup_policy: Optional[_builtins.str] = None,
                 timeout: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceTimeout'] = None,
                 vhost_user: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUser'] = None,
                 vhost_vdpa: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostVdpa'] = None,
                 volume: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVolume'] = None):
        """
        :param 'DomainDevicesDiskMirrorBackingStoreSourceBlockArgs' block: Describes a block device used as the source for the mirror backing store.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceCookiesArgs' cookies: Provides optional cookie data associated with the mirror backing store source (for example, auth or session data), with content treated as user-provided.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceDataStoreArgs' data_store: Configures a data store descriptor for the mirrored backing store, typically used with networked or advanced storage backends that expose format-specific options.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceDirArgs' dir: Configures a directory-based source for the mirrored backing store, pointing to a host directory used by the backing image.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceEncryptionArgs' encryption: Enables disk image encryption configuration for this disk and groups attributes defining the encryption engine, format, and secrets.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceFileArgs' file: Configures a file-based backing store source for the disk mirror, defining how the backing image is accessed from the host filesystem.
        :param _builtins.float index: Sets the index of this backing store within a backing chain, used when multiple backing layers are present; value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainDevicesDiskMirrorBackingStoreSourceNetworkArgs' network: Configures a network-based backing store source (such as NBD, iSCSI, or RBD) for the disk mirror, including authentication and host endpoints.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceNvmeArgs' nvme: Enables using an NVMe-backed source for the mirrored disks backing store; when present, it selects an NVMe device or namespace as the source, with details defined by libvirt/QEMU for NVMe disks.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceReadaheadArgs' readahead: Configures read-ahead behavior for the mirrored disks backing-store source, allowing tuning of how much data is pre-fetched from the backend.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceReservationsArgs' reservations: Configures SCSI-style reservations or similar persistent reservation management for the mirrored disks backing-store source, controlling how access is coordinated across nodes.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceSlicesArgs' slices: Configures optional slice or segment information for the backing store source (for example, to describe which logical slices of a device are used); content is user-provided.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceSslArgs' ssl: Enables SSL/TLS parameters for accessing the mirrored backing-store source when it is provided over a secure transport.
        :param _builtins.str startup_policy: Specifies how strictly the mirrored backing-store source must be available during domain startup; valid values include "mandatory", "requisite", "optional" (userprovided string matched by libvirt).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainDevicesDiskMirrorBackingStoreSourceTimeoutArgs' timeout: Configures a timeout for connecting to or initializing the mirrored backing-store source.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceVhostUserArgs' vhost_user: Selects a vhost-user backend as the transport for the mirrored backing-store source, allowing it to be provided via a userspace process.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceVhostVdpaArgs' vhost_vdpa: Selects a vhost-vDPA backend for the disk mirror backing store, allowing acceleration via a vDPA device; additional details are determined by libvirt and device configuration.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceVolumeArgs' volume: Configures the backingStore source as a libvirt storage volume reference instead of a raw file/block path for the mirrored disk.
        """
        if block is not None:
            pulumi.set(__self__, "block", block)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if data_store is not None:
            pulumi.set(__self__, "data_store", data_store)
        if dir is not None:
            pulumi.set(__self__, "dir", dir)
        if encryption is not None:
            pulumi.set(__self__, "encryption", encryption)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if nvme is not None:
            pulumi.set(__self__, "nvme", nvme)
        if readahead is not None:
            pulumi.set(__self__, "readahead", readahead)
        if reservations is not None:
            pulumi.set(__self__, "reservations", reservations)
        if slices is not None:
            pulumi.set(__self__, "slices", slices)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if startup_policy is not None:
            pulumi.set(__self__, "startup_policy", startup_policy)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if vhost_user is not None:
            pulumi.set(__self__, "vhost_user", vhost_user)
        if vhost_vdpa is not None:
            pulumi.set(__self__, "vhost_vdpa", vhost_vdpa)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceBlock']:
        """
        Describes a block device used as the source for the mirror backing store.
        """
        return pulumi.get(self, "block")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceCookies']:
        """
        Provides optional cookie data associated with the mirror backing store source (for example, auth or session data), with content treated as user-provided.
        """
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="dataStore")
    def data_store(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceDataStore']:
        """
        Configures a data store descriptor for the mirrored backing store, typically used with networked or advanced storage backends that expose format-specific options.
        """
        return pulumi.get(self, "data_store")

    @_builtins.property
    @pulumi.getter
    def dir(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceDir']:
        """
        Configures a directory-based source for the mirrored backing store, pointing to a host directory used by the backing image.
        """
        return pulumi.get(self, "dir")

    @_builtins.property
    @pulumi.getter
    def encryption(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceEncryption']:
        """
        Enables disk image encryption configuration for this disk and groups attributes defining the encryption engine, format, and secrets.
        """
        return pulumi.get(self, "encryption")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceFile']:
        """
        Configures a file-based backing store source for the disk mirror, defining how the backing image is accessed from the host filesystem.
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the index of this backing store within a backing chain, used when multiple backing layers are present; value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "index")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceNetwork']:
        """
        Configures a network-based backing store source (such as NBD, iSCSI, or RBD) for the disk mirror, including authentication and host endpoints.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def nvme(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceNvme']:
        """
        Enables using an NVMe-backed source for the mirrored disks backing store; when present, it selects an NVMe device or namespace as the source, with details defined by libvirt/QEMU for NVMe disks.
        """
        return pulumi.get(self, "nvme")

    @_builtins.property
    @pulumi.getter
    def readahead(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReadahead']:
        """
        Configures read-ahead behavior for the mirrored disks backing-store source, allowing tuning of how much data is pre-fetched from the backend.
        """
        return pulumi.get(self, "readahead")

    @_builtins.property
    @pulumi.getter
    def reservations(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservations']:
        """
        Configures SCSI-style reservations or similar persistent reservation management for the mirrored disks backing-store source, controlling how access is coordinated across nodes.
        """
        return pulumi.get(self, "reservations")

    @_builtins.property
    @pulumi.getter
    def slices(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceSlices']:
        """
        Configures optional slice or segment information for the backing store source (for example, to describe which logical slices of a device are used); content is user-provided.
        """
        return pulumi.get(self, "slices")

    @_builtins.property
    @pulumi.getter
    def ssl(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceSsl']:
        """
        Enables SSL/TLS parameters for accessing the mirrored backing-store source when it is provided over a secure transport.
        """
        return pulumi.get(self, "ssl")

    @_builtins.property
    @pulumi.getter(name="startupPolicy")
    def startup_policy(self) -> Optional[_builtins.str]:
        """
        Specifies how strictly the mirrored backing-store source must be available during domain startup; valid values include "mandatory", "requisite", "optional" (userprovided string matched by libvirt).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "startup_policy")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceTimeout']:
        """
        Configures a timeout for connecting to or initializing the mirrored backing-store source.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="vhostUser")
    def vhost_user(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUser']:
        """
        Selects a vhost-user backend as the transport for the mirrored backing-store source, allowing it to be provided via a userspace process.
        """
        return pulumi.get(self, "vhost_user")

    @_builtins.property
    @pulumi.getter(name="vhostVdpa")
    def vhost_vdpa(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostVdpa']:
        """
        Selects a vhost-vDPA backend for the disk mirror backing store, allowing acceleration via a vDPA device; additional details are determined by libvirt and device configuration.
        """
        return pulumi.get(self, "vhost_vdpa")

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVolume']:
        """
        Configures the backingStore source as a libvirt storage volume reference instead of a raw file/block path for the mirrored disk.
        """
        return pulumi.get(self, "volume")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceBlock(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceBlock. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceBlock.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceBlock.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dev: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceBlockSecLabel']] = None):
        """
        :param _builtins.str dev: Sets the host block device path used as the mirror backing store source (for example "/dev/sdb1"); the value is user-provided and must reference an existing block device.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param Sequence['DomainDevicesDiskMirrorBackingStoreSourceBlockSecLabelArgs'] sec_labels: Configures an optional security label for the block-device backing store of the mirror, controlling how security drivers label this source.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional[_builtins.str]:
        """
        Sets the host block device path used as the mirror backing store source (for example "/dev/sdb1"); the value is user-provided and must reference an existing block device.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceBlockSecLabel']]:
        """
        Configures an optional security label for the block-device backing store of the mirror, controlling how security drivers label this source.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceBlockSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceBlockSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceBlockSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceBlockSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceCookies(dict):
    def __init__(__self__, *,
                 cookies: Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceCookiesCookie']] = None):
        """
        :param Sequence['DomainDevicesDiskMirrorBackingStoreSourceCookiesCookieArgs'] cookies: Configures one or more HTTP cookies to be sent when accessing the mirrored backing store over a network protocol that supports cookies (for example, HTTPS or HTTP-based storage).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceCookiesCookie']]:
        """
        Configures one or more HTTP cookies to be sent when accessing the mirrored backing store over a network protocol that supports cookies (for example, HTTPS or HTTP-based storage).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "cookies")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceCookiesCookie(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Sets the cookie name for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "sessionid").
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str value: Sets the cookie value for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "abc123").
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the cookie name for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "sessionid").

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Sets the cookie value for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "abc123").

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceDataStore(dict):
    def __init__(__self__, *,
                 format: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceDataStoreFormat'] = None):
        """
        :param 'DomainDevicesDiskMirrorBackingStoreSourceDataStoreFormatArgs' format: Configures the on-disk format settings for the mirrored backing stores data store, including format type and optional metadata cache tuning.
        """
        if format is not None:
            pulumi.set(__self__, "format", format)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceDataStoreFormat']:
        """
        Configures the on-disk format settings for the mirrored backing stores data store, including format type and optional metadata cache tuning.
        """
        return pulumi.get(self, "format")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceDataStoreFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataCache":
            suggest = "metadata_cache"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceDataStoreFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceDataStoreFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceDataStoreFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 metadata_cache: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceDataStoreFormatMetadataCache'] = None):
        """
        :param _builtins.str type: Sets the data store format type for the mirrored backing store (for example, "qcow2" or "raw"); the value is user-provided and must be a valid libvirt disk format name.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainDevicesDiskMirrorBackingStoreSourceDataStoreFormatMetadataCacheArgs' metadata_cache: Configures metadata cache behavior for the mirrored backing stores data store format (for example, limiting the size of cached metadata).
        """
        pulumi.set(__self__, "type", type)
        if metadata_cache is not None:
            pulumi.set(__self__, "metadata_cache", metadata_cache)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets the data store format type for the mirrored backing store (for example, "qcow2" or "raw"); the value is user-provided and must be a valid libvirt disk format name.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="metadataCache")
    def metadata_cache(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceDataStoreFormatMetadataCache']:
        """
        Configures metadata cache behavior for the mirrored backing stores data store format (for example, limiting the size of cached metadata).
        """
        return pulumi.get(self, "metadata_cache")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceDataStoreFormatMetadataCache(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSize":
            suggest = "max_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceDataStoreFormatMetadataCache. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceDataStoreFormatMetadataCache.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceDataStoreFormatMetadataCache.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_size: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceDataStoreFormatMetadataCacheMaxSize'] = None):
        """
        :param 'DomainDevicesDiskMirrorBackingStoreSourceDataStoreFormatMetadataCacheMaxSizeArgs' max_size: Sets the maximum size of the metadata cache used by the data store format; value and unit together define the limit (for example, 64 MiB).
        """
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceDataStoreFormatMetadataCacheMaxSize']:
        """
        Sets the maximum size of the metadata cache used by the data store format; value and unit together define the limit (for example, 64 MiB).
        """
        return pulumi.get(self, "max_size")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceDataStoreFormatMetadataCacheMaxSize(dict):
    def __init__(__self__, *,
                 value: _builtins.float,
                 unit: Optional[_builtins.str] = None):
        """
        :param _builtins.float value: Sets the numeric value for the metadata cache maximum size in the specified unit; this must be a positive integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str unit: Sets the unit used for the metadata cache maximum size; valid units follow libvirt size units such as "B", "KiB", "MiB", "GiB" and are user-chosen.
               
               See: <https://libvirt.org/formatdomain.html#memory-allocation>
        """
        pulumi.set(__self__, "value", value)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.float:
        """
        Sets the numeric value for the metadata cache maximum size in the specified unit; this must be a positive integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        """
        Sets the unit used for the metadata cache maximum size; valid units follow libvirt size units such as "B", "KiB", "MiB", "GiB" and are user-chosen.

        See: <https://libvirt.org/formatdomain.html#memory-allocation>
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceDir(dict):
    def __init__(__self__, *,
                 dir: Optional[_builtins.str] = None):
        """
        :param _builtins.str dir: Sets the host directory path used as the mirrored backing store source; this must be an absolute path on the host (for example, "/var/lib/libvirt/images").
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if dir is not None:
            pulumi.set(__self__, "dir", dir)

    @_builtins.property
    @pulumi.getter
    def dir(self) -> Optional[_builtins.str]:
        """
        Sets the host directory path used as the mirrored backing store source; this must be an absolute path on the host (for example, "/var/lib/libvirt/images").

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "dir")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceEncryption(dict):
    def __init__(__self__, *,
                 engine: Optional[_builtins.str] = None,
                 format: Optional[_builtins.str] = None,
                 secrets: Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceEncryptionSecret']] = None):
        """
        :param _builtins.str engine: Sets the encryption engine/provider to use for the disk (user-provided string, e.g. implementation-specific engine name).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str format: Sets the disk encryption format, such as "luks" or another user-provided scheme supported by libvirt/qemu.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param Sequence['DomainDevicesDiskMirrorBackingStoreSourceEncryptionSecretArgs'] secrets: Defines one or more secret references used to access the encrypted disk, each describing how libvirt locates the secret material.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if engine is not None:
            pulumi.set(__self__, "engine", engine)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def engine(self) -> Optional[_builtins.str]:
        """
        Sets the encryption engine/provider to use for the disk (user-provided string, e.g. implementation-specific engine name).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "engine")

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[_builtins.str]:
        """
        Sets the disk encryption format, such as "luks" or another user-provided scheme supported by libvirt/qemu.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceEncryptionSecret']]:
        """
        Defines one or more secret references used to access the encrypted disk, each describing how libvirt locates the secret material.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceEncryptionSecret(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 usage: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str usage: Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str uuid: Exposes the UUID of the libvirt secret used for iSCSI authentication; this is computed from the referenced secret rather than configured directly.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def usage(self) -> Optional[_builtins.str]:
        """
        Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "usage")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        Exposes the UUID of the libvirt secret used for iSCSI authentication; this is computed from the referenced secret rather than configured directly.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fdGroup":
            suggest = "fd_group"
        elif key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fd_group: Optional[_builtins.str] = None,
                 file: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceFileSecLabel']] = None):
        """
        :param _builtins.str fd_group: Sets the name of an fdgroup whose pre-opened file descriptor is used for this backing store instead of opening the file path directly; value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str file: Sets the absolute path on the host to the backing file used as the source for this mirrored disk (for example, /var/lib/libvirt/images/base.qcow2).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param Sequence['DomainDevicesDiskMirrorBackingStoreSourceFileSecLabelArgs'] sec_labels: Configures an explicit security label for the file backing store, overriding default security driver labeling for this file.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if fd_group is not None:
            pulumi.set(__self__, "fd_group", fd_group)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter(name="fdGroup")
    def fd_group(self) -> Optional[_builtins.str]:
        """
        Sets the name of an fdgroup whose pre-opened file descriptor is used for this backing store instead of opening the file path directly; value is user-provided.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "fd_group")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional[_builtins.str]:
        """
        Sets the absolute path on the host to the backing file used as the source for this mirrored disk (for example, /var/lib/libvirt/images/base.qcow2).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceFileSecLabel']]:
        """
        Configures an explicit security label for the file backing store, overriding default security driver labeling for this file.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceFileSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceFileSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceFileSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceFileSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "knownHosts":
            suggest = "known_hosts"
        elif key == "tlsHostname":
            suggest = "tls_hostname"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceNetworkAuth'] = None,
                 config: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceNetworkConfig'] = None,
                 hosts: Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceNetworkHost']] = None,
                 identity: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceNetworkIdentity'] = None,
                 initiator: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceNetworkInitiator'] = None,
                 known_hosts: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceNetworkKnownHosts'] = None,
                 name: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 query: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceNetworkReconnect'] = None,
                 snapshot: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceNetworkSnapshot'] = None,
                 tls: Optional[_builtins.str] = None,
                 tls_hostname: Optional[_builtins.str] = None):
        """
        :param 'DomainDevicesDiskMirrorBackingStoreSourceNetworkAuthArgs' auth: Configures CHAP authentication parameters for the iSCSI source backing an assigned SCSI host device; include this block only when the target requires authentication.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceNetworkConfigArgs' config: Points to an external configuration source for the network backing store (for example, an RBD or Ceph config file) that libvirt passes to the backend.
        :param Sequence['DomainDevicesDiskMirrorBackingStoreSourceNetworkHostArgs'] hosts: Declares one or more network endpoints (hosts) for the backing store server, each with its own name/address and possibly additional attributes.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainDevicesDiskMirrorBackingStoreSourceNetworkIdentityArgs' identity: Configures authentication/identity parameters used when accessing the mirrored backing store over a network, such as user, group, keyfile, or agent socket, depending on the protocol.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceNetworkInitiatorArgs' initiator: Configures initiator identity information (typically for iSCSI-like protocols) used when accessing the mirrored network backing store.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceNetworkKnownHostsArgs' known_hosts: Enables use of a known-hosts file to validate the remote hosts identity when connecting to the mirrored network backing store.
        :param _builtins.str name: Sets a name for the network source of the mirrored backing store, typically used by certain protocols (such as RBD pool or NBD export names); value is user-provided and protocol-specific.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str protocol: Sets the network storage protocol used for the mirrored backing store; value is user-provided but must be a protocol supported by libvirt for network disks (for example, rbd, sheepdog, gluster, nbd).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str query: Sets an optional query string or subresource specifier for the network storage URL of the mirrored backing store; value is user-provided and protocol-specific.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainDevicesDiskMirrorBackingStoreSourceNetworkReconnectArgs' reconnect: Configures automatic reconnection behavior for the mirrored network backing store after a connection loss.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceNetworkSnapshotArgs' snapshot: Configures snapshot-related behavior for the network-based mirrored backing store, with semantics depending on the underlying protocol and storage implementation.
        :param _builtins.str tls: Controls whether TLS is used for the mirrored disks network backing-store connection; value is user-provided and typically enabled only when the chosen protocol and backend support TLS.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str tls_hostname: Sets the expected TLS hostname for the mirrored disks network backing-store connection, used for certificate verification; value is user-provided and should match the server certificates hostname (for example, "storage.example.com").
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if initiator is not None:
            pulumi.set(__self__, "initiator", initiator)
        if known_hosts is not None:
            pulumi.set(__self__, "known_hosts", known_hosts)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if snapshot is not None:
            pulumi.set(__self__, "snapshot", snapshot)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if tls_hostname is not None:
            pulumi.set(__self__, "tls_hostname", tls_hostname)

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceNetworkAuth']:
        """
        Configures CHAP authentication parameters for the iSCSI source backing an assigned SCSI host device; include this block only when the target requires authentication.
        """
        return pulumi.get(self, "auth")

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceNetworkConfig']:
        """
        Points to an external configuration source for the network backing store (for example, an RBD or Ceph config file) that libvirt passes to the backend.
        """
        return pulumi.get(self, "config")

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceNetworkHost']]:
        """
        Declares one or more network endpoints (hosts) for the backing store server, each with its own name/address and possibly additional attributes.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter
    def identity(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceNetworkIdentity']:
        """
        Configures authentication/identity parameters used when accessing the mirrored backing store over a network, such as user, group, keyfile, or agent socket, depending on the protocol.
        """
        return pulumi.get(self, "identity")

    @_builtins.property
    @pulumi.getter
    def initiator(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceNetworkInitiator']:
        """
        Configures initiator identity information (typically for iSCSI-like protocols) used when accessing the mirrored network backing store.
        """
        return pulumi.get(self, "initiator")

    @_builtins.property
    @pulumi.getter(name="knownHosts")
    def known_hosts(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceNetworkKnownHosts']:
        """
        Enables use of a known-hosts file to validate the remote hosts identity when connecting to the mirrored network backing store.
        """
        return pulumi.get(self, "known_hosts")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets a name for the network source of the mirrored backing store, typically used by certain protocols (such as RBD pool or NBD export names); value is user-provided and protocol-specific.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        Sets the network storage protocol used for the mirrored backing store; value is user-provided but must be a protocol supported by libvirt for network disks (for example, rbd, sheepdog, gluster, nbd).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional[_builtins.str]:
        """
        Sets an optional query string or subresource specifier for the network storage URL of the mirrored backing store; value is user-provided and protocol-specific.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "query")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceNetworkReconnect']:
        """
        Configures automatic reconnection behavior for the mirrored network backing store after a connection loss.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter
    def snapshot(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceNetworkSnapshot']:
        """
        Configures snapshot-related behavior for the network-based mirrored backing store, with semantics depending on the underlying protocol and storage implementation.
        """
        return pulumi.get(self, "snapshot")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[_builtins.str]:
        """
        Controls whether TLS is used for the mirrored disks network backing-store connection; value is user-provided and typically enabled only when the chosen protocol and backend support TLS.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "tls")

    @_builtins.property
    @pulumi.getter(name="tlsHostname")
    def tls_hostname(self) -> Optional[_builtins.str]:
        """
        Sets the expected TLS hostname for the mirrored disks network backing-store connection, used for certificate verification; value is user-provided and should match the server certificates hostname (for example, "storage.example.com").

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "tls_hostname")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceNetworkAuth(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceNetworkAuthSecret'] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param 'DomainDevicesDiskMirrorBackingStoreSourceNetworkAuthSecretArgs' secret: Configures the libvirt secret object used to hold the iSCSI authentication password for this hostdev; this references an existing libvirt secret, not the clear-text secret.
        :param _builtins.str username: Sets the CHAP username used when authenticating to the iSCSI target for this SCSI hostdev; the value is user-provided (for example, "chapuser1").
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceNetworkAuthSecret']:
        """
        Configures the libvirt secret object used to hold the iSCSI authentication password for this hostdev; this references an existing libvirt secret, not the clear-text secret.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        Sets the CHAP username used when authenticating to the iSCSI target for this SCSI hostdev; the value is user-provided (for example, "chapuser1").

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceNetworkAuthSecret(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 usage: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str usage: Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str uuid: Exposes the UUID of the libvirt secret used for iSCSI authentication; this is computed from the referenced secret rather than configured directly.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def usage(self) -> Optional[_builtins.str]:
        """
        Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "usage")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        Exposes the UUID of the libvirt secret used for iSCSI authentication; this is computed from the referenced secret rather than configured directly.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceNetworkConfig(dict):
    def __init__(__self__, *,
                 file: _builtins.str):
        """
        :param _builtins.str file: Sets the path to the configuration file used for the network backing store connection, such as a Ceph configuration file (/etc/ceph/ceph.conf).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "file", file)

    @_builtins.property
    @pulumi.getter
    def file(self) -> _builtins.str:
        """
        Sets the path to the configuration file used for the network backing store connection, such as a Ceph configuration file (/etc/ceph/ceph.conf).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "file")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceNetworkHost(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 socket: Optional[_builtins.str] = None,
                 transport: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Sets the hostname or IP address of the iSCSI target portal (for example, "10.0.0.10" or "iscsi.example.com").
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str port: Sets the TCP port of the iSCSI target portal; if omitted, libvirt/driver defaults (commonly 3260) are used.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str socket: Sets a UNIX domain socket path to connect to an iSCSI target via a local socket instead of TCP; value is a user-provided filesystem path.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str transport: Sets the transport type used to reach the iSCSI target portal; valid values are user-provided strings as supported by the environment (for example, "tcp" or "iser").
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if socket is not None:
            pulumi.set(__self__, "socket", socket)
        if transport is not None:
            pulumi.set(__self__, "transport", transport)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the hostname or IP address of the iSCSI target portal (for example, "10.0.0.10" or "iscsi.example.com").

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        """
        Sets the TCP port of the iSCSI target portal; if omitted, libvirt/driver defaults (commonly 3260) are used.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def socket(self) -> Optional[_builtins.str]:
        """
        Sets a UNIX domain socket path to connect to an iSCSI target via a local socket instead of TCP; value is a user-provided filesystem path.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "socket")

    @_builtins.property
    @pulumi.getter
    def transport(self) -> Optional[_builtins.str]:
        """
        Sets the transport type used to reach the iSCSI target portal; valid values are user-provided strings as supported by the environment (for example, "tcp" or "iser").

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "transport")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceNetworkIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentSock":
            suggest = "agent_sock"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceNetworkIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceNetworkIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceNetworkIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_sock: Optional[_builtins.str] = None,
                 group: Optional[_builtins.str] = None,
                 keyfile: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str agent_sock: Sets the path to a local agent socket used for external authentication (for example, SASL or SSH agent) when connecting to the network backing store; value is a user-provided Unix socket path.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str group: Sets the group name to use for authentication or access control when connecting to the network backing store; value is user-provided and protocol-specific.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str keyfile: Sets the path to a private key file used for authenticating to the network backing store (for example, an SSH or TLS key); value is a user-provided filesystem path.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str user: Sets the user identifier used for authentication to the network backing store; value is user-provided and typically matches a remote account name.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str user_name: Sets an explicit username string used for authentication to the network backing store, separate from any other user identity settings; value is user-provided (for example, "backupuser").
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if agent_sock is not None:
            pulumi.set(__self__, "agent_sock", agent_sock)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if keyfile is not None:
            pulumi.set(__self__, "keyfile", keyfile)
        if user is not None:
            pulumi.set(__self__, "user", user)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="agentSock")
    def agent_sock(self) -> Optional[_builtins.str]:
        """
        Sets the path to a local agent socket used for external authentication (for example, SASL or SSH agent) when connecting to the network backing store; value is a user-provided Unix socket path.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "agent_sock")

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[_builtins.str]:
        """
        Sets the group name to use for authentication or access control when connecting to the network backing store; value is user-provided and protocol-specific.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter
    def keyfile(self) -> Optional[_builtins.str]:
        """
        Sets the path to a private key file used for authenticating to the network backing store (for example, an SSH or TLS key); value is a user-provided filesystem path.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "keyfile")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        Sets the user identifier used for authentication to the network backing store; value is user-provided and typically matches a remote account name.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "user")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        """
        Sets an explicit username string used for authentication to the network backing store, separate from any other user identity settings; value is user-provided (for example, "backupuser").

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceNetworkInitiator(dict):
    def __init__(__self__, *,
                 iqn: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceNetworkInitiatorIqn'] = None):
        """
        :param 'DomainDevicesDiskMirrorBackingStoreSourceNetworkInitiatorIqnArgs' iqn: Configures the iSCSI initiator IQN block for the mirrored network backing store, defining the initiator name presented to the target.
        """
        if iqn is not None:
            pulumi.set(__self__, "iqn", iqn)

    @_builtins.property
    @pulumi.getter
    def iqn(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceNetworkInitiatorIqn']:
        """
        Configures the iSCSI initiator IQN block for the mirrored network backing store, defining the initiator name presented to the target.
        """
        return pulumi.get(self, "iqn")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceNetworkInitiatorIqn(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Sets the initiator IQN string used when logging into an iSCSI target backing the mirrored disk; value must be a valid IQN (for example, iqn.2020-01.com.example:host1).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the initiator IQN string used when logging into an iSCSI target backing the mirrored disk; value must be a valid IQN (for example, iqn.2020-01.com.example:host1).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceNetworkKnownHosts(dict):
    def __init__(__self__, *,
                 path: _builtins.str):
        """
        :param _builtins.str path: Sets the path to the known-hosts file used to verify the identity of the remote storage host; value is a required user-provided filesystem path (for example, /etc/libvirt/known_hosts).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the path to the known-hosts file used to verify the identity of the remote storage host; value is a required user-provided filesystem path (for example, /etc/libvirt/known_hosts).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceNetworkReconnect(dict):
    def __init__(__self__, *,
                 delay: _builtins.str):
        """
        :param _builtins.str delay: Sets the reconnection delay (in seconds) before retrying a failed connection to the mirrored network backing store; value is a required user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "delay", delay)

    @_builtins.property
    @pulumi.getter
    def delay(self) -> _builtins.str:
        """
        Sets the reconnection delay (in seconds) before retrying a failed connection to the mirrored network backing store; value is a required user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "delay")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceNetworkSnapshot(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the name of the network snapshot to use as the backing store for the mirrored disks network source; value is user-provided and must match an existing snapshot identifier on the storage backend.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the name of the network snapshot to use as the backing store for the mirrored disks network source; value is user-provided and must match an existing snapshot identifier on the storage backend.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceNvme(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceReadahead(dict):
    def __init__(__self__, *,
                 size: _builtins.str):
        """
        :param _builtins.str size: Sets the read-ahead size for the mirrored disks backing store; value is a user-provided positive integer in bytes (for example, 65536 for 64 KiB).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        """
        Sets the read-ahead size for the mirrored disks backing store; value is a user-provided positive integer in bytes (for example, 65536 for 64 KiB).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceReservations(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.str] = None,
                 managed: Optional[_builtins.bool] = None,
                 source: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSource'] = None):
        """
        :param _builtins.str enabled: Controls whether persistent reservations are enabled for the mirrored disks backing-store source; value is user-provided and typically expects "yes" or "no" semantics per libvirt.
        :param _builtins.bool managed: Indicates whether reservations are managed by libvirt ("yes") or externally ("no"); value is provided as a string and translated to a boolean, with "yes" meaning true and "no" meaning false.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceArgs' source: Selects the mechanism used to provide reservation control for the mirrored backing-store source, such as a D-Bus service or a device/file endpoint.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if managed is not None:
            pulumi.set(__self__, "managed", managed)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.str]:
        """
        Controls whether persistent reservations are enabled for the mirrored disks backing-store source; value is user-provided and typically expects "yes" or "no" semantics per libvirt.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def managed(self) -> Optional[_builtins.bool]:
        """
        Indicates whether reservations are managed by libvirt ("yes") or externally ("no"); value is provided as a string and translated to a boolean, with "yes" meaning true and "no" meaning false.
        """
        return pulumi.get(self, "managed")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSource']:
        """
        Selects the mechanism used to provide reservation control for the mirrored backing-store source, such as a D-Bus service or a device/file endpoint.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceReservationsSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "qemuvdAgent":
            suggest = "qemuvd_agent"
        elif key == "spicePort":
            suggest = "spice_port"
        elif key == "spiceVmc":
            suggest = "spice_vmc"
        elif key == "stdIo":
            suggest = "std_io"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceReservationsSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceReservationsSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceReservationsSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbus: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceDbus'] = None,
                 dev: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceDev'] = None,
                 file: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceFile'] = None,
                 nmdm: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceNmdm'] = None,
                 null: Optional[_builtins.bool] = None,
                 pipe: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePipe'] = None,
                 pty: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePty'] = None,
                 qemuvd_agent: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceQemuvdAgent'] = None,
                 spice_port: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceSpicePort'] = None,
                 spice_vmc: Optional[_builtins.bool] = None,
                 std_io: Optional[_builtins.bool] = None,
                 tcp: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceTcp'] = None,
                 udp: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUdp'] = None,
                 unix: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUnix'] = None,
                 vc: Optional[_builtins.bool] = None):
        """
        :param 'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceDbusArgs' dbus: Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceDevArgs' dev: Configures an EGD RNG backend that reads entropy from a host character device node.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceFileArgs' file: Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceNmdmArgs' nmdm: Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        :param _builtins.bool null: Enables use of a null character device as the reservation backing source; when this boolean is true, a Null source is emitted and all written data is discarded.
               
               See: <https://libvirt.org/formatdomain.html#null-device>
        :param 'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePipeArgs' pipe: Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePtyArgs' pty: Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceQemuvdAgentArgs' qemuvd_agent: Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceSpicePortArgs' spice_port: Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        :param _builtins.bool spice_vmc: Enables a SPICE VMC (SPICE management channel) backend for this backing-store source; when set true the element is emitted, when false or null it is omitted.
               
               See: <https://libvirt.org/formatdomain.html#spice-channel>
        :param _builtins.bool std_io: Connects the backing-store sources character channel to the domains standard I/O (stdin/stdout/stderr); when true the element is emitted, when false or null it is omitted.
               
               See: <https://libvirt.org/formatdomain.html#host-interface>
        :param 'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceTcpArgs' tcp: Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUdpArgs' udp: Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUnixArgs' unix: Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        :param _builtins.bool vc: Enables use of a VC (virtual cluster or vendor-specific) reservation source when set; since this is presence-based, setting it to true emits the element and false/null omits it.
        """
        if dbus is not None:
            pulumi.set(__self__, "dbus", dbus)
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if nmdm is not None:
            pulumi.set(__self__, "nmdm", nmdm)
        if null is not None:
            pulumi.set(__self__, "null", null)
        if pipe is not None:
            pulumi.set(__self__, "pipe", pipe)
        if pty is not None:
            pulumi.set(__self__, "pty", pty)
        if qemuvd_agent is not None:
            pulumi.set(__self__, "qemuvd_agent", qemuvd_agent)
        if spice_port is not None:
            pulumi.set(__self__, "spice_port", spice_port)
        if spice_vmc is not None:
            pulumi.set(__self__, "spice_vmc", spice_vmc)
        if std_io is not None:
            pulumi.set(__self__, "std_io", std_io)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)
        if unix is not None:
            pulumi.set(__self__, "unix", unix)
        if vc is not None:
            pulumi.set(__self__, "vc", vc)

    @_builtins.property
    @pulumi.getter
    def dbus(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceDbus']:
        """
        Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        """
        return pulumi.get(self, "dbus")

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceDev']:
        """
        Configures an EGD RNG backend that reads entropy from a host character device node.
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceFile']:
        """
        Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def nmdm(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceNmdm']:
        """
        Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        """
        return pulumi.get(self, "nmdm")

    @_builtins.property
    @pulumi.getter
    def null(self) -> Optional[_builtins.bool]:
        """
        Enables use of a null character device as the reservation backing source; when this boolean is true, a Null source is emitted and all written data is discarded.

        See: <https://libvirt.org/formatdomain.html#null-device>
        """
        return pulumi.get(self, "null")

    @_builtins.property
    @pulumi.getter
    def pipe(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePipe']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        """
        return pulumi.get(self, "pipe")

    @_builtins.property
    @pulumi.getter
    def pty(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePty']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        """
        return pulumi.get(self, "pty")

    @_builtins.property
    @pulumi.getter(name="qemuvdAgent")
    def qemuvd_agent(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceQemuvdAgent']:
        """
        Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        """
        return pulumi.get(self, "qemuvd_agent")

    @_builtins.property
    @pulumi.getter(name="spicePort")
    def spice_port(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceSpicePort']:
        """
        Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        """
        return pulumi.get(self, "spice_port")

    @_builtins.property
    @pulumi.getter(name="spiceVmc")
    def spice_vmc(self) -> Optional[_builtins.bool]:
        """
        Enables a SPICE VMC (SPICE management channel) backend for this backing-store source; when set true the element is emitted, when false or null it is omitted.

        See: <https://libvirt.org/formatdomain.html#spice-channel>
        """
        return pulumi.get(self, "spice_vmc")

    @_builtins.property
    @pulumi.getter(name="stdIo")
    def std_io(self) -> Optional[_builtins.bool]:
        """
        Connects the backing-store sources character channel to the domains standard I/O (stdin/stdout/stderr); when true the element is emitted, when false or null it is omitted.

        See: <https://libvirt.org/formatdomain.html#host-interface>
        """
        return pulumi.get(self, "std_io")

    @_builtins.property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceTcp']:
        """
        Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        """
        return pulumi.get(self, "tcp")

    @_builtins.property
    @pulumi.getter
    def udp(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUdp']:
        """
        Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        """
        return pulumi.get(self, "udp")

    @_builtins.property
    @pulumi.getter
    def unix(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUnix']:
        """
        Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        """
        return pulumi.get(self, "unix")

    @_builtins.property
    @pulumi.getter
    def vc(self) -> Optional[_builtins.bool]:
        """
        Enables use of a VC (virtual cluster or vendor-specific) reservation source when set; since this is presence-based, setting it to true emits the element and false/null omits it.
        """
        return pulumi.get(self, "vc")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceDbus(dict):
    def __init__(__self__, *,
                 channel: Optional[_builtins.str] = None):
        """
        :param _builtins.str channel: Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.str]:
        """
        Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceDev(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceDev. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceDev.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceDev.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceDevSecLabel']] = None):
        """
        :param _builtins.str path: Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceDevSecLabelArgs'] sec_labels: Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceDevSecLabel']]:
        """
        Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceDevSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceDevSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceDevSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceDevSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 append: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceFileSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str append: Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
               
               See: <https://libvirt.org/formatdomain.html#device-logfile>
        :param Sequence['DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceFileSecLabelArgs'] sec_labels: Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def append(self) -> Optional[_builtins.str]:
        """
        Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.

        See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        return pulumi.get(self, "append")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceFileSecLabel']]:
        """
        Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceFileSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceFileSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceFileSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceFileSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceNmdm(dict):
    def __init__(__self__, *,
                 master: _builtins.str,
                 slave: _builtins.str):
        """
        :param _builtins.str master: Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        :param _builtins.str slave: Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        pulumi.set(__self__, "master", master)
        pulumi.set(__self__, "slave", slave)

    @_builtins.property
    @pulumi.getter
    def master(self) -> _builtins.str:
        """
        Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "master")

    @_builtins.property
    @pulumi.getter
    def slave(self) -> _builtins.str:
        """
        Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "slave")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePipe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePipe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePipe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePipe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePipeSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePipeSecLabelArgs'] sec_labels: Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePipeSecLabel']]:
        """
        Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePipeSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePipeSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePipeSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePipeSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePtySecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePtySecLabelArgs'] sec_labels: Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePtySecLabel']]:
        """
        Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePtySecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePtySecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePtySecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceReservationsSourcePtySecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceQemuvdAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clipBoard":
            suggest = "clip_board"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceQemuvdAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceQemuvdAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceQemuvdAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clip_board: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceQemuvdAgentClipBoard'] = None,
                 mouse: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceQemuvdAgentMouse'] = None):
        """
        :param 'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceQemuvdAgentClipBoardArgs' clip_board: Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceQemuvdAgentMouseArgs' mouse: Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        if clip_board is not None:
            pulumi.set(__self__, "clip_board", clip_board)
        if mouse is not None:
            pulumi.set(__self__, "mouse", mouse)

    @_builtins.property
    @pulumi.getter(name="clipBoard")
    def clip_board(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceQemuvdAgentClipBoard']:
        """
        Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        """
        return pulumi.get(self, "clip_board")

    @_builtins.property
    @pulumi.getter
    def mouse(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceQemuvdAgentMouse']:
        """
        Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        return pulumi.get(self, "mouse")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceQemuvdAgentClipBoard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyPaste":
            suggest = "copy_paste"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceQemuvdAgentClipBoard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceQemuvdAgentClipBoard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceQemuvdAgentClipBoard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_paste: _builtins.str):
        """
        :param _builtins.str copy_paste: Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "copy_paste", copy_paste)

    @_builtins.property
    @pulumi.getter(name="copyPaste")
    def copy_paste(self) -> _builtins.str:
        """
        Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "copy_paste")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceQemuvdAgentMouse(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceSpicePort(dict):
    def __init__(__self__, *,
                 channel: _builtins.str):
        """
        :param _builtins.str channel: Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceTcp(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceTcpReconnect'] = None,
                 service: Optional[_builtins.str] = None,
                 tls: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str mode: Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceTcpReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param _builtins.str service: Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str tls: Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceTcpReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[_builtins.str]:
        """
        Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceTcpReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindHost":
            suggest = "bind_host"
        elif key == "bindService":
            suggest = "bind_service"
        elif key == "connectHost":
            suggest = "connect_host"
        elif key == "connectService":
            suggest = "connect_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bind_host: _builtins.str,
                 bind_service: _builtins.str,
                 connect_host: _builtins.str,
                 connect_service: _builtins.str):
        """
        :param _builtins.str bind_host: Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str bind_service: Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_host: Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_service: Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "bind_host", bind_host)
        pulumi.set(__self__, "bind_service", bind_service)
        pulumi.set(__self__, "connect_host", connect_host)
        pulumi.set(__self__, "connect_service", connect_service)

    @_builtins.property
    @pulumi.getter(name="bindHost")
    def bind_host(self) -> _builtins.str:
        """
        Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_host")

    @_builtins.property
    @pulumi.getter(name="bindService")
    def bind_service(self) -> _builtins.str:
        """
        Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_service")

    @_builtins.property
    @pulumi.getter(name="connectHost")
    def connect_host(self) -> _builtins.str:
        """
        Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_host")

    @_builtins.property
    @pulumi.getter(name="connectService")
    def connect_service(self) -> _builtins.str:
        """
        Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_service")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUnix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUnix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUnix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUnix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUnixReconnect'] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUnixSecLabel']] = None):
        """
        :param _builtins.str mode: Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str path: Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUnixReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param Sequence['DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUnixSecLabelArgs'] sec_labels: Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUnixReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUnixSecLabel']]:
        """
        Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUnixReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUnixSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUnixSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUnixSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceReservationsSourceUnixSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceSlices(dict):
    def __init__(__self__, *,
                 slices: Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceSlicesSlice']] = None):
        """
        :param Sequence['DomainDevicesDiskMirrorBackingStoreSourceSlicesSliceArgs'] slices: Configures one or more slices of the backing-store source, each describing a contiguous portion of the underlying device or file that is exposed through this mirror backing store.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if slices is not None:
            pulumi.set(__self__, "slices", slices)

    @_builtins.property
    @pulumi.getter
    def slices(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceSlicesSlice']]:
        """
        Configures one or more slices of the backing-store source, each describing a contiguous portion of the underlying device or file that is exposed through this mirror backing store.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "slices")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceSlicesSlice(dict):
    def __init__(__self__, *,
                 offset: _builtins.float,
                 size: _builtins.float,
                 type: _builtins.str):
        """
        :param _builtins.float offset: Sets the starting offset (in bytes) of this slice within the underlying backing-store source; must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.float size: Sets the size (in bytes) of this slice within the underlying backing-store source; must be a positive integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str type: Specifies the type of slice mapping to use for this range; the value is userprovided and must match a type supported by the hypervisor (for example, a particular mapping or layout scheme).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def offset(self) -> _builtins.float:
        """
        Sets the starting offset (in bytes) of this slice within the underlying backing-store source; must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "offset")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.float:
        """
        Sets the size (in bytes) of this slice within the underlying backing-store source; must be a positive integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of slice mapping to use for this range; the value is userprovided and must match a type supported by the hypervisor (for example, a particular mapping or layout scheme).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceSsl(dict):
    def __init__(__self__, *,
                 verify: _builtins.str):
        """
        :param _builtins.str verify: Controls certificate verification for SSL/TLS access to the mirrored backing-store source; typical values are "yes" or "no" to enable or disable verification.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "verify", verify)

    @_builtins.property
    @pulumi.getter
    def verify(self) -> _builtins.str:
        """
        Controls certificate verification for SSL/TLS access to the mirrored backing-store source; typical values are "yes" or "no" to enable or disable verification.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "verify")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceTimeout(dict):
    def __init__(__self__, *,
                 seconds: _builtins.str):
        """
        :param _builtins.str seconds: Sets the timeout duration in seconds for accessing the mirrored backing-store source; must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.str:
        """
        Sets the timeout duration in seconds for accessing the mirrored backing-store source; must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceVhostUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "qemuvdAgent":
            suggest = "qemuvd_agent"
        elif key == "spicePort":
            suggest = "spice_port"
        elif key == "spiceVmc":
            suggest = "spice_vmc"
        elif key == "stdIo":
            suggest = "std_io"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceVhostUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVhostUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVhostUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbus: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserDbus'] = None,
                 dev: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserDev'] = None,
                 file: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserFile'] = None,
                 nmdm: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserNmdm'] = None,
                 null: Optional[_builtins.bool] = None,
                 pipe: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserPipe'] = None,
                 pty: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserPty'] = None,
                 qemuvd_agent: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserQemuvdAgent'] = None,
                 spice_port: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserSpicePort'] = None,
                 spice_vmc: Optional[_builtins.bool] = None,
                 std_io: Optional[_builtins.bool] = None,
                 tcp: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserTcp'] = None,
                 udp: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserUdp'] = None,
                 unix: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserUnix'] = None,
                 vc: Optional[_builtins.bool] = None):
        """
        :param 'DomainDevicesDiskMirrorBackingStoreSourceVhostUserDbusArgs' dbus: Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceVhostUserDevArgs' dev: Configures an EGD RNG backend that reads entropy from a host character device node.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceVhostUserFileArgs' file: Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceVhostUserNmdmArgs' nmdm: Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        :param _builtins.bool null: When set to true, uses a null character device as the vhost-user backing-store source, discarding all output and providing no input; when false or unset, the null device is not used.
               
               See: <https://libvirt.org/formatdomain.html#null-device>
        :param 'DomainDevicesDiskMirrorBackingStoreSourceVhostUserPipeArgs' pipe: Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceVhostUserPtyArgs' pty: Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceVhostUserQemuvdAgentArgs' qemuvd_agent: Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceVhostUserSpicePortArgs' spice_port: Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        :param _builtins.bool spice_vmc: When set to true, exposes the vhost-user backing through a SPICE virtio-serial management channel (SpiceVMC); when false or unset, the element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#spice-channel>
        :param _builtins.bool std_io: When set to true, connects the vhost-user backing to the domains standard I/O character device; when false or unset, the StdIO element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#host-interface>
        :param 'DomainDevicesDiskMirrorBackingStoreSourceVhostUserTcpArgs' tcp: Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceVhostUserUdpArgs' udp: Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceVhostUserUnixArgs' unix: Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        :param _builtins.bool vc: Enables use of a vhost-user communication mechanism compatible with a VC-style (versioned capability) endpoint for the disk mirror backing store; when set true the VC element is emitted, when false or null it is omitted.
        """
        if dbus is not None:
            pulumi.set(__self__, "dbus", dbus)
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if nmdm is not None:
            pulumi.set(__self__, "nmdm", nmdm)
        if null is not None:
            pulumi.set(__self__, "null", null)
        if pipe is not None:
            pulumi.set(__self__, "pipe", pipe)
        if pty is not None:
            pulumi.set(__self__, "pty", pty)
        if qemuvd_agent is not None:
            pulumi.set(__self__, "qemuvd_agent", qemuvd_agent)
        if spice_port is not None:
            pulumi.set(__self__, "spice_port", spice_port)
        if spice_vmc is not None:
            pulumi.set(__self__, "spice_vmc", spice_vmc)
        if std_io is not None:
            pulumi.set(__self__, "std_io", std_io)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)
        if unix is not None:
            pulumi.set(__self__, "unix", unix)
        if vc is not None:
            pulumi.set(__self__, "vc", vc)

    @_builtins.property
    @pulumi.getter
    def dbus(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserDbus']:
        """
        Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        """
        return pulumi.get(self, "dbus")

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserDev']:
        """
        Configures an EGD RNG backend that reads entropy from a host character device node.
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserFile']:
        """
        Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def nmdm(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserNmdm']:
        """
        Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        """
        return pulumi.get(self, "nmdm")

    @_builtins.property
    @pulumi.getter
    def null(self) -> Optional[_builtins.bool]:
        """
        When set to true, uses a null character device as the vhost-user backing-store source, discarding all output and providing no input; when false or unset, the null device is not used.

        See: <https://libvirt.org/formatdomain.html#null-device>
        """
        return pulumi.get(self, "null")

    @_builtins.property
    @pulumi.getter
    def pipe(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserPipe']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        """
        return pulumi.get(self, "pipe")

    @_builtins.property
    @pulumi.getter
    def pty(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserPty']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        """
        return pulumi.get(self, "pty")

    @_builtins.property
    @pulumi.getter(name="qemuvdAgent")
    def qemuvd_agent(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserQemuvdAgent']:
        """
        Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        """
        return pulumi.get(self, "qemuvd_agent")

    @_builtins.property
    @pulumi.getter(name="spicePort")
    def spice_port(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserSpicePort']:
        """
        Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        """
        return pulumi.get(self, "spice_port")

    @_builtins.property
    @pulumi.getter(name="spiceVmc")
    def spice_vmc(self) -> Optional[_builtins.bool]:
        """
        When set to true, exposes the vhost-user backing through a SPICE virtio-serial management channel (SpiceVMC); when false or unset, the element is omitted.

        See: <https://libvirt.org/formatdomain.html#spice-channel>
        """
        return pulumi.get(self, "spice_vmc")

    @_builtins.property
    @pulumi.getter(name="stdIo")
    def std_io(self) -> Optional[_builtins.bool]:
        """
        When set to true, connects the vhost-user backing to the domains standard I/O character device; when false or unset, the StdIO element is omitted.

        See: <https://libvirt.org/formatdomain.html#host-interface>
        """
        return pulumi.get(self, "std_io")

    @_builtins.property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserTcp']:
        """
        Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        """
        return pulumi.get(self, "tcp")

    @_builtins.property
    @pulumi.getter
    def udp(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserUdp']:
        """
        Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        """
        return pulumi.get(self, "udp")

    @_builtins.property
    @pulumi.getter
    def unix(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserUnix']:
        """
        Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        """
        return pulumi.get(self, "unix")

    @_builtins.property
    @pulumi.getter
    def vc(self) -> Optional[_builtins.bool]:
        """
        Enables use of a vhost-user communication mechanism compatible with a VC-style (versioned capability) endpoint for the disk mirror backing store; when set true the VC element is emitted, when false or null it is omitted.
        """
        return pulumi.get(self, "vc")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceVhostUserDbus(dict):
    def __init__(__self__, *,
                 channel: Optional[_builtins.str] = None):
        """
        :param _builtins.str channel: Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.str]:
        """
        Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceVhostUserDev(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceVhostUserDev. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVhostUserDev.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVhostUserDev.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserDevSecLabel']] = None):
        """
        :param _builtins.str path: Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesDiskMirrorBackingStoreSourceVhostUserDevSecLabelArgs'] sec_labels: Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserDevSecLabel']]:
        """
        Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceVhostUserDevSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceVhostUserDevSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVhostUserDevSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVhostUserDevSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceVhostUserFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceVhostUserFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVhostUserFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVhostUserFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 append: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserFileSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str append: Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
               
               See: <https://libvirt.org/formatdomain.html#device-logfile>
        :param Sequence['DomainDevicesDiskMirrorBackingStoreSourceVhostUserFileSecLabelArgs'] sec_labels: Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def append(self) -> Optional[_builtins.str]:
        """
        Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.

        See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        return pulumi.get(self, "append")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserFileSecLabel']]:
        """
        Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceVhostUserFileSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceVhostUserFileSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVhostUserFileSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVhostUserFileSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceVhostUserNmdm(dict):
    def __init__(__self__, *,
                 master: _builtins.str,
                 slave: _builtins.str):
        """
        :param _builtins.str master: Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        :param _builtins.str slave: Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        pulumi.set(__self__, "master", master)
        pulumi.set(__self__, "slave", slave)

    @_builtins.property
    @pulumi.getter
    def master(self) -> _builtins.str:
        """
        Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "master")

    @_builtins.property
    @pulumi.getter
    def slave(self) -> _builtins.str:
        """
        Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "slave")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceVhostUserPipe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceVhostUserPipe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVhostUserPipe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVhostUserPipe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserPipeSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesDiskMirrorBackingStoreSourceVhostUserPipeSecLabelArgs'] sec_labels: Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserPipeSecLabel']]:
        """
        Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceVhostUserPipeSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceVhostUserPipeSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVhostUserPipeSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVhostUserPipeSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceVhostUserPty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceVhostUserPty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVhostUserPty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVhostUserPty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserPtySecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesDiskMirrorBackingStoreSourceVhostUserPtySecLabelArgs'] sec_labels: Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserPtySecLabel']]:
        """
        Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceVhostUserPtySecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceVhostUserPtySecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVhostUserPtySecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVhostUserPtySecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceVhostUserQemuvdAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clipBoard":
            suggest = "clip_board"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceVhostUserQemuvdAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVhostUserQemuvdAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVhostUserQemuvdAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clip_board: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserQemuvdAgentClipBoard'] = None,
                 mouse: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserQemuvdAgentMouse'] = None):
        """
        :param 'DomainDevicesDiskMirrorBackingStoreSourceVhostUserQemuvdAgentClipBoardArgs' clip_board: Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        :param 'DomainDevicesDiskMirrorBackingStoreSourceVhostUserQemuvdAgentMouseArgs' mouse: Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        if clip_board is not None:
            pulumi.set(__self__, "clip_board", clip_board)
        if mouse is not None:
            pulumi.set(__self__, "mouse", mouse)

    @_builtins.property
    @pulumi.getter(name="clipBoard")
    def clip_board(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserQemuvdAgentClipBoard']:
        """
        Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        """
        return pulumi.get(self, "clip_board")

    @_builtins.property
    @pulumi.getter
    def mouse(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserQemuvdAgentMouse']:
        """
        Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        return pulumi.get(self, "mouse")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceVhostUserQemuvdAgentClipBoard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyPaste":
            suggest = "copy_paste"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceVhostUserQemuvdAgentClipBoard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVhostUserQemuvdAgentClipBoard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVhostUserQemuvdAgentClipBoard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_paste: _builtins.str):
        """
        :param _builtins.str copy_paste: Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "copy_paste", copy_paste)

    @_builtins.property
    @pulumi.getter(name="copyPaste")
    def copy_paste(self) -> _builtins.str:
        """
        Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "copy_paste")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceVhostUserQemuvdAgentMouse(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceVhostUserSpicePort(dict):
    def __init__(__self__, *,
                 channel: _builtins.str):
        """
        :param _builtins.str channel: Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceVhostUserTcp(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserTcpReconnect'] = None,
                 service: Optional[_builtins.str] = None,
                 tls: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str mode: Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesDiskMirrorBackingStoreSourceVhostUserTcpReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param _builtins.str service: Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str tls: Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserTcpReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[_builtins.str]:
        """
        Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceVhostUserTcpReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceVhostUserUdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindHost":
            suggest = "bind_host"
        elif key == "bindService":
            suggest = "bind_service"
        elif key == "connectHost":
            suggest = "connect_host"
        elif key == "connectService":
            suggest = "connect_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceVhostUserUdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVhostUserUdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVhostUserUdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bind_host: _builtins.str,
                 bind_service: _builtins.str,
                 connect_host: _builtins.str,
                 connect_service: _builtins.str):
        """
        :param _builtins.str bind_host: Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str bind_service: Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_host: Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_service: Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "bind_host", bind_host)
        pulumi.set(__self__, "bind_service", bind_service)
        pulumi.set(__self__, "connect_host", connect_host)
        pulumi.set(__self__, "connect_service", connect_service)

    @_builtins.property
    @pulumi.getter(name="bindHost")
    def bind_host(self) -> _builtins.str:
        """
        Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_host")

    @_builtins.property
    @pulumi.getter(name="bindService")
    def bind_service(self) -> _builtins.str:
        """
        Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_service")

    @_builtins.property
    @pulumi.getter(name="connectHost")
    def connect_host(self) -> _builtins.str:
        """
        Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_host")

    @_builtins.property
    @pulumi.getter(name="connectService")
    def connect_service(self) -> _builtins.str:
        """
        Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_service")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceVhostUserUnix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceVhostUserUnix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVhostUserUnix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVhostUserUnix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserUnixReconnect'] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserUnixSecLabel']] = None):
        """
        :param _builtins.str mode: Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str path: Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesDiskMirrorBackingStoreSourceVhostUserUnixReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param Sequence['DomainDevicesDiskMirrorBackingStoreSourceVhostUserUnixSecLabelArgs'] sec_labels: Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserUnixReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceVhostUserUnixSecLabel']]:
        """
        Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceVhostUserUnixReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceVhostUserUnixSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceVhostUserUnixSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVhostUserUnixSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVhostUserUnixSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceVhostVdpa(dict):
    def __init__(__self__, *,
                 dev: _builtins.str):
        """
        :param _builtins.str dev: Sets the host vDPA character device path used as the backingStore source for the mirrored disk when using a vhost-vdpa backend; the value is user-provided and must reference an existing device node (for example, /dev/vhost-vdpa0).
        """
        pulumi.set(__self__, "dev", dev)

    @_builtins.property
    @pulumi.getter
    def dev(self) -> _builtins.str:
        """
        Sets the host vDPA character device path used as the backingStore source for the mirrored disk when using a vhost-vdpa backend; the value is user-provided and must reference an existing device node (for example, /dev/vhost-vdpa0).
        """
        return pulumi.get(self, "dev")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 pool: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceVolumeSecLabel']] = None,
                 volume: Optional[_builtins.str] = None):
        """
        :param _builtins.str mode: Sets the access mode with which the storage volume is used as the backingStore source (for example, "readOnly" or "readWrite" depending on driver support); the value is user-provided.
        :param _builtins.str pool: Names the storage pool that contains the backing storage volume used as the mirror backingStore source; must match an existing libvirt storage pool name.
        :param Sequence['DomainDevicesDiskMirrorBackingStoreSourceVolumeSecLabelArgs'] sec_labels: Configures an optional security label override applied to the backing storage volume used as the mirror backingStore source.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str volume: Sets the name of the storage volume within the specified pool that is used as the backingStore source for the mirrored disk.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if pool is not None:
            pulumi.set(__self__, "pool", pool)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the access mode with which the storage volume is used as the backingStore source (for example, "readOnly" or "readWrite" depending on driver support); the value is user-provided.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def pool(self) -> Optional[_builtins.str]:
        """
        Names the storage pool that contains the backing storage volume used as the mirror backingStore source; must match an existing libvirt storage pool name.
        """
        return pulumi.get(self, "pool")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorBackingStoreSourceVolumeSecLabel']]:
        """
        Configures an optional security label override applied to the backing storage volume used as the mirror backingStore source.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional[_builtins.str]:
        """
        Sets the name of the storage volume within the specified pool that is used as the backingStore source for the mirrored disk.
        """
        return pulumi.get(self, "volume")


@pulumi.output_type
class DomainDevicesDiskMirrorBackingStoreSourceVolumeSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorBackingStoreSourceVolumeSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVolumeSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorBackingStoreSourceVolumeSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskMirrorFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataCache":
            suggest = "metadata_cache"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 metadata_cache: Optional['outputs.DomainDevicesDiskMirrorFormatMetadataCache'] = None):
        """
        :param _builtins.str type: Sets the data store format type for the mirrored backing store (for example, "qcow2" or "raw"); the value is user-provided and must be a valid libvirt disk format name.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainDevicesDiskMirrorFormatMetadataCacheArgs' metadata_cache: Configures metadata cache behavior for the mirrored backing stores data store format (for example, limiting the size of cached metadata).
        """
        pulumi.set(__self__, "type", type)
        if metadata_cache is not None:
            pulumi.set(__self__, "metadata_cache", metadata_cache)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets the data store format type for the mirrored backing store (for example, "qcow2" or "raw"); the value is user-provided and must be a valid libvirt disk format name.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="metadataCache")
    def metadata_cache(self) -> Optional['outputs.DomainDevicesDiskMirrorFormatMetadataCache']:
        """
        Configures metadata cache behavior for the mirrored backing stores data store format (for example, limiting the size of cached metadata).
        """
        return pulumi.get(self, "metadata_cache")


@pulumi.output_type
class DomainDevicesDiskMirrorFormatMetadataCache(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSize":
            suggest = "max_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorFormatMetadataCache. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorFormatMetadataCache.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorFormatMetadataCache.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_size: Optional['outputs.DomainDevicesDiskMirrorFormatMetadataCacheMaxSize'] = None):
        """
        :param 'DomainDevicesDiskMirrorFormatMetadataCacheMaxSizeArgs' max_size: Sets the maximum size of the metadata cache used by the data store format; value and unit together define the limit (for example, 64 MiB).
        """
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional['outputs.DomainDevicesDiskMirrorFormatMetadataCacheMaxSize']:
        """
        Sets the maximum size of the metadata cache used by the data store format; value and unit together define the limit (for example, 64 MiB).
        """
        return pulumi.get(self, "max_size")


@pulumi.output_type
class DomainDevicesDiskMirrorFormatMetadataCacheMaxSize(dict):
    def __init__(__self__, *,
                 value: _builtins.float,
                 unit: Optional[_builtins.str] = None):
        """
        :param _builtins.float value: Sets the numeric value for the metadata cache maximum size in the specified unit; this must be a positive integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str unit: Sets the unit used for the metadata cache maximum size; valid units follow libvirt size units such as "B", "KiB", "MiB", "GiB" and are user-chosen.
               
               See: <https://libvirt.org/formatdomain.html#memory-allocation>
        """
        pulumi.set(__self__, "value", value)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.float:
        """
        Sets the numeric value for the metadata cache maximum size in the specified unit; this must be a positive integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        """
        Sets the unit used for the metadata cache maximum size; valid units follow libvirt size units such as "B", "KiB", "MiB", "GiB" and are user-chosen.

        See: <https://libvirt.org/formatdomain.html#memory-allocation>
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class DomainDevicesDiskMirrorSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataStore":
            suggest = "data_store"
        elif key == "startupPolicy":
            suggest = "startup_policy"
        elif key == "vhostUser":
            suggest = "vhost_user"
        elif key == "vhostVdpa":
            suggest = "vhost_vdpa"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block: Optional['outputs.DomainDevicesDiskMirrorSourceBlock'] = None,
                 cookies: Optional['outputs.DomainDevicesDiskMirrorSourceCookies'] = None,
                 data_store: Optional['outputs.DomainDevicesDiskMirrorSourceDataStore'] = None,
                 dir: Optional['outputs.DomainDevicesDiskMirrorSourceDir'] = None,
                 encryption: Optional['outputs.DomainDevicesDiskMirrorSourceEncryption'] = None,
                 file: Optional['outputs.DomainDevicesDiskMirrorSourceFile'] = None,
                 index: Optional[_builtins.float] = None,
                 network: Optional['outputs.DomainDevicesDiskMirrorSourceNetwork'] = None,
                 nvme: Optional['outputs.DomainDevicesDiskMirrorSourceNvme'] = None,
                 readahead: Optional['outputs.DomainDevicesDiskMirrorSourceReadahead'] = None,
                 reservations: Optional['outputs.DomainDevicesDiskMirrorSourceReservations'] = None,
                 slices: Optional['outputs.DomainDevicesDiskMirrorSourceSlices'] = None,
                 ssl: Optional['outputs.DomainDevicesDiskMirrorSourceSsl'] = None,
                 startup_policy: Optional[_builtins.str] = None,
                 timeout: Optional['outputs.DomainDevicesDiskMirrorSourceTimeout'] = None,
                 vhost_user: Optional['outputs.DomainDevicesDiskMirrorSourceVhostUser'] = None,
                 vhost_vdpa: Optional['outputs.DomainDevicesDiskMirrorSourceVhostVdpa'] = None,
                 volume: Optional['outputs.DomainDevicesDiskMirrorSourceVolume'] = None):
        """
        :param 'DomainDevicesDiskMirrorSourceBlockArgs' block: Describes a block device used as the source for the mirror backing store.
        :param 'DomainDevicesDiskMirrorSourceCookiesArgs' cookies: Provides optional cookie data associated with the mirror backing store source (for example, auth or session data), with content treated as user-provided.
        :param 'DomainDevicesDiskMirrorSourceDataStoreArgs' data_store: Configures a data store descriptor for the mirrored backing store, typically used with networked or advanced storage backends that expose format-specific options.
        :param 'DomainDevicesDiskMirrorSourceDirArgs' dir: Configures a directory-based source for the mirrored backing store, pointing to a host directory used by the backing image.
        :param 'DomainDevicesDiskMirrorSourceEncryptionArgs' encryption: Enables disk image encryption configuration for this disk and groups attributes defining the encryption engine, format, and secrets.
        :param 'DomainDevicesDiskMirrorSourceFileArgs' file: Configures a file-based backing store source for the disk mirror, defining how the backing image is accessed from the host filesystem.
        :param _builtins.float index: Sets the index of this backing store within a backing chain, used when multiple backing layers are present; value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainDevicesDiskMirrorSourceNetworkArgs' network: Configures a network-based backing store source (such as NBD, iSCSI, or RBD) for the disk mirror, including authentication and host endpoints.
        :param 'DomainDevicesDiskMirrorSourceNvmeArgs' nvme: Enables using an NVMe-backed source for the mirrored disks backing store; when present, it selects an NVMe device or namespace as the source, with details defined by libvirt/QEMU for NVMe disks.
        :param 'DomainDevicesDiskMirrorSourceReadaheadArgs' readahead: Configures read-ahead behavior for the mirrored disks backing-store source, allowing tuning of how much data is pre-fetched from the backend.
        :param 'DomainDevicesDiskMirrorSourceReservationsArgs' reservations: Configures SCSI-style reservations or similar persistent reservation management for the mirrored disks backing-store source, controlling how access is coordinated across nodes.
        :param 'DomainDevicesDiskMirrorSourceSlicesArgs' slices: Configures optional slice or segment information for the backing store source (for example, to describe which logical slices of a device are used); content is user-provided.
        :param 'DomainDevicesDiskMirrorSourceSslArgs' ssl: Enables SSL/TLS parameters for accessing the mirrored backing-store source when it is provided over a secure transport.
        :param _builtins.str startup_policy: Specifies how strictly the mirrored backing-store source must be available during domain startup; valid values include "mandatory", "requisite", "optional" (userprovided string matched by libvirt).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainDevicesDiskMirrorSourceTimeoutArgs' timeout: Configures a timeout for connecting to or initializing the mirrored backing-store source.
        :param 'DomainDevicesDiskMirrorSourceVhostUserArgs' vhost_user: Selects a vhost-user backend as the transport for the mirrored backing-store source, allowing it to be provided via a userspace process.
        :param 'DomainDevicesDiskMirrorSourceVhostVdpaArgs' vhost_vdpa: Selects a vhost-vDPA backend for the disk mirror backing store, allowing acceleration via a vDPA device; additional details are determined by libvirt and device configuration.
        :param 'DomainDevicesDiskMirrorSourceVolumeArgs' volume: Configures the backingStore source as a libvirt storage volume reference instead of a raw file/block path for the mirrored disk.
        """
        if block is not None:
            pulumi.set(__self__, "block", block)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if data_store is not None:
            pulumi.set(__self__, "data_store", data_store)
        if dir is not None:
            pulumi.set(__self__, "dir", dir)
        if encryption is not None:
            pulumi.set(__self__, "encryption", encryption)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if nvme is not None:
            pulumi.set(__self__, "nvme", nvme)
        if readahead is not None:
            pulumi.set(__self__, "readahead", readahead)
        if reservations is not None:
            pulumi.set(__self__, "reservations", reservations)
        if slices is not None:
            pulumi.set(__self__, "slices", slices)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if startup_policy is not None:
            pulumi.set(__self__, "startup_policy", startup_policy)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if vhost_user is not None:
            pulumi.set(__self__, "vhost_user", vhost_user)
        if vhost_vdpa is not None:
            pulumi.set(__self__, "vhost_vdpa", vhost_vdpa)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceBlock']:
        """
        Describes a block device used as the source for the mirror backing store.
        """
        return pulumi.get(self, "block")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceCookies']:
        """
        Provides optional cookie data associated with the mirror backing store source (for example, auth or session data), with content treated as user-provided.
        """
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="dataStore")
    def data_store(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceDataStore']:
        """
        Configures a data store descriptor for the mirrored backing store, typically used with networked or advanced storage backends that expose format-specific options.
        """
        return pulumi.get(self, "data_store")

    @_builtins.property
    @pulumi.getter
    def dir(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceDir']:
        """
        Configures a directory-based source for the mirrored backing store, pointing to a host directory used by the backing image.
        """
        return pulumi.get(self, "dir")

    @_builtins.property
    @pulumi.getter
    def encryption(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceEncryption']:
        """
        Enables disk image encryption configuration for this disk and groups attributes defining the encryption engine, format, and secrets.
        """
        return pulumi.get(self, "encryption")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceFile']:
        """
        Configures a file-based backing store source for the disk mirror, defining how the backing image is accessed from the host filesystem.
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the index of this backing store within a backing chain, used when multiple backing layers are present; value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "index")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceNetwork']:
        """
        Configures a network-based backing store source (such as NBD, iSCSI, or RBD) for the disk mirror, including authentication and host endpoints.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def nvme(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceNvme']:
        """
        Enables using an NVMe-backed source for the mirrored disks backing store; when present, it selects an NVMe device or namespace as the source, with details defined by libvirt/QEMU for NVMe disks.
        """
        return pulumi.get(self, "nvme")

    @_builtins.property
    @pulumi.getter
    def readahead(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceReadahead']:
        """
        Configures read-ahead behavior for the mirrored disks backing-store source, allowing tuning of how much data is pre-fetched from the backend.
        """
        return pulumi.get(self, "readahead")

    @_builtins.property
    @pulumi.getter
    def reservations(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceReservations']:
        """
        Configures SCSI-style reservations or similar persistent reservation management for the mirrored disks backing-store source, controlling how access is coordinated across nodes.
        """
        return pulumi.get(self, "reservations")

    @_builtins.property
    @pulumi.getter
    def slices(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceSlices']:
        """
        Configures optional slice or segment information for the backing store source (for example, to describe which logical slices of a device are used); content is user-provided.
        """
        return pulumi.get(self, "slices")

    @_builtins.property
    @pulumi.getter
    def ssl(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceSsl']:
        """
        Enables SSL/TLS parameters for accessing the mirrored backing-store source when it is provided over a secure transport.
        """
        return pulumi.get(self, "ssl")

    @_builtins.property
    @pulumi.getter(name="startupPolicy")
    def startup_policy(self) -> Optional[_builtins.str]:
        """
        Specifies how strictly the mirrored backing-store source must be available during domain startup; valid values include "mandatory", "requisite", "optional" (userprovided string matched by libvirt).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "startup_policy")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceTimeout']:
        """
        Configures a timeout for connecting to or initializing the mirrored backing-store source.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="vhostUser")
    def vhost_user(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceVhostUser']:
        """
        Selects a vhost-user backend as the transport for the mirrored backing-store source, allowing it to be provided via a userspace process.
        """
        return pulumi.get(self, "vhost_user")

    @_builtins.property
    @pulumi.getter(name="vhostVdpa")
    def vhost_vdpa(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceVhostVdpa']:
        """
        Selects a vhost-vDPA backend for the disk mirror backing store, allowing acceleration via a vDPA device; additional details are determined by libvirt and device configuration.
        """
        return pulumi.get(self, "vhost_vdpa")

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceVolume']:
        """
        Configures the backingStore source as a libvirt storage volume reference instead of a raw file/block path for the mirrored disk.
        """
        return pulumi.get(self, "volume")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceBlock(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceBlock. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceBlock.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceBlock.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dev: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceBlockSecLabel']] = None):
        """
        :param _builtins.str dev: Sets the host block device path used as the mirror backing store source (for example "/dev/sdb1"); the value is user-provided and must reference an existing block device.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param Sequence['DomainDevicesDiskMirrorSourceBlockSecLabelArgs'] sec_labels: Configures an optional security label for the block-device backing store of the mirror, controlling how security drivers label this source.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional[_builtins.str]:
        """
        Sets the host block device path used as the mirror backing store source (for example "/dev/sdb1"); the value is user-provided and must reference an existing block device.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceBlockSecLabel']]:
        """
        Configures an optional security label for the block-device backing store of the mirror, controlling how security drivers label this source.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceBlockSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceBlockSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceBlockSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceBlockSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceCookies(dict):
    def __init__(__self__, *,
                 cookies: Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceCookiesCookie']] = None):
        """
        :param Sequence['DomainDevicesDiskMirrorSourceCookiesCookieArgs'] cookies: Configures one or more HTTP cookies to be sent when accessing the mirrored backing store over a network protocol that supports cookies (for example, HTTPS or HTTP-based storage).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceCookiesCookie']]:
        """
        Configures one or more HTTP cookies to be sent when accessing the mirrored backing store over a network protocol that supports cookies (for example, HTTPS or HTTP-based storage).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "cookies")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceCookiesCookie(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Sets the cookie name for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "sessionid").
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str value: Sets the cookie value for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "abc123").
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the cookie name for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "sessionid").

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Sets the cookie value for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "abc123").

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceDataStore(dict):
    def __init__(__self__, *,
                 format: Optional['outputs.DomainDevicesDiskMirrorSourceDataStoreFormat'] = None):
        """
        :param 'DomainDevicesDiskMirrorSourceDataStoreFormatArgs' format: Configures the on-disk format settings for the mirrored backing stores data store, including format type and optional metadata cache tuning.
        """
        if format is not None:
            pulumi.set(__self__, "format", format)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceDataStoreFormat']:
        """
        Configures the on-disk format settings for the mirrored backing stores data store, including format type and optional metadata cache tuning.
        """
        return pulumi.get(self, "format")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceDataStoreFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataCache":
            suggest = "metadata_cache"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceDataStoreFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceDataStoreFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceDataStoreFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 metadata_cache: Optional['outputs.DomainDevicesDiskMirrorSourceDataStoreFormatMetadataCache'] = None):
        """
        :param _builtins.str type: Sets the data store format type for the mirrored backing store (for example, "qcow2" or "raw"); the value is user-provided and must be a valid libvirt disk format name.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainDevicesDiskMirrorSourceDataStoreFormatMetadataCacheArgs' metadata_cache: Configures metadata cache behavior for the mirrored backing stores data store format (for example, limiting the size of cached metadata).
        """
        pulumi.set(__self__, "type", type)
        if metadata_cache is not None:
            pulumi.set(__self__, "metadata_cache", metadata_cache)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets the data store format type for the mirrored backing store (for example, "qcow2" or "raw"); the value is user-provided and must be a valid libvirt disk format name.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="metadataCache")
    def metadata_cache(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceDataStoreFormatMetadataCache']:
        """
        Configures metadata cache behavior for the mirrored backing stores data store format (for example, limiting the size of cached metadata).
        """
        return pulumi.get(self, "metadata_cache")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceDataStoreFormatMetadataCache(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSize":
            suggest = "max_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceDataStoreFormatMetadataCache. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceDataStoreFormatMetadataCache.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceDataStoreFormatMetadataCache.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_size: Optional['outputs.DomainDevicesDiskMirrorSourceDataStoreFormatMetadataCacheMaxSize'] = None):
        """
        :param 'DomainDevicesDiskMirrorSourceDataStoreFormatMetadataCacheMaxSizeArgs' max_size: Sets the maximum size of the metadata cache used by the data store format; value and unit together define the limit (for example, 64 MiB).
        """
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceDataStoreFormatMetadataCacheMaxSize']:
        """
        Sets the maximum size of the metadata cache used by the data store format; value and unit together define the limit (for example, 64 MiB).
        """
        return pulumi.get(self, "max_size")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceDataStoreFormatMetadataCacheMaxSize(dict):
    def __init__(__self__, *,
                 value: _builtins.float,
                 unit: Optional[_builtins.str] = None):
        """
        :param _builtins.float value: Sets the numeric value for the metadata cache maximum size in the specified unit; this must be a positive integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str unit: Sets the unit used for the metadata cache maximum size; valid units follow libvirt size units such as "B", "KiB", "MiB", "GiB" and are user-chosen.
               
               See: <https://libvirt.org/formatdomain.html#memory-allocation>
        """
        pulumi.set(__self__, "value", value)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.float:
        """
        Sets the numeric value for the metadata cache maximum size in the specified unit; this must be a positive integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        """
        Sets the unit used for the metadata cache maximum size; valid units follow libvirt size units such as "B", "KiB", "MiB", "GiB" and are user-chosen.

        See: <https://libvirt.org/formatdomain.html#memory-allocation>
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceDir(dict):
    def __init__(__self__, *,
                 dir: Optional[_builtins.str] = None):
        """
        :param _builtins.str dir: Sets the host directory path used as the mirrored backing store source; this must be an absolute path on the host (for example, "/var/lib/libvirt/images").
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if dir is not None:
            pulumi.set(__self__, "dir", dir)

    @_builtins.property
    @pulumi.getter
    def dir(self) -> Optional[_builtins.str]:
        """
        Sets the host directory path used as the mirrored backing store source; this must be an absolute path on the host (for example, "/var/lib/libvirt/images").

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "dir")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceEncryption(dict):
    def __init__(__self__, *,
                 engine: Optional[_builtins.str] = None,
                 format: Optional[_builtins.str] = None,
                 secrets: Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceEncryptionSecret']] = None):
        """
        :param _builtins.str engine: Sets the encryption engine/provider to use for the disk (user-provided string, e.g. implementation-specific engine name).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str format: Sets the disk encryption format, such as "luks" or another user-provided scheme supported by libvirt/qemu.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param Sequence['DomainDevicesDiskMirrorSourceEncryptionSecretArgs'] secrets: Defines one or more secret references used to access the encrypted disk, each describing how libvirt locates the secret material.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if engine is not None:
            pulumi.set(__self__, "engine", engine)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def engine(self) -> Optional[_builtins.str]:
        """
        Sets the encryption engine/provider to use for the disk (user-provided string, e.g. implementation-specific engine name).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "engine")

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[_builtins.str]:
        """
        Sets the disk encryption format, such as "luks" or another user-provided scheme supported by libvirt/qemu.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceEncryptionSecret']]:
        """
        Defines one or more secret references used to access the encrypted disk, each describing how libvirt locates the secret material.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceEncryptionSecret(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 usage: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str usage: Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str uuid: Exposes the UUID of the libvirt secret used for iSCSI authentication; this is computed from the referenced secret rather than configured directly.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def usage(self) -> Optional[_builtins.str]:
        """
        Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "usage")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        Exposes the UUID of the libvirt secret used for iSCSI authentication; this is computed from the referenced secret rather than configured directly.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fdGroup":
            suggest = "fd_group"
        elif key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fd_group: Optional[_builtins.str] = None,
                 file: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceFileSecLabel']] = None):
        """
        :param _builtins.str fd_group: Sets the name of an fdgroup whose pre-opened file descriptor is used for this backing store instead of opening the file path directly; value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str file: Sets the absolute path on the host to the backing file used as the source for this mirrored disk (for example, /var/lib/libvirt/images/base.qcow2).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param Sequence['DomainDevicesDiskMirrorSourceFileSecLabelArgs'] sec_labels: Configures an explicit security label for the file backing store, overriding default security driver labeling for this file.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if fd_group is not None:
            pulumi.set(__self__, "fd_group", fd_group)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter(name="fdGroup")
    def fd_group(self) -> Optional[_builtins.str]:
        """
        Sets the name of an fdgroup whose pre-opened file descriptor is used for this backing store instead of opening the file path directly; value is user-provided.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "fd_group")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional[_builtins.str]:
        """
        Sets the absolute path on the host to the backing file used as the source for this mirrored disk (for example, /var/lib/libvirt/images/base.qcow2).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceFileSecLabel']]:
        """
        Configures an explicit security label for the file backing store, overriding default security driver labeling for this file.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceFileSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceFileSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceFileSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceFileSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "knownHosts":
            suggest = "known_hosts"
        elif key == "tlsHostname":
            suggest = "tls_hostname"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth: Optional['outputs.DomainDevicesDiskMirrorSourceNetworkAuth'] = None,
                 config: Optional['outputs.DomainDevicesDiskMirrorSourceNetworkConfig'] = None,
                 hosts: Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceNetworkHost']] = None,
                 identity: Optional['outputs.DomainDevicesDiskMirrorSourceNetworkIdentity'] = None,
                 initiator: Optional['outputs.DomainDevicesDiskMirrorSourceNetworkInitiator'] = None,
                 known_hosts: Optional['outputs.DomainDevicesDiskMirrorSourceNetworkKnownHosts'] = None,
                 name: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 query: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesDiskMirrorSourceNetworkReconnect'] = None,
                 snapshot: Optional['outputs.DomainDevicesDiskMirrorSourceNetworkSnapshot'] = None,
                 tls: Optional[_builtins.str] = None,
                 tls_hostname: Optional[_builtins.str] = None):
        """
        :param 'DomainDevicesDiskMirrorSourceNetworkAuthArgs' auth: Configures CHAP authentication parameters for the iSCSI source backing an assigned SCSI host device; include this block only when the target requires authentication.
        :param 'DomainDevicesDiskMirrorSourceNetworkConfigArgs' config: Points to an external configuration source for the network backing store (for example, an RBD or Ceph config file) that libvirt passes to the backend.
        :param Sequence['DomainDevicesDiskMirrorSourceNetworkHostArgs'] hosts: Declares one or more network endpoints (hosts) for the backing store server, each with its own name/address and possibly additional attributes.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainDevicesDiskMirrorSourceNetworkIdentityArgs' identity: Configures authentication/identity parameters used when accessing the mirrored backing store over a network, such as user, group, keyfile, or agent socket, depending on the protocol.
        :param 'DomainDevicesDiskMirrorSourceNetworkInitiatorArgs' initiator: Configures initiator identity information (typically for iSCSI-like protocols) used when accessing the mirrored network backing store.
        :param 'DomainDevicesDiskMirrorSourceNetworkKnownHostsArgs' known_hosts: Enables use of a known-hosts file to validate the remote hosts identity when connecting to the mirrored network backing store.
        :param _builtins.str name: Sets a name for the network source of the mirrored backing store, typically used by certain protocols (such as RBD pool or NBD export names); value is user-provided and protocol-specific.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str protocol: Sets the network storage protocol used for the mirrored backing store; value is user-provided but must be a protocol supported by libvirt for network disks (for example, rbd, sheepdog, gluster, nbd).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str query: Sets an optional query string or subresource specifier for the network storage URL of the mirrored backing store; value is user-provided and protocol-specific.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainDevicesDiskMirrorSourceNetworkReconnectArgs' reconnect: Configures automatic reconnection behavior for the mirrored network backing store after a connection loss.
        :param 'DomainDevicesDiskMirrorSourceNetworkSnapshotArgs' snapshot: Configures snapshot-related behavior for the network-based mirrored backing store, with semantics depending on the underlying protocol and storage implementation.
        :param _builtins.str tls: Controls whether TLS is used for the mirrored disks network backing-store connection; value is user-provided and typically enabled only when the chosen protocol and backend support TLS.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str tls_hostname: Sets the expected TLS hostname for the mirrored disks network backing-store connection, used for certificate verification; value is user-provided and should match the server certificates hostname (for example, "storage.example.com").
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if initiator is not None:
            pulumi.set(__self__, "initiator", initiator)
        if known_hosts is not None:
            pulumi.set(__self__, "known_hosts", known_hosts)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if snapshot is not None:
            pulumi.set(__self__, "snapshot", snapshot)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if tls_hostname is not None:
            pulumi.set(__self__, "tls_hostname", tls_hostname)

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceNetworkAuth']:
        """
        Configures CHAP authentication parameters for the iSCSI source backing an assigned SCSI host device; include this block only when the target requires authentication.
        """
        return pulumi.get(self, "auth")

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceNetworkConfig']:
        """
        Points to an external configuration source for the network backing store (for example, an RBD or Ceph config file) that libvirt passes to the backend.
        """
        return pulumi.get(self, "config")

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceNetworkHost']]:
        """
        Declares one or more network endpoints (hosts) for the backing store server, each with its own name/address and possibly additional attributes.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter
    def identity(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceNetworkIdentity']:
        """
        Configures authentication/identity parameters used when accessing the mirrored backing store over a network, such as user, group, keyfile, or agent socket, depending on the protocol.
        """
        return pulumi.get(self, "identity")

    @_builtins.property
    @pulumi.getter
    def initiator(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceNetworkInitiator']:
        """
        Configures initiator identity information (typically for iSCSI-like protocols) used when accessing the mirrored network backing store.
        """
        return pulumi.get(self, "initiator")

    @_builtins.property
    @pulumi.getter(name="knownHosts")
    def known_hosts(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceNetworkKnownHosts']:
        """
        Enables use of a known-hosts file to validate the remote hosts identity when connecting to the mirrored network backing store.
        """
        return pulumi.get(self, "known_hosts")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets a name for the network source of the mirrored backing store, typically used by certain protocols (such as RBD pool or NBD export names); value is user-provided and protocol-specific.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        Sets the network storage protocol used for the mirrored backing store; value is user-provided but must be a protocol supported by libvirt for network disks (for example, rbd, sheepdog, gluster, nbd).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional[_builtins.str]:
        """
        Sets an optional query string or subresource specifier for the network storage URL of the mirrored backing store; value is user-provided and protocol-specific.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "query")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceNetworkReconnect']:
        """
        Configures automatic reconnection behavior for the mirrored network backing store after a connection loss.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter
    def snapshot(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceNetworkSnapshot']:
        """
        Configures snapshot-related behavior for the network-based mirrored backing store, with semantics depending on the underlying protocol and storage implementation.
        """
        return pulumi.get(self, "snapshot")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[_builtins.str]:
        """
        Controls whether TLS is used for the mirrored disks network backing-store connection; value is user-provided and typically enabled only when the chosen protocol and backend support TLS.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "tls")

    @_builtins.property
    @pulumi.getter(name="tlsHostname")
    def tls_hostname(self) -> Optional[_builtins.str]:
        """
        Sets the expected TLS hostname for the mirrored disks network backing-store connection, used for certificate verification; value is user-provided and should match the server certificates hostname (for example, "storage.example.com").

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "tls_hostname")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceNetworkAuth(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.DomainDevicesDiskMirrorSourceNetworkAuthSecret'] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param 'DomainDevicesDiskMirrorSourceNetworkAuthSecretArgs' secret: Configures the libvirt secret object used to hold the iSCSI authentication password for this hostdev; this references an existing libvirt secret, not the clear-text secret.
        :param _builtins.str username: Sets the CHAP username used when authenticating to the iSCSI target for this SCSI hostdev; the value is user-provided (for example, "chapuser1").
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceNetworkAuthSecret']:
        """
        Configures the libvirt secret object used to hold the iSCSI authentication password for this hostdev; this references an existing libvirt secret, not the clear-text secret.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        Sets the CHAP username used when authenticating to the iSCSI target for this SCSI hostdev; the value is user-provided (for example, "chapuser1").

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceNetworkAuthSecret(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 usage: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str usage: Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str uuid: Exposes the UUID of the libvirt secret used for iSCSI authentication; this is computed from the referenced secret rather than configured directly.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def usage(self) -> Optional[_builtins.str]:
        """
        Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "usage")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        Exposes the UUID of the libvirt secret used for iSCSI authentication; this is computed from the referenced secret rather than configured directly.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceNetworkConfig(dict):
    def __init__(__self__, *,
                 file: _builtins.str):
        """
        :param _builtins.str file: Sets the path to the configuration file used for the network backing store connection, such as a Ceph configuration file (/etc/ceph/ceph.conf).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "file", file)

    @_builtins.property
    @pulumi.getter
    def file(self) -> _builtins.str:
        """
        Sets the path to the configuration file used for the network backing store connection, such as a Ceph configuration file (/etc/ceph/ceph.conf).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "file")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceNetworkHost(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 socket: Optional[_builtins.str] = None,
                 transport: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Sets the hostname or IP address of the iSCSI target portal (for example, "10.0.0.10" or "iscsi.example.com").
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str port: Sets the TCP port of the iSCSI target portal; if omitted, libvirt/driver defaults (commonly 3260) are used.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str socket: Sets a UNIX domain socket path to connect to an iSCSI target via a local socket instead of TCP; value is a user-provided filesystem path.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str transport: Sets the transport type used to reach the iSCSI target portal; valid values are user-provided strings as supported by the environment (for example, "tcp" or "iser").
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if socket is not None:
            pulumi.set(__self__, "socket", socket)
        if transport is not None:
            pulumi.set(__self__, "transport", transport)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the hostname or IP address of the iSCSI target portal (for example, "10.0.0.10" or "iscsi.example.com").

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        """
        Sets the TCP port of the iSCSI target portal; if omitted, libvirt/driver defaults (commonly 3260) are used.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def socket(self) -> Optional[_builtins.str]:
        """
        Sets a UNIX domain socket path to connect to an iSCSI target via a local socket instead of TCP; value is a user-provided filesystem path.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "socket")

    @_builtins.property
    @pulumi.getter
    def transport(self) -> Optional[_builtins.str]:
        """
        Sets the transport type used to reach the iSCSI target portal; valid values are user-provided strings as supported by the environment (for example, "tcp" or "iser").

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "transport")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceNetworkIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentSock":
            suggest = "agent_sock"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceNetworkIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceNetworkIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceNetworkIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_sock: Optional[_builtins.str] = None,
                 group: Optional[_builtins.str] = None,
                 keyfile: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str agent_sock: Sets the path to a local agent socket used for external authentication (for example, SASL or SSH agent) when connecting to the network backing store; value is a user-provided Unix socket path.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str group: Sets the group name to use for authentication or access control when connecting to the network backing store; value is user-provided and protocol-specific.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str keyfile: Sets the path to a private key file used for authenticating to the network backing store (for example, an SSH or TLS key); value is a user-provided filesystem path.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str user: Sets the user identifier used for authentication to the network backing store; value is user-provided and typically matches a remote account name.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str user_name: Sets an explicit username string used for authentication to the network backing store, separate from any other user identity settings; value is user-provided (for example, "backupuser").
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if agent_sock is not None:
            pulumi.set(__self__, "agent_sock", agent_sock)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if keyfile is not None:
            pulumi.set(__self__, "keyfile", keyfile)
        if user is not None:
            pulumi.set(__self__, "user", user)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="agentSock")
    def agent_sock(self) -> Optional[_builtins.str]:
        """
        Sets the path to a local agent socket used for external authentication (for example, SASL or SSH agent) when connecting to the network backing store; value is a user-provided Unix socket path.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "agent_sock")

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[_builtins.str]:
        """
        Sets the group name to use for authentication or access control when connecting to the network backing store; value is user-provided and protocol-specific.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter
    def keyfile(self) -> Optional[_builtins.str]:
        """
        Sets the path to a private key file used for authenticating to the network backing store (for example, an SSH or TLS key); value is a user-provided filesystem path.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "keyfile")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        Sets the user identifier used for authentication to the network backing store; value is user-provided and typically matches a remote account name.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "user")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        """
        Sets an explicit username string used for authentication to the network backing store, separate from any other user identity settings; value is user-provided (for example, "backupuser").

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceNetworkInitiator(dict):
    def __init__(__self__, *,
                 iqn: Optional['outputs.DomainDevicesDiskMirrorSourceNetworkInitiatorIqn'] = None):
        """
        :param 'DomainDevicesDiskMirrorSourceNetworkInitiatorIqnArgs' iqn: Configures the iSCSI initiator IQN block for the mirrored network backing store, defining the initiator name presented to the target.
        """
        if iqn is not None:
            pulumi.set(__self__, "iqn", iqn)

    @_builtins.property
    @pulumi.getter
    def iqn(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceNetworkInitiatorIqn']:
        """
        Configures the iSCSI initiator IQN block for the mirrored network backing store, defining the initiator name presented to the target.
        """
        return pulumi.get(self, "iqn")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceNetworkInitiatorIqn(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Sets the initiator IQN string used when logging into an iSCSI target backing the mirrored disk; value must be a valid IQN (for example, iqn.2020-01.com.example:host1).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the initiator IQN string used when logging into an iSCSI target backing the mirrored disk; value must be a valid IQN (for example, iqn.2020-01.com.example:host1).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceNetworkKnownHosts(dict):
    def __init__(__self__, *,
                 path: _builtins.str):
        """
        :param _builtins.str path: Sets the path to the known-hosts file used to verify the identity of the remote storage host; value is a required user-provided filesystem path (for example, /etc/libvirt/known_hosts).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the path to the known-hosts file used to verify the identity of the remote storage host; value is a required user-provided filesystem path (for example, /etc/libvirt/known_hosts).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceNetworkReconnect(dict):
    def __init__(__self__, *,
                 delay: _builtins.str):
        """
        :param _builtins.str delay: Sets the reconnection delay (in seconds) before retrying a failed connection to the mirrored network backing store; value is a required user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "delay", delay)

    @_builtins.property
    @pulumi.getter
    def delay(self) -> _builtins.str:
        """
        Sets the reconnection delay (in seconds) before retrying a failed connection to the mirrored network backing store; value is a required user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "delay")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceNetworkSnapshot(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the name of the network snapshot to use as the backing store for the mirrored disks network source; value is user-provided and must match an existing snapshot identifier on the storage backend.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the name of the network snapshot to use as the backing store for the mirrored disks network source; value is user-provided and must match an existing snapshot identifier on the storage backend.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceNvme(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesDiskMirrorSourceReadahead(dict):
    def __init__(__self__, *,
                 size: _builtins.str):
        """
        :param _builtins.str size: Sets the read-ahead size for the mirrored disks backing store; value is a user-provided positive integer in bytes (for example, 65536 for 64 KiB).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        """
        Sets the read-ahead size for the mirrored disks backing store; value is a user-provided positive integer in bytes (for example, 65536 for 64 KiB).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceReservations(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.str] = None,
                 managed: Optional[_builtins.bool] = None,
                 source: Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSource'] = None):
        """
        :param _builtins.str enabled: Controls whether persistent reservations are enabled for the mirrored disks backing-store source; value is user-provided and typically expects "yes" or "no" semantics per libvirt.
        :param _builtins.bool managed: Indicates whether reservations are managed by libvirt ("yes") or externally ("no"); value is provided as a string and translated to a boolean, with "yes" meaning true and "no" meaning false.
        :param 'DomainDevicesDiskMirrorSourceReservationsSourceArgs' source: Selects the mechanism used to provide reservation control for the mirrored backing-store source, such as a D-Bus service or a device/file endpoint.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if managed is not None:
            pulumi.set(__self__, "managed", managed)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.str]:
        """
        Controls whether persistent reservations are enabled for the mirrored disks backing-store source; value is user-provided and typically expects "yes" or "no" semantics per libvirt.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def managed(self) -> Optional[_builtins.bool]:
        """
        Indicates whether reservations are managed by libvirt ("yes") or externally ("no"); value is provided as a string and translated to a boolean, with "yes" meaning true and "no" meaning false.
        """
        return pulumi.get(self, "managed")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSource']:
        """
        Selects the mechanism used to provide reservation control for the mirrored backing-store source, such as a D-Bus service or a device/file endpoint.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceReservationsSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "qemuvdAgent":
            suggest = "qemuvd_agent"
        elif key == "spicePort":
            suggest = "spice_port"
        elif key == "spiceVmc":
            suggest = "spice_vmc"
        elif key == "stdIo":
            suggest = "std_io"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceReservationsSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceReservationsSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceReservationsSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbus: Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourceDbus'] = None,
                 dev: Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourceDev'] = None,
                 file: Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourceFile'] = None,
                 nmdm: Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourceNmdm'] = None,
                 null: Optional[_builtins.bool] = None,
                 pipe: Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourcePipe'] = None,
                 pty: Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourcePty'] = None,
                 qemuvd_agent: Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourceQemuvdAgent'] = None,
                 spice_port: Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourceSpicePort'] = None,
                 spice_vmc: Optional[_builtins.bool] = None,
                 std_io: Optional[_builtins.bool] = None,
                 tcp: Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourceTcp'] = None,
                 udp: Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourceUdp'] = None,
                 unix: Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourceUnix'] = None,
                 vc: Optional[_builtins.bool] = None):
        """
        :param 'DomainDevicesDiskMirrorSourceReservationsSourceDbusArgs' dbus: Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        :param 'DomainDevicesDiskMirrorSourceReservationsSourceDevArgs' dev: Configures an EGD RNG backend that reads entropy from a host character device node.
        :param 'DomainDevicesDiskMirrorSourceReservationsSourceFileArgs' file: Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        :param 'DomainDevicesDiskMirrorSourceReservationsSourceNmdmArgs' nmdm: Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        :param _builtins.bool null: Enables use of a null character device as the reservation backing source; when this boolean is true, a Null source is emitted and all written data is discarded.
               
               See: <https://libvirt.org/formatdomain.html#null-device>
        :param 'DomainDevicesDiskMirrorSourceReservationsSourcePipeArgs' pipe: Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        :param 'DomainDevicesDiskMirrorSourceReservationsSourcePtyArgs' pty: Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        :param 'DomainDevicesDiskMirrorSourceReservationsSourceQemuvdAgentArgs' qemuvd_agent: Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        :param 'DomainDevicesDiskMirrorSourceReservationsSourceSpicePortArgs' spice_port: Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        :param _builtins.bool spice_vmc: Enables a SPICE VMC (SPICE management channel) backend for this backing-store source; when set true the element is emitted, when false or null it is omitted.
               
               See: <https://libvirt.org/formatdomain.html#spice-channel>
        :param _builtins.bool std_io: Connects the backing-store sources character channel to the domains standard I/O (stdin/stdout/stderr); when true the element is emitted, when false or null it is omitted.
               
               See: <https://libvirt.org/formatdomain.html#host-interface>
        :param 'DomainDevicesDiskMirrorSourceReservationsSourceTcpArgs' tcp: Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        :param 'DomainDevicesDiskMirrorSourceReservationsSourceUdpArgs' udp: Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        :param 'DomainDevicesDiskMirrorSourceReservationsSourceUnixArgs' unix: Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        :param _builtins.bool vc: Enables use of a VC (virtual cluster or vendor-specific) reservation source when set; since this is presence-based, setting it to true emits the element and false/null omits it.
        """
        if dbus is not None:
            pulumi.set(__self__, "dbus", dbus)
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if nmdm is not None:
            pulumi.set(__self__, "nmdm", nmdm)
        if null is not None:
            pulumi.set(__self__, "null", null)
        if pipe is not None:
            pulumi.set(__self__, "pipe", pipe)
        if pty is not None:
            pulumi.set(__self__, "pty", pty)
        if qemuvd_agent is not None:
            pulumi.set(__self__, "qemuvd_agent", qemuvd_agent)
        if spice_port is not None:
            pulumi.set(__self__, "spice_port", spice_port)
        if spice_vmc is not None:
            pulumi.set(__self__, "spice_vmc", spice_vmc)
        if std_io is not None:
            pulumi.set(__self__, "std_io", std_io)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)
        if unix is not None:
            pulumi.set(__self__, "unix", unix)
        if vc is not None:
            pulumi.set(__self__, "vc", vc)

    @_builtins.property
    @pulumi.getter
    def dbus(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourceDbus']:
        """
        Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        """
        return pulumi.get(self, "dbus")

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourceDev']:
        """
        Configures an EGD RNG backend that reads entropy from a host character device node.
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourceFile']:
        """
        Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def nmdm(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourceNmdm']:
        """
        Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        """
        return pulumi.get(self, "nmdm")

    @_builtins.property
    @pulumi.getter
    def null(self) -> Optional[_builtins.bool]:
        """
        Enables use of a null character device as the reservation backing source; when this boolean is true, a Null source is emitted and all written data is discarded.

        See: <https://libvirt.org/formatdomain.html#null-device>
        """
        return pulumi.get(self, "null")

    @_builtins.property
    @pulumi.getter
    def pipe(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourcePipe']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        """
        return pulumi.get(self, "pipe")

    @_builtins.property
    @pulumi.getter
    def pty(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourcePty']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        """
        return pulumi.get(self, "pty")

    @_builtins.property
    @pulumi.getter(name="qemuvdAgent")
    def qemuvd_agent(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourceQemuvdAgent']:
        """
        Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        """
        return pulumi.get(self, "qemuvd_agent")

    @_builtins.property
    @pulumi.getter(name="spicePort")
    def spice_port(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourceSpicePort']:
        """
        Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        """
        return pulumi.get(self, "spice_port")

    @_builtins.property
    @pulumi.getter(name="spiceVmc")
    def spice_vmc(self) -> Optional[_builtins.bool]:
        """
        Enables a SPICE VMC (SPICE management channel) backend for this backing-store source; when set true the element is emitted, when false or null it is omitted.

        See: <https://libvirt.org/formatdomain.html#spice-channel>
        """
        return pulumi.get(self, "spice_vmc")

    @_builtins.property
    @pulumi.getter(name="stdIo")
    def std_io(self) -> Optional[_builtins.bool]:
        """
        Connects the backing-store sources character channel to the domains standard I/O (stdin/stdout/stderr); when true the element is emitted, when false or null it is omitted.

        See: <https://libvirt.org/formatdomain.html#host-interface>
        """
        return pulumi.get(self, "std_io")

    @_builtins.property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourceTcp']:
        """
        Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        """
        return pulumi.get(self, "tcp")

    @_builtins.property
    @pulumi.getter
    def udp(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourceUdp']:
        """
        Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        """
        return pulumi.get(self, "udp")

    @_builtins.property
    @pulumi.getter
    def unix(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourceUnix']:
        """
        Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        """
        return pulumi.get(self, "unix")

    @_builtins.property
    @pulumi.getter
    def vc(self) -> Optional[_builtins.bool]:
        """
        Enables use of a VC (virtual cluster or vendor-specific) reservation source when set; since this is presence-based, setting it to true emits the element and false/null omits it.
        """
        return pulumi.get(self, "vc")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceReservationsSourceDbus(dict):
    def __init__(__self__, *,
                 channel: Optional[_builtins.str] = None):
        """
        :param _builtins.str channel: Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.str]:
        """
        Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceReservationsSourceDev(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceReservationsSourceDev. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceReservationsSourceDev.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceReservationsSourceDev.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceReservationsSourceDevSecLabel']] = None):
        """
        :param _builtins.str path: Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesDiskMirrorSourceReservationsSourceDevSecLabelArgs'] sec_labels: Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceReservationsSourceDevSecLabel']]:
        """
        Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceReservationsSourceDevSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceReservationsSourceDevSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceReservationsSourceDevSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceReservationsSourceDevSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceReservationsSourceFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceReservationsSourceFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceReservationsSourceFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceReservationsSourceFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 append: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceReservationsSourceFileSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str append: Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
               
               See: <https://libvirt.org/formatdomain.html#device-logfile>
        :param Sequence['DomainDevicesDiskMirrorSourceReservationsSourceFileSecLabelArgs'] sec_labels: Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def append(self) -> Optional[_builtins.str]:
        """
        Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.

        See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        return pulumi.get(self, "append")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceReservationsSourceFileSecLabel']]:
        """
        Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceReservationsSourceFileSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceReservationsSourceFileSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceReservationsSourceFileSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceReservationsSourceFileSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceReservationsSourceNmdm(dict):
    def __init__(__self__, *,
                 master: _builtins.str,
                 slave: _builtins.str):
        """
        :param _builtins.str master: Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        :param _builtins.str slave: Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        pulumi.set(__self__, "master", master)
        pulumi.set(__self__, "slave", slave)

    @_builtins.property
    @pulumi.getter
    def master(self) -> _builtins.str:
        """
        Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "master")

    @_builtins.property
    @pulumi.getter
    def slave(self) -> _builtins.str:
        """
        Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "slave")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceReservationsSourcePipe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceReservationsSourcePipe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceReservationsSourcePipe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceReservationsSourcePipe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceReservationsSourcePipeSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesDiskMirrorSourceReservationsSourcePipeSecLabelArgs'] sec_labels: Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceReservationsSourcePipeSecLabel']]:
        """
        Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceReservationsSourcePipeSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceReservationsSourcePipeSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceReservationsSourcePipeSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceReservationsSourcePipeSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceReservationsSourcePty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceReservationsSourcePty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceReservationsSourcePty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceReservationsSourcePty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceReservationsSourcePtySecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesDiskMirrorSourceReservationsSourcePtySecLabelArgs'] sec_labels: Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceReservationsSourcePtySecLabel']]:
        """
        Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceReservationsSourcePtySecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceReservationsSourcePtySecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceReservationsSourcePtySecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceReservationsSourcePtySecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceReservationsSourceQemuvdAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clipBoard":
            suggest = "clip_board"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceReservationsSourceQemuvdAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceReservationsSourceQemuvdAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceReservationsSourceQemuvdAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clip_board: Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourceQemuvdAgentClipBoard'] = None,
                 mouse: Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourceQemuvdAgentMouse'] = None):
        """
        :param 'DomainDevicesDiskMirrorSourceReservationsSourceQemuvdAgentClipBoardArgs' clip_board: Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        :param 'DomainDevicesDiskMirrorSourceReservationsSourceQemuvdAgentMouseArgs' mouse: Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        if clip_board is not None:
            pulumi.set(__self__, "clip_board", clip_board)
        if mouse is not None:
            pulumi.set(__self__, "mouse", mouse)

    @_builtins.property
    @pulumi.getter(name="clipBoard")
    def clip_board(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourceQemuvdAgentClipBoard']:
        """
        Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        """
        return pulumi.get(self, "clip_board")

    @_builtins.property
    @pulumi.getter
    def mouse(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourceQemuvdAgentMouse']:
        """
        Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        return pulumi.get(self, "mouse")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceReservationsSourceQemuvdAgentClipBoard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyPaste":
            suggest = "copy_paste"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceReservationsSourceQemuvdAgentClipBoard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceReservationsSourceQemuvdAgentClipBoard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceReservationsSourceQemuvdAgentClipBoard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_paste: _builtins.str):
        """
        :param _builtins.str copy_paste: Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "copy_paste", copy_paste)

    @_builtins.property
    @pulumi.getter(name="copyPaste")
    def copy_paste(self) -> _builtins.str:
        """
        Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "copy_paste")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceReservationsSourceQemuvdAgentMouse(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceReservationsSourceSpicePort(dict):
    def __init__(__self__, *,
                 channel: _builtins.str):
        """
        :param _builtins.str channel: Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceReservationsSourceTcp(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourceTcpReconnect'] = None,
                 service: Optional[_builtins.str] = None,
                 tls: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str mode: Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesDiskMirrorSourceReservationsSourceTcpReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param _builtins.str service: Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str tls: Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourceTcpReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[_builtins.str]:
        """
        Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceReservationsSourceTcpReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceReservationsSourceUdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindHost":
            suggest = "bind_host"
        elif key == "bindService":
            suggest = "bind_service"
        elif key == "connectHost":
            suggest = "connect_host"
        elif key == "connectService":
            suggest = "connect_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceReservationsSourceUdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceReservationsSourceUdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceReservationsSourceUdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bind_host: _builtins.str,
                 bind_service: _builtins.str,
                 connect_host: _builtins.str,
                 connect_service: _builtins.str):
        """
        :param _builtins.str bind_host: Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str bind_service: Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_host: Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_service: Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "bind_host", bind_host)
        pulumi.set(__self__, "bind_service", bind_service)
        pulumi.set(__self__, "connect_host", connect_host)
        pulumi.set(__self__, "connect_service", connect_service)

    @_builtins.property
    @pulumi.getter(name="bindHost")
    def bind_host(self) -> _builtins.str:
        """
        Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_host")

    @_builtins.property
    @pulumi.getter(name="bindService")
    def bind_service(self) -> _builtins.str:
        """
        Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_service")

    @_builtins.property
    @pulumi.getter(name="connectHost")
    def connect_host(self) -> _builtins.str:
        """
        Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_host")

    @_builtins.property
    @pulumi.getter(name="connectService")
    def connect_service(self) -> _builtins.str:
        """
        Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_service")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceReservationsSourceUnix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceReservationsSourceUnix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceReservationsSourceUnix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceReservationsSourceUnix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourceUnixReconnect'] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceReservationsSourceUnixSecLabel']] = None):
        """
        :param _builtins.str mode: Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str path: Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesDiskMirrorSourceReservationsSourceUnixReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param Sequence['DomainDevicesDiskMirrorSourceReservationsSourceUnixSecLabelArgs'] sec_labels: Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceReservationsSourceUnixReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceReservationsSourceUnixSecLabel']]:
        """
        Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceReservationsSourceUnixReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceReservationsSourceUnixSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceReservationsSourceUnixSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceReservationsSourceUnixSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceReservationsSourceUnixSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceSlices(dict):
    def __init__(__self__, *,
                 slices: Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceSlicesSlice']] = None):
        """
        :param Sequence['DomainDevicesDiskMirrorSourceSlicesSliceArgs'] slices: Configures one or more slices of the backing-store source, each describing a contiguous portion of the underlying device or file that is exposed through this mirror backing store.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if slices is not None:
            pulumi.set(__self__, "slices", slices)

    @_builtins.property
    @pulumi.getter
    def slices(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceSlicesSlice']]:
        """
        Configures one or more slices of the backing-store source, each describing a contiguous portion of the underlying device or file that is exposed through this mirror backing store.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "slices")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceSlicesSlice(dict):
    def __init__(__self__, *,
                 offset: _builtins.float,
                 size: _builtins.float,
                 type: _builtins.str):
        """
        :param _builtins.float offset: Sets the starting offset (in bytes) of this slice within the underlying backing-store source; must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.float size: Sets the size (in bytes) of this slice within the underlying backing-store source; must be a positive integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str type: Specifies the type of slice mapping to use for this range; the value is userprovided and must match a type supported by the hypervisor (for example, a particular mapping or layout scheme).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def offset(self) -> _builtins.float:
        """
        Sets the starting offset (in bytes) of this slice within the underlying backing-store source; must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "offset")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.float:
        """
        Sets the size (in bytes) of this slice within the underlying backing-store source; must be a positive integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of slice mapping to use for this range; the value is userprovided and must match a type supported by the hypervisor (for example, a particular mapping or layout scheme).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceSsl(dict):
    def __init__(__self__, *,
                 verify: _builtins.str):
        """
        :param _builtins.str verify: Controls certificate verification for SSL/TLS access to the mirrored backing-store source; typical values are "yes" or "no" to enable or disable verification.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "verify", verify)

    @_builtins.property
    @pulumi.getter
    def verify(self) -> _builtins.str:
        """
        Controls certificate verification for SSL/TLS access to the mirrored backing-store source; typical values are "yes" or "no" to enable or disable verification.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "verify")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceTimeout(dict):
    def __init__(__self__, *,
                 seconds: _builtins.str):
        """
        :param _builtins.str seconds: Sets the timeout duration in seconds for accessing the mirrored backing-store source; must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.str:
        """
        Sets the timeout duration in seconds for accessing the mirrored backing-store source; must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceVhostUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "qemuvdAgent":
            suggest = "qemuvd_agent"
        elif key == "spicePort":
            suggest = "spice_port"
        elif key == "spiceVmc":
            suggest = "spice_vmc"
        elif key == "stdIo":
            suggest = "std_io"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceVhostUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceVhostUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceVhostUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbus: Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserDbus'] = None,
                 dev: Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserDev'] = None,
                 file: Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserFile'] = None,
                 nmdm: Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserNmdm'] = None,
                 null: Optional[_builtins.bool] = None,
                 pipe: Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserPipe'] = None,
                 pty: Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserPty'] = None,
                 qemuvd_agent: Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserQemuvdAgent'] = None,
                 spice_port: Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserSpicePort'] = None,
                 spice_vmc: Optional[_builtins.bool] = None,
                 std_io: Optional[_builtins.bool] = None,
                 tcp: Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserTcp'] = None,
                 udp: Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserUdp'] = None,
                 unix: Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserUnix'] = None,
                 vc: Optional[_builtins.bool] = None):
        """
        :param 'DomainDevicesDiskMirrorSourceVhostUserDbusArgs' dbus: Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        :param 'DomainDevicesDiskMirrorSourceVhostUserDevArgs' dev: Configures an EGD RNG backend that reads entropy from a host character device node.
        :param 'DomainDevicesDiskMirrorSourceVhostUserFileArgs' file: Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        :param 'DomainDevicesDiskMirrorSourceVhostUserNmdmArgs' nmdm: Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        :param _builtins.bool null: When set to true, uses a null character device as the vhost-user backing-store source, discarding all output and providing no input; when false or unset, the null device is not used.
               
               See: <https://libvirt.org/formatdomain.html#null-device>
        :param 'DomainDevicesDiskMirrorSourceVhostUserPipeArgs' pipe: Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        :param 'DomainDevicesDiskMirrorSourceVhostUserPtyArgs' pty: Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        :param 'DomainDevicesDiskMirrorSourceVhostUserQemuvdAgentArgs' qemuvd_agent: Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        :param 'DomainDevicesDiskMirrorSourceVhostUserSpicePortArgs' spice_port: Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        :param _builtins.bool spice_vmc: When set to true, exposes the vhost-user backing through a SPICE virtio-serial management channel (SpiceVMC); when false or unset, the element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#spice-channel>
        :param _builtins.bool std_io: When set to true, connects the vhost-user backing to the domains standard I/O character device; when false or unset, the StdIO element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#host-interface>
        :param 'DomainDevicesDiskMirrorSourceVhostUserTcpArgs' tcp: Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        :param 'DomainDevicesDiskMirrorSourceVhostUserUdpArgs' udp: Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        :param 'DomainDevicesDiskMirrorSourceVhostUserUnixArgs' unix: Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        :param _builtins.bool vc: Enables use of a vhost-user communication mechanism compatible with a VC-style (versioned capability) endpoint for the disk mirror backing store; when set true the VC element is emitted, when false or null it is omitted.
        """
        if dbus is not None:
            pulumi.set(__self__, "dbus", dbus)
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if nmdm is not None:
            pulumi.set(__self__, "nmdm", nmdm)
        if null is not None:
            pulumi.set(__self__, "null", null)
        if pipe is not None:
            pulumi.set(__self__, "pipe", pipe)
        if pty is not None:
            pulumi.set(__self__, "pty", pty)
        if qemuvd_agent is not None:
            pulumi.set(__self__, "qemuvd_agent", qemuvd_agent)
        if spice_port is not None:
            pulumi.set(__self__, "spice_port", spice_port)
        if spice_vmc is not None:
            pulumi.set(__self__, "spice_vmc", spice_vmc)
        if std_io is not None:
            pulumi.set(__self__, "std_io", std_io)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)
        if unix is not None:
            pulumi.set(__self__, "unix", unix)
        if vc is not None:
            pulumi.set(__self__, "vc", vc)

    @_builtins.property
    @pulumi.getter
    def dbus(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserDbus']:
        """
        Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        """
        return pulumi.get(self, "dbus")

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserDev']:
        """
        Configures an EGD RNG backend that reads entropy from a host character device node.
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserFile']:
        """
        Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def nmdm(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserNmdm']:
        """
        Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        """
        return pulumi.get(self, "nmdm")

    @_builtins.property
    @pulumi.getter
    def null(self) -> Optional[_builtins.bool]:
        """
        When set to true, uses a null character device as the vhost-user backing-store source, discarding all output and providing no input; when false or unset, the null device is not used.

        See: <https://libvirt.org/formatdomain.html#null-device>
        """
        return pulumi.get(self, "null")

    @_builtins.property
    @pulumi.getter
    def pipe(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserPipe']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        """
        return pulumi.get(self, "pipe")

    @_builtins.property
    @pulumi.getter
    def pty(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserPty']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        """
        return pulumi.get(self, "pty")

    @_builtins.property
    @pulumi.getter(name="qemuvdAgent")
    def qemuvd_agent(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserQemuvdAgent']:
        """
        Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        """
        return pulumi.get(self, "qemuvd_agent")

    @_builtins.property
    @pulumi.getter(name="spicePort")
    def spice_port(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserSpicePort']:
        """
        Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        """
        return pulumi.get(self, "spice_port")

    @_builtins.property
    @pulumi.getter(name="spiceVmc")
    def spice_vmc(self) -> Optional[_builtins.bool]:
        """
        When set to true, exposes the vhost-user backing through a SPICE virtio-serial management channel (SpiceVMC); when false or unset, the element is omitted.

        See: <https://libvirt.org/formatdomain.html#spice-channel>
        """
        return pulumi.get(self, "spice_vmc")

    @_builtins.property
    @pulumi.getter(name="stdIo")
    def std_io(self) -> Optional[_builtins.bool]:
        """
        When set to true, connects the vhost-user backing to the domains standard I/O character device; when false or unset, the StdIO element is omitted.

        See: <https://libvirt.org/formatdomain.html#host-interface>
        """
        return pulumi.get(self, "std_io")

    @_builtins.property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserTcp']:
        """
        Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        """
        return pulumi.get(self, "tcp")

    @_builtins.property
    @pulumi.getter
    def udp(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserUdp']:
        """
        Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        """
        return pulumi.get(self, "udp")

    @_builtins.property
    @pulumi.getter
    def unix(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserUnix']:
        """
        Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        """
        return pulumi.get(self, "unix")

    @_builtins.property
    @pulumi.getter
    def vc(self) -> Optional[_builtins.bool]:
        """
        Enables use of a vhost-user communication mechanism compatible with a VC-style (versioned capability) endpoint for the disk mirror backing store; when set true the VC element is emitted, when false or null it is omitted.
        """
        return pulumi.get(self, "vc")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceVhostUserDbus(dict):
    def __init__(__self__, *,
                 channel: Optional[_builtins.str] = None):
        """
        :param _builtins.str channel: Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.str]:
        """
        Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceVhostUserDev(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceVhostUserDev. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceVhostUserDev.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceVhostUserDev.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceVhostUserDevSecLabel']] = None):
        """
        :param _builtins.str path: Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesDiskMirrorSourceVhostUserDevSecLabelArgs'] sec_labels: Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceVhostUserDevSecLabel']]:
        """
        Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceVhostUserDevSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceVhostUserDevSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceVhostUserDevSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceVhostUserDevSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceVhostUserFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceVhostUserFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceVhostUserFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceVhostUserFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 append: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceVhostUserFileSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str append: Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
               
               See: <https://libvirt.org/formatdomain.html#device-logfile>
        :param Sequence['DomainDevicesDiskMirrorSourceVhostUserFileSecLabelArgs'] sec_labels: Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def append(self) -> Optional[_builtins.str]:
        """
        Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.

        See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        return pulumi.get(self, "append")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceVhostUserFileSecLabel']]:
        """
        Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceVhostUserFileSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceVhostUserFileSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceVhostUserFileSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceVhostUserFileSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceVhostUserNmdm(dict):
    def __init__(__self__, *,
                 master: _builtins.str,
                 slave: _builtins.str):
        """
        :param _builtins.str master: Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        :param _builtins.str slave: Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        pulumi.set(__self__, "master", master)
        pulumi.set(__self__, "slave", slave)

    @_builtins.property
    @pulumi.getter
    def master(self) -> _builtins.str:
        """
        Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "master")

    @_builtins.property
    @pulumi.getter
    def slave(self) -> _builtins.str:
        """
        Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "slave")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceVhostUserPipe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceVhostUserPipe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceVhostUserPipe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceVhostUserPipe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceVhostUserPipeSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesDiskMirrorSourceVhostUserPipeSecLabelArgs'] sec_labels: Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceVhostUserPipeSecLabel']]:
        """
        Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceVhostUserPipeSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceVhostUserPipeSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceVhostUserPipeSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceVhostUserPipeSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceVhostUserPty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceVhostUserPty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceVhostUserPty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceVhostUserPty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceVhostUserPtySecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesDiskMirrorSourceVhostUserPtySecLabelArgs'] sec_labels: Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceVhostUserPtySecLabel']]:
        """
        Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceVhostUserPtySecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceVhostUserPtySecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceVhostUserPtySecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceVhostUserPtySecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceVhostUserQemuvdAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clipBoard":
            suggest = "clip_board"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceVhostUserQemuvdAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceVhostUserQemuvdAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceVhostUserQemuvdAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clip_board: Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserQemuvdAgentClipBoard'] = None,
                 mouse: Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserQemuvdAgentMouse'] = None):
        """
        :param 'DomainDevicesDiskMirrorSourceVhostUserQemuvdAgentClipBoardArgs' clip_board: Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        :param 'DomainDevicesDiskMirrorSourceVhostUserQemuvdAgentMouseArgs' mouse: Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        if clip_board is not None:
            pulumi.set(__self__, "clip_board", clip_board)
        if mouse is not None:
            pulumi.set(__self__, "mouse", mouse)

    @_builtins.property
    @pulumi.getter(name="clipBoard")
    def clip_board(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserQemuvdAgentClipBoard']:
        """
        Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        """
        return pulumi.get(self, "clip_board")

    @_builtins.property
    @pulumi.getter
    def mouse(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserQemuvdAgentMouse']:
        """
        Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        return pulumi.get(self, "mouse")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceVhostUserQemuvdAgentClipBoard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyPaste":
            suggest = "copy_paste"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceVhostUserQemuvdAgentClipBoard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceVhostUserQemuvdAgentClipBoard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceVhostUserQemuvdAgentClipBoard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_paste: _builtins.str):
        """
        :param _builtins.str copy_paste: Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "copy_paste", copy_paste)

    @_builtins.property
    @pulumi.getter(name="copyPaste")
    def copy_paste(self) -> _builtins.str:
        """
        Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "copy_paste")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceVhostUserQemuvdAgentMouse(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceVhostUserSpicePort(dict):
    def __init__(__self__, *,
                 channel: _builtins.str):
        """
        :param _builtins.str channel: Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceVhostUserTcp(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserTcpReconnect'] = None,
                 service: Optional[_builtins.str] = None,
                 tls: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str mode: Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesDiskMirrorSourceVhostUserTcpReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param _builtins.str service: Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str tls: Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserTcpReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[_builtins.str]:
        """
        Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceVhostUserTcpReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceVhostUserUdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindHost":
            suggest = "bind_host"
        elif key == "bindService":
            suggest = "bind_service"
        elif key == "connectHost":
            suggest = "connect_host"
        elif key == "connectService":
            suggest = "connect_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceVhostUserUdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceVhostUserUdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceVhostUserUdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bind_host: _builtins.str,
                 bind_service: _builtins.str,
                 connect_host: _builtins.str,
                 connect_service: _builtins.str):
        """
        :param _builtins.str bind_host: Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str bind_service: Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_host: Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_service: Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "bind_host", bind_host)
        pulumi.set(__self__, "bind_service", bind_service)
        pulumi.set(__self__, "connect_host", connect_host)
        pulumi.set(__self__, "connect_service", connect_service)

    @_builtins.property
    @pulumi.getter(name="bindHost")
    def bind_host(self) -> _builtins.str:
        """
        Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_host")

    @_builtins.property
    @pulumi.getter(name="bindService")
    def bind_service(self) -> _builtins.str:
        """
        Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_service")

    @_builtins.property
    @pulumi.getter(name="connectHost")
    def connect_host(self) -> _builtins.str:
        """
        Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_host")

    @_builtins.property
    @pulumi.getter(name="connectService")
    def connect_service(self) -> _builtins.str:
        """
        Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_service")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceVhostUserUnix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceVhostUserUnix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceVhostUserUnix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceVhostUserUnix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserUnixReconnect'] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceVhostUserUnixSecLabel']] = None):
        """
        :param _builtins.str mode: Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str path: Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesDiskMirrorSourceVhostUserUnixReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param Sequence['DomainDevicesDiskMirrorSourceVhostUserUnixSecLabelArgs'] sec_labels: Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesDiskMirrorSourceVhostUserUnixReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceVhostUserUnixSecLabel']]:
        """
        Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceVhostUserUnixReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceVhostUserUnixSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceVhostUserUnixSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceVhostUserUnixSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceVhostUserUnixSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceVhostVdpa(dict):
    def __init__(__self__, *,
                 dev: _builtins.str):
        """
        :param _builtins.str dev: Sets the host vDPA character device path used as the backingStore source for the mirrored disk when using a vhost-vdpa backend; the value is user-provided and must reference an existing device node (for example, /dev/vhost-vdpa0).
        """
        pulumi.set(__self__, "dev", dev)

    @_builtins.property
    @pulumi.getter
    def dev(self) -> _builtins.str:
        """
        Sets the host vDPA character device path used as the backingStore source for the mirrored disk when using a vhost-vdpa backend; the value is user-provided and must reference an existing device node (for example, /dev/vhost-vdpa0).
        """
        return pulumi.get(self, "dev")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 pool: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceVolumeSecLabel']] = None,
                 volume: Optional[_builtins.str] = None):
        """
        :param _builtins.str mode: Sets the access mode with which the storage volume is used as the backingStore source (for example, "readOnly" or "readWrite" depending on driver support); the value is user-provided.
        :param _builtins.str pool: Names the storage pool that contains the backing storage volume used as the mirror backingStore source; must match an existing libvirt storage pool name.
        :param Sequence['DomainDevicesDiskMirrorSourceVolumeSecLabelArgs'] sec_labels: Configures an optional security label override applied to the backing storage volume used as the mirror backingStore source.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str volume: Sets the name of the storage volume within the specified pool that is used as the backingStore source for the mirrored disk.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if pool is not None:
            pulumi.set(__self__, "pool", pool)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the access mode with which the storage volume is used as the backingStore source (for example, "readOnly" or "readWrite" depending on driver support); the value is user-provided.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def pool(self) -> Optional[_builtins.str]:
        """
        Names the storage pool that contains the backing storage volume used as the mirror backingStore source; must match an existing libvirt storage pool name.
        """
        return pulumi.get(self, "pool")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskMirrorSourceVolumeSecLabel']]:
        """
        Configures an optional security label override applied to the backing storage volume used as the mirror backingStore source.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional[_builtins.str]:
        """
        Sets the name of the storage volume within the specified pool that is used as the backingStore source for the mirrored disk.
        """
        return pulumi.get(self, "volume")


@pulumi.output_type
class DomainDevicesDiskMirrorSourceVolumeSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskMirrorSourceVolumeSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskMirrorSourceVolumeSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskMirrorSourceVolumeSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataStore":
            suggest = "data_store"
        elif key == "startupPolicy":
            suggest = "startup_policy"
        elif key == "vhostUser":
            suggest = "vhost_user"
        elif key == "vhostVdpa":
            suggest = "vhost_vdpa"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block: Optional['outputs.DomainDevicesDiskSourceBlock'] = None,
                 cookies: Optional['outputs.DomainDevicesDiskSourceCookies'] = None,
                 data_store: Optional['outputs.DomainDevicesDiskSourceDataStore'] = None,
                 dir: Optional['outputs.DomainDevicesDiskSourceDir'] = None,
                 encryption: Optional['outputs.DomainDevicesDiskSourceEncryption'] = None,
                 file: Optional['outputs.DomainDevicesDiskSourceFile'] = None,
                 index: Optional[_builtins.float] = None,
                 network: Optional['outputs.DomainDevicesDiskSourceNetwork'] = None,
                 nvme: Optional['outputs.DomainDevicesDiskSourceNvme'] = None,
                 readahead: Optional['outputs.DomainDevicesDiskSourceReadahead'] = None,
                 reservations: Optional['outputs.DomainDevicesDiskSourceReservations'] = None,
                 slices: Optional['outputs.DomainDevicesDiskSourceSlices'] = None,
                 ssl: Optional['outputs.DomainDevicesDiskSourceSsl'] = None,
                 startup_policy: Optional[_builtins.str] = None,
                 timeout: Optional['outputs.DomainDevicesDiskSourceTimeout'] = None,
                 vhost_user: Optional['outputs.DomainDevicesDiskSourceVhostUser'] = None,
                 vhost_vdpa: Optional['outputs.DomainDevicesDiskSourceVhostVdpa'] = None,
                 volume: Optional['outputs.DomainDevicesDiskSourceVolume'] = None):
        """
        :param 'DomainDevicesDiskSourceBlockArgs' block: Describes a block device used as the source for the mirror backing store.
        :param 'DomainDevicesDiskSourceCookiesArgs' cookies: Provides optional cookie data associated with the mirror backing store source (for example, auth or session data), with content treated as user-provided.
        :param 'DomainDevicesDiskSourceDataStoreArgs' data_store: Configures a data store descriptor for the mirrored backing store, typically used with networked or advanced storage backends that expose format-specific options.
        :param 'DomainDevicesDiskSourceDirArgs' dir: Configures a directory-based source for the mirrored backing store, pointing to a host directory used by the backing image.
        :param 'DomainDevicesDiskSourceEncryptionArgs' encryption: Enables disk image encryption configuration for this disk and groups attributes defining the encryption engine, format, and secrets.
        :param 'DomainDevicesDiskSourceFileArgs' file: Configures a file-based backing store source for the disk mirror, defining how the backing image is accessed from the host filesystem.
        :param _builtins.float index: Sets the index of this backing store within a backing chain, used when multiple backing layers are present; value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainDevicesDiskSourceNetworkArgs' network: Configures a network-based backing store source (such as NBD, iSCSI, or RBD) for the disk mirror, including authentication and host endpoints.
        :param 'DomainDevicesDiskSourceNvmeArgs' nvme: Enables using an NVMe-backed source for the mirrored disks backing store; when present, it selects an NVMe device or namespace as the source, with details defined by libvirt/QEMU for NVMe disks.
        :param 'DomainDevicesDiskSourceReadaheadArgs' readahead: Configures read-ahead behavior for the mirrored disks backing-store source, allowing tuning of how much data is pre-fetched from the backend.
        :param 'DomainDevicesDiskSourceReservationsArgs' reservations: Configures SCSI-style reservations or similar persistent reservation management for the mirrored disks backing-store source, controlling how access is coordinated across nodes.
        :param 'DomainDevicesDiskSourceSlicesArgs' slices: Configures optional slice or segment information for the backing store source (for example, to describe which logical slices of a device are used); content is user-provided.
        :param 'DomainDevicesDiskSourceSslArgs' ssl: Enables SSL/TLS parameters for accessing the mirrored backing-store source when it is provided over a secure transport.
        :param _builtins.str startup_policy: Specifies how strictly the mirrored backing-store source must be available during domain startup; valid values include "mandatory", "requisite", "optional" (userprovided string matched by libvirt).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainDevicesDiskSourceTimeoutArgs' timeout: Configures a timeout for connecting to or initializing the mirrored backing-store source.
        :param 'DomainDevicesDiskSourceVhostUserArgs' vhost_user: Selects a vhost-user backend as the transport for the mirrored backing-store source, allowing it to be provided via a userspace process.
        :param 'DomainDevicesDiskSourceVhostVdpaArgs' vhost_vdpa: Selects a vhost-vDPA backend for the disk mirror backing store, allowing acceleration via a vDPA device; additional details are determined by libvirt and device configuration.
        :param 'DomainDevicesDiskSourceVolumeArgs' volume: Configures the backingStore source as a libvirt storage volume reference instead of a raw file/block path for the mirrored disk.
        """
        if block is not None:
            pulumi.set(__self__, "block", block)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if data_store is not None:
            pulumi.set(__self__, "data_store", data_store)
        if dir is not None:
            pulumi.set(__self__, "dir", dir)
        if encryption is not None:
            pulumi.set(__self__, "encryption", encryption)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if nvme is not None:
            pulumi.set(__self__, "nvme", nvme)
        if readahead is not None:
            pulumi.set(__self__, "readahead", readahead)
        if reservations is not None:
            pulumi.set(__self__, "reservations", reservations)
        if slices is not None:
            pulumi.set(__self__, "slices", slices)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if startup_policy is not None:
            pulumi.set(__self__, "startup_policy", startup_policy)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if vhost_user is not None:
            pulumi.set(__self__, "vhost_user", vhost_user)
        if vhost_vdpa is not None:
            pulumi.set(__self__, "vhost_vdpa", vhost_vdpa)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional['outputs.DomainDevicesDiskSourceBlock']:
        """
        Describes a block device used as the source for the mirror backing store.
        """
        return pulumi.get(self, "block")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.DomainDevicesDiskSourceCookies']:
        """
        Provides optional cookie data associated with the mirror backing store source (for example, auth or session data), with content treated as user-provided.
        """
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="dataStore")
    def data_store(self) -> Optional['outputs.DomainDevicesDiskSourceDataStore']:
        """
        Configures a data store descriptor for the mirrored backing store, typically used with networked or advanced storage backends that expose format-specific options.
        """
        return pulumi.get(self, "data_store")

    @_builtins.property
    @pulumi.getter
    def dir(self) -> Optional['outputs.DomainDevicesDiskSourceDir']:
        """
        Configures a directory-based source for the mirrored backing store, pointing to a host directory used by the backing image.
        """
        return pulumi.get(self, "dir")

    @_builtins.property
    @pulumi.getter
    def encryption(self) -> Optional['outputs.DomainDevicesDiskSourceEncryption']:
        """
        Enables disk image encryption configuration for this disk and groups attributes defining the encryption engine, format, and secrets.
        """
        return pulumi.get(self, "encryption")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.DomainDevicesDiskSourceFile']:
        """
        Configures a file-based backing store source for the disk mirror, defining how the backing image is accessed from the host filesystem.
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the index of this backing store within a backing chain, used when multiple backing layers are present; value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "index")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional['outputs.DomainDevicesDiskSourceNetwork']:
        """
        Configures a network-based backing store source (such as NBD, iSCSI, or RBD) for the disk mirror, including authentication and host endpoints.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def nvme(self) -> Optional['outputs.DomainDevicesDiskSourceNvme']:
        """
        Enables using an NVMe-backed source for the mirrored disks backing store; when present, it selects an NVMe device or namespace as the source, with details defined by libvirt/QEMU for NVMe disks.
        """
        return pulumi.get(self, "nvme")

    @_builtins.property
    @pulumi.getter
    def readahead(self) -> Optional['outputs.DomainDevicesDiskSourceReadahead']:
        """
        Configures read-ahead behavior for the mirrored disks backing-store source, allowing tuning of how much data is pre-fetched from the backend.
        """
        return pulumi.get(self, "readahead")

    @_builtins.property
    @pulumi.getter
    def reservations(self) -> Optional['outputs.DomainDevicesDiskSourceReservations']:
        """
        Configures SCSI-style reservations or similar persistent reservation management for the mirrored disks backing-store source, controlling how access is coordinated across nodes.
        """
        return pulumi.get(self, "reservations")

    @_builtins.property
    @pulumi.getter
    def slices(self) -> Optional['outputs.DomainDevicesDiskSourceSlices']:
        """
        Configures optional slice or segment information for the backing store source (for example, to describe which logical slices of a device are used); content is user-provided.
        """
        return pulumi.get(self, "slices")

    @_builtins.property
    @pulumi.getter
    def ssl(self) -> Optional['outputs.DomainDevicesDiskSourceSsl']:
        """
        Enables SSL/TLS parameters for accessing the mirrored backing-store source when it is provided over a secure transport.
        """
        return pulumi.get(self, "ssl")

    @_builtins.property
    @pulumi.getter(name="startupPolicy")
    def startup_policy(self) -> Optional[_builtins.str]:
        """
        Specifies how strictly the mirrored backing-store source must be available during domain startup; valid values include "mandatory", "requisite", "optional" (userprovided string matched by libvirt).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "startup_policy")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.DomainDevicesDiskSourceTimeout']:
        """
        Configures a timeout for connecting to or initializing the mirrored backing-store source.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="vhostUser")
    def vhost_user(self) -> Optional['outputs.DomainDevicesDiskSourceVhostUser']:
        """
        Selects a vhost-user backend as the transport for the mirrored backing-store source, allowing it to be provided via a userspace process.
        """
        return pulumi.get(self, "vhost_user")

    @_builtins.property
    @pulumi.getter(name="vhostVdpa")
    def vhost_vdpa(self) -> Optional['outputs.DomainDevicesDiskSourceVhostVdpa']:
        """
        Selects a vhost-vDPA backend for the disk mirror backing store, allowing acceleration via a vDPA device; additional details are determined by libvirt and device configuration.
        """
        return pulumi.get(self, "vhost_vdpa")

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional['outputs.DomainDevicesDiskSourceVolume']:
        """
        Configures the backingStore source as a libvirt storage volume reference instead of a raw file/block path for the mirrored disk.
        """
        return pulumi.get(self, "volume")


@pulumi.output_type
class DomainDevicesDiskSourceBlock(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceBlock. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceBlock.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceBlock.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dev: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskSourceBlockSecLabel']] = None):
        """
        :param _builtins.str dev: Sets the host block device path used as the mirror backing store source (for example "/dev/sdb1"); the value is user-provided and must reference an existing block device.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param Sequence['DomainDevicesDiskSourceBlockSecLabelArgs'] sec_labels: Configures an optional security label for the block-device backing store of the mirror, controlling how security drivers label this source.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional[_builtins.str]:
        """
        Sets the host block device path used as the mirror backing store source (for example "/dev/sdb1"); the value is user-provided and must reference an existing block device.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskSourceBlockSecLabel']]:
        """
        Configures an optional security label for the block-device backing store of the mirror, controlling how security drivers label this source.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskSourceBlockSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceBlockSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceBlockSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceBlockSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskSourceCookies(dict):
    def __init__(__self__, *,
                 cookies: Optional[Sequence['outputs.DomainDevicesDiskSourceCookiesCookie']] = None):
        """
        :param Sequence['DomainDevicesDiskSourceCookiesCookieArgs'] cookies: Configures one or more HTTP cookies to be sent when accessing the mirrored backing store over a network protocol that supports cookies (for example, HTTPS or HTTP-based storage).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[Sequence['outputs.DomainDevicesDiskSourceCookiesCookie']]:
        """
        Configures one or more HTTP cookies to be sent when accessing the mirrored backing store over a network protocol that supports cookies (for example, HTTPS or HTTP-based storage).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "cookies")


@pulumi.output_type
class DomainDevicesDiskSourceCookiesCookie(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Sets the cookie name for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "sessionid").
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str value: Sets the cookie value for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "abc123").
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the cookie name for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "sessionid").

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Sets the cookie value for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "abc123").

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainDevicesDiskSourceDataStore(dict):
    def __init__(__self__, *,
                 format: Optional['outputs.DomainDevicesDiskSourceDataStoreFormat'] = None):
        """
        :param 'DomainDevicesDiskSourceDataStoreFormatArgs' format: Configures the on-disk format settings for the mirrored backing stores data store, including format type and optional metadata cache tuning.
        """
        if format is not None:
            pulumi.set(__self__, "format", format)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional['outputs.DomainDevicesDiskSourceDataStoreFormat']:
        """
        Configures the on-disk format settings for the mirrored backing stores data store, including format type and optional metadata cache tuning.
        """
        return pulumi.get(self, "format")


@pulumi.output_type
class DomainDevicesDiskSourceDataStoreFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataCache":
            suggest = "metadata_cache"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceDataStoreFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceDataStoreFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceDataStoreFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 metadata_cache: Optional['outputs.DomainDevicesDiskSourceDataStoreFormatMetadataCache'] = None):
        """
        :param _builtins.str type: Sets the data store format type for the mirrored backing store (for example, "qcow2" or "raw"); the value is user-provided and must be a valid libvirt disk format name.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainDevicesDiskSourceDataStoreFormatMetadataCacheArgs' metadata_cache: Configures metadata cache behavior for the mirrored backing stores data store format (for example, limiting the size of cached metadata).
        """
        pulumi.set(__self__, "type", type)
        if metadata_cache is not None:
            pulumi.set(__self__, "metadata_cache", metadata_cache)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets the data store format type for the mirrored backing store (for example, "qcow2" or "raw"); the value is user-provided and must be a valid libvirt disk format name.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="metadataCache")
    def metadata_cache(self) -> Optional['outputs.DomainDevicesDiskSourceDataStoreFormatMetadataCache']:
        """
        Configures metadata cache behavior for the mirrored backing stores data store format (for example, limiting the size of cached metadata).
        """
        return pulumi.get(self, "metadata_cache")


@pulumi.output_type
class DomainDevicesDiskSourceDataStoreFormatMetadataCache(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSize":
            suggest = "max_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceDataStoreFormatMetadataCache. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceDataStoreFormatMetadataCache.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceDataStoreFormatMetadataCache.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_size: Optional['outputs.DomainDevicesDiskSourceDataStoreFormatMetadataCacheMaxSize'] = None):
        """
        :param 'DomainDevicesDiskSourceDataStoreFormatMetadataCacheMaxSizeArgs' max_size: Sets the maximum size of the metadata cache used by the data store format; value and unit together define the limit (for example, 64 MiB).
        """
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional['outputs.DomainDevicesDiskSourceDataStoreFormatMetadataCacheMaxSize']:
        """
        Sets the maximum size of the metadata cache used by the data store format; value and unit together define the limit (for example, 64 MiB).
        """
        return pulumi.get(self, "max_size")


@pulumi.output_type
class DomainDevicesDiskSourceDataStoreFormatMetadataCacheMaxSize(dict):
    def __init__(__self__, *,
                 value: _builtins.float,
                 unit: Optional[_builtins.str] = None):
        """
        :param _builtins.float value: Sets the numeric value for the metadata cache maximum size in the specified unit; this must be a positive integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str unit: Sets the unit used for the metadata cache maximum size; valid units follow libvirt size units such as "B", "KiB", "MiB", "GiB" and are user-chosen.
               
               See: <https://libvirt.org/formatdomain.html#memory-allocation>
        """
        pulumi.set(__self__, "value", value)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.float:
        """
        Sets the numeric value for the metadata cache maximum size in the specified unit; this must be a positive integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        """
        Sets the unit used for the metadata cache maximum size; valid units follow libvirt size units such as "B", "KiB", "MiB", "GiB" and are user-chosen.

        See: <https://libvirt.org/formatdomain.html#memory-allocation>
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class DomainDevicesDiskSourceDir(dict):
    def __init__(__self__, *,
                 dir: Optional[_builtins.str] = None):
        """
        :param _builtins.str dir: Sets the host directory path used as the mirrored backing store source; this must be an absolute path on the host (for example, "/var/lib/libvirt/images").
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if dir is not None:
            pulumi.set(__self__, "dir", dir)

    @_builtins.property
    @pulumi.getter
    def dir(self) -> Optional[_builtins.str]:
        """
        Sets the host directory path used as the mirrored backing store source; this must be an absolute path on the host (for example, "/var/lib/libvirt/images").

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "dir")


@pulumi.output_type
class DomainDevicesDiskSourceEncryption(dict):
    def __init__(__self__, *,
                 engine: Optional[_builtins.str] = None,
                 format: Optional[_builtins.str] = None,
                 secrets: Optional[Sequence['outputs.DomainDevicesDiskSourceEncryptionSecret']] = None):
        """
        :param _builtins.str engine: Sets the encryption engine/provider to use for the disk (user-provided string, e.g. implementation-specific engine name).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str format: Sets the disk encryption format, such as "luks" or another user-provided scheme supported by libvirt/qemu.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param Sequence['DomainDevicesDiskSourceEncryptionSecretArgs'] secrets: Defines one or more secret references used to access the encrypted disk, each describing how libvirt locates the secret material.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if engine is not None:
            pulumi.set(__self__, "engine", engine)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def engine(self) -> Optional[_builtins.str]:
        """
        Sets the encryption engine/provider to use for the disk (user-provided string, e.g. implementation-specific engine name).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "engine")

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[_builtins.str]:
        """
        Sets the disk encryption format, such as "luks" or another user-provided scheme supported by libvirt/qemu.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[Sequence['outputs.DomainDevicesDiskSourceEncryptionSecret']]:
        """
        Defines one or more secret references used to access the encrypted disk, each describing how libvirt locates the secret material.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class DomainDevicesDiskSourceEncryptionSecret(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 usage: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str usage: Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str uuid: Exposes the UUID of the libvirt secret used for iSCSI authentication; this is computed from the referenced secret rather than configured directly.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def usage(self) -> Optional[_builtins.str]:
        """
        Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "usage")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        Exposes the UUID of the libvirt secret used for iSCSI authentication; this is computed from the referenced secret rather than configured directly.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class DomainDevicesDiskSourceFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fdGroup":
            suggest = "fd_group"
        elif key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fd_group: Optional[_builtins.str] = None,
                 file: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskSourceFileSecLabel']] = None):
        """
        :param _builtins.str fd_group: Sets the name of an fdgroup whose pre-opened file descriptor is used for this backing store instead of opening the file path directly; value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str file: Sets the absolute path on the host to the backing file used as the source for this mirrored disk (for example, /var/lib/libvirt/images/base.qcow2).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param Sequence['DomainDevicesDiskSourceFileSecLabelArgs'] sec_labels: Configures an explicit security label for the file backing store, overriding default security driver labeling for this file.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if fd_group is not None:
            pulumi.set(__self__, "fd_group", fd_group)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter(name="fdGroup")
    def fd_group(self) -> Optional[_builtins.str]:
        """
        Sets the name of an fdgroup whose pre-opened file descriptor is used for this backing store instead of opening the file path directly; value is user-provided.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "fd_group")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional[_builtins.str]:
        """
        Sets the absolute path on the host to the backing file used as the source for this mirrored disk (for example, /var/lib/libvirt/images/base.qcow2).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskSourceFileSecLabel']]:
        """
        Configures an explicit security label for the file backing store, overriding default security driver labeling for this file.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskSourceFileSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceFileSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceFileSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceFileSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskSourceNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "knownHosts":
            suggest = "known_hosts"
        elif key == "tlsHostname":
            suggest = "tls_hostname"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth: Optional['outputs.DomainDevicesDiskSourceNetworkAuth'] = None,
                 config: Optional['outputs.DomainDevicesDiskSourceNetworkConfig'] = None,
                 hosts: Optional[Sequence['outputs.DomainDevicesDiskSourceNetworkHost']] = None,
                 identity: Optional['outputs.DomainDevicesDiskSourceNetworkIdentity'] = None,
                 initiator: Optional['outputs.DomainDevicesDiskSourceNetworkInitiator'] = None,
                 known_hosts: Optional['outputs.DomainDevicesDiskSourceNetworkKnownHosts'] = None,
                 name: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 query: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesDiskSourceNetworkReconnect'] = None,
                 snapshot: Optional['outputs.DomainDevicesDiskSourceNetworkSnapshot'] = None,
                 tls: Optional[_builtins.str] = None,
                 tls_hostname: Optional[_builtins.str] = None):
        """
        :param 'DomainDevicesDiskSourceNetworkAuthArgs' auth: Configures CHAP authentication parameters for the iSCSI source backing an assigned SCSI host device; include this block only when the target requires authentication.
        :param 'DomainDevicesDiskSourceNetworkConfigArgs' config: Points to an external configuration source for the network backing store (for example, an RBD or Ceph config file) that libvirt passes to the backend.
        :param Sequence['DomainDevicesDiskSourceNetworkHostArgs'] hosts: Declares one or more network endpoints (hosts) for the backing store server, each with its own name/address and possibly additional attributes.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainDevicesDiskSourceNetworkIdentityArgs' identity: Configures authentication/identity parameters used when accessing the mirrored backing store over a network, such as user, group, keyfile, or agent socket, depending on the protocol.
        :param 'DomainDevicesDiskSourceNetworkInitiatorArgs' initiator: Configures initiator identity information (typically for iSCSI-like protocols) used when accessing the mirrored network backing store.
        :param 'DomainDevicesDiskSourceNetworkKnownHostsArgs' known_hosts: Enables use of a known-hosts file to validate the remote hosts identity when connecting to the mirrored network backing store.
        :param _builtins.str name: Sets a name for the network source of the mirrored backing store, typically used by certain protocols (such as RBD pool or NBD export names); value is user-provided and protocol-specific.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str protocol: Sets the network storage protocol used for the mirrored backing store; value is user-provided but must be a protocol supported by libvirt for network disks (for example, rbd, sheepdog, gluster, nbd).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str query: Sets an optional query string or subresource specifier for the network storage URL of the mirrored backing store; value is user-provided and protocol-specific.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainDevicesDiskSourceNetworkReconnectArgs' reconnect: Configures automatic reconnection behavior for the mirrored network backing store after a connection loss.
        :param 'DomainDevicesDiskSourceNetworkSnapshotArgs' snapshot: Configures snapshot-related behavior for the network-based mirrored backing store, with semantics depending on the underlying protocol and storage implementation.
        :param _builtins.str tls: Controls whether TLS is used for the mirrored disks network backing-store connection; value is user-provided and typically enabled only when the chosen protocol and backend support TLS.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str tls_hostname: Sets the expected TLS hostname for the mirrored disks network backing-store connection, used for certificate verification; value is user-provided and should match the server certificates hostname (for example, "storage.example.com").
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if initiator is not None:
            pulumi.set(__self__, "initiator", initiator)
        if known_hosts is not None:
            pulumi.set(__self__, "known_hosts", known_hosts)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if snapshot is not None:
            pulumi.set(__self__, "snapshot", snapshot)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if tls_hostname is not None:
            pulumi.set(__self__, "tls_hostname", tls_hostname)

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional['outputs.DomainDevicesDiskSourceNetworkAuth']:
        """
        Configures CHAP authentication parameters for the iSCSI source backing an assigned SCSI host device; include this block only when the target requires authentication.
        """
        return pulumi.get(self, "auth")

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional['outputs.DomainDevicesDiskSourceNetworkConfig']:
        """
        Points to an external configuration source for the network backing store (for example, an RBD or Ceph config file) that libvirt passes to the backend.
        """
        return pulumi.get(self, "config")

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence['outputs.DomainDevicesDiskSourceNetworkHost']]:
        """
        Declares one or more network endpoints (hosts) for the backing store server, each with its own name/address and possibly additional attributes.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter
    def identity(self) -> Optional['outputs.DomainDevicesDiskSourceNetworkIdentity']:
        """
        Configures authentication/identity parameters used when accessing the mirrored backing store over a network, such as user, group, keyfile, or agent socket, depending on the protocol.
        """
        return pulumi.get(self, "identity")

    @_builtins.property
    @pulumi.getter
    def initiator(self) -> Optional['outputs.DomainDevicesDiskSourceNetworkInitiator']:
        """
        Configures initiator identity information (typically for iSCSI-like protocols) used when accessing the mirrored network backing store.
        """
        return pulumi.get(self, "initiator")

    @_builtins.property
    @pulumi.getter(name="knownHosts")
    def known_hosts(self) -> Optional['outputs.DomainDevicesDiskSourceNetworkKnownHosts']:
        """
        Enables use of a known-hosts file to validate the remote hosts identity when connecting to the mirrored network backing store.
        """
        return pulumi.get(self, "known_hosts")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets a name for the network source of the mirrored backing store, typically used by certain protocols (such as RBD pool or NBD export names); value is user-provided and protocol-specific.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        Sets the network storage protocol used for the mirrored backing store; value is user-provided but must be a protocol supported by libvirt for network disks (for example, rbd, sheepdog, gluster, nbd).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional[_builtins.str]:
        """
        Sets an optional query string or subresource specifier for the network storage URL of the mirrored backing store; value is user-provided and protocol-specific.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "query")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesDiskSourceNetworkReconnect']:
        """
        Configures automatic reconnection behavior for the mirrored network backing store after a connection loss.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter
    def snapshot(self) -> Optional['outputs.DomainDevicesDiskSourceNetworkSnapshot']:
        """
        Configures snapshot-related behavior for the network-based mirrored backing store, with semantics depending on the underlying protocol and storage implementation.
        """
        return pulumi.get(self, "snapshot")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[_builtins.str]:
        """
        Controls whether TLS is used for the mirrored disks network backing-store connection; value is user-provided and typically enabled only when the chosen protocol and backend support TLS.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "tls")

    @_builtins.property
    @pulumi.getter(name="tlsHostname")
    def tls_hostname(self) -> Optional[_builtins.str]:
        """
        Sets the expected TLS hostname for the mirrored disks network backing-store connection, used for certificate verification; value is user-provided and should match the server certificates hostname (for example, "storage.example.com").

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "tls_hostname")


@pulumi.output_type
class DomainDevicesDiskSourceNetworkAuth(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.DomainDevicesDiskSourceNetworkAuthSecret'] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param 'DomainDevicesDiskSourceNetworkAuthSecretArgs' secret: Configures the libvirt secret object used to hold the iSCSI authentication password for this hostdev; this references an existing libvirt secret, not the clear-text secret.
        :param _builtins.str username: Sets the CHAP username used when authenticating to the iSCSI target for this SCSI hostdev; the value is user-provided (for example, "chapuser1").
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.DomainDevicesDiskSourceNetworkAuthSecret']:
        """
        Configures the libvirt secret object used to hold the iSCSI authentication password for this hostdev; this references an existing libvirt secret, not the clear-text secret.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        Sets the CHAP username used when authenticating to the iSCSI target for this SCSI hostdev; the value is user-provided (for example, "chapuser1").

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class DomainDevicesDiskSourceNetworkAuthSecret(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 usage: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str usage: Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str uuid: Exposes the UUID of the libvirt secret used for iSCSI authentication; this is computed from the referenced secret rather than configured directly.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def usage(self) -> Optional[_builtins.str]:
        """
        Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "usage")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        Exposes the UUID of the libvirt secret used for iSCSI authentication; this is computed from the referenced secret rather than configured directly.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class DomainDevicesDiskSourceNetworkConfig(dict):
    def __init__(__self__, *,
                 file: _builtins.str):
        """
        :param _builtins.str file: Sets the path to the configuration file used for the network backing store connection, such as a Ceph configuration file (/etc/ceph/ceph.conf).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "file", file)

    @_builtins.property
    @pulumi.getter
    def file(self) -> _builtins.str:
        """
        Sets the path to the configuration file used for the network backing store connection, such as a Ceph configuration file (/etc/ceph/ceph.conf).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "file")


@pulumi.output_type
class DomainDevicesDiskSourceNetworkHost(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 socket: Optional[_builtins.str] = None,
                 transport: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Sets the hostname or IP address of the iSCSI target portal (for example, "10.0.0.10" or "iscsi.example.com").
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str port: Sets the TCP port of the iSCSI target portal; if omitted, libvirt/driver defaults (commonly 3260) are used.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str socket: Sets a UNIX domain socket path to connect to an iSCSI target via a local socket instead of TCP; value is a user-provided filesystem path.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str transport: Sets the transport type used to reach the iSCSI target portal; valid values are user-provided strings as supported by the environment (for example, "tcp" or "iser").
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if socket is not None:
            pulumi.set(__self__, "socket", socket)
        if transport is not None:
            pulumi.set(__self__, "transport", transport)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the hostname or IP address of the iSCSI target portal (for example, "10.0.0.10" or "iscsi.example.com").

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        """
        Sets the TCP port of the iSCSI target portal; if omitted, libvirt/driver defaults (commonly 3260) are used.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def socket(self) -> Optional[_builtins.str]:
        """
        Sets a UNIX domain socket path to connect to an iSCSI target via a local socket instead of TCP; value is a user-provided filesystem path.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "socket")

    @_builtins.property
    @pulumi.getter
    def transport(self) -> Optional[_builtins.str]:
        """
        Sets the transport type used to reach the iSCSI target portal; valid values are user-provided strings as supported by the environment (for example, "tcp" or "iser").

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "transport")


@pulumi.output_type
class DomainDevicesDiskSourceNetworkIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentSock":
            suggest = "agent_sock"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceNetworkIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceNetworkIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceNetworkIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_sock: Optional[_builtins.str] = None,
                 group: Optional[_builtins.str] = None,
                 keyfile: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str agent_sock: Sets the path to a local agent socket used for external authentication (for example, SASL or SSH agent) when connecting to the network backing store; value is a user-provided Unix socket path.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str group: Sets the group name to use for authentication or access control when connecting to the network backing store; value is user-provided and protocol-specific.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str keyfile: Sets the path to a private key file used for authenticating to the network backing store (for example, an SSH or TLS key); value is a user-provided filesystem path.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str user: Sets the user identifier used for authentication to the network backing store; value is user-provided and typically matches a remote account name.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str user_name: Sets an explicit username string used for authentication to the network backing store, separate from any other user identity settings; value is user-provided (for example, "backupuser").
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if agent_sock is not None:
            pulumi.set(__self__, "agent_sock", agent_sock)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if keyfile is not None:
            pulumi.set(__self__, "keyfile", keyfile)
        if user is not None:
            pulumi.set(__self__, "user", user)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="agentSock")
    def agent_sock(self) -> Optional[_builtins.str]:
        """
        Sets the path to a local agent socket used for external authentication (for example, SASL or SSH agent) when connecting to the network backing store; value is a user-provided Unix socket path.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "agent_sock")

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[_builtins.str]:
        """
        Sets the group name to use for authentication or access control when connecting to the network backing store; value is user-provided and protocol-specific.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter
    def keyfile(self) -> Optional[_builtins.str]:
        """
        Sets the path to a private key file used for authenticating to the network backing store (for example, an SSH or TLS key); value is a user-provided filesystem path.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "keyfile")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        Sets the user identifier used for authentication to the network backing store; value is user-provided and typically matches a remote account name.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "user")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        """
        Sets an explicit username string used for authentication to the network backing store, separate from any other user identity settings; value is user-provided (for example, "backupuser").

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class DomainDevicesDiskSourceNetworkInitiator(dict):
    def __init__(__self__, *,
                 iqn: Optional['outputs.DomainDevicesDiskSourceNetworkInitiatorIqn'] = None):
        """
        :param 'DomainDevicesDiskSourceNetworkInitiatorIqnArgs' iqn: Configures the iSCSI initiator IQN block for the mirrored network backing store, defining the initiator name presented to the target.
        """
        if iqn is not None:
            pulumi.set(__self__, "iqn", iqn)

    @_builtins.property
    @pulumi.getter
    def iqn(self) -> Optional['outputs.DomainDevicesDiskSourceNetworkInitiatorIqn']:
        """
        Configures the iSCSI initiator IQN block for the mirrored network backing store, defining the initiator name presented to the target.
        """
        return pulumi.get(self, "iqn")


@pulumi.output_type
class DomainDevicesDiskSourceNetworkInitiatorIqn(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Sets the initiator IQN string used when logging into an iSCSI target backing the mirrored disk; value must be a valid IQN (for example, iqn.2020-01.com.example:host1).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the initiator IQN string used when logging into an iSCSI target backing the mirrored disk; value must be a valid IQN (for example, iqn.2020-01.com.example:host1).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesDiskSourceNetworkKnownHosts(dict):
    def __init__(__self__, *,
                 path: _builtins.str):
        """
        :param _builtins.str path: Sets the path to the known-hosts file used to verify the identity of the remote storage host; value is a required user-provided filesystem path (for example, /etc/libvirt/known_hosts).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the path to the known-hosts file used to verify the identity of the remote storage host; value is a required user-provided filesystem path (for example, /etc/libvirt/known_hosts).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DomainDevicesDiskSourceNetworkReconnect(dict):
    def __init__(__self__, *,
                 delay: _builtins.str):
        """
        :param _builtins.str delay: Sets the reconnection delay (in seconds) before retrying a failed connection to the mirrored network backing store; value is a required user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "delay", delay)

    @_builtins.property
    @pulumi.getter
    def delay(self) -> _builtins.str:
        """
        Sets the reconnection delay (in seconds) before retrying a failed connection to the mirrored network backing store; value is a required user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "delay")


@pulumi.output_type
class DomainDevicesDiskSourceNetworkSnapshot(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the name of the network snapshot to use as the backing store for the mirrored disks network source; value is user-provided and must match an existing snapshot identifier on the storage backend.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the name of the network snapshot to use as the backing store for the mirrored disks network source; value is user-provided and must match an existing snapshot identifier on the storage backend.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesDiskSourceNvme(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesDiskSourceReadahead(dict):
    def __init__(__self__, *,
                 size: _builtins.str):
        """
        :param _builtins.str size: Sets the read-ahead size for the mirrored disks backing store; value is a user-provided positive integer in bytes (for example, 65536 for 64 KiB).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        """
        Sets the read-ahead size for the mirrored disks backing store; value is a user-provided positive integer in bytes (for example, 65536 for 64 KiB).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class DomainDevicesDiskSourceReservations(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.str] = None,
                 managed: Optional[_builtins.bool] = None,
                 source: Optional['outputs.DomainDevicesDiskSourceReservationsSource'] = None):
        """
        :param _builtins.str enabled: Controls whether persistent reservations are enabled for the mirrored disks backing-store source; value is user-provided and typically expects "yes" or "no" semantics per libvirt.
        :param _builtins.bool managed: Indicates whether reservations are managed by libvirt ("yes") or externally ("no"); value is provided as a string and translated to a boolean, with "yes" meaning true and "no" meaning false.
        :param 'DomainDevicesDiskSourceReservationsSourceArgs' source: Selects the mechanism used to provide reservation control for the mirrored backing-store source, such as a D-Bus service or a device/file endpoint.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if managed is not None:
            pulumi.set(__self__, "managed", managed)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.str]:
        """
        Controls whether persistent reservations are enabled for the mirrored disks backing-store source; value is user-provided and typically expects "yes" or "no" semantics per libvirt.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def managed(self) -> Optional[_builtins.bool]:
        """
        Indicates whether reservations are managed by libvirt ("yes") or externally ("no"); value is provided as a string and translated to a boolean, with "yes" meaning true and "no" meaning false.
        """
        return pulumi.get(self, "managed")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainDevicesDiskSourceReservationsSource']:
        """
        Selects the mechanism used to provide reservation control for the mirrored backing-store source, such as a D-Bus service or a device/file endpoint.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class DomainDevicesDiskSourceReservationsSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "qemuvdAgent":
            suggest = "qemuvd_agent"
        elif key == "spicePort":
            suggest = "spice_port"
        elif key == "spiceVmc":
            suggest = "spice_vmc"
        elif key == "stdIo":
            suggest = "std_io"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceReservationsSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceReservationsSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceReservationsSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbus: Optional['outputs.DomainDevicesDiskSourceReservationsSourceDbus'] = None,
                 dev: Optional['outputs.DomainDevicesDiskSourceReservationsSourceDev'] = None,
                 file: Optional['outputs.DomainDevicesDiskSourceReservationsSourceFile'] = None,
                 nmdm: Optional['outputs.DomainDevicesDiskSourceReservationsSourceNmdm'] = None,
                 null: Optional[_builtins.bool] = None,
                 pipe: Optional['outputs.DomainDevicesDiskSourceReservationsSourcePipe'] = None,
                 pty: Optional['outputs.DomainDevicesDiskSourceReservationsSourcePty'] = None,
                 qemuvd_agent: Optional['outputs.DomainDevicesDiskSourceReservationsSourceQemuvdAgent'] = None,
                 spice_port: Optional['outputs.DomainDevicesDiskSourceReservationsSourceSpicePort'] = None,
                 spice_vmc: Optional[_builtins.bool] = None,
                 std_io: Optional[_builtins.bool] = None,
                 tcp: Optional['outputs.DomainDevicesDiskSourceReservationsSourceTcp'] = None,
                 udp: Optional['outputs.DomainDevicesDiskSourceReservationsSourceUdp'] = None,
                 unix: Optional['outputs.DomainDevicesDiskSourceReservationsSourceUnix'] = None,
                 vc: Optional[_builtins.bool] = None):
        """
        :param 'DomainDevicesDiskSourceReservationsSourceDbusArgs' dbus: Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        :param 'DomainDevicesDiskSourceReservationsSourceDevArgs' dev: Configures an EGD RNG backend that reads entropy from a host character device node.
        :param 'DomainDevicesDiskSourceReservationsSourceFileArgs' file: Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        :param 'DomainDevicesDiskSourceReservationsSourceNmdmArgs' nmdm: Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        :param _builtins.bool null: Enables use of a null character device as the reservation backing source; when this boolean is true, a Null source is emitted and all written data is discarded.
               
               See: <https://libvirt.org/formatdomain.html#null-device>
        :param 'DomainDevicesDiskSourceReservationsSourcePipeArgs' pipe: Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        :param 'DomainDevicesDiskSourceReservationsSourcePtyArgs' pty: Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        :param 'DomainDevicesDiskSourceReservationsSourceQemuvdAgentArgs' qemuvd_agent: Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        :param 'DomainDevicesDiskSourceReservationsSourceSpicePortArgs' spice_port: Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        :param _builtins.bool spice_vmc: Enables a SPICE VMC (SPICE management channel) backend for this backing-store source; when set true the element is emitted, when false or null it is omitted.
               
               See: <https://libvirt.org/formatdomain.html#spice-channel>
        :param _builtins.bool std_io: Connects the backing-store sources character channel to the domains standard I/O (stdin/stdout/stderr); when true the element is emitted, when false or null it is omitted.
               
               See: <https://libvirt.org/formatdomain.html#host-interface>
        :param 'DomainDevicesDiskSourceReservationsSourceTcpArgs' tcp: Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        :param 'DomainDevicesDiskSourceReservationsSourceUdpArgs' udp: Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        :param 'DomainDevicesDiskSourceReservationsSourceUnixArgs' unix: Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        :param _builtins.bool vc: Enables use of a VC (virtual cluster or vendor-specific) reservation source when set; since this is presence-based, setting it to true emits the element and false/null omits it.
        """
        if dbus is not None:
            pulumi.set(__self__, "dbus", dbus)
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if nmdm is not None:
            pulumi.set(__self__, "nmdm", nmdm)
        if null is not None:
            pulumi.set(__self__, "null", null)
        if pipe is not None:
            pulumi.set(__self__, "pipe", pipe)
        if pty is not None:
            pulumi.set(__self__, "pty", pty)
        if qemuvd_agent is not None:
            pulumi.set(__self__, "qemuvd_agent", qemuvd_agent)
        if spice_port is not None:
            pulumi.set(__self__, "spice_port", spice_port)
        if spice_vmc is not None:
            pulumi.set(__self__, "spice_vmc", spice_vmc)
        if std_io is not None:
            pulumi.set(__self__, "std_io", std_io)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)
        if unix is not None:
            pulumi.set(__self__, "unix", unix)
        if vc is not None:
            pulumi.set(__self__, "vc", vc)

    @_builtins.property
    @pulumi.getter
    def dbus(self) -> Optional['outputs.DomainDevicesDiskSourceReservationsSourceDbus']:
        """
        Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        """
        return pulumi.get(self, "dbus")

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional['outputs.DomainDevicesDiskSourceReservationsSourceDev']:
        """
        Configures an EGD RNG backend that reads entropy from a host character device node.
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.DomainDevicesDiskSourceReservationsSourceFile']:
        """
        Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def nmdm(self) -> Optional['outputs.DomainDevicesDiskSourceReservationsSourceNmdm']:
        """
        Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        """
        return pulumi.get(self, "nmdm")

    @_builtins.property
    @pulumi.getter
    def null(self) -> Optional[_builtins.bool]:
        """
        Enables use of a null character device as the reservation backing source; when this boolean is true, a Null source is emitted and all written data is discarded.

        See: <https://libvirt.org/formatdomain.html#null-device>
        """
        return pulumi.get(self, "null")

    @_builtins.property
    @pulumi.getter
    def pipe(self) -> Optional['outputs.DomainDevicesDiskSourceReservationsSourcePipe']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        """
        return pulumi.get(self, "pipe")

    @_builtins.property
    @pulumi.getter
    def pty(self) -> Optional['outputs.DomainDevicesDiskSourceReservationsSourcePty']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        """
        return pulumi.get(self, "pty")

    @_builtins.property
    @pulumi.getter(name="qemuvdAgent")
    def qemuvd_agent(self) -> Optional['outputs.DomainDevicesDiskSourceReservationsSourceQemuvdAgent']:
        """
        Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        """
        return pulumi.get(self, "qemuvd_agent")

    @_builtins.property
    @pulumi.getter(name="spicePort")
    def spice_port(self) -> Optional['outputs.DomainDevicesDiskSourceReservationsSourceSpicePort']:
        """
        Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        """
        return pulumi.get(self, "spice_port")

    @_builtins.property
    @pulumi.getter(name="spiceVmc")
    def spice_vmc(self) -> Optional[_builtins.bool]:
        """
        Enables a SPICE VMC (SPICE management channel) backend for this backing-store source; when set true the element is emitted, when false or null it is omitted.

        See: <https://libvirt.org/formatdomain.html#spice-channel>
        """
        return pulumi.get(self, "spice_vmc")

    @_builtins.property
    @pulumi.getter(name="stdIo")
    def std_io(self) -> Optional[_builtins.bool]:
        """
        Connects the backing-store sources character channel to the domains standard I/O (stdin/stdout/stderr); when true the element is emitted, when false or null it is omitted.

        See: <https://libvirt.org/formatdomain.html#host-interface>
        """
        return pulumi.get(self, "std_io")

    @_builtins.property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.DomainDevicesDiskSourceReservationsSourceTcp']:
        """
        Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        """
        return pulumi.get(self, "tcp")

    @_builtins.property
    @pulumi.getter
    def udp(self) -> Optional['outputs.DomainDevicesDiskSourceReservationsSourceUdp']:
        """
        Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        """
        return pulumi.get(self, "udp")

    @_builtins.property
    @pulumi.getter
    def unix(self) -> Optional['outputs.DomainDevicesDiskSourceReservationsSourceUnix']:
        """
        Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        """
        return pulumi.get(self, "unix")

    @_builtins.property
    @pulumi.getter
    def vc(self) -> Optional[_builtins.bool]:
        """
        Enables use of a VC (virtual cluster or vendor-specific) reservation source when set; since this is presence-based, setting it to true emits the element and false/null omits it.
        """
        return pulumi.get(self, "vc")


@pulumi.output_type
class DomainDevicesDiskSourceReservationsSourceDbus(dict):
    def __init__(__self__, *,
                 channel: Optional[_builtins.str] = None):
        """
        :param _builtins.str channel: Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.str]:
        """
        Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesDiskSourceReservationsSourceDev(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceReservationsSourceDev. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceReservationsSourceDev.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceReservationsSourceDev.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskSourceReservationsSourceDevSecLabel']] = None):
        """
        :param _builtins.str path: Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesDiskSourceReservationsSourceDevSecLabelArgs'] sec_labels: Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskSourceReservationsSourceDevSecLabel']]:
        """
        Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskSourceReservationsSourceDevSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceReservationsSourceDevSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceReservationsSourceDevSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceReservationsSourceDevSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskSourceReservationsSourceFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceReservationsSourceFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceReservationsSourceFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceReservationsSourceFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 append: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskSourceReservationsSourceFileSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str append: Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
               
               See: <https://libvirt.org/formatdomain.html#device-logfile>
        :param Sequence['DomainDevicesDiskSourceReservationsSourceFileSecLabelArgs'] sec_labels: Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def append(self) -> Optional[_builtins.str]:
        """
        Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.

        See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        return pulumi.get(self, "append")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskSourceReservationsSourceFileSecLabel']]:
        """
        Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskSourceReservationsSourceFileSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceReservationsSourceFileSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceReservationsSourceFileSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceReservationsSourceFileSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskSourceReservationsSourceNmdm(dict):
    def __init__(__self__, *,
                 master: _builtins.str,
                 slave: _builtins.str):
        """
        :param _builtins.str master: Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        :param _builtins.str slave: Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        pulumi.set(__self__, "master", master)
        pulumi.set(__self__, "slave", slave)

    @_builtins.property
    @pulumi.getter
    def master(self) -> _builtins.str:
        """
        Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "master")

    @_builtins.property
    @pulumi.getter
    def slave(self) -> _builtins.str:
        """
        Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "slave")


@pulumi.output_type
class DomainDevicesDiskSourceReservationsSourcePipe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceReservationsSourcePipe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceReservationsSourcePipe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceReservationsSourcePipe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskSourceReservationsSourcePipeSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesDiskSourceReservationsSourcePipeSecLabelArgs'] sec_labels: Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskSourceReservationsSourcePipeSecLabel']]:
        """
        Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskSourceReservationsSourcePipeSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceReservationsSourcePipeSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceReservationsSourcePipeSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceReservationsSourcePipeSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskSourceReservationsSourcePty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceReservationsSourcePty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceReservationsSourcePty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceReservationsSourcePty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskSourceReservationsSourcePtySecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesDiskSourceReservationsSourcePtySecLabelArgs'] sec_labels: Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskSourceReservationsSourcePtySecLabel']]:
        """
        Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskSourceReservationsSourcePtySecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceReservationsSourcePtySecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceReservationsSourcePtySecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceReservationsSourcePtySecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskSourceReservationsSourceQemuvdAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clipBoard":
            suggest = "clip_board"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceReservationsSourceQemuvdAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceReservationsSourceQemuvdAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceReservationsSourceQemuvdAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clip_board: Optional['outputs.DomainDevicesDiskSourceReservationsSourceQemuvdAgentClipBoard'] = None,
                 mouse: Optional['outputs.DomainDevicesDiskSourceReservationsSourceQemuvdAgentMouse'] = None):
        """
        :param 'DomainDevicesDiskSourceReservationsSourceQemuvdAgentClipBoardArgs' clip_board: Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        :param 'DomainDevicesDiskSourceReservationsSourceQemuvdAgentMouseArgs' mouse: Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        if clip_board is not None:
            pulumi.set(__self__, "clip_board", clip_board)
        if mouse is not None:
            pulumi.set(__self__, "mouse", mouse)

    @_builtins.property
    @pulumi.getter(name="clipBoard")
    def clip_board(self) -> Optional['outputs.DomainDevicesDiskSourceReservationsSourceQemuvdAgentClipBoard']:
        """
        Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        """
        return pulumi.get(self, "clip_board")

    @_builtins.property
    @pulumi.getter
    def mouse(self) -> Optional['outputs.DomainDevicesDiskSourceReservationsSourceQemuvdAgentMouse']:
        """
        Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        return pulumi.get(self, "mouse")


@pulumi.output_type
class DomainDevicesDiskSourceReservationsSourceQemuvdAgentClipBoard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyPaste":
            suggest = "copy_paste"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceReservationsSourceQemuvdAgentClipBoard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceReservationsSourceQemuvdAgentClipBoard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceReservationsSourceQemuvdAgentClipBoard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_paste: _builtins.str):
        """
        :param _builtins.str copy_paste: Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "copy_paste", copy_paste)

    @_builtins.property
    @pulumi.getter(name="copyPaste")
    def copy_paste(self) -> _builtins.str:
        """
        Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "copy_paste")


@pulumi.output_type
class DomainDevicesDiskSourceReservationsSourceQemuvdAgentMouse(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DomainDevicesDiskSourceReservationsSourceSpicePort(dict):
    def __init__(__self__, *,
                 channel: _builtins.str):
        """
        :param _builtins.str channel: Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesDiskSourceReservationsSourceTcp(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesDiskSourceReservationsSourceTcpReconnect'] = None,
                 service: Optional[_builtins.str] = None,
                 tls: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str mode: Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesDiskSourceReservationsSourceTcpReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param _builtins.str service: Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str tls: Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesDiskSourceReservationsSourceTcpReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[_builtins.str]:
        """
        Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class DomainDevicesDiskSourceReservationsSourceTcpReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesDiskSourceReservationsSourceUdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindHost":
            suggest = "bind_host"
        elif key == "bindService":
            suggest = "bind_service"
        elif key == "connectHost":
            suggest = "connect_host"
        elif key == "connectService":
            suggest = "connect_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceReservationsSourceUdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceReservationsSourceUdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceReservationsSourceUdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bind_host: _builtins.str,
                 bind_service: _builtins.str,
                 connect_host: _builtins.str,
                 connect_service: _builtins.str):
        """
        :param _builtins.str bind_host: Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str bind_service: Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_host: Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_service: Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "bind_host", bind_host)
        pulumi.set(__self__, "bind_service", bind_service)
        pulumi.set(__self__, "connect_host", connect_host)
        pulumi.set(__self__, "connect_service", connect_service)

    @_builtins.property
    @pulumi.getter(name="bindHost")
    def bind_host(self) -> _builtins.str:
        """
        Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_host")

    @_builtins.property
    @pulumi.getter(name="bindService")
    def bind_service(self) -> _builtins.str:
        """
        Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_service")

    @_builtins.property
    @pulumi.getter(name="connectHost")
    def connect_host(self) -> _builtins.str:
        """
        Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_host")

    @_builtins.property
    @pulumi.getter(name="connectService")
    def connect_service(self) -> _builtins.str:
        """
        Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_service")


@pulumi.output_type
class DomainDevicesDiskSourceReservationsSourceUnix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceReservationsSourceUnix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceReservationsSourceUnix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceReservationsSourceUnix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesDiskSourceReservationsSourceUnixReconnect'] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskSourceReservationsSourceUnixSecLabel']] = None):
        """
        :param _builtins.str mode: Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str path: Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesDiskSourceReservationsSourceUnixReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param Sequence['DomainDevicesDiskSourceReservationsSourceUnixSecLabelArgs'] sec_labels: Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesDiskSourceReservationsSourceUnixReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskSourceReservationsSourceUnixSecLabel']]:
        """
        Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskSourceReservationsSourceUnixReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesDiskSourceReservationsSourceUnixSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceReservationsSourceUnixSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceReservationsSourceUnixSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceReservationsSourceUnixSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskSourceSlices(dict):
    def __init__(__self__, *,
                 slices: Optional[Sequence['outputs.DomainDevicesDiskSourceSlicesSlice']] = None):
        """
        :param Sequence['DomainDevicesDiskSourceSlicesSliceArgs'] slices: Configures one or more slices of the backing-store source, each describing a contiguous portion of the underlying device or file that is exposed through this mirror backing store.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if slices is not None:
            pulumi.set(__self__, "slices", slices)

    @_builtins.property
    @pulumi.getter
    def slices(self) -> Optional[Sequence['outputs.DomainDevicesDiskSourceSlicesSlice']]:
        """
        Configures one or more slices of the backing-store source, each describing a contiguous portion of the underlying device or file that is exposed through this mirror backing store.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "slices")


@pulumi.output_type
class DomainDevicesDiskSourceSlicesSlice(dict):
    def __init__(__self__, *,
                 offset: _builtins.float,
                 size: _builtins.float,
                 type: _builtins.str):
        """
        :param _builtins.float offset: Sets the starting offset (in bytes) of this slice within the underlying backing-store source; must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.float size: Sets the size (in bytes) of this slice within the underlying backing-store source; must be a positive integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str type: Specifies the type of slice mapping to use for this range; the value is userprovided and must match a type supported by the hypervisor (for example, a particular mapping or layout scheme).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def offset(self) -> _builtins.float:
        """
        Sets the starting offset (in bytes) of this slice within the underlying backing-store source; must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "offset")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.float:
        """
        Sets the size (in bytes) of this slice within the underlying backing-store source; must be a positive integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of slice mapping to use for this range; the value is userprovided and must match a type supported by the hypervisor (for example, a particular mapping or layout scheme).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainDevicesDiskSourceSsl(dict):
    def __init__(__self__, *,
                 verify: _builtins.str):
        """
        :param _builtins.str verify: Controls certificate verification for SSL/TLS access to the mirrored backing-store source; typical values are "yes" or "no" to enable or disable verification.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "verify", verify)

    @_builtins.property
    @pulumi.getter
    def verify(self) -> _builtins.str:
        """
        Controls certificate verification for SSL/TLS access to the mirrored backing-store source; typical values are "yes" or "no" to enable or disable verification.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "verify")


@pulumi.output_type
class DomainDevicesDiskSourceTimeout(dict):
    def __init__(__self__, *,
                 seconds: _builtins.str):
        """
        :param _builtins.str seconds: Sets the timeout duration in seconds for accessing the mirrored backing-store source; must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.str:
        """
        Sets the timeout duration in seconds for accessing the mirrored backing-store source; must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class DomainDevicesDiskSourceVhostUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "qemuvdAgent":
            suggest = "qemuvd_agent"
        elif key == "spicePort":
            suggest = "spice_port"
        elif key == "spiceVmc":
            suggest = "spice_vmc"
        elif key == "stdIo":
            suggest = "std_io"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceVhostUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceVhostUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceVhostUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbus: Optional['outputs.DomainDevicesDiskSourceVhostUserDbus'] = None,
                 dev: Optional['outputs.DomainDevicesDiskSourceVhostUserDev'] = None,
                 file: Optional['outputs.DomainDevicesDiskSourceVhostUserFile'] = None,
                 nmdm: Optional['outputs.DomainDevicesDiskSourceVhostUserNmdm'] = None,
                 null: Optional[_builtins.bool] = None,
                 pipe: Optional['outputs.DomainDevicesDiskSourceVhostUserPipe'] = None,
                 pty: Optional['outputs.DomainDevicesDiskSourceVhostUserPty'] = None,
                 qemuvd_agent: Optional['outputs.DomainDevicesDiskSourceVhostUserQemuvdAgent'] = None,
                 spice_port: Optional['outputs.DomainDevicesDiskSourceVhostUserSpicePort'] = None,
                 spice_vmc: Optional[_builtins.bool] = None,
                 std_io: Optional[_builtins.bool] = None,
                 tcp: Optional['outputs.DomainDevicesDiskSourceVhostUserTcp'] = None,
                 udp: Optional['outputs.DomainDevicesDiskSourceVhostUserUdp'] = None,
                 unix: Optional['outputs.DomainDevicesDiskSourceVhostUserUnix'] = None,
                 vc: Optional[_builtins.bool] = None):
        """
        :param 'DomainDevicesDiskSourceVhostUserDbusArgs' dbus: Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        :param 'DomainDevicesDiskSourceVhostUserDevArgs' dev: Configures an EGD RNG backend that reads entropy from a host character device node.
        :param 'DomainDevicesDiskSourceVhostUserFileArgs' file: Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        :param 'DomainDevicesDiskSourceVhostUserNmdmArgs' nmdm: Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        :param _builtins.bool null: When set to true, uses a null character device as the vhost-user backing-store source, discarding all output and providing no input; when false or unset, the null device is not used.
               
               See: <https://libvirt.org/formatdomain.html#null-device>
        :param 'DomainDevicesDiskSourceVhostUserPipeArgs' pipe: Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        :param 'DomainDevicesDiskSourceVhostUserPtyArgs' pty: Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        :param 'DomainDevicesDiskSourceVhostUserQemuvdAgentArgs' qemuvd_agent: Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        :param 'DomainDevicesDiskSourceVhostUserSpicePortArgs' spice_port: Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        :param _builtins.bool spice_vmc: When set to true, exposes the vhost-user backing through a SPICE virtio-serial management channel (SpiceVMC); when false or unset, the element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#spice-channel>
        :param _builtins.bool std_io: When set to true, connects the vhost-user backing to the domains standard I/O character device; when false or unset, the StdIO element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#host-interface>
        :param 'DomainDevicesDiskSourceVhostUserTcpArgs' tcp: Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        :param 'DomainDevicesDiskSourceVhostUserUdpArgs' udp: Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        :param 'DomainDevicesDiskSourceVhostUserUnixArgs' unix: Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        :param _builtins.bool vc: Enables use of a vhost-user communication mechanism compatible with a VC-style (versioned capability) endpoint for the disk mirror backing store; when set true the VC element is emitted, when false or null it is omitted.
        """
        if dbus is not None:
            pulumi.set(__self__, "dbus", dbus)
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if nmdm is not None:
            pulumi.set(__self__, "nmdm", nmdm)
        if null is not None:
            pulumi.set(__self__, "null", null)
        if pipe is not None:
            pulumi.set(__self__, "pipe", pipe)
        if pty is not None:
            pulumi.set(__self__, "pty", pty)
        if qemuvd_agent is not None:
            pulumi.set(__self__, "qemuvd_agent", qemuvd_agent)
        if spice_port is not None:
            pulumi.set(__self__, "spice_port", spice_port)
        if spice_vmc is not None:
            pulumi.set(__self__, "spice_vmc", spice_vmc)
        if std_io is not None:
            pulumi.set(__self__, "std_io", std_io)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)
        if unix is not None:
            pulumi.set(__self__, "unix", unix)
        if vc is not None:
            pulumi.set(__self__, "vc", vc)

    @_builtins.property
    @pulumi.getter
    def dbus(self) -> Optional['outputs.DomainDevicesDiskSourceVhostUserDbus']:
        """
        Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        """
        return pulumi.get(self, "dbus")

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional['outputs.DomainDevicesDiskSourceVhostUserDev']:
        """
        Configures an EGD RNG backend that reads entropy from a host character device node.
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.DomainDevicesDiskSourceVhostUserFile']:
        """
        Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def nmdm(self) -> Optional['outputs.DomainDevicesDiskSourceVhostUserNmdm']:
        """
        Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        """
        return pulumi.get(self, "nmdm")

    @_builtins.property
    @pulumi.getter
    def null(self) -> Optional[_builtins.bool]:
        """
        When set to true, uses a null character device as the vhost-user backing-store source, discarding all output and providing no input; when false or unset, the null device is not used.

        See: <https://libvirt.org/formatdomain.html#null-device>
        """
        return pulumi.get(self, "null")

    @_builtins.property
    @pulumi.getter
    def pipe(self) -> Optional['outputs.DomainDevicesDiskSourceVhostUserPipe']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        """
        return pulumi.get(self, "pipe")

    @_builtins.property
    @pulumi.getter
    def pty(self) -> Optional['outputs.DomainDevicesDiskSourceVhostUserPty']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        """
        return pulumi.get(self, "pty")

    @_builtins.property
    @pulumi.getter(name="qemuvdAgent")
    def qemuvd_agent(self) -> Optional['outputs.DomainDevicesDiskSourceVhostUserQemuvdAgent']:
        """
        Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        """
        return pulumi.get(self, "qemuvd_agent")

    @_builtins.property
    @pulumi.getter(name="spicePort")
    def spice_port(self) -> Optional['outputs.DomainDevicesDiskSourceVhostUserSpicePort']:
        """
        Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        """
        return pulumi.get(self, "spice_port")

    @_builtins.property
    @pulumi.getter(name="spiceVmc")
    def spice_vmc(self) -> Optional[_builtins.bool]:
        """
        When set to true, exposes the vhost-user backing through a SPICE virtio-serial management channel (SpiceVMC); when false or unset, the element is omitted.

        See: <https://libvirt.org/formatdomain.html#spice-channel>
        """
        return pulumi.get(self, "spice_vmc")

    @_builtins.property
    @pulumi.getter(name="stdIo")
    def std_io(self) -> Optional[_builtins.bool]:
        """
        When set to true, connects the vhost-user backing to the domains standard I/O character device; when false or unset, the StdIO element is omitted.

        See: <https://libvirt.org/formatdomain.html#host-interface>
        """
        return pulumi.get(self, "std_io")

    @_builtins.property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.DomainDevicesDiskSourceVhostUserTcp']:
        """
        Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        """
        return pulumi.get(self, "tcp")

    @_builtins.property
    @pulumi.getter
    def udp(self) -> Optional['outputs.DomainDevicesDiskSourceVhostUserUdp']:
        """
        Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        """
        return pulumi.get(self, "udp")

    @_builtins.property
    @pulumi.getter
    def unix(self) -> Optional['outputs.DomainDevicesDiskSourceVhostUserUnix']:
        """
        Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        """
        return pulumi.get(self, "unix")

    @_builtins.property
    @pulumi.getter
    def vc(self) -> Optional[_builtins.bool]:
        """
        Enables use of a vhost-user communication mechanism compatible with a VC-style (versioned capability) endpoint for the disk mirror backing store; when set true the VC element is emitted, when false or null it is omitted.
        """
        return pulumi.get(self, "vc")


@pulumi.output_type
class DomainDevicesDiskSourceVhostUserDbus(dict):
    def __init__(__self__, *,
                 channel: Optional[_builtins.str] = None):
        """
        :param _builtins.str channel: Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.str]:
        """
        Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesDiskSourceVhostUserDev(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceVhostUserDev. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceVhostUserDev.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceVhostUserDev.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskSourceVhostUserDevSecLabel']] = None):
        """
        :param _builtins.str path: Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesDiskSourceVhostUserDevSecLabelArgs'] sec_labels: Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskSourceVhostUserDevSecLabel']]:
        """
        Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskSourceVhostUserDevSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceVhostUserDevSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceVhostUserDevSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceVhostUserDevSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskSourceVhostUserFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceVhostUserFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceVhostUserFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceVhostUserFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 append: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskSourceVhostUserFileSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str append: Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
               
               See: <https://libvirt.org/formatdomain.html#device-logfile>
        :param Sequence['DomainDevicesDiskSourceVhostUserFileSecLabelArgs'] sec_labels: Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def append(self) -> Optional[_builtins.str]:
        """
        Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.

        See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        return pulumi.get(self, "append")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskSourceVhostUserFileSecLabel']]:
        """
        Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskSourceVhostUserFileSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceVhostUserFileSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceVhostUserFileSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceVhostUserFileSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskSourceVhostUserNmdm(dict):
    def __init__(__self__, *,
                 master: _builtins.str,
                 slave: _builtins.str):
        """
        :param _builtins.str master: Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        :param _builtins.str slave: Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        pulumi.set(__self__, "master", master)
        pulumi.set(__self__, "slave", slave)

    @_builtins.property
    @pulumi.getter
    def master(self) -> _builtins.str:
        """
        Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "master")

    @_builtins.property
    @pulumi.getter
    def slave(self) -> _builtins.str:
        """
        Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "slave")


@pulumi.output_type
class DomainDevicesDiskSourceVhostUserPipe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceVhostUserPipe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceVhostUserPipe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceVhostUserPipe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskSourceVhostUserPipeSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesDiskSourceVhostUserPipeSecLabelArgs'] sec_labels: Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskSourceVhostUserPipeSecLabel']]:
        """
        Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskSourceVhostUserPipeSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceVhostUserPipeSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceVhostUserPipeSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceVhostUserPipeSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskSourceVhostUserPty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceVhostUserPty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceVhostUserPty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceVhostUserPty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskSourceVhostUserPtySecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesDiskSourceVhostUserPtySecLabelArgs'] sec_labels: Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskSourceVhostUserPtySecLabel']]:
        """
        Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskSourceVhostUserPtySecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceVhostUserPtySecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceVhostUserPtySecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceVhostUserPtySecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskSourceVhostUserQemuvdAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clipBoard":
            suggest = "clip_board"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceVhostUserQemuvdAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceVhostUserQemuvdAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceVhostUserQemuvdAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clip_board: Optional['outputs.DomainDevicesDiskSourceVhostUserQemuvdAgentClipBoard'] = None,
                 mouse: Optional['outputs.DomainDevicesDiskSourceVhostUserQemuvdAgentMouse'] = None):
        """
        :param 'DomainDevicesDiskSourceVhostUserQemuvdAgentClipBoardArgs' clip_board: Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        :param 'DomainDevicesDiskSourceVhostUserQemuvdAgentMouseArgs' mouse: Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        if clip_board is not None:
            pulumi.set(__self__, "clip_board", clip_board)
        if mouse is not None:
            pulumi.set(__self__, "mouse", mouse)

    @_builtins.property
    @pulumi.getter(name="clipBoard")
    def clip_board(self) -> Optional['outputs.DomainDevicesDiskSourceVhostUserQemuvdAgentClipBoard']:
        """
        Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        """
        return pulumi.get(self, "clip_board")

    @_builtins.property
    @pulumi.getter
    def mouse(self) -> Optional['outputs.DomainDevicesDiskSourceVhostUserQemuvdAgentMouse']:
        """
        Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        return pulumi.get(self, "mouse")


@pulumi.output_type
class DomainDevicesDiskSourceVhostUserQemuvdAgentClipBoard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyPaste":
            suggest = "copy_paste"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceVhostUserQemuvdAgentClipBoard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceVhostUserQemuvdAgentClipBoard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceVhostUserQemuvdAgentClipBoard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_paste: _builtins.str):
        """
        :param _builtins.str copy_paste: Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "copy_paste", copy_paste)

    @_builtins.property
    @pulumi.getter(name="copyPaste")
    def copy_paste(self) -> _builtins.str:
        """
        Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "copy_paste")


@pulumi.output_type
class DomainDevicesDiskSourceVhostUserQemuvdAgentMouse(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DomainDevicesDiskSourceVhostUserSpicePort(dict):
    def __init__(__self__, *,
                 channel: _builtins.str):
        """
        :param _builtins.str channel: Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesDiskSourceVhostUserTcp(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesDiskSourceVhostUserTcpReconnect'] = None,
                 service: Optional[_builtins.str] = None,
                 tls: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str mode: Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesDiskSourceVhostUserTcpReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param _builtins.str service: Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str tls: Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesDiskSourceVhostUserTcpReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[_builtins.str]:
        """
        Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class DomainDevicesDiskSourceVhostUserTcpReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesDiskSourceVhostUserUdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindHost":
            suggest = "bind_host"
        elif key == "bindService":
            suggest = "bind_service"
        elif key == "connectHost":
            suggest = "connect_host"
        elif key == "connectService":
            suggest = "connect_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceVhostUserUdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceVhostUserUdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceVhostUserUdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bind_host: _builtins.str,
                 bind_service: _builtins.str,
                 connect_host: _builtins.str,
                 connect_service: _builtins.str):
        """
        :param _builtins.str bind_host: Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str bind_service: Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_host: Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_service: Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "bind_host", bind_host)
        pulumi.set(__self__, "bind_service", bind_service)
        pulumi.set(__self__, "connect_host", connect_host)
        pulumi.set(__self__, "connect_service", connect_service)

    @_builtins.property
    @pulumi.getter(name="bindHost")
    def bind_host(self) -> _builtins.str:
        """
        Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_host")

    @_builtins.property
    @pulumi.getter(name="bindService")
    def bind_service(self) -> _builtins.str:
        """
        Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_service")

    @_builtins.property
    @pulumi.getter(name="connectHost")
    def connect_host(self) -> _builtins.str:
        """
        Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_host")

    @_builtins.property
    @pulumi.getter(name="connectService")
    def connect_service(self) -> _builtins.str:
        """
        Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_service")


@pulumi.output_type
class DomainDevicesDiskSourceVhostUserUnix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceVhostUserUnix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceVhostUserUnix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceVhostUserUnix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesDiskSourceVhostUserUnixReconnect'] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskSourceVhostUserUnixSecLabel']] = None):
        """
        :param _builtins.str mode: Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str path: Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesDiskSourceVhostUserUnixReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param Sequence['DomainDevicesDiskSourceVhostUserUnixSecLabelArgs'] sec_labels: Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesDiskSourceVhostUserUnixReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskSourceVhostUserUnixSecLabel']]:
        """
        Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesDiskSourceVhostUserUnixReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesDiskSourceVhostUserUnixSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceVhostUserUnixSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceVhostUserUnixSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceVhostUserUnixSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskSourceVhostVdpa(dict):
    def __init__(__self__, *,
                 dev: _builtins.str):
        """
        :param _builtins.str dev: Sets the host vDPA character device path used as the backingStore source for the mirrored disk when using a vhost-vdpa backend; the value is user-provided and must reference an existing device node (for example, /dev/vhost-vdpa0).
        """
        pulumi.set(__self__, "dev", dev)

    @_builtins.property
    @pulumi.getter
    def dev(self) -> _builtins.str:
        """
        Sets the host vDPA character device path used as the backingStore source for the mirrored disk when using a vhost-vdpa backend; the value is user-provided and must reference an existing device node (for example, /dev/vhost-vdpa0).
        """
        return pulumi.get(self, "dev")


@pulumi.output_type
class DomainDevicesDiskSourceVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 pool: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesDiskSourceVolumeSecLabel']] = None,
                 volume: Optional[_builtins.str] = None):
        """
        :param _builtins.str mode: Sets the access mode with which the storage volume is used as the backingStore source (for example, "readOnly" or "readWrite" depending on driver support); the value is user-provided.
        :param _builtins.str pool: Names the storage pool that contains the backing storage volume used as the mirror backingStore source; must match an existing libvirt storage pool name.
        :param Sequence['DomainDevicesDiskSourceVolumeSecLabelArgs'] sec_labels: Configures an optional security label override applied to the backing storage volume used as the mirror backingStore source.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str volume: Sets the name of the storage volume within the specified pool that is used as the backingStore source for the mirrored disk.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if pool is not None:
            pulumi.set(__self__, "pool", pool)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the access mode with which the storage volume is used as the backingStore source (for example, "readOnly" or "readWrite" depending on driver support); the value is user-provided.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def pool(self) -> Optional[_builtins.str]:
        """
        Names the storage pool that contains the backing storage volume used as the mirror backingStore source; must match an existing libvirt storage pool name.
        """
        return pulumi.get(self, "pool")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesDiskSourceVolumeSecLabel']]:
        """
        Configures an optional security label override applied to the backing storage volume used as the mirror backingStore source.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional[_builtins.str]:
        """
        Sets the name of the storage volume within the specified pool that is used as the backingStore source for the mirrored disk.
        """
        return pulumi.get(self, "volume")


@pulumi.output_type
class DomainDevicesDiskSourceVolumeSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskSourceVolumeSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskSourceVolumeSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskSourceVolumeSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesDiskTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rotationRate":
            suggest = "rotation_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bus: Optional[_builtins.str] = None,
                 dev: Optional[_builtins.str] = None,
                 removable: Optional[_builtins.str] = None,
                 rotation_rate: Optional[_builtins.float] = None,
                 tray: Optional[_builtins.str] = None):
        """
        :param _builtins.str bus: Sets the guest bus type this disk is attached to, such as "ide", "sata", "scsi", "virtio", "usb", or "xen".
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str dev: Sets the guest device name exposed by this disk on the chosen bus (for example "vda", "sda", or "hda").
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str removable: Sets whether the guest can treat this disk as removable media; accepts "on" or "off" when supported by the bus/model.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.float rotation_rate: Sets the simulated disk rotation rate in revolutions per minute (RPM), typically "1" for SSDs or a realistic integer like "7200" for HDDs.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str tray: Sets the current tray state for tray-capable devices (e.g. CD-ROM), accepting "open" or "closed".
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if bus is not None:
            pulumi.set(__self__, "bus", bus)
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if removable is not None:
            pulumi.set(__self__, "removable", removable)
        if rotation_rate is not None:
            pulumi.set(__self__, "rotation_rate", rotation_rate)
        if tray is not None:
            pulumi.set(__self__, "tray", tray)

    @_builtins.property
    @pulumi.getter
    def bus(self) -> Optional[_builtins.str]:
        """
        Sets the guest bus type this disk is attached to, such as "ide", "sata", "scsi", "virtio", "usb", or "xen".

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "bus")

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional[_builtins.str]:
        """
        Sets the guest device name exposed by this disk on the chosen bus (for example "vda", "sda", or "hda").

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter
    def removable(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest can treat this disk as removable media; accepts "on" or "off" when supported by the bus/model.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "removable")

    @_builtins.property
    @pulumi.getter(name="rotationRate")
    def rotation_rate(self) -> Optional[_builtins.float]:
        """
        Sets the simulated disk rotation rate in revolutions per minute (RPM), typically "1" for SSDs or a realistic integer like "7200" for HDDs.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "rotation_rate")

    @_builtins.property
    @pulumi.getter
    def tray(self) -> Optional[_builtins.str]:
        """
        Sets the current tray state for tray-capable devices (e.g. CD-ROM), accepting "open" or "closed".

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "tray")


@pulumi.output_type
class DomainDevicesDiskThrottleFilters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "throttleFilters":
            suggest = "throttle_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskThrottleFilters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskThrottleFilters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskThrottleFilters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 throttle_filters: Optional[Sequence['outputs.DomainDevicesDiskThrottleFiltersThrottleFilter']] = None):
        """
        :param Sequence['DomainDevicesDiskThrottleFiltersThrottleFilterArgs'] throttle_filters: Declares a single throttle filter element referencing a named throttle group to control this disks I/O limits.
               
               See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        """
        if throttle_filters is not None:
            pulumi.set(__self__, "throttle_filters", throttle_filters)

    @_builtins.property
    @pulumi.getter(name="throttleFilters")
    def throttle_filters(self) -> Optional[Sequence['outputs.DomainDevicesDiskThrottleFiltersThrottleFilter']]:
        """
        Declares a single throttle filter element referencing a named throttle group to control this disks I/O limits.

        See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        """
        return pulumi.get(self, "throttle_filters")


@pulumi.output_type
class DomainDevicesDiskThrottleFiltersThrottleFilter(dict):
    def __init__(__self__, *,
                 group: _builtins.str):
        """
        :param _builtins.str group: Sets the name of the throttle group that this disks throttle filter should attach to; must match an existing group defined under domain throttlegroups.
               
               See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        """
        pulumi.set(__self__, "group", group)

    @_builtins.property
    @pulumi.getter
    def group(self) -> _builtins.str:
        """
        Sets the name of the throttle group that this disks throttle filter should attach to; must match an existing group defined under domain throttlegroups.

        See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        """
        return pulumi.get(self, "group")


@pulumi.output_type
class DomainDevicesDiskTransient(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shareBacking":
            suggest = "share_backing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesDiskTransient. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesDiskTransient.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesDiskTransient.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 share_backing: Optional[_builtins.str] = None):
        """
        :param _builtins.str share_backing: Sets whether a transient disk is allowed to share its backing image with other guests; accepts "yes" or "no".
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if share_backing is not None:
            pulumi.set(__self__, "share_backing", share_backing)

    @_builtins.property
    @pulumi.getter(name="shareBacking")
    def share_backing(self) -> Optional[_builtins.str]:
        """
        Sets whether a transient disk is allowed to share its backing image with other guests; accepts "yes" or "no".

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "share_backing")


@pulumi.output_type
class DomainDevicesFilesystem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessMode":
            suggest = "access_mode"
        elif key == "idMap":
            suggest = "id_map"
        elif key == "multiDevs":
            suggest = "multi_devs"
        elif key == "readOnly":
            suggest = "read_only"
        elif key == "spaceHardLimit":
            suggest = "space_hard_limit"
        elif key == "spaceHardLimitUnit":
            suggest = "space_hard_limit_unit"
        elif key == "spaceSoftLimit":
            suggest = "space_soft_limit"
        elif key == "spaceSoftLimitUnit":
            suggest = "space_soft_limit_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesFilesystem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesFilesystem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesFilesystem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_mode: Optional[_builtins.str] = None,
                 acpi: Optional['outputs.DomainDevicesFilesystemAcpi'] = None,
                 address: Optional['outputs.DomainDevicesFilesystemAddress'] = None,
                 alias: Optional['outputs.DomainDevicesFilesystemAlias'] = None,
                 binary: Optional['outputs.DomainDevicesFilesystemBinary'] = None,
                 boot: Optional['outputs.DomainDevicesFilesystemBoot'] = None,
                 dmode: Optional[_builtins.str] = None,
                 driver: Optional['outputs.DomainDevicesFilesystemDriver'] = None,
                 fmode: Optional[_builtins.str] = None,
                 id_map: Optional['outputs.DomainDevicesFilesystemIdMap'] = None,
                 model: Optional[_builtins.str] = None,
                 multi_devs: Optional[_builtins.str] = None,
                 read_only: Optional[_builtins.bool] = None,
                 source: Optional['outputs.DomainDevicesFilesystemSource'] = None,
                 space_hard_limit: Optional[_builtins.float] = None,
                 space_hard_limit_unit: Optional[_builtins.str] = None,
                 space_soft_limit: Optional[_builtins.float] = None,
                 space_soft_limit_unit: Optional[_builtins.str] = None,
                 target: Optional['outputs.DomainDevicesFilesystemTarget'] = None):
        """
        :param _builtins.str access_mode: Sets how the guest accesses the host filesystem, typically "passthrough", "mapped", or "squash" for directory-based filesystems.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        :param 'DomainDevicesFilesystemAcpiArgs' acpi: Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        :param 'DomainDevicesFilesystemAddressArgs' address: Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        :param 'DomainDevicesFilesystemAliasArgs' alias: Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        :param 'DomainDevicesFilesystemBinaryArgs' binary: Configures a virtiofsd-like helper binary used to export the host filesystem to the guest, including its path and runtime limits. When omitted, libvirt or the hypervisor default behavior for the filesystem backend is used.
        :param 'DomainDevicesFilesystemBootArgs' boot: Enables boot-order control for this redirected device, allowing it to participate in the device boot sequence.
        :param _builtins.str dmode: Sets the default directory permission bits (in octal, e.g. 0755) that libvirt applies to newly created directories inside the guest-visible mount of this filesystem.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        :param 'DomainDevicesFilesystemDriverArgs' driver: Configures driver-specific options for the filesystem device, including implementation type and virtio transport tuning for applicable models.
        :param _builtins.str fmode: Sets the default file permission bits (in octal, e.g. 0644) that libvirt applies to newly created regular files inside the guest-visible mount of this filesystem.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        :param 'DomainDevicesFilesystemIdMapArgs' id_map: Configures user and group ID mapping for this filesystem device, allowing remapping of guest UIDs/GIDs to different host IDs.
        :param _builtins.str model: Sets the filesystem device model presented to the guest, typically `virtio` for paravirtualized filesystems; the exact value is user-provided but must be supported by the hypervisor (e.g. `virtiofs` for type `virtiofs`).
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        :param _builtins.str multi_devs: Controls how the guest is allowed to access multiple backing devices under a single shared filesystem, using libvirts `multidevs` policy such as `default`, `remap`, `forbid`, or `warn`.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        :param _builtins.bool read_only: Controls whether the filesystem is attached read-only to the guest; when true the `<readonly>` element is emitted, otherwise it is omitted and the filesystem is writable if supported.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        :param 'DomainDevicesFilesystemSourceArgs' source: Groups the specification of the host-side filesystem source, with exactly one of the child variants (`bind`, `block`, `file`, `mount`, `ram`, or `template`) used depending on the filesystem `type`.
        :param _builtins.float space_hard_limit: Sets a hard limit on the amount of host storage space that the filesystem device may consume; the numeric value is interpreted together with space_hard_limit_unit.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        :param _builtins.str space_hard_limit_unit: Sets the unit for space_hard_limit (for example, "bytes", "KiB", "MiB", "GiB"); the value is a libvirt size unit string and must be consistent with the numeric limit.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        :param _builtins.float space_soft_limit: Sets a soft (advisory) limit on the amount of host storage space that the filesystem device should use; the numeric value is interpreted together with space_soft_limit_unit.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        :param _builtins.str space_soft_limit_unit: Sets the unit for space_soft_limit (for example, "bytes", "KiB", "MiB", "GiB"); the value is a libvirt size unit string and must be consistent with the numeric limit.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        :param 'DomainDevicesFilesystemTargetArgs' target: Configures how and where the filesystem is exposed inside the guest by providing the guest-side mount target.
        """
        if access_mode is not None:
            pulumi.set(__self__, "access_mode", access_mode)
        if acpi is not None:
            pulumi.set(__self__, "acpi", acpi)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if binary is not None:
            pulumi.set(__self__, "binary", binary)
        if boot is not None:
            pulumi.set(__self__, "boot", boot)
        if dmode is not None:
            pulumi.set(__self__, "dmode", dmode)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if fmode is not None:
            pulumi.set(__self__, "fmode", fmode)
        if id_map is not None:
            pulumi.set(__self__, "id_map", id_map)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if multi_devs is not None:
            pulumi.set(__self__, "multi_devs", multi_devs)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if space_hard_limit is not None:
            pulumi.set(__self__, "space_hard_limit", space_hard_limit)
        if space_hard_limit_unit is not None:
            pulumi.set(__self__, "space_hard_limit_unit", space_hard_limit_unit)
        if space_soft_limit is not None:
            pulumi.set(__self__, "space_soft_limit", space_soft_limit)
        if space_soft_limit_unit is not None:
            pulumi.set(__self__, "space_soft_limit_unit", space_soft_limit_unit)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter(name="accessMode")
    def access_mode(self) -> Optional[_builtins.str]:
        """
        Sets how the guest accesses the host filesystem, typically "passthrough", "mapped", or "squash" for directory-based filesystems.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "access_mode")

    @_builtins.property
    @pulumi.getter
    def acpi(self) -> Optional['outputs.DomainDevicesFilesystemAcpi']:
        """
        Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        """
        return pulumi.get(self, "acpi")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesFilesystemAddress']:
        """
        Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional['outputs.DomainDevicesFilesystemAlias']:
        """
        Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def binary(self) -> Optional['outputs.DomainDevicesFilesystemBinary']:
        """
        Configures a virtiofsd-like helper binary used to export the host filesystem to the guest, including its path and runtime limits. When omitted, libvirt or the hypervisor default behavior for the filesystem backend is used.
        """
        return pulumi.get(self, "binary")

    @_builtins.property
    @pulumi.getter
    def boot(self) -> Optional['outputs.DomainDevicesFilesystemBoot']:
        """
        Enables boot-order control for this redirected device, allowing it to participate in the device boot sequence.
        """
        return pulumi.get(self, "boot")

    @_builtins.property
    @pulumi.getter
    def dmode(self) -> Optional[_builtins.str]:
        """
        Sets the default directory permission bits (in octal, e.g. 0755) that libvirt applies to newly created directories inside the guest-visible mount of this filesystem.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "dmode")

    @_builtins.property
    @pulumi.getter
    def driver(self) -> Optional['outputs.DomainDevicesFilesystemDriver']:
        """
        Configures driver-specific options for the filesystem device, including implementation type and virtio transport tuning for applicable models.
        """
        return pulumi.get(self, "driver")

    @_builtins.property
    @pulumi.getter
    def fmode(self) -> Optional[_builtins.str]:
        """
        Sets the default file permission bits (in octal, e.g. 0644) that libvirt applies to newly created regular files inside the guest-visible mount of this filesystem.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "fmode")

    @_builtins.property
    @pulumi.getter(name="idMap")
    def id_map(self) -> Optional['outputs.DomainDevicesFilesystemIdMap']:
        """
        Configures user and group ID mapping for this filesystem device, allowing remapping of guest UIDs/GIDs to different host IDs.
        """
        return pulumi.get(self, "id_map")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Sets the filesystem device model presented to the guest, typically `virtio` for paravirtualized filesystems; the exact value is user-provided but must be supported by the hypervisor (e.g. `virtiofs` for type `virtiofs`).

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter(name="multiDevs")
    def multi_devs(self) -> Optional[_builtins.str]:
        """
        Controls how the guest is allowed to access multiple backing devices under a single shared filesystem, using libvirts `multidevs` policy such as `default`, `remap`, `forbid`, or `warn`.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "multi_devs")

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[_builtins.bool]:
        """
        Controls whether the filesystem is attached read-only to the guest; when true the `<readonly>` element is emitted, otherwise it is omitted and the filesystem is writable if supported.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "read_only")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainDevicesFilesystemSource']:
        """
        Groups the specification of the host-side filesystem source, with exactly one of the child variants (`bind`, `block`, `file`, `mount`, `ram`, or `template`) used depending on the filesystem `type`.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="spaceHardLimit")
    def space_hard_limit(self) -> Optional[_builtins.float]:
        """
        Sets a hard limit on the amount of host storage space that the filesystem device may consume; the numeric value is interpreted together with space_hard_limit_unit.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "space_hard_limit")

    @_builtins.property
    @pulumi.getter(name="spaceHardLimitUnit")
    def space_hard_limit_unit(self) -> Optional[_builtins.str]:
        """
        Sets the unit for space_hard_limit (for example, "bytes", "KiB", "MiB", "GiB"); the value is a libvirt size unit string and must be consistent with the numeric limit.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "space_hard_limit_unit")

    @_builtins.property
    @pulumi.getter(name="spaceSoftLimit")
    def space_soft_limit(self) -> Optional[_builtins.float]:
        """
        Sets a soft (advisory) limit on the amount of host storage space that the filesystem device should use; the numeric value is interpreted together with space_soft_limit_unit.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "space_soft_limit")

    @_builtins.property
    @pulumi.getter(name="spaceSoftLimitUnit")
    def space_soft_limit_unit(self) -> Optional[_builtins.str]:
        """
        Sets the unit for space_soft_limit (for example, "bytes", "KiB", "MiB", "GiB"); the value is a libvirt size unit string and must be consistent with the numeric limit.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "space_soft_limit_unit")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional['outputs.DomainDevicesFilesystemTarget']:
        """
        Configures how and where the filesystem is exposed inside the guest by providing the guest-side mount target.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class DomainDevicesFilesystemAcpi(dict):
    def __init__(__self__, *,
                 index: Optional[_builtins.float] = None):
        """
        :param _builtins.float index: Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        """
        if index is not None:
            pulumi.set(__self__, "index", index)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "index")


@pulumi.output_type
class DomainDevicesFilesystemAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesFilesystemAlias(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
               
               See: <https://libvirt.org/formatdomain.html#devices>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesFilesystemBinary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "openFiles":
            suggest = "open_files"
        elif key == "threadPool":
            suggest = "thread_pool"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesFilesystemBinary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesFilesystemBinary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesFilesystemBinary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache: Optional['outputs.DomainDevicesFilesystemBinaryCache'] = None,
                 lock: Optional['outputs.DomainDevicesFilesystemBinaryLock'] = None,
                 open_files: Optional['outputs.DomainDevicesFilesystemBinaryOpenFiles'] = None,
                 path: Optional[_builtins.str] = None,
                 sandbox: Optional['outputs.DomainDevicesFilesystemBinarySandbox'] = None,
                 thread_pool: Optional['outputs.DomainDevicesFilesystemBinaryThreadPool'] = None,
                 xattr: Optional[_builtins.str] = None):
        """
        :param 'DomainDevicesFilesystemBinaryCacheArgs' cache: Configures caching behavior for the filesystem helper binary, such as how it caches file metadata or data. The effective policy is controlled by the required mode attribute.
        :param 'DomainDevicesFilesystemBinaryLockArgs' lock: Configures file locking behavior used by the filesystem helper binary when accessing shared host files. Its flock and posix attributes enable or disable the respective locking mechanisms.
        :param 'DomainDevicesFilesystemBinaryOpenFilesArgs' open_files: Configures limits related to the number of open files the filesystem helper binary may keep, helping constrain resource usage. The max attribute defines the actual numeric limit.
        :param _builtins.str path: Sets the absolute path to the filesystem helper binary (such as a virtiofsd-style daemon) that will be executed to serve this filesystem. Value is user-provided and must point to an executable on the host (for example, "/usr/libexec/virtiofsd").
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        :param 'DomainDevicesFilesystemBinarySandboxArgs' sandbox: Configures sandboxing behavior for the filesystem helper binary, such as whether it runs in a restricted environment. The mode attribute selects the sandboxing policy.
        :param 'DomainDevicesFilesystemBinaryThreadPoolArgs' thread_pool: Configures the thread pool used by the filesystem helper binary to handle I/O requests. The size attribute controls the number of worker threads.
        :param _builtins.str xattr: Enables or disables extended attribute (xattr) support for the filesystem helper binary when exporting the filesystem; value is typically "on"/"off" or "yes"/"no". When omitted, the backend default is used.
        """
        if cache is not None:
            pulumi.set(__self__, "cache", cache)
        if lock is not None:
            pulumi.set(__self__, "lock", lock)
        if open_files is not None:
            pulumi.set(__self__, "open_files", open_files)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if sandbox is not None:
            pulumi.set(__self__, "sandbox", sandbox)
        if thread_pool is not None:
            pulumi.set(__self__, "thread_pool", thread_pool)
        if xattr is not None:
            pulumi.set(__self__, "xattr", xattr)

    @_builtins.property
    @pulumi.getter
    def cache(self) -> Optional['outputs.DomainDevicesFilesystemBinaryCache']:
        """
        Configures caching behavior for the filesystem helper binary, such as how it caches file metadata or data. The effective policy is controlled by the required mode attribute.
        """
        return pulumi.get(self, "cache")

    @_builtins.property
    @pulumi.getter
    def lock(self) -> Optional['outputs.DomainDevicesFilesystemBinaryLock']:
        """
        Configures file locking behavior used by the filesystem helper binary when accessing shared host files. Its flock and posix attributes enable or disable the respective locking mechanisms.
        """
        return pulumi.get(self, "lock")

    @_builtins.property
    @pulumi.getter(name="openFiles")
    def open_files(self) -> Optional['outputs.DomainDevicesFilesystemBinaryOpenFiles']:
        """
        Configures limits related to the number of open files the filesystem helper binary may keep, helping constrain resource usage. The max attribute defines the actual numeric limit.
        """
        return pulumi.get(self, "open_files")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Sets the absolute path to the filesystem helper binary (such as a virtiofsd-style daemon) that will be executed to serve this filesystem. Value is user-provided and must point to an executable on the host (for example, "/usr/libexec/virtiofsd").

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def sandbox(self) -> Optional['outputs.DomainDevicesFilesystemBinarySandbox']:
        """
        Configures sandboxing behavior for the filesystem helper binary, such as whether it runs in a restricted environment. The mode attribute selects the sandboxing policy.
        """
        return pulumi.get(self, "sandbox")

    @_builtins.property
    @pulumi.getter(name="threadPool")
    def thread_pool(self) -> Optional['outputs.DomainDevicesFilesystemBinaryThreadPool']:
        """
        Configures the thread pool used by the filesystem helper binary to handle I/O requests. The size attribute controls the number of worker threads.
        """
        return pulumi.get(self, "thread_pool")

    @_builtins.property
    @pulumi.getter
    def xattr(self) -> Optional[_builtins.str]:
        """
        Enables or disables extended attribute (xattr) support for the filesystem helper binary when exporting the filesystem; value is typically "on"/"off" or "yes"/"no". When omitted, the backend default is used.
        """
        return pulumi.get(self, "xattr")


@pulumi.output_type
class DomainDevicesFilesystemBinaryCache(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: Sets the cache mode policy for the filesystem helper binary; value is user-provided and should match libvirt's supported cache modes (for example, "always", "none", or similar driver-specific values).
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets the cache mode policy for the filesystem helper binary; value is user-provided and should match libvirt's supported cache modes (for example, "always", "none", or similar driver-specific values).
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DomainDevicesFilesystemBinaryLock(dict):
    def __init__(__self__, *,
                 flock: Optional[_builtins.str] = None,
                 posix: Optional[_builtins.str] = None):
        """
        :param _builtins.str flock: Enables or disables use of flock-style locking by the filesystem helper binary; value is typically "on"/"off" or "yes"/"no" according to libvirt's locking options. When omitted, the driver default is used.
        :param _builtins.str posix: Enables or disables use of POSIX locks by the filesystem helper binary; value is typically "on"/"off" or "yes"/"no" according to libvirt's locking options. When omitted, the driver default is used.
        """
        if flock is not None:
            pulumi.set(__self__, "flock", flock)
        if posix is not None:
            pulumi.set(__self__, "posix", posix)

    @_builtins.property
    @pulumi.getter
    def flock(self) -> Optional[_builtins.str]:
        """
        Enables or disables use of flock-style locking by the filesystem helper binary; value is typically "on"/"off" or "yes"/"no" according to libvirt's locking options. When omitted, the driver default is used.
        """
        return pulumi.get(self, "flock")

    @_builtins.property
    @pulumi.getter
    def posix(self) -> Optional[_builtins.str]:
        """
        Enables or disables use of POSIX locks by the filesystem helper binary; value is typically "on"/"off" or "yes"/"no" according to libvirt's locking options. When omitted, the driver default is used.
        """
        return pulumi.get(self, "posix")


@pulumi.output_type
class DomainDevicesFilesystemBinaryOpenFiles(dict):
    def __init__(__self__, *,
                 max: _builtins.float):
        """
        :param _builtins.float max: Sets the maximum number of open file descriptors allowed for the filesystem helper binary; value is a user-provided positive integer. For example, 1024 or 4096.
        """
        pulumi.set(__self__, "max", max)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.float:
        """
        Sets the maximum number of open file descriptors allowed for the filesystem helper binary; value is a user-provided positive integer. For example, 1024 or 4096.
        """
        return pulumi.get(self, "max")


@pulumi.output_type
class DomainDevicesFilesystemBinarySandbox(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: Sets the sandbox mode for the filesystem helper binary; value is user-provided and should match one of libvirt's supported sandbox modes for this backend. For example, a mode could indicate "chroot" or "none" depending on driver support.
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets the sandbox mode for the filesystem helper binary; value is user-provided and should match one of libvirt's supported sandbox modes for this backend. For example, a mode could indicate "chroot" or "none" depending on driver support.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DomainDevicesFilesystemBinaryThreadPool(dict):
    def __init__(__self__, *,
                 size: Optional[_builtins.float] = None):
        """
        :param _builtins.float size: Sets the number of worker threads in the filesystem helper binary's thread pool; value is a user-provided non-negative integer. For example, 4 or 16.
        """
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.float]:
        """
        Sets the number of worker threads in the filesystem helper binary's thread pool; value is a user-provided non-negative integer. For example, 4 or 16.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class DomainDevicesFilesystemBoot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadParm":
            suggest = "load_parm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesFilesystemBoot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesFilesystemBoot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesFilesystemBoot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 order: _builtins.float,
                 load_parm: Optional[_builtins.str] = None):
        """
        :param _builtins.float order: Sets the boot priority for this redirected device, as a positive integer where lower values are tried earlier during guest boot (for example, 1 for first, 2 for second).
               
               See: <https://libvirt.org/formatdomain.html#specifying-boot-order>
        :param _builtins.str load_parm: Sets an optional firmware load parameter string associated with booting from this redirected device, passed to firmware on platforms that support loadparm (e.g. s390x).
               
               See: <https://libvirt.org/formatdomain.html#specifying-boot-order>
        """
        pulumi.set(__self__, "order", order)
        if load_parm is not None:
            pulumi.set(__self__, "load_parm", load_parm)

    @_builtins.property
    @pulumi.getter
    def order(self) -> _builtins.float:
        """
        Sets the boot priority for this redirected device, as a positive integer where lower values are tried earlier during guest boot (for example, 1 for first, 2 for second).

        See: <https://libvirt.org/formatdomain.html#specifying-boot-order>
        """
        return pulumi.get(self, "order")

    @_builtins.property
    @pulumi.getter(name="loadParm")
    def load_parm(self) -> Optional[_builtins.str]:
        """
        Sets an optional firmware load parameter string associated with booting from this redirected device, passed to firmware on platforms that support loadparm (e.g. s390x).

        See: <https://libvirt.org/formatdomain.html#specifying-boot-order>
        """
        return pulumi.get(self, "load_parm")


@pulumi.output_type
class DomainDevicesFilesystemDriver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pagePerVq":
            suggest = "page_per_vq"
        elif key == "wrPolicy":
            suggest = "wr_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesFilesystemDriver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesFilesystemDriver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesFilesystemDriver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ats: Optional[_builtins.str] = None,
                 format: Optional[_builtins.str] = None,
                 iommu: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 packed: Optional[_builtins.str] = None,
                 page_per_vq: Optional[_builtins.str] = None,
                 queue: Optional[_builtins.float] = None,
                 type: Optional[_builtins.str] = None,
                 wr_policy: Optional[_builtins.str] = None):
        """
        :param _builtins.str ats: Enables or disables Address Translation Service for a virtio-based filesystem device; valid values are "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.str format: Sets an optional driver-specific format identifier for the filesystem backend; the value is user-provided and depends on the underlying driver.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        :param _builtins.str iommu: Enables or disables use of an emulated IOMMU for the virtio filesystem device; valid values are "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.str name: Sets the backend driver name for the filesystem device (for example a specific virtiofs or 9p implementation); the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        :param _builtins.str packed: Enables or disables virtio packed ring layout for the filesystem device; valid values are "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.str page_per_vq: Enables or disables use of a separate notification page per virtqueue for the virtio filesystem device; valid values are "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.float queue: Sets a driver-specific queue-related parameter (such as number or size of queues) for the filesystem device; the value is user-provided and must be a non-negative integer when used.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        :param _builtins.str type: Selects the filesystem driver type, such as "virtiofs" or "path", determining how the host directory is exposed to the guest; the exact valid values are driver-dependent.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        :param _builtins.str wr_policy: Sets the write policy for the filesystem backend (for example "immediate" or "delayed") controlling how writes are flushed to host storage; the value is user-provided and driver-specific.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        if ats is not None:
            pulumi.set(__self__, "ats", ats)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if iommu is not None:
            pulumi.set(__self__, "iommu", iommu)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if packed is not None:
            pulumi.set(__self__, "packed", packed)
        if page_per_vq is not None:
            pulumi.set(__self__, "page_per_vq", page_per_vq)
        if queue is not None:
            pulumi.set(__self__, "queue", queue)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if wr_policy is not None:
            pulumi.set(__self__, "wr_policy", wr_policy)

    @_builtins.property
    @pulumi.getter
    def ats(self) -> Optional[_builtins.str]:
        """
        Enables or disables Address Translation Service for a virtio-based filesystem device; valid values are "on" or "off".

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "ats")

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[_builtins.str]:
        """
        Sets an optional driver-specific format identifier for the filesystem backend; the value is user-provided and depends on the underlying driver.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter
    def iommu(self) -> Optional[_builtins.str]:
        """
        Enables or disables use of an emulated IOMMU for the virtio filesystem device; valid values are "on" or "off".

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "iommu")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the backend driver name for the filesystem device (for example a specific virtiofs or 9p implementation); the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def packed(self) -> Optional[_builtins.str]:
        """
        Enables or disables virtio packed ring layout for the filesystem device; valid values are "on" or "off".

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "packed")

    @_builtins.property
    @pulumi.getter(name="pagePerVq")
    def page_per_vq(self) -> Optional[_builtins.str]:
        """
        Enables or disables use of a separate notification page per virtqueue for the virtio filesystem device; valid values are "on" or "off".

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "page_per_vq")

    @_builtins.property
    @pulumi.getter
    def queue(self) -> Optional[_builtins.float]:
        """
        Sets a driver-specific queue-related parameter (such as number or size of queues) for the filesystem device; the value is user-provided and must be a non-negative integer when used.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "queue")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Selects the filesystem driver type, such as "virtiofs" or "path", determining how the host directory is exposed to the guest; the exact valid values are driver-dependent.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="wrPolicy")
    def wr_policy(self) -> Optional[_builtins.str]:
        """
        Sets the write policy for the filesystem backend (for example "immediate" or "delayed") controlling how writes are flushed to host storage; the value is user-provided and driver-specific.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "wr_policy")


@pulumi.output_type
class DomainDevicesFilesystemIdMap(dict):
    def __init__(__self__, *,
                 gids: Optional[Sequence['outputs.DomainDevicesFilesystemIdMapGid']] = None,
                 uids: Optional[Sequence['outputs.DomainDevicesFilesystemIdMapUid']] = None):
        """
        :param Sequence['DomainDevicesFilesystemIdMapGidArgs'] gids: Defines one or more group ID (GID) mapping ranges for the filesystem, remapping guest GIDs to host GIDs according to the attributes provided.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        :param Sequence['DomainDevicesFilesystemIdMapUidArgs'] uids: Defines one or more user ID (UID) mapping ranges for the filesystem, remapping guest UIDs to host UIDs via count/start/target attributes similar to gid mapping.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        if gids is not None:
            pulumi.set(__self__, "gids", gids)
        if uids is not None:
            pulumi.set(__self__, "uids", uids)

    @_builtins.property
    @pulumi.getter
    def gids(self) -> Optional[Sequence['outputs.DomainDevicesFilesystemIdMapGid']]:
        """
        Defines one or more group ID (GID) mapping ranges for the filesystem, remapping guest GIDs to host GIDs according to the attributes provided.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "gids")

    @_builtins.property
    @pulumi.getter
    def uids(self) -> Optional[Sequence['outputs.DomainDevicesFilesystemIdMapUid']]:
        """
        Defines one or more user ID (UID) mapping ranges for the filesystem, remapping guest UIDs to host UIDs via count/start/target attributes similar to gid mapping.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "uids")


@pulumi.output_type
class DomainDevicesFilesystemIdMapGid(dict):
    def __init__(__self__, *,
                 count: _builtins.float,
                 start: _builtins.float,
                 target: _builtins.float):
        """
        :param _builtins.float count: Sets the size of the GID mapping range (number of consecutive IDs) for this mapping entry; must be a positive integer.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        :param _builtins.float start: Sets the starting guest GID for this mapping range; must be a non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        :param _builtins.float target: Sets the starting host GID to which the guest GID range is mapped; must be a non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "start", start)
        pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.float:
        """
        Sets the size of the GID mapping range (number of consecutive IDs) for this mapping entry; must be a positive integer.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def start(self) -> _builtins.float:
        """
        Sets the starting guest GID for this mapping range; must be a non-negative integer.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "start")

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.float:
        """
        Sets the starting host GID to which the guest GID range is mapped; must be a non-negative integer.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class DomainDevicesFilesystemIdMapUid(dict):
    def __init__(__self__, *,
                 count: _builtins.float,
                 start: _builtins.float,
                 target: _builtins.float):
        """
        :param _builtins.float count: Sets the size of the GID mapping range (number of consecutive IDs) for this mapping entry; must be a positive integer.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        :param _builtins.float start: Sets the starting guest GID for this mapping range; must be a non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        :param _builtins.float target: Sets the starting host GID to which the guest GID range is mapped; must be a non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "start", start)
        pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.float:
        """
        Sets the size of the GID mapping range (number of consecutive IDs) for this mapping entry; must be a positive integer.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def start(self) -> _builtins.float:
        """
        Sets the starting guest GID for this mapping range; must be a non-negative integer.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "start")

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.float:
        """
        Sets the starting host GID to which the guest GID range is mapped; must be a non-negative integer.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class DomainDevicesFilesystemSource(dict):
    def __init__(__self__, *,
                 bind: Optional['outputs.DomainDevicesFilesystemSourceBind'] = None,
                 block: Optional['outputs.DomainDevicesFilesystemSourceBlock'] = None,
                 file: Optional['outputs.DomainDevicesFilesystemSourceFile'] = None,
                 mount: Optional['outputs.DomainDevicesFilesystemSourceMount'] = None,
                 ram: Optional['outputs.DomainDevicesFilesystemSourceRam'] = None,
                 template: Optional['outputs.DomainDevicesFilesystemSourceTemplate'] = None,
                 volume: Optional['outputs.DomainDevicesFilesystemSourceVolume'] = None):
        """
        :param 'DomainDevicesFilesystemSourceBindArgs' bind: Selects a host directory to be exposed via a bind-mountstyle filesystem source, used when `type="mount"` and `accessmode`/`source` semantics require an existing directory.
        :param 'DomainDevicesFilesystemSourceBlockArgs' block: Selects a host block device node as the filesystem source, used for block-backed filesystems.
        :param 'DomainDevicesFilesystemSourceFileArgs' file: Selects a regular host file (for example an image or archive) as the filesystem source.
        :param 'DomainDevicesFilesystemSourceMountArgs' mount: Selects an existing host mount point or socket as the filesystem source, typically used for 9p/virtio-fs style exports.
        :param 'DomainDevicesFilesystemSourceRamArgs' ram: Selects a RAM-backed filesystem source that uses host memory only, configured by `usage` and optional `units`.
        :param 'DomainDevicesFilesystemSourceTemplateArgs' template: Selects a template-based source for the filesystem, where the actual contents are derived from a template definition; the specific semantics and value are user-provided.
        :param 'DomainDevicesFilesystemSourceVolumeArgs' volume: Enables using a managed storage volume as the filesystem source instead of a host path, referencing a volume from a libvirt storage pool.
        """
        if bind is not None:
            pulumi.set(__self__, "bind", bind)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if mount is not None:
            pulumi.set(__self__, "mount", mount)
        if ram is not None:
            pulumi.set(__self__, "ram", ram)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def bind(self) -> Optional['outputs.DomainDevicesFilesystemSourceBind']:
        """
        Selects a host directory to be exposed via a bind-mountstyle filesystem source, used when `type="mount"` and `accessmode`/`source` semantics require an existing directory.
        """
        return pulumi.get(self, "bind")

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional['outputs.DomainDevicesFilesystemSourceBlock']:
        """
        Selects a host block device node as the filesystem source, used for block-backed filesystems.
        """
        return pulumi.get(self, "block")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.DomainDevicesFilesystemSourceFile']:
        """
        Selects a regular host file (for example an image or archive) as the filesystem source.
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def mount(self) -> Optional['outputs.DomainDevicesFilesystemSourceMount']:
        """
        Selects an existing host mount point or socket as the filesystem source, typically used for 9p/virtio-fs style exports.
        """
        return pulumi.get(self, "mount")

    @_builtins.property
    @pulumi.getter
    def ram(self) -> Optional['outputs.DomainDevicesFilesystemSourceRam']:
        """
        Selects a RAM-backed filesystem source that uses host memory only, configured by `usage` and optional `units`.
        """
        return pulumi.get(self, "ram")

    @_builtins.property
    @pulumi.getter
    def template(self) -> Optional['outputs.DomainDevicesFilesystemSourceTemplate']:
        """
        Selects a template-based source for the filesystem, where the actual contents are derived from a template definition; the specific semantics and value are user-provided.
        """
        return pulumi.get(self, "template")

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional['outputs.DomainDevicesFilesystemSourceVolume']:
        """
        Enables using a managed storage volume as the filesystem source instead of a host path, referencing a volume from a libvirt storage pool.
        """
        return pulumi.get(self, "volume")


@pulumi.output_type
class DomainDevicesFilesystemSourceBind(dict):
    def __init__(__self__, *,
                 dir: _builtins.str):
        """
        :param _builtins.str dir: Sets the absolute path of the host directory that is bind-mounted into the guest filesystem when using a bind source.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        pulumi.set(__self__, "dir", dir)

    @_builtins.property
    @pulumi.getter
    def dir(self) -> _builtins.str:
        """
        Sets the absolute path of the host directory that is bind-mounted into the guest filesystem when using a bind source.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "dir")


@pulumi.output_type
class DomainDevicesFilesystemSourceBlock(dict):
    def __init__(__self__, *,
                 dev: _builtins.str):
        """
        :param _builtins.str dev: Sets the path of the host block device (for example `/dev/sdb1`) to use as the backing storage for the filesystem.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        pulumi.set(__self__, "dev", dev)

    @_builtins.property
    @pulumi.getter
    def dev(self) -> _builtins.str:
        """
        Sets the path of the host block device (for example `/dev/sdb1`) to use as the backing storage for the filesystem.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "dev")


@pulumi.output_type
class DomainDevicesFilesystemSourceFile(dict):
    def __init__(__self__, *,
                 file: _builtins.str):
        """
        :param _builtins.str file: Sets the path of the host file to be used as the filesystem source (for example `/var/lib/images/rootfs.img`).
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        pulumi.set(__self__, "file", file)

    @_builtins.property
    @pulumi.getter
    def file(self) -> _builtins.str:
        """
        Sets the path of the host file to be used as the filesystem source (for example `/var/lib/images/rootfs.img`).

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "file")


@pulumi.output_type
class DomainDevicesFilesystemSourceMount(dict):
    def __init__(__self__, *,
                 dir: Optional[_builtins.str] = None,
                 socket: Optional[_builtins.str] = None):
        """
        :param _builtins.str dir: Sets the host directory that is already mounted and will be exposed directly to the guest as the filesystem source.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        :param _builtins.str socket: Sets the path of a host socket associated with the mount-based filesystem source (for example a virtio-fs daemon socket); value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        if dir is not None:
            pulumi.set(__self__, "dir", dir)
        if socket is not None:
            pulumi.set(__self__, "socket", socket)

    @_builtins.property
    @pulumi.getter
    def dir(self) -> Optional[_builtins.str]:
        """
        Sets the host directory that is already mounted and will be exposed directly to the guest as the filesystem source.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "dir")

    @_builtins.property
    @pulumi.getter
    def socket(self) -> Optional[_builtins.str]:
        """
        Sets the path of a host socket associated with the mount-based filesystem source (for example a virtio-fs daemon socket); value is user-provided.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "socket")


@pulumi.output_type
class DomainDevicesFilesystemSourceRam(dict):
    def __init__(__self__, *,
                 usage: _builtins.float,
                 units: Optional[_builtins.str] = None):
        """
        :param _builtins.float usage: Sets the size of the RAM-backed filesystem in the specified units (or libvirt default units); value is user-provided and must be a positive integer.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        :param _builtins.str units: Sets the units for the RAM filesystem `usage` value, such as `KB`, `MB`, or `GB`; if omitted, libvirt uses its default unit handling.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        pulumi.set(__self__, "usage", usage)
        if units is not None:
            pulumi.set(__self__, "units", units)

    @_builtins.property
    @pulumi.getter
    def usage(self) -> _builtins.float:
        """
        Sets the size of the RAM-backed filesystem in the specified units (or libvirt default units); value is user-provided and must be a positive integer.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "usage")

    @_builtins.property
    @pulumi.getter
    def units(self) -> Optional[_builtins.str]:
        """
        Sets the units for the RAM filesystem `usage` value, such as `KB`, `MB`, or `GB`; if omitted, libvirt uses its default unit handling.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "units")


@pulumi.output_type
class DomainDevicesFilesystemSourceTemplate(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the name of a filesystem source template to use, referring to a pre-defined template configuration; the value is user-provided and must match an existing template name.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the name of a filesystem source template to use, referring to a pre-defined template configuration; the value is user-provided and must match an existing template name.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesFilesystemSourceVolume(dict):
    def __init__(__self__, *,
                 pool: _builtins.str,
                 volume: _builtins.str):
        """
        :param _builtins.str pool: Sets the name of the storage pool that contains the volume used as the filesystem source; the value is user-provided and must match an existing pool (for example, "default").
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        :param _builtins.str volume: Sets the name of the storage volume within the specified pool to expose as the filesystem source (for example, "myshare.img"); the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        pulumi.set(__self__, "pool", pool)
        pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def pool(self) -> _builtins.str:
        """
        Sets the name of the storage pool that contains the volume used as the filesystem source; the value is user-provided and must match an existing pool (for example, "default").

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "pool")

    @_builtins.property
    @pulumi.getter
    def volume(self) -> _builtins.str:
        """
        Sets the name of the storage volume within the specified pool to expose as the filesystem source (for example, "myshare.img"); the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "volume")


@pulumi.output_type
class DomainDevicesFilesystemTarget(dict):
    def __init__(__self__, *,
                 dir: _builtins.str):
        """
        :param _builtins.str dir: Sets the guest-visible directory path for the filesystem mount point (for example, "/mnt/share"); the value is user-provided and must be an absolute path in the guest.
               
               See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        pulumi.set(__self__, "dir", dir)

    @_builtins.property
    @pulumi.getter
    def dir(self) -> _builtins.str:
        """
        Sets the guest-visible directory path for the filesystem mount point (for example, "/mnt/share"); the value is user-provided and must be an absolute path in the guest.

        See: <https://libvirt.org/formatdomain.html#filesystems>
        """
        return pulumi.get(self, "dir")


@pulumi.output_type
class DomainDevicesGraphic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eglHeadless":
            suggest = "egl_headless"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesGraphic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesGraphic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesGraphic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio: Optional['outputs.DomainDevicesGraphicAudio'] = None,
                 dbus: Optional['outputs.DomainDevicesGraphicDbus'] = None,
                 desktop: Optional['outputs.DomainDevicesGraphicDesktop'] = None,
                 egl_headless: Optional['outputs.DomainDevicesGraphicEglHeadless'] = None,
                 rdp: Optional['outputs.DomainDevicesGraphicRdp'] = None,
                 sdl: Optional['outputs.DomainDevicesGraphicSdl'] = None,
                 spice: Optional['outputs.DomainDevicesGraphicSpice'] = None,
                 vnc: Optional['outputs.DomainDevicesGraphicVnc'] = None):
        """
        :param 'DomainDevicesGraphicAudioArgs' audio: Configures an audio backend association for this graphics device, linking it to a specific <audio> definition by id.
        :param 'DomainDevicesGraphicDbusArgs' dbus: Enables a DBus-based display backend for the graphics device, allowing the display to be exported over DBus instead of a traditional VNC/SPICE socket.
        :param 'DomainDevicesGraphicDesktopArgs' desktop: Configures desktop integration for the graphics device, such as exposing the guest window as a desktop surface on the host; the specific value is user-provided according to the chosen graphics type.
        :param 'DomainDevicesGraphicEglHeadlessArgs' egl_headless: Enables the egl-headless graphics backend, which provides a headless OpenGL-capable display surface without a visible window.
        :param 'DomainDevicesGraphicRdpArgs' rdp: Enables an RDP graphics server for the guest and configures its RDP-specific options.
        :param 'DomainDevicesGraphicSdlArgs' sdl: Enables and configures an SDL graphics backend for the guest display; when present, an SDL graphics device is attached to the domain.
        :param 'DomainDevicesGraphicSpiceArgs' spice: Enables and configures a SPICE graphics backend for the guest display; when present, a SPICE graphics device is attached to the domain.
        :param 'DomainDevicesGraphicVncArgs' vnc: Enables a VNC graphics device for the guest and groups all VNC-specific options such as port, listeners, keyboard mapping, and connection policy.
        """
        if audio is not None:
            pulumi.set(__self__, "audio", audio)
        if dbus is not None:
            pulumi.set(__self__, "dbus", dbus)
        if desktop is not None:
            pulumi.set(__self__, "desktop", desktop)
        if egl_headless is not None:
            pulumi.set(__self__, "egl_headless", egl_headless)
        if rdp is not None:
            pulumi.set(__self__, "rdp", rdp)
        if sdl is not None:
            pulumi.set(__self__, "sdl", sdl)
        if spice is not None:
            pulumi.set(__self__, "spice", spice)
        if vnc is not None:
            pulumi.set(__self__, "vnc", vnc)

    @_builtins.property
    @pulumi.getter
    def audio(self) -> Optional['outputs.DomainDevicesGraphicAudio']:
        """
        Configures an audio backend association for this graphics device, linking it to a specific <audio> definition by id.
        """
        return pulumi.get(self, "audio")

    @_builtins.property
    @pulumi.getter
    def dbus(self) -> Optional['outputs.DomainDevicesGraphicDbus']:
        """
        Enables a DBus-based display backend for the graphics device, allowing the display to be exported over DBus instead of a traditional VNC/SPICE socket.
        """
        return pulumi.get(self, "dbus")

    @_builtins.property
    @pulumi.getter
    def desktop(self) -> Optional['outputs.DomainDevicesGraphicDesktop']:
        """
        Configures desktop integration for the graphics device, such as exposing the guest window as a desktop surface on the host; the specific value is user-provided according to the chosen graphics type.
        """
        return pulumi.get(self, "desktop")

    @_builtins.property
    @pulumi.getter(name="eglHeadless")
    def egl_headless(self) -> Optional['outputs.DomainDevicesGraphicEglHeadless']:
        """
        Enables the egl-headless graphics backend, which provides a headless OpenGL-capable display surface without a visible window.
        """
        return pulumi.get(self, "egl_headless")

    @_builtins.property
    @pulumi.getter
    def rdp(self) -> Optional['outputs.DomainDevicesGraphicRdp']:
        """
        Enables an RDP graphics server for the guest and configures its RDP-specific options.
        """
        return pulumi.get(self, "rdp")

    @_builtins.property
    @pulumi.getter
    def sdl(self) -> Optional['outputs.DomainDevicesGraphicSdl']:
        """
        Enables and configures an SDL graphics backend for the guest display; when present, an SDL graphics device is attached to the domain.
        """
        return pulumi.get(self, "sdl")

    @_builtins.property
    @pulumi.getter
    def spice(self) -> Optional['outputs.DomainDevicesGraphicSpice']:
        """
        Enables and configures a SPICE graphics backend for the guest display; when present, a SPICE graphics device is attached to the domain.
        """
        return pulumi.get(self, "spice")

    @_builtins.property
    @pulumi.getter
    def vnc(self) -> Optional['outputs.DomainDevicesGraphicVnc']:
        """
        Enables a VNC graphics device for the guest and groups all VNC-specific options such as port, listeners, keyboard mapping, and connection policy.
        """
        return pulumi.get(self, "vnc")


@pulumi.output_type
class DomainDevicesGraphicAudio(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.float] = None):
        """
        :param _builtins.float id: Identifies which audio backend definition this graphics device should use; when omitted, libvirt may assign or infer an id automatically.
               
               See: <https://libvirt.org/formatdomain.html#audio-backends>
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.float]:
        """
        Identifies which audio backend definition this graphics device should use; when omitted, libvirt may assign or infer an id automatically.

        See: <https://libvirt.org/formatdomain.html#audio-backends>
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class DomainDevicesGraphicDbus(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 gl: Optional['outputs.DomainDevicesGraphicDbusGl'] = None,
                 p2p: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: Sets the DBus address (bus or endpoint string) that the graphics device uses for its DBus display connection; the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param 'DomainDevicesGraphicDbusGlArgs' gl: Configures OpenGL acceleration options for the DBus graphics backend, including whether GL is enabled and which render node to use.
        :param _builtins.str p2p: Controls whether peer-to-peer DBus connections are used for the graphics device; valid values are "yes" or "no".
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if gl is not None:
            pulumi.set(__self__, "gl", gl)
        if p2p is not None:
            pulumi.set(__self__, "p2p", p2p)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Sets the DBus address (bus or endpoint string) that the graphics device uses for its DBus display connection; the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def gl(self) -> Optional['outputs.DomainDevicesGraphicDbusGl']:
        """
        Configures OpenGL acceleration options for the DBus graphics backend, including whether GL is enabled and which render node to use.
        """
        return pulumi.get(self, "gl")

    @_builtins.property
    @pulumi.getter
    def p2p(self) -> Optional[_builtins.str]:
        """
        Controls whether peer-to-peer DBus connections are used for the graphics device; valid values are "yes" or "no".

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "p2p")


@pulumi.output_type
class DomainDevicesGraphicDbusGl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "renderNode":
            suggest = "render_node"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesGraphicDbusGl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesGraphicDbusGl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesGraphicDbusGl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable: Optional[_builtins.str] = None,
                 render_node: Optional[_builtins.str] = None):
        """
        :param _builtins.str enable: Controls whether OpenGL acceleration is enabled for the DBus graphics backend; valid values are "yes" or "no".
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param _builtins.str render_node: Sets the host render node device path used for GL rendering (for example, "/dev/dri/renderD128"); the value is user-provided and must refer to an existing render node.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if render_node is not None:
            pulumi.set(__self__, "render_node", render_node)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[_builtins.str]:
        """
        Controls whether OpenGL acceleration is enabled for the DBus graphics backend; valid values are "yes" or "no".

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter(name="renderNode")
    def render_node(self) -> Optional[_builtins.str]:
        """
        Sets the host render node device path used for GL rendering (for example, "/dev/dri/renderD128"); the value is user-provided and must refer to an existing render node.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "render_node")


@pulumi.output_type
class DomainDevicesGraphicDesktop(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fullScreen":
            suggest = "full_screen"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesGraphicDesktop. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesGraphicDesktop.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesGraphicDesktop.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display: Optional[_builtins.str] = None,
                 full_screen: Optional[_builtins.str] = None):
        """
        :param _builtins.str display: Sets the X11 display string for the SDL graphics desktop (for example, ":0.0") when using the SDL graphics backend; the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param _builtins.str full_screen: Controls whether the SDL desktop window starts in fullscreen mode; accepts "yes" or "no".
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        if display is not None:
            pulumi.set(__self__, "display", display)
        if full_screen is not None:
            pulumi.set(__self__, "full_screen", full_screen)

    @_builtins.property
    @pulumi.getter
    def display(self) -> Optional[_builtins.str]:
        """
        Sets the X11 display string for the SDL graphics desktop (for example, ":0.0") when using the SDL graphics backend; the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "display")

    @_builtins.property
    @pulumi.getter(name="fullScreen")
    def full_screen(self) -> Optional[_builtins.str]:
        """
        Controls whether the SDL desktop window starts in fullscreen mode; accepts "yes" or "no".

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "full_screen")


@pulumi.output_type
class DomainDevicesGraphicEglHeadless(dict):
    def __init__(__self__, *,
                 gl: Optional['outputs.DomainDevicesGraphicEglHeadlessGl'] = None):
        """
        :param 'DomainDevicesGraphicEglHeadlessGlArgs' gl: Configures OpenGL-related options for the egl-headless graphics backend.
        """
        if gl is not None:
            pulumi.set(__self__, "gl", gl)

    @_builtins.property
    @pulumi.getter
    def gl(self) -> Optional['outputs.DomainDevicesGraphicEglHeadlessGl']:
        """
        Configures OpenGL-related options for the egl-headless graphics backend.
        """
        return pulumi.get(self, "gl")


@pulumi.output_type
class DomainDevicesGraphicEglHeadlessGl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "renderNode":
            suggest = "render_node"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesGraphicEglHeadlessGl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesGraphicEglHeadlessGl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesGraphicEglHeadlessGl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 render_node: Optional[_builtins.str] = None):
        """
        :param _builtins.str render_node: Sets the DRM render node path to use for EGL/GL rendering with egl-headless (for example, "/dev/dri/renderD128"); the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        if render_node is not None:
            pulumi.set(__self__, "render_node", render_node)

    @_builtins.property
    @pulumi.getter(name="renderNode")
    def render_node(self) -> Optional[_builtins.str]:
        """
        Sets the DRM render node path to use for EGL/GL rendering with egl-headless (for example, "/dev/dri/renderD128"); the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "render_node")


@pulumi.output_type
class DomainDevicesGraphicRdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoPort":
            suggest = "auto_port"
        elif key == "multiUser":
            suggest = "multi_user"
        elif key == "replaceUser":
            suggest = "replace_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesGraphicRdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesGraphicRdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesGraphicRdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_port: Optional[_builtins.bool] = None,
                 listen: Optional[_builtins.str] = None,
                 listeners: Optional[Sequence['outputs.DomainDevicesGraphicRdpListener']] = None,
                 multi_user: Optional[_builtins.str] = None,
                 passwd: Optional[_builtins.str] = None,
                 port: Optional[_builtins.float] = None,
                 replace_user: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.bool auto_port: Controls whether the RDP server port is chosen automatically ("yes") or must be specified explicitly ("no"); this is a string-to-boolean flag.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param _builtins.str listen: Sets a single listen address or special value (such as "0.0.0.0") for the RDP server; value is user-provided and used when listener sub-elements are not used.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param Sequence['DomainDevicesGraphicRdpListenerArgs'] listeners: Defines one or more listener endpoints for the RDP server (by address, network, or UNIX socket), overriding the simple listen attribute when present.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param _builtins.str multi_user: Controls whether the RDP server allows multiple simultaneous clients ("yes") or restricts access to a single client ("no"); the value is user-provided as "yes"/"no".
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param _builtins.str passwd: Sets the password required to connect to the RDP server; the value is user-provided and may be empty to allow passwordless access, depending on hypervisor policy.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param _builtins.float port: Sets the TCP port number on which the RDP server listens (for example, 3389); must be a valid unused TCP port when auto_port is "no".
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param _builtins.str replace_user: Controls whether a new RDP client connection replaces the currently connected user ("yes") or is refused when a client is already connected ("no"); value is user-provided as "yes"/"no".
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param _builtins.str username: Sets the username used by the RDP graphics backend for client authentication; the value is user-provided and backend-specific.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        if auto_port is not None:
            pulumi.set(__self__, "auto_port", auto_port)
        if listen is not None:
            pulumi.set(__self__, "listen", listen)
        if listeners is not None:
            pulumi.set(__self__, "listeners", listeners)
        if multi_user is not None:
            pulumi.set(__self__, "multi_user", multi_user)
        if passwd is not None:
            pulumi.set(__self__, "passwd", passwd)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if replace_user is not None:
            pulumi.set(__self__, "replace_user", replace_user)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="autoPort")
    def auto_port(self) -> Optional[_builtins.bool]:
        """
        Controls whether the RDP server port is chosen automatically ("yes") or must be specified explicitly ("no"); this is a string-to-boolean flag.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "auto_port")

    @_builtins.property
    @pulumi.getter
    def listen(self) -> Optional[_builtins.str]:
        """
        Sets a single listen address or special value (such as "0.0.0.0") for the RDP server; value is user-provided and used when listener sub-elements are not used.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "listen")

    @_builtins.property
    @pulumi.getter
    def listeners(self) -> Optional[Sequence['outputs.DomainDevicesGraphicRdpListener']]:
        """
        Defines one or more listener endpoints for the RDP server (by address, network, or UNIX socket), overriding the simple listen attribute when present.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "listeners")

    @_builtins.property
    @pulumi.getter(name="multiUser")
    def multi_user(self) -> Optional[_builtins.str]:
        """
        Controls whether the RDP server allows multiple simultaneous clients ("yes") or restricts access to a single client ("no"); the value is user-provided as "yes"/"no".

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "multi_user")

    @_builtins.property
    @pulumi.getter
    def passwd(self) -> Optional[_builtins.str]:
        """
        Sets the password required to connect to the RDP server; the value is user-provided and may be empty to allow passwordless access, depending on hypervisor policy.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "passwd")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.float]:
        """
        Sets the TCP port number on which the RDP server listens (for example, 3389); must be a valid unused TCP port when auto_port is "no".

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="replaceUser")
    def replace_user(self) -> Optional[_builtins.str]:
        """
        Controls whether a new RDP client connection replaces the currently connected user ("yes") or is refused when a client is already connected ("no"); value is user-provided as "yes"/"no".

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "replace_user")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        Sets the username used by the RDP graphics backend for client authentication; the value is user-provided and backend-specific.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class DomainDevicesGraphicRdpListener(dict):
    def __init__(__self__, *,
                 address: Optional['outputs.DomainDevicesGraphicRdpListenerAddress'] = None,
                 network: Optional['outputs.DomainDevicesGraphicRdpListenerNetwork'] = None,
                 socket: Optional['outputs.DomainDevicesGraphicRdpListenerSocket'] = None):
        """
        :param 'DomainDevicesGraphicRdpListenerAddressArgs' address: Declares a SPICE listener that binds directly to a host IP address using the nested `address` attribute.
        :param 'DomainDevicesGraphicRdpListenerNetworkArgs' network: Declares a SPICE listener whose binding is determined by the specified libvirt virtual network and optional address.
        :param 'DomainDevicesGraphicRdpListenerSocketArgs' socket: Declares a SPICE listener that uses a UNIX domain socket instead of TCP/IP for client connections.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if socket is not None:
            pulumi.set(__self__, "socket", socket)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesGraphicRdpListenerAddress']:
        """
        Declares a SPICE listener that binds directly to a host IP address using the nested `address` attribute.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional['outputs.DomainDevicesGraphicRdpListenerNetwork']:
        """
        Declares a SPICE listener whose binding is determined by the specified libvirt virtual network and optional address.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def socket(self) -> Optional['outputs.DomainDevicesGraphicRdpListenerSocket']:
        """
        Declares a SPICE listener that uses a UNIX domain socket instead of TCP/IP for client connections.
        """
        return pulumi.get(self, "socket")


@pulumi.output_type
class DomainDevicesGraphicRdpListenerAddress(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: Sets the host IP address or hostname on which this SPICE listener should bind (for example `127.0.0.1` or `0.0.0.0`; value is user-provided).
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        if address is not None:
            pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Sets the host IP address or hostname on which this SPICE listener should bind (for example `127.0.0.1` or `0.0.0.0`; value is user-provided).

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class DomainDevicesGraphicRdpListenerNetwork(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 network: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: Optionally overrides the automatically chosen address for a network-based SPICE listener with a specific IP/hostname (user-provided value).
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param _builtins.str network: Names the libvirt virtual network that defines where this SPICE listener will be exposed (value must match an existing libvirt network name).
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if network is not None:
            pulumi.set(__self__, "network", network)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Optionally overrides the automatically chosen address for a network-based SPICE listener with a specific IP/hostname (user-provided value).

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        Names the libvirt virtual network that defines where this SPICE listener will be exposed (value must match an existing libvirt network name).

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class DomainDevicesGraphicRdpListenerSocket(dict):
    def __init__(__self__, *,
                 socket: Optional[_builtins.str] = None):
        """
        :param _builtins.str socket: Sets the filesystem path to the UNIX domain socket used by this SPICE listener (for example `/var/run/libvirt/qemu/spice.sock`; value is user-provided).
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        if socket is not None:
            pulumi.set(__self__, "socket", socket)

    @_builtins.property
    @pulumi.getter
    def socket(self) -> Optional[_builtins.str]:
        """
        Sets the filesystem path to the UNIX domain socket used by this SPICE listener (for example `/var/run/libvirt/qemu/spice.sock`; value is user-provided).

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "socket")


@pulumi.output_type
class DomainDevicesGraphicSdl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fullScreen":
            suggest = "full_screen"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesGraphicSdl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesGraphicSdl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesGraphicSdl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display: Optional[_builtins.str] = None,
                 full_screen: Optional[_builtins.str] = None,
                 gl: Optional['outputs.DomainDevicesGraphicSdlGl'] = None,
                 xauth: Optional[_builtins.str] = None):
        """
        :param _builtins.str display: Sets the SDL display identifier (for example, ":0.0") on which the SDL window is opened; the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param _builtins.str full_screen: Controls whether the SDL window starts in fullscreen mode; accepts "yes" or "no".
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param 'DomainDevicesGraphicSdlGlArgs' gl: Enables configuration of OpenGL support for the SDL graphics backend; when present, it toggles SDL OpenGL rendering options.
        :param _builtins.str xauth: Sets the X11 authorization file or token used by SDL to connect to the X server; the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        if display is not None:
            pulumi.set(__self__, "display", display)
        if full_screen is not None:
            pulumi.set(__self__, "full_screen", full_screen)
        if gl is not None:
            pulumi.set(__self__, "gl", gl)
        if xauth is not None:
            pulumi.set(__self__, "xauth", xauth)

    @_builtins.property
    @pulumi.getter
    def display(self) -> Optional[_builtins.str]:
        """
        Sets the SDL display identifier (for example, ":0.0") on which the SDL window is opened; the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "display")

    @_builtins.property
    @pulumi.getter(name="fullScreen")
    def full_screen(self) -> Optional[_builtins.str]:
        """
        Controls whether the SDL window starts in fullscreen mode; accepts "yes" or "no".

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "full_screen")

    @_builtins.property
    @pulumi.getter
    def gl(self) -> Optional['outputs.DomainDevicesGraphicSdlGl']:
        """
        Enables configuration of OpenGL support for the SDL graphics backend; when present, it toggles SDL OpenGL rendering options.
        """
        return pulumi.get(self, "gl")

    @_builtins.property
    @pulumi.getter
    def xauth(self) -> Optional[_builtins.str]:
        """
        Sets the X11 authorization file or token used by SDL to connect to the X server; the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "xauth")


@pulumi.output_type
class DomainDevicesGraphicSdlGl(dict):
    def __init__(__self__, *,
                 enable: Optional[_builtins.str] = None):
        """
        :param _builtins.str enable: Controls whether OpenGL rendering is enabled for the SDL graphics backend; accepts "yes" or "no".
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[_builtins.str]:
        """
        Controls whether OpenGL rendering is enabled for the SDL graphics backend; accepts "yes" or "no".

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "enable")


@pulumi.output_type
class DomainDevicesGraphicSpice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoPort":
            suggest = "auto_port"
        elif key == "clipBoard":
            suggest = "clip_board"
        elif key == "defaultMode":
            suggest = "default_mode"
        elif key == "fileTransfer":
            suggest = "file_transfer"
        elif key == "passwdValidTo":
            suggest = "passwd_valid_to"
        elif key == "tlsPort":
            suggest = "tls_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesGraphicSpice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesGraphicSpice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesGraphicSpice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_port: Optional[_builtins.bool] = None,
                 channels: Optional[Sequence['outputs.DomainDevicesGraphicSpiceChannel']] = None,
                 clip_board: Optional['outputs.DomainDevicesGraphicSpiceClipBoard'] = None,
                 connected: Optional[_builtins.str] = None,
                 default_mode: Optional[_builtins.str] = None,
                 file_transfer: Optional['outputs.DomainDevicesGraphicSpiceFileTransfer'] = None,
                 gl: Optional['outputs.DomainDevicesGraphicSpiceGl'] = None,
                 image: Optional['outputs.DomainDevicesGraphicSpiceImage'] = None,
                 jpeg: Optional['outputs.DomainDevicesGraphicSpiceJpeg'] = None,
                 keymap: Optional[_builtins.str] = None,
                 listen: Optional[_builtins.str] = None,
                 listeners: Optional[Sequence['outputs.DomainDevicesGraphicSpiceListener']] = None,
                 mouse: Optional['outputs.DomainDevicesGraphicSpiceMouse'] = None,
                 passwd: Optional[_builtins.str] = None,
                 passwd_valid_to: Optional[_builtins.str] = None,
                 playback: Optional['outputs.DomainDevicesGraphicSpicePlayback'] = None,
                 port: Optional[_builtins.float] = None,
                 streaming: Optional['outputs.DomainDevicesGraphicSpiceStreaming'] = None,
                 tls_port: Optional[_builtins.float] = None,
                 zlib: Optional['outputs.DomainDevicesGraphicSpiceZlib'] = None):
        """
        :param _builtins.bool auto_port: Controls whether libvirt automatically selects the SPICE TCP port; this is a yes/no flag encoded as "yes" for true and "no" for false.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param Sequence['DomainDevicesGraphicSpiceChannelArgs'] channels: Defines an individual SPICE channel (such as "main" or "cursor") and its connection mode.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param 'DomainDevicesGraphicSpiceClipBoardArgs' clip_board: Enables configuration of clipboard sharing behavior between the SPICE client and the guest.
        :param _builtins.str connected: Sets whether clients are allowed to connect at VM startup ("yes") or only later ("no"); accepts "yes" or "no".
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param _builtins.str default_mode: Specifies the default connection mode for SPICE (for example, "any", "secure", or "insecure"); the value is user-provided but must be a mode supported by SPICE.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param 'DomainDevicesGraphicSpiceFileTransferArgs' file_transfer: Enables configuration of file transfer support between the SPICE client and the guest.
        :param 'DomainDevicesGraphicSpiceGlArgs' gl: Enables configuration of OpenGL/3D rendering for the SPICE graphics backend.
        :param 'DomainDevicesGraphicSpiceImageArgs' image: Enables configuration of SPICE image encoding options; presence of this block allows tuning of how screen images are compressed before being sent to the client.
        :param 'DomainDevicesGraphicSpiceJpegArgs' jpeg: Enables configuration of SPICE JPEG encoding behavior; presence of this block allows controlling whether and how JPEG compression is used for images.
        :param _builtins.str keymap: Sets the keyboard layout name SPICE reports to the guest, such as `en-us` or `de`, to control key mapping behavior (value is user-provided).
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param _builtins.str listen: Sets a legacy listen address for the SPICE server; use of this attribute is generally superseded by the more detailed `listeners` configuration (value is user-provided IP/host or `0.0.0.0`).
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param Sequence['DomainDevicesGraphicSpiceListenerArgs'] listeners: Configures one or more SPICE listen endpoints (TCP address, libvirt network, or UNIX socket) through nested listener blocks.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param 'DomainDevicesGraphicSpiceMouseArgs' mouse: Enables configuration of SPICE mouse handling behavior; presence of this block allows setting the mouse mode.
        :param _builtins.str passwd: Sets a simple password string required for SPICE client connections to this guest (value is user-provided and should follow your security policies).
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param _builtins.str passwd_valid_to: Sets an expiration timestamp for the SPICE password, using a libvirt-supported date/time format (for example `2010-04-19T12:00:00`).
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param 'DomainDevicesGraphicSpicePlaybackArgs' playback: Enables configuration of SPICE audio playback behavior; presence of this block allows controlling whether audio output to the client is enabled or tuned.
        :param _builtins.float port: Sets the TCP port on which the SPICE server listens for unencrypted connections; value is a user-provided integer in the valid TCP port range.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param 'DomainDevicesGraphicSpiceStreamingArgs' streaming: Enables SPICE streaming configuration, allowing control of how guest display frames are streamed to the client.
        :param _builtins.float tls_port: Sets the TCP port on which the SPICE server listens for TLS-encrypted connections; value is a user-provided integer in the valid TCP port range.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param 'DomainDevicesGraphicSpiceZlibArgs' zlib: Enables separate configuration of SPICE image compression using zlib for the display channel.
        """
        if auto_port is not None:
            pulumi.set(__self__, "auto_port", auto_port)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if clip_board is not None:
            pulumi.set(__self__, "clip_board", clip_board)
        if connected is not None:
            pulumi.set(__self__, "connected", connected)
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if file_transfer is not None:
            pulumi.set(__self__, "file_transfer", file_transfer)
        if gl is not None:
            pulumi.set(__self__, "gl", gl)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if jpeg is not None:
            pulumi.set(__self__, "jpeg", jpeg)
        if keymap is not None:
            pulumi.set(__self__, "keymap", keymap)
        if listen is not None:
            pulumi.set(__self__, "listen", listen)
        if listeners is not None:
            pulumi.set(__self__, "listeners", listeners)
        if mouse is not None:
            pulumi.set(__self__, "mouse", mouse)
        if passwd is not None:
            pulumi.set(__self__, "passwd", passwd)
        if passwd_valid_to is not None:
            pulumi.set(__self__, "passwd_valid_to", passwd_valid_to)
        if playback is not None:
            pulumi.set(__self__, "playback", playback)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if streaming is not None:
            pulumi.set(__self__, "streaming", streaming)
        if tls_port is not None:
            pulumi.set(__self__, "tls_port", tls_port)
        if zlib is not None:
            pulumi.set(__self__, "zlib", zlib)

    @_builtins.property
    @pulumi.getter(name="autoPort")
    def auto_port(self) -> Optional[_builtins.bool]:
        """
        Controls whether libvirt automatically selects the SPICE TCP port; this is a yes/no flag encoded as "yes" for true and "no" for false.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "auto_port")

    @_builtins.property
    @pulumi.getter
    def channels(self) -> Optional[Sequence['outputs.DomainDevicesGraphicSpiceChannel']]:
        """
        Defines an individual SPICE channel (such as "main" or "cursor") and its connection mode.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "channels")

    @_builtins.property
    @pulumi.getter(name="clipBoard")
    def clip_board(self) -> Optional['outputs.DomainDevicesGraphicSpiceClipBoard']:
        """
        Enables configuration of clipboard sharing behavior between the SPICE client and the guest.
        """
        return pulumi.get(self, "clip_board")

    @_builtins.property
    @pulumi.getter
    def connected(self) -> Optional[_builtins.str]:
        """
        Sets whether clients are allowed to connect at VM startup ("yes") or only later ("no"); accepts "yes" or "no".

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "connected")

    @_builtins.property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[_builtins.str]:
        """
        Specifies the default connection mode for SPICE (for example, "any", "secure", or "insecure"); the value is user-provided but must be a mode supported by SPICE.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "default_mode")

    @_builtins.property
    @pulumi.getter(name="fileTransfer")
    def file_transfer(self) -> Optional['outputs.DomainDevicesGraphicSpiceFileTransfer']:
        """
        Enables configuration of file transfer support between the SPICE client and the guest.
        """
        return pulumi.get(self, "file_transfer")

    @_builtins.property
    @pulumi.getter
    def gl(self) -> Optional['outputs.DomainDevicesGraphicSpiceGl']:
        """
        Enables configuration of OpenGL/3D rendering for the SPICE graphics backend.
        """
        return pulumi.get(self, "gl")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional['outputs.DomainDevicesGraphicSpiceImage']:
        """
        Enables configuration of SPICE image encoding options; presence of this block allows tuning of how screen images are compressed before being sent to the client.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def jpeg(self) -> Optional['outputs.DomainDevicesGraphicSpiceJpeg']:
        """
        Enables configuration of SPICE JPEG encoding behavior; presence of this block allows controlling whether and how JPEG compression is used for images.
        """
        return pulumi.get(self, "jpeg")

    @_builtins.property
    @pulumi.getter
    def keymap(self) -> Optional[_builtins.str]:
        """
        Sets the keyboard layout name SPICE reports to the guest, such as `en-us` or `de`, to control key mapping behavior (value is user-provided).

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "keymap")

    @_builtins.property
    @pulumi.getter
    def listen(self) -> Optional[_builtins.str]:
        """
        Sets a legacy listen address for the SPICE server; use of this attribute is generally superseded by the more detailed `listeners` configuration (value is user-provided IP/host or `0.0.0.0`).

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "listen")

    @_builtins.property
    @pulumi.getter
    def listeners(self) -> Optional[Sequence['outputs.DomainDevicesGraphicSpiceListener']]:
        """
        Configures one or more SPICE listen endpoints (TCP address, libvirt network, or UNIX socket) through nested listener blocks.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "listeners")

    @_builtins.property
    @pulumi.getter
    def mouse(self) -> Optional['outputs.DomainDevicesGraphicSpiceMouse']:
        """
        Enables configuration of SPICE mouse handling behavior; presence of this block allows setting the mouse mode.
        """
        return pulumi.get(self, "mouse")

    @_builtins.property
    @pulumi.getter
    def passwd(self) -> Optional[_builtins.str]:
        """
        Sets a simple password string required for SPICE client connections to this guest (value is user-provided and should follow your security policies).

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "passwd")

    @_builtins.property
    @pulumi.getter(name="passwdValidTo")
    def passwd_valid_to(self) -> Optional[_builtins.str]:
        """
        Sets an expiration timestamp for the SPICE password, using a libvirt-supported date/time format (for example `2010-04-19T12:00:00`).

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "passwd_valid_to")

    @_builtins.property
    @pulumi.getter
    def playback(self) -> Optional['outputs.DomainDevicesGraphicSpicePlayback']:
        """
        Enables configuration of SPICE audio playback behavior; presence of this block allows controlling whether audio output to the client is enabled or tuned.
        """
        return pulumi.get(self, "playback")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.float]:
        """
        Sets the TCP port on which the SPICE server listens for unencrypted connections; value is a user-provided integer in the valid TCP port range.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def streaming(self) -> Optional['outputs.DomainDevicesGraphicSpiceStreaming']:
        """
        Enables SPICE streaming configuration, allowing control of how guest display frames are streamed to the client.
        """
        return pulumi.get(self, "streaming")

    @_builtins.property
    @pulumi.getter(name="tlsPort")
    def tls_port(self) -> Optional[_builtins.float]:
        """
        Sets the TCP port on which the SPICE server listens for TLS-encrypted connections; value is a user-provided integer in the valid TCP port range.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "tls_port")

    @_builtins.property
    @pulumi.getter
    def zlib(self) -> Optional['outputs.DomainDevicesGraphicSpiceZlib']:
        """
        Enables separate configuration of SPICE image compression using zlib for the display channel.
        """
        return pulumi.get(self, "zlib")


@pulumi.output_type
class DomainDevicesGraphicSpiceChannel(dict):
    def __init__(__self__, *,
                 mode: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str mode: Sets how the SPICE channel connects, typically "secure" or "insecure" depending on the desired transport; the value is required and user-provided.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param _builtins.str name: Names the SPICE channel to configure (for example, "main", "cursor", "display", "record", "playback"); this value is required and must match a supported SPICE channel name.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets how the SPICE channel connects, typically "secure" or "insecure" depending on the desired transport; the value is required and user-provided.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Names the SPICE channel to configure (for example, "main", "cursor", "display", "record", "playback"); this value is required and must match a supported SPICE channel name.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesGraphicSpiceClipBoard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyPaste":
            suggest = "copy_paste"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesGraphicSpiceClipBoard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesGraphicSpiceClipBoard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesGraphicSpiceClipBoard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_paste: _builtins.str):
        """
        :param _builtins.str copy_paste: Controls whether clipboard copy/paste is allowed over SPICE; accepts "yes" or "no".
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        pulumi.set(__self__, "copy_paste", copy_paste)

    @_builtins.property
    @pulumi.getter(name="copyPaste")
    def copy_paste(self) -> _builtins.str:
        """
        Controls whether clipboard copy/paste is allowed over SPICE; accepts "yes" or "no".

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "copy_paste")


@pulumi.output_type
class DomainDevicesGraphicSpiceFileTransfer(dict):
    def __init__(__self__, *,
                 enable: _builtins.str):
        """
        :param _builtins.str enable: Controls whether SPICE client file transfer into the guest is enabled; accepts "yes" or "no".
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> _builtins.str:
        """
        Controls whether SPICE client file transfer into the guest is enabled; accepts "yes" or "no".

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "enable")


@pulumi.output_type
class DomainDevicesGraphicSpiceGl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "renderNode":
            suggest = "render_node"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesGraphicSpiceGl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesGraphicSpiceGl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesGraphicSpiceGl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable: Optional[_builtins.str] = None,
                 render_node: Optional[_builtins.str] = None):
        """
        :param _builtins.str enable: Controls whether OpenGL/3D rendering is enabled for SPICE (for example, via virgl); accepts "yes" or "no".
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param _builtins.str render_node: Sets the host render node device path that SPICE should use for OpenGL rendering when GL is enabled (user-provided path such as `/dev/dri/renderD128`).
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if render_node is not None:
            pulumi.set(__self__, "render_node", render_node)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[_builtins.str]:
        """
        Controls whether OpenGL/3D rendering is enabled for SPICE (for example, via virgl); accepts "yes" or "no".

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter(name="renderNode")
    def render_node(self) -> Optional[_builtins.str]:
        """
        Sets the host render node device path that SPICE should use for OpenGL rendering when GL is enabled (user-provided path such as `/dev/dri/renderD128`).

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "render_node")


@pulumi.output_type
class DomainDevicesGraphicSpiceImage(dict):
    def __init__(__self__, *,
                 compression: _builtins.str):
        """
        :param _builtins.str compression: Sets the SPICE image compression policy; valid values include `auto_glz`, `auto_lz`, `quic`, `glz`, `lz`, `off`, and `always`.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        pulumi.set(__self__, "compression", compression)

    @_builtins.property
    @pulumi.getter
    def compression(self) -> _builtins.str:
        """
        Sets the SPICE image compression policy; valid values include `auto_glz`, `auto_lz`, `quic`, `glz`, `lz`, `off`, and `always`.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "compression")


@pulumi.output_type
class DomainDevicesGraphicSpiceJpeg(dict):
    def __init__(__self__, *,
                 compression: _builtins.str):
        """
        :param _builtins.str compression: Sets the SPICE JPEG compression policy, typically one of `auto`, `never`, or `always`, controlling when JPEG is used for image encoding.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        pulumi.set(__self__, "compression", compression)

    @_builtins.property
    @pulumi.getter
    def compression(self) -> _builtins.str:
        """
        Sets the SPICE JPEG compression policy, typically one of `auto`, `never`, or `always`, controlling when JPEG is used for image encoding.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "compression")


@pulumi.output_type
class DomainDevicesGraphicSpiceListener(dict):
    def __init__(__self__, *,
                 address: Optional['outputs.DomainDevicesGraphicSpiceListenerAddress'] = None,
                 network: Optional['outputs.DomainDevicesGraphicSpiceListenerNetwork'] = None,
                 socket: Optional['outputs.DomainDevicesGraphicSpiceListenerSocket'] = None):
        """
        :param 'DomainDevicesGraphicSpiceListenerAddressArgs' address: Declares a SPICE listener that binds directly to a host IP address using the nested `address` attribute.
        :param 'DomainDevicesGraphicSpiceListenerNetworkArgs' network: Declares a SPICE listener whose binding is determined by the specified libvirt virtual network and optional address.
        :param 'DomainDevicesGraphicSpiceListenerSocketArgs' socket: Declares a SPICE listener that uses a UNIX domain socket instead of TCP/IP for client connections.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if socket is not None:
            pulumi.set(__self__, "socket", socket)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesGraphicSpiceListenerAddress']:
        """
        Declares a SPICE listener that binds directly to a host IP address using the nested `address` attribute.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional['outputs.DomainDevicesGraphicSpiceListenerNetwork']:
        """
        Declares a SPICE listener whose binding is determined by the specified libvirt virtual network and optional address.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def socket(self) -> Optional['outputs.DomainDevicesGraphicSpiceListenerSocket']:
        """
        Declares a SPICE listener that uses a UNIX domain socket instead of TCP/IP for client connections.
        """
        return pulumi.get(self, "socket")


@pulumi.output_type
class DomainDevicesGraphicSpiceListenerAddress(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: Sets the host IP address or hostname on which this SPICE listener should bind (for example `127.0.0.1` or `0.0.0.0`; value is user-provided).
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        if address is not None:
            pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Sets the host IP address or hostname on which this SPICE listener should bind (for example `127.0.0.1` or `0.0.0.0`; value is user-provided).

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class DomainDevicesGraphicSpiceListenerNetwork(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 network: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: Optionally overrides the automatically chosen address for a network-based SPICE listener with a specific IP/hostname (user-provided value).
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param _builtins.str network: Names the libvirt virtual network that defines where this SPICE listener will be exposed (value must match an existing libvirt network name).
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if network is not None:
            pulumi.set(__self__, "network", network)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Optionally overrides the automatically chosen address for a network-based SPICE listener with a specific IP/hostname (user-provided value).

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        Names the libvirt virtual network that defines where this SPICE listener will be exposed (value must match an existing libvirt network name).

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class DomainDevicesGraphicSpiceListenerSocket(dict):
    def __init__(__self__, *,
                 socket: Optional[_builtins.str] = None):
        """
        :param _builtins.str socket: Sets the filesystem path to the UNIX domain socket used by this SPICE listener (for example `/var/run/libvirt/qemu/spice.sock`; value is user-provided).
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        if socket is not None:
            pulumi.set(__self__, "socket", socket)

    @_builtins.property
    @pulumi.getter
    def socket(self) -> Optional[_builtins.str]:
        """
        Sets the filesystem path to the UNIX domain socket used by this SPICE listener (for example `/var/run/libvirt/qemu/spice.sock`; value is user-provided).

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "socket")


@pulumi.output_type
class DomainDevicesGraphicSpiceMouse(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: Sets the SPICE mouse mode, typically `server` (relative pointer) or `client` (absolute pointer integration), controlling how mouse input is interpreted.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets the SPICE mouse mode, typically `server` (relative pointer) or `client` (absolute pointer integration), controlling how mouse input is interpreted.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DomainDevicesGraphicSpicePlayback(dict):
    def __init__(__self__, *,
                 compression: _builtins.str):
        """
        :param _builtins.str compression: Sets the audio compression mode for SPICE playback; valid values are those supported by libvirt/QEMU (for example "on", "off", or codec-specific modes), and a value is required when the playback element is present.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        pulumi.set(__self__, "compression", compression)

    @_builtins.property
    @pulumi.getter
    def compression(self) -> _builtins.str:
        """
        Sets the audio compression mode for SPICE playback; valid values are those supported by libvirt/QEMU (for example "on", "off", or codec-specific modes), and a value is required when the playback element is present.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "compression")


@pulumi.output_type
class DomainDevicesGraphicSpiceStreaming(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: Sets the SPICE display streaming mode (for example "filter", "all", or "off", depending on hypervisor support); a mode value is required when streaming is configured.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets the SPICE display streaming mode (for example "filter", "all", or "off", depending on hypervisor support); a mode value is required when streaming is configured.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DomainDevicesGraphicSpiceZlib(dict):
    def __init__(__self__, *,
                 compression: _builtins.str):
        """
        :param _builtins.str compression: Sets the zlib compression policy for SPICE image data (for example "always", "never", or "auto", depending on hypervisor support); a value is required when the zlib element is present.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        pulumi.set(__self__, "compression", compression)

    @_builtins.property
    @pulumi.getter
    def compression(self) -> _builtins.str:
        """
        Sets the zlib compression policy for SPICE image data (for example "always", "never", or "auto", depending on hypervisor support); a value is required when the zlib element is present.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "compression")


@pulumi.output_type
class DomainDevicesGraphicVnc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoPort":
            suggest = "auto_port"
        elif key == "passwdValidTo":
            suggest = "passwd_valid_to"
        elif key == "powerControl":
            suggest = "power_control"
        elif key == "sharePolicy":
            suggest = "share_policy"
        elif key == "webSocket":
            suggest = "web_socket"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesGraphicVnc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesGraphicVnc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesGraphicVnc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_port: Optional[_builtins.bool] = None,
                 connected: Optional[_builtins.str] = None,
                 keymap: Optional[_builtins.str] = None,
                 listen: Optional[_builtins.str] = None,
                 listeners: Optional[Sequence['outputs.DomainDevicesGraphicVncListener']] = None,
                 passwd: Optional[_builtins.str] = None,
                 passwd_valid_to: Optional[_builtins.str] = None,
                 port: Optional[_builtins.float] = None,
                 power_control: Optional[_builtins.str] = None,
                 share_policy: Optional[_builtins.str] = None,
                 socket: Optional[_builtins.str] = None,
                 web_socket: Optional[_builtins.float] = None):
        """
        :param _builtins.bool auto_port: Controls whether the VNC server automatically chooses a TCP port; this is a string-valued boolean where "yes" enables automatic port selection and "no" disables it.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param _builtins.str connected: Sets the initial connection policy for VNC (for example "keep", "fail", or "disconnect" as supported by libvirt) indicating how the guest should behave when a client is or is not connected.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param _builtins.str keymap: Sets the keymap layout used for keyboard input over VNC; value is a user-provided keymap name such as "en-us" or "de".
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param _builtins.str listen: Configures how the VNC server listens for client connections, either as a simple address attribute or via child listener elements.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param Sequence['DomainDevicesGraphicVncListenerArgs'] listeners: Provides one or more explicit VNC listen endpoints (address, network, or Unix socket) instead of a single listen address attribute.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param _builtins.str passwd: Sets the VNC password required for clients to connect to this graphics device; the value is user-provided and should follow any security policies you enforce for secrets. Example: "S3cr3tP@ss".
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param _builtins.str passwd_valid_to: Sets an absolute expiry time for the VNC password, after which the password is no longer valid; the format is a user-provided timestamp string as expected by libvirt/qemu.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param _builtins.float port: Sets the TCP port on which the VNC server listens; use -1 or omit to let libvirt automatically choose an available port, or specify an integer port such as 5900.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param _builtins.str power_control: Enables or disables guest power control over the VNC session; accepts "yes" or "no".
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param _builtins.str share_policy: Controls how VNC connections are shared between clients; valid values are "allow-exclusive", "force-shared", or "ignore".
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param _builtins.str socket: Sets the path to a UNIX domain socket to use instead of a TCP port for the VNC server; the value is a user-provided filesystem path (for example, "/var/run/libvirt/qemu-vnc.sock").
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param _builtins.float web_socket: Sets the TCP port for the VNC WebSocket proxy, allowing browser-based VNC clients to connect; use -1 or omit to auto-assign, or specify an integer port.
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        if auto_port is not None:
            pulumi.set(__self__, "auto_port", auto_port)
        if connected is not None:
            pulumi.set(__self__, "connected", connected)
        if keymap is not None:
            pulumi.set(__self__, "keymap", keymap)
        if listen is not None:
            pulumi.set(__self__, "listen", listen)
        if listeners is not None:
            pulumi.set(__self__, "listeners", listeners)
        if passwd is not None:
            pulumi.set(__self__, "passwd", passwd)
        if passwd_valid_to is not None:
            pulumi.set(__self__, "passwd_valid_to", passwd_valid_to)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if power_control is not None:
            pulumi.set(__self__, "power_control", power_control)
        if share_policy is not None:
            pulumi.set(__self__, "share_policy", share_policy)
        if socket is not None:
            pulumi.set(__self__, "socket", socket)
        if web_socket is not None:
            pulumi.set(__self__, "web_socket", web_socket)

    @_builtins.property
    @pulumi.getter(name="autoPort")
    def auto_port(self) -> Optional[_builtins.bool]:
        """
        Controls whether the VNC server automatically chooses a TCP port; this is a string-valued boolean where "yes" enables automatic port selection and "no" disables it.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "auto_port")

    @_builtins.property
    @pulumi.getter
    def connected(self) -> Optional[_builtins.str]:
        """
        Sets the initial connection policy for VNC (for example "keep", "fail", or "disconnect" as supported by libvirt) indicating how the guest should behave when a client is or is not connected.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "connected")

    @_builtins.property
    @pulumi.getter
    def keymap(self) -> Optional[_builtins.str]:
        """
        Sets the keymap layout used for keyboard input over VNC; value is a user-provided keymap name such as "en-us" or "de".

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "keymap")

    @_builtins.property
    @pulumi.getter
    def listen(self) -> Optional[_builtins.str]:
        """
        Configures how the VNC server listens for client connections, either as a simple address attribute or via child listener elements.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "listen")

    @_builtins.property
    @pulumi.getter
    def listeners(self) -> Optional[Sequence['outputs.DomainDevicesGraphicVncListener']]:
        """
        Provides one or more explicit VNC listen endpoints (address, network, or Unix socket) instead of a single listen address attribute.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "listeners")

    @_builtins.property
    @pulumi.getter
    def passwd(self) -> Optional[_builtins.str]:
        """
        Sets the VNC password required for clients to connect to this graphics device; the value is user-provided and should follow any security policies you enforce for secrets. Example: "S3cr3tP@ss".

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "passwd")

    @_builtins.property
    @pulumi.getter(name="passwdValidTo")
    def passwd_valid_to(self) -> Optional[_builtins.str]:
        """
        Sets an absolute expiry time for the VNC password, after which the password is no longer valid; the format is a user-provided timestamp string as expected by libvirt/qemu.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "passwd_valid_to")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.float]:
        """
        Sets the TCP port on which the VNC server listens; use -1 or omit to let libvirt automatically choose an available port, or specify an integer port such as 5900.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="powerControl")
    def power_control(self) -> Optional[_builtins.str]:
        """
        Enables or disables guest power control over the VNC session; accepts "yes" or "no".

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "power_control")

    @_builtins.property
    @pulumi.getter(name="sharePolicy")
    def share_policy(self) -> Optional[_builtins.str]:
        """
        Controls how VNC connections are shared between clients; valid values are "allow-exclusive", "force-shared", or "ignore".

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "share_policy")

    @_builtins.property
    @pulumi.getter
    def socket(self) -> Optional[_builtins.str]:
        """
        Sets the path to a UNIX domain socket to use instead of a TCP port for the VNC server; the value is a user-provided filesystem path (for example, "/var/run/libvirt/qemu-vnc.sock").

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "socket")

    @_builtins.property
    @pulumi.getter(name="webSocket")
    def web_socket(self) -> Optional[_builtins.float]:
        """
        Sets the TCP port for the VNC WebSocket proxy, allowing browser-based VNC clients to connect; use -1 or omit to auto-assign, or specify an integer port.

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "web_socket")


@pulumi.output_type
class DomainDevicesGraphicVncListener(dict):
    def __init__(__self__, *,
                 address: Optional['outputs.DomainDevicesGraphicVncListenerAddress'] = None,
                 network: Optional['outputs.DomainDevicesGraphicVncListenerNetwork'] = None,
                 socket: Optional['outputs.DomainDevicesGraphicVncListenerSocket'] = None):
        """
        :param 'DomainDevicesGraphicVncListenerAddressArgs' address: Declares a SPICE listener that binds directly to a host IP address using the nested `address` attribute.
        :param 'DomainDevicesGraphicVncListenerNetworkArgs' network: Declares a SPICE listener whose binding is determined by the specified libvirt virtual network and optional address.
        :param 'DomainDevicesGraphicVncListenerSocketArgs' socket: Declares a SPICE listener that uses a UNIX domain socket instead of TCP/IP for client connections.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if socket is not None:
            pulumi.set(__self__, "socket", socket)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesGraphicVncListenerAddress']:
        """
        Declares a SPICE listener that binds directly to a host IP address using the nested `address` attribute.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional['outputs.DomainDevicesGraphicVncListenerNetwork']:
        """
        Declares a SPICE listener whose binding is determined by the specified libvirt virtual network and optional address.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def socket(self) -> Optional['outputs.DomainDevicesGraphicVncListenerSocket']:
        """
        Declares a SPICE listener that uses a UNIX domain socket instead of TCP/IP for client connections.
        """
        return pulumi.get(self, "socket")


@pulumi.output_type
class DomainDevicesGraphicVncListenerAddress(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: Sets the host IP address or hostname on which this SPICE listener should bind (for example `127.0.0.1` or `0.0.0.0`; value is user-provided).
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        if address is not None:
            pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Sets the host IP address or hostname on which this SPICE listener should bind (for example `127.0.0.1` or `0.0.0.0`; value is user-provided).

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class DomainDevicesGraphicVncListenerNetwork(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 network: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: Optionally overrides the automatically chosen address for a network-based SPICE listener with a specific IP/hostname (user-provided value).
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        :param _builtins.str network: Names the libvirt virtual network that defines where this SPICE listener will be exposed (value must match an existing libvirt network name).
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if network is not None:
            pulumi.set(__self__, "network", network)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Optionally overrides the automatically chosen address for a network-based SPICE listener with a specific IP/hostname (user-provided value).

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        Names the libvirt virtual network that defines where this SPICE listener will be exposed (value must match an existing libvirt network name).

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class DomainDevicesGraphicVncListenerSocket(dict):
    def __init__(__self__, *,
                 socket: Optional[_builtins.str] = None):
        """
        :param _builtins.str socket: Sets the filesystem path to the UNIX domain socket used by this SPICE listener (for example `/var/run/libvirt/qemu/spice.sock`; value is user-provided).
               
               See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        if socket is not None:
            pulumi.set(__self__, "socket", socket)

    @_builtins.property
    @pulumi.getter
    def socket(self) -> Optional[_builtins.str]:
        """
        Sets the filesystem path to the UNIX domain socket used by this SPICE listener (for example `/var/run/libvirt/qemu/spice.sock`; value is user-provided).

        See: <https://libvirt.org/formatdomain.html#graphical-framebuffers>
        """
        return pulumi.get(self, "socket")


@pulumi.output_type
class DomainDevicesHostdev(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capsMisc":
            suggest = "caps_misc"
        elif key == "capsNet":
            suggest = "caps_net"
        elif key == "capsStorage":
            suggest = "caps_storage"
        elif key == "subsysMDev":
            suggest = "subsys_m_dev"
        elif key == "subsysPci":
            suggest = "subsys_pci"
        elif key == "subsysScsi":
            suggest = "subsys_scsi"
        elif key == "subsysScsiHost":
            suggest = "subsys_scsi_host"
        elif key == "subsysUsb":
            suggest = "subsys_usb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesHostdev. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesHostdev.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesHostdev.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acpi: Optional['outputs.DomainDevicesHostdevAcpi'] = None,
                 address: Optional['outputs.DomainDevicesHostdevAddress'] = None,
                 alias: Optional['outputs.DomainDevicesHostdevAlias'] = None,
                 boot: Optional['outputs.DomainDevicesHostdevBoot'] = None,
                 caps_misc: Optional['outputs.DomainDevicesHostdevCapsMisc'] = None,
                 caps_net: Optional['outputs.DomainDevicesHostdevCapsNet'] = None,
                 caps_storage: Optional['outputs.DomainDevicesHostdevCapsStorage'] = None,
                 managed: Optional[_builtins.bool] = None,
                 rom: Optional['outputs.DomainDevicesHostdevRom'] = None,
                 subsys_m_dev: Optional['outputs.DomainDevicesHostdevSubsysMDev'] = None,
                 subsys_pci: Optional['outputs.DomainDevicesHostdevSubsysPci'] = None,
                 subsys_scsi: Optional['outputs.DomainDevicesHostdevSubsysScsi'] = None,
                 subsys_scsi_host: Optional['outputs.DomainDevicesHostdevSubsysScsiHost'] = None,
                 subsys_usb: Optional['outputs.DomainDevicesHostdevSubsysUsb'] = None):
        """
        :param 'DomainDevicesHostdevAcpiArgs' acpi: Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        :param 'DomainDevicesHostdevAddressArgs' address: Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        :param 'DomainDevicesHostdevAliasArgs' alias: Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        :param 'DomainDevicesHostdevBootArgs' boot: Enables boot-order control for this redirected device, allowing it to participate in the device boot sequence.
        :param 'DomainDevicesHostdevCapsMiscArgs' caps_misc: Enables miscellaneous capability-specific configuration for the host device, used for device types that expose extra capabilities not covered by other elements.
        :param 'DomainDevicesHostdevCapsNetArgs' caps_net: Enables network-related capability configuration for the host device, typically for host NICs or VF-based network passthrough with extra capabilities.
        :param 'DomainDevicesHostdevCapsStorageArgs' caps_storage: Configures storage-related capabilities for a passthrough host device, such as its backing block source.
        :param _builtins.bool managed: Controls whether libvirt manages detaching and reattaching the host device driver, as a string boolean where "yes" enables management and "no" disables it.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param 'DomainDevicesHostdevRomArgs' rom: Configures an optional PCI ROM image for the passthrough host device, including whether it is enabled, where it is mapped, and an alternate ROM file.
        :param 'DomainDevicesHostdevSubsysMDevArgs' subsys_m_dev: Configures mediated device (mdev)specific settings for a passthrough host device, such as display handling for a vGPU.
        :param 'DomainDevicesHostdevSubsysPciArgs' subsys_pci: Selects PCI as the host device subsystem type and groups all PCI-specific passthrough settings for this hostdev.
        :param 'DomainDevicesHostdevSubsysScsiArgs' subsys_scsi: Configures a host SCSI device (or LUN) to be passed through to the guest using a SCSI hostdev subsystem.
        :param 'DomainDevicesHostdevSubsysScsiHostArgs' subsys_scsi_host: Configures a SCSI host adapterstyle host device passthrough (SubsysSCSIHost) to the guest, rather than an individual LUN.
        :param 'DomainDevicesHostdevSubsysUsbArgs' subsys_usb: Configures a host USB device passthrough entry for the guest, corresponding to a `<hostdev>` with USB subsystem-specific settings.
        """
        if acpi is not None:
            pulumi.set(__self__, "acpi", acpi)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if boot is not None:
            pulumi.set(__self__, "boot", boot)
        if caps_misc is not None:
            pulumi.set(__self__, "caps_misc", caps_misc)
        if caps_net is not None:
            pulumi.set(__self__, "caps_net", caps_net)
        if caps_storage is not None:
            pulumi.set(__self__, "caps_storage", caps_storage)
        if managed is not None:
            pulumi.set(__self__, "managed", managed)
        if rom is not None:
            pulumi.set(__self__, "rom", rom)
        if subsys_m_dev is not None:
            pulumi.set(__self__, "subsys_m_dev", subsys_m_dev)
        if subsys_pci is not None:
            pulumi.set(__self__, "subsys_pci", subsys_pci)
        if subsys_scsi is not None:
            pulumi.set(__self__, "subsys_scsi", subsys_scsi)
        if subsys_scsi_host is not None:
            pulumi.set(__self__, "subsys_scsi_host", subsys_scsi_host)
        if subsys_usb is not None:
            pulumi.set(__self__, "subsys_usb", subsys_usb)

    @_builtins.property
    @pulumi.getter
    def acpi(self) -> Optional['outputs.DomainDevicesHostdevAcpi']:
        """
        Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        """
        return pulumi.get(self, "acpi")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesHostdevAddress']:
        """
        Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional['outputs.DomainDevicesHostdevAlias']:
        """
        Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def boot(self) -> Optional['outputs.DomainDevicesHostdevBoot']:
        """
        Enables boot-order control for this redirected device, allowing it to participate in the device boot sequence.
        """
        return pulumi.get(self, "boot")

    @_builtins.property
    @pulumi.getter(name="capsMisc")
    def caps_misc(self) -> Optional['outputs.DomainDevicesHostdevCapsMisc']:
        """
        Enables miscellaneous capability-specific configuration for the host device, used for device types that expose extra capabilities not covered by other elements.
        """
        return pulumi.get(self, "caps_misc")

    @_builtins.property
    @pulumi.getter(name="capsNet")
    def caps_net(self) -> Optional['outputs.DomainDevicesHostdevCapsNet']:
        """
        Enables network-related capability configuration for the host device, typically for host NICs or VF-based network passthrough with extra capabilities.
        """
        return pulumi.get(self, "caps_net")

    @_builtins.property
    @pulumi.getter(name="capsStorage")
    def caps_storage(self) -> Optional['outputs.DomainDevicesHostdevCapsStorage']:
        """
        Configures storage-related capabilities for a passthrough host device, such as its backing block source.
        """
        return pulumi.get(self, "caps_storage")

    @_builtins.property
    @pulumi.getter
    def managed(self) -> Optional[_builtins.bool]:
        """
        Controls whether libvirt manages detaching and reattaching the host device driver, as a string boolean where "yes" enables management and "no" disables it.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "managed")

    @_builtins.property
    @pulumi.getter
    def rom(self) -> Optional['outputs.DomainDevicesHostdevRom']:
        """
        Configures an optional PCI ROM image for the passthrough host device, including whether it is enabled, where it is mapped, and an alternate ROM file.
        """
        return pulumi.get(self, "rom")

    @_builtins.property
    @pulumi.getter(name="subsysMDev")
    def subsys_m_dev(self) -> Optional['outputs.DomainDevicesHostdevSubsysMDev']:
        """
        Configures mediated device (mdev)specific settings for a passthrough host device, such as display handling for a vGPU.
        """
        return pulumi.get(self, "subsys_m_dev")

    @_builtins.property
    @pulumi.getter(name="subsysPci")
    def subsys_pci(self) -> Optional['outputs.DomainDevicesHostdevSubsysPci']:
        """
        Selects PCI as the host device subsystem type and groups all PCI-specific passthrough settings for this hostdev.
        """
        return pulumi.get(self, "subsys_pci")

    @_builtins.property
    @pulumi.getter(name="subsysScsi")
    def subsys_scsi(self) -> Optional['outputs.DomainDevicesHostdevSubsysScsi']:
        """
        Configures a host SCSI device (or LUN) to be passed through to the guest using a SCSI hostdev subsystem.
        """
        return pulumi.get(self, "subsys_scsi")

    @_builtins.property
    @pulumi.getter(name="subsysScsiHost")
    def subsys_scsi_host(self) -> Optional['outputs.DomainDevicesHostdevSubsysScsiHost']:
        """
        Configures a SCSI host adapterstyle host device passthrough (SubsysSCSIHost) to the guest, rather than an individual LUN.
        """
        return pulumi.get(self, "subsys_scsi_host")

    @_builtins.property
    @pulumi.getter(name="subsysUsb")
    def subsys_usb(self) -> Optional['outputs.DomainDevicesHostdevSubsysUsb']:
        """
        Configures a host USB device passthrough entry for the guest, corresponding to a `<hostdev>` with USB subsystem-specific settings.
        """
        return pulumi.get(self, "subsys_usb")


@pulumi.output_type
class DomainDevicesHostdevAcpi(dict):
    def __init__(__self__, *,
                 index: Optional[_builtins.float] = None):
        """
        :param _builtins.float index: Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        """
        if index is not None:
            pulumi.set(__self__, "index", index)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "index")


@pulumi.output_type
class DomainDevicesHostdevAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesHostdevAlias(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
               
               See: <https://libvirt.org/formatdomain.html#devices>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesHostdevBoot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadParm":
            suggest = "load_parm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesHostdevBoot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesHostdevBoot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesHostdevBoot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 order: _builtins.float,
                 load_parm: Optional[_builtins.str] = None):
        """
        :param _builtins.float order: Sets the boot priority for this redirected device, as a positive integer where lower values are tried earlier during guest boot (for example, 1 for first, 2 for second).
               
               See: <https://libvirt.org/formatdomain.html#specifying-boot-order>
        :param _builtins.str load_parm: Sets an optional firmware load parameter string associated with booting from this redirected device, passed to firmware on platforms that support loadparm (e.g. s390x).
               
               See: <https://libvirt.org/formatdomain.html#specifying-boot-order>
        """
        pulumi.set(__self__, "order", order)
        if load_parm is not None:
            pulumi.set(__self__, "load_parm", load_parm)

    @_builtins.property
    @pulumi.getter
    def order(self) -> _builtins.float:
        """
        Sets the boot priority for this redirected device, as a positive integer where lower values are tried earlier during guest boot (for example, 1 for first, 2 for second).

        See: <https://libvirt.org/formatdomain.html#specifying-boot-order>
        """
        return pulumi.get(self, "order")

    @_builtins.property
    @pulumi.getter(name="loadParm")
    def load_parm(self) -> Optional[_builtins.str]:
        """
        Sets an optional firmware load parameter string associated with booting from this redirected device, passed to firmware on platforms that support loadparm (e.g. s390x).

        See: <https://libvirt.org/formatdomain.html#specifying-boot-order>
        """
        return pulumi.get(self, "load_parm")


@pulumi.output_type
class DomainDevicesHostdevCapsMisc(dict):
    def __init__(__self__, *,
                 source: Optional['outputs.DomainDevicesHostdevCapsMiscSource'] = None):
        """
        :param 'DomainDevicesHostdevCapsMiscSourceArgs' source: Defines the source configuration for the miscellaneous capability, such as underlying host resources or paths needed by that capability.
        """
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainDevicesHostdevCapsMiscSource']:
        """
        Defines the source configuration for the miscellaneous capability, such as underlying host resources or paths needed by that capability.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class DomainDevicesHostdevCapsMiscSource(dict):
    def __init__(__self__, *,
                 char: _builtins.str):
        """
        :param _builtins.str char: Specifies a character-device style source (for example, a host chardev path) used by the miscellaneous capability; the value is a user-provided device path.
               
               See: <https://libvirt.org/formatdomain.html#block-character-devices>
        """
        pulumi.set(__self__, "char", char)

    @_builtins.property
    @pulumi.getter
    def char(self) -> _builtins.str:
        """
        Specifies a character-device style source (for example, a host chardev path) used by the miscellaneous capability; the value is a user-provided device path.

        See: <https://libvirt.org/formatdomain.html#block-character-devices>
        """
        return pulumi.get(self, "char")


@pulumi.output_type
class DomainDevicesHostdevCapsNet(dict):
    def __init__(__self__, *,
                 ips: Optional[Sequence['outputs.DomainDevicesHostdevCapsNetIp']] = None,
                 routes: Optional[Sequence['outputs.DomainDevicesHostdevCapsNetRoute']] = None,
                 source: Optional['outputs.DomainDevicesHostdevCapsNetSource'] = None):
        """
        :param Sequence['DomainDevicesHostdevCapsNetIpArgs'] ips: Configures one or more IP addresses associated with the passthrough network host device, including address, family, and prefix.
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        :param Sequence['DomainDevicesHostdevCapsNetRouteArgs'] routes: Defines a static route reachable via the passthrough network host device, including destination address, family, and gateway.
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        :param 'DomainDevicesHostdevCapsNetSourceArgs' source: Configures the source information for the passthrough network host device, such as the backing host interface.
        """
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Optional[Sequence['outputs.DomainDevicesHostdevCapsNetIp']]:
        """
        Configures one or more IP addresses associated with the passthrough network host device, including address, family, and prefix.

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "ips")

    @_builtins.property
    @pulumi.getter
    def routes(self) -> Optional[Sequence['outputs.DomainDevicesHostdevCapsNetRoute']]:
        """
        Defines a static route reachable via the passthrough network host device, including destination address, family, and gateway.

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "routes")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainDevicesHostdevCapsNetSource']:
        """
        Configures the source information for the passthrough network host device, such as the backing host interface.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class DomainDevicesHostdevCapsNetIp(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 family: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.float] = None):
        """
        :param _builtins.str address: Sets the IP address assigned to the passthrough network device; value is user-provided (for example, "192.168.122.10" or "2001:db8::10").
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        :param _builtins.str family: Sets the IP address family for the passthrough network device, typically "ipv4" or "ipv6".
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        :param _builtins.float prefix: Sets the CIDR prefix length of the IP address for the passthrough network device, as a non-negative integer (for example, 24 for IPv4 or 64 for IPv6).
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Sets the IP address assigned to the passthrough network device; value is user-provided (for example, "192.168.122.10" or "2001:db8::10").

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def family(self) -> Optional[_builtins.str]:
        """
        Sets the IP address family for the passthrough network device, typically "ipv4" or "ipv6".

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "family")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.float]:
        """
        Sets the CIDR prefix length of the IP address for the passthrough network device, as a non-negative integer (for example, 24 for IPv4 or 64 for IPv6).

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class DomainDevicesHostdevCapsNetRoute(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 family: Optional[_builtins.str] = None,
                 gateway: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: Sets the destination network address for the static route associated with the passthrough host device; value is user-provided (for example, "10.0.0.0").
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        :param _builtins.str family: Sets the address family for the static route, typically "ipv4" or "ipv6".
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        :param _builtins.str gateway: Sets the gateway IP address used to reach the route destination network via the passthrough device; value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Sets the destination network address for the static route associated with the passthrough host device; value is user-provided (for example, "10.0.0.0").

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def family(self) -> Optional[_builtins.str]:
        """
        Sets the address family for the static route, typically "ipv4" or "ipv6".

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "family")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[_builtins.str]:
        """
        Sets the gateway IP address used to reach the route destination network via the passthrough device; value is user-provided.

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "gateway")


@pulumi.output_type
class DomainDevicesHostdevCapsNetSource(dict):
    def __init__(__self__, *,
                 interface: _builtins.str):
        """
        :param _builtins.str interface: Specifies the name of the host network interface used as the source for the passthrough network device (for example, "eth0"); this field is required when configuring caps_net.source.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        pulumi.set(__self__, "interface", interface)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> _builtins.str:
        """
        Specifies the name of the host network interface used as the source for the passthrough network device (for example, "eth0"); this field is required when configuring caps_net.source.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "interface")


@pulumi.output_type
class DomainDevicesHostdevCapsStorage(dict):
    def __init__(__self__, *,
                 source: Optional['outputs.DomainDevicesHostdevCapsStorageSource'] = None):
        """
        :param 'DomainDevicesHostdevCapsStorageSourceArgs' source: Defines the storage source information for the passthrough host device, typically pointing to a host block device.
        """
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainDevicesHostdevCapsStorageSource']:
        """
        Defines the storage source information for the passthrough host device, typically pointing to a host block device.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class DomainDevicesHostdevCapsStorageSource(dict):
    def __init__(__self__, *,
                 block: _builtins.str):
        """
        :param _builtins.str block: Specifies the path of the host block device used as the storage source for the passthrough device (for example, "/dev/sdb"); this field is required when configuring caps_storage.source.
               
               See: <https://libvirt.org/formatdomain.html#block-character-devices>
        """
        pulumi.set(__self__, "block", block)

    @_builtins.property
    @pulumi.getter
    def block(self) -> _builtins.str:
        """
        Specifies the path of the host block device used as the storage source for the passthrough device (for example, "/dev/sdb"); this field is required when configuring caps_storage.source.

        See: <https://libvirt.org/formatdomain.html#block-character-devices>
        """
        return pulumi.get(self, "block")


@pulumi.output_type
class DomainDevicesHostdevRom(dict):
    def __init__(__self__, *,
                 bar: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.str] = None,
                 file: Optional[_builtins.str] = None):
        """
        :param _builtins.str bar: Controls whether the devices ROM is exposed in PCI BAR space, typically "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#interface-rom-bios-configuration>
        :param _builtins.str enabled: Enables or disables use of the ROM image for the host device, as a user-provided string flag (for example, "on"/"off" or "yes"/"no" depending on libvirt expectations).
               
               See: <https://libvirt.org/formatdomain.html#interface-rom-bios-configuration>
        :param _builtins.str file: Specifies a path to a custom ROM file to use for the passthrough device (for example, "/usr/share/roms/nic.rom"); value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#interface-rom-bios-configuration>
        """
        if bar is not None:
            pulumi.set(__self__, "bar", bar)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if file is not None:
            pulumi.set(__self__, "file", file)

    @_builtins.property
    @pulumi.getter
    def bar(self) -> Optional[_builtins.str]:
        """
        Controls whether the devices ROM is exposed in PCI BAR space, typically "on" or "off".

        See: <https://libvirt.org/formatdomain.html#interface-rom-bios-configuration>
        """
        return pulumi.get(self, "bar")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.str]:
        """
        Enables or disables use of the ROM image for the host device, as a user-provided string flag (for example, "on"/"off" or "yes"/"no" depending on libvirt expectations).

        See: <https://libvirt.org/formatdomain.html#interface-rom-bios-configuration>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional[_builtins.str]:
        """
        Specifies a path to a custom ROM file to use for the passthrough device (for example, "/usr/share/roms/nic.rom"); value is user-provided.

        See: <https://libvirt.org/formatdomain.html#interface-rom-bios-configuration>
        """
        return pulumi.get(self, "file")


@pulumi.output_type
class DomainDevicesHostdevSubsysMDev(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ramFb":
            suggest = "ram_fb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesHostdevSubsysMDev. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesHostdevSubsysMDev.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesHostdevSubsysMDev.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 ram_fb: Optional[_builtins.str] = None,
                 source: Optional['outputs.DomainDevicesHostdevSubsysMDevSource'] = None):
        """
        :param _builtins.str display: Sets how display output of a mediated (mdev) device is exposed to the guest; the value is user-provided and backend-specific (for example, selecting a particular vGPU display mode).
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        :param _builtins.str model: Sets the mediated device (mdev) model for this hostdev, identifying which virtual function or vGPU type is exposed to the guest; the value is user-provided and must match a model supported by the host driver (for example, an NVIDIA vGPU type name).
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        :param _builtins.str ram_fb: Controls whether a frame buffer (ramfb) is created for this mediated device; accepts "on"/"off" as yes/no flags when supported by the host driver.
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        :param 'DomainDevicesHostdevSubsysMDevSourceArgs' source: Groups the source configuration for the mediated device passed through to the guest, such as its unique address on the host.
        """
        if display is not None:
            pulumi.set(__self__, "display", display)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if ram_fb is not None:
            pulumi.set(__self__, "ram_fb", ram_fb)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def display(self) -> Optional[_builtins.str]:
        """
        Sets how display output of a mediated (mdev) device is exposed to the guest; the value is user-provided and backend-specific (for example, selecting a particular vGPU display mode).

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "display")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Sets the mediated device (mdev) model for this hostdev, identifying which virtual function or vGPU type is exposed to the guest; the value is user-provided and must match a model supported by the host driver (for example, an NVIDIA vGPU type name).

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter(name="ramFb")
    def ram_fb(self) -> Optional[_builtins.str]:
        """
        Controls whether a frame buffer (ramfb) is created for this mediated device; accepts "on"/"off" as yes/no flags when supported by the host driver.

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "ram_fb")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainDevicesHostdevSubsysMDevSource']:
        """
        Groups the source configuration for the mediated device passed through to the guest, such as its unique address on the host.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class DomainDevicesHostdevSubsysMDevSource(dict):
    def __init__(__self__, *,
                 address: Optional['outputs.DomainDevicesHostdevSubsysMDevSourceAddress'] = None):
        """
        :param 'DomainDevicesHostdevSubsysMDevSourceAddressArgs' address: Defines the host-side address for the mediated device source; for mdev this typically contains the UUID identifying the mediated device instance on the host.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesHostdevSubsysMDevSourceAddress']:
        """
        Defines the host-side address for the mediated device source; for mdev this typically contains the UUID identifying the mediated device instance on the host.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class DomainDevicesHostdevSubsysMDevSourceAddress(dict):
    def __init__(__self__, *,
                 uuid: Optional[_builtins.str] = None):
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "uuid")


@pulumi.output_type
class DomainDevicesHostdevSubsysPci(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ramFb":
            suggest = "ram_fb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesHostdevSubsysPci. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesHostdevSubsysPci.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesHostdevSubsysPci.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display: Optional[_builtins.str] = None,
                 driver: Optional['outputs.DomainDevicesHostdevSubsysPciDriver'] = None,
                 ram_fb: Optional[_builtins.str] = None,
                 source: Optional['outputs.DomainDevicesHostdevSubsysPciSource'] = None,
                 teaming: Optional['outputs.DomainDevicesHostdevSubsysPciTeaming'] = None):
        """
        :param _builtins.str display: Controls whether this PCI hostdev is treated as a display device (for example, a GPU providing primary display); valid values are "on" or "off" as yes/no flags when supported.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param 'DomainDevicesHostdevSubsysPciDriverArgs' driver: Groups driver-related configuration for PCI passthrough, such as which kernel driver or model to use for the device in the guest.
        :param _builtins.str ram_fb: Controls whether a ramfb (in-memory frame buffer) is created for this PCI hostdev, typically used with GPUs; accepts "on"/"off" as yes/no flags when supported.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param 'DomainDevicesHostdevSubsysPciSourceArgs' source: Groups the source configuration for the PCI device being passed through, including its PCI address on the host.
        :param 'DomainDevicesHostdevSubsysPciTeamingArgs' teaming: Configures this PCI hostdev as part of an interface teaming/bonding setup in the guest, pairing it with another interface for failover.
        """
        if display is not None:
            pulumi.set(__self__, "display", display)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if ram_fb is not None:
            pulumi.set(__self__, "ram_fb", ram_fb)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if teaming is not None:
            pulumi.set(__self__, "teaming", teaming)

    @_builtins.property
    @pulumi.getter
    def display(self) -> Optional[_builtins.str]:
        """
        Controls whether this PCI hostdev is treated as a display device (for example, a GPU providing primary display); valid values are "on" or "off" as yes/no flags when supported.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "display")

    @_builtins.property
    @pulumi.getter
    def driver(self) -> Optional['outputs.DomainDevicesHostdevSubsysPciDriver']:
        """
        Groups driver-related configuration for PCI passthrough, such as which kernel driver or model to use for the device in the guest.
        """
        return pulumi.get(self, "driver")

    @_builtins.property
    @pulumi.getter(name="ramFb")
    def ram_fb(self) -> Optional[_builtins.str]:
        """
        Controls whether a ramfb (in-memory frame buffer) is created for this PCI hostdev, typically used with GPUs; accepts "on"/"off" as yes/no flags when supported.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "ram_fb")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainDevicesHostdevSubsysPciSource']:
        """
        Groups the source configuration for the PCI device being passed through, including its PCI address on the host.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def teaming(self) -> Optional['outputs.DomainDevicesHostdevSubsysPciTeaming']:
        """
        Configures this PCI hostdev as part of an interface teaming/bonding setup in the guest, pairing it with another interface for failover.
        """
        return pulumi.get(self, "teaming")


@pulumi.output_type
class DomainDevicesHostdevSubsysPciDriver(dict):
    def __init__(__self__, *,
                 model: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str model: Sets the model of the guest-side driver used for this PCI hostdev; the value is user-provided and must be a model supported by the hypervisor for PCI passthrough.
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        :param _builtins.str name: Specifies the host-side kernel driver name to bind for this PCI device (for example, "vfio-pci"); the value is user-provided and must match a valid driver on the host.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Sets the model of the guest-side driver used for this PCI hostdev; the value is user-provided and must be a model supported by the hypervisor for PCI passthrough.

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Specifies the host-side kernel driver name to bind for this PCI device (for example, "vfio-pci"); the value is user-provided and must match a valid driver on the host.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesHostdevSubsysPciSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "writeFiltering":
            suggest = "write_filtering"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesHostdevSubsysPciSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesHostdevSubsysPciSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesHostdevSubsysPciSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional['outputs.DomainDevicesHostdevSubsysPciSourceAddress'] = None,
                 write_filtering: Optional[_builtins.str] = None):
        """
        :param 'DomainDevicesHostdevSubsysPciSourceAddressArgs' address: Defines the host PCI address of the device to passthrough, typically via domain, bus, slot, and function (and optional zPCI info on s390x).
        :param _builtins.str write_filtering: Controls whether write filtering is enabled for a PCI passthrough device, typically to restrict or filter MMIO/PCI configuration writes; accepts user-provided value as defined by libvirt (for example "on" or "off").
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if write_filtering is not None:
            pulumi.set(__self__, "write_filtering", write_filtering)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesHostdevSubsysPciSourceAddress']:
        """
        Defines the host PCI address of the device to passthrough, typically via domain, bus, slot, and function (and optional zPCI info on s390x).
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="writeFiltering")
    def write_filtering(self) -> Optional[_builtins.str]:
        """
        Controls whether write filtering is enabled for a PCI passthrough device, typically to restrict or filter MMIO/PCI configuration writes; accepts user-provided value as defined by libvirt (for example "on" or "off").

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "write_filtering")


@pulumi.output_type
class DomainDevicesHostdevSubsysPciSourceAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "multiFunction":
            suggest = "multi_function"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesHostdevSubsysPciSourceAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesHostdevSubsysPciSourceAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesHostdevSubsysPciSourceAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bus: Optional[_builtins.float] = None,
                 domain: Optional[_builtins.float] = None,
                 function: Optional[_builtins.float] = None,
                 multi_function: Optional[_builtins.str] = None,
                 slot: Optional[_builtins.float] = None,
                 zpci: Optional['outputs.DomainDevicesHostdevSubsysPciSourceAddressZpci'] = None):
        """
        :param _builtins.float bus: Sets the PCI bus number of the host device to passthrough; the value is usually a hexadecimal or decimal bus index matching the host's PCI topology (for example, "0x03").
               
               See: <https://libvirt.org/formatdomain.html#device-addresses>
        :param _builtins.float domain: Sets the PCI domain number of the host device (segment), typically "0" on most systems; the value must match the device's domain as reported by tools like lspci.
               
               See: <https://libvirt.org/formatdomain.html#device-addresses>
        :param _builtins.float function: Sets the PCI function number of the host device (07), usually provided as a small integer or hex string (for example, "0" or "0x0") corresponding to the device's function.
               
               See: <https://libvirt.org/formatdomain.html#device-addresses>
        :param _builtins.str multi_function: Indicates whether the PCI device is part of a multifunction PCI slot; accepts "on"/"off" as yes/no flags.
               
               See: <https://libvirt.org/formatdomain.html#device-addresses>
        :param _builtins.float slot: Sets the PCI slot number of the host device, usually as a hex or decimal value (for example, "0x00" or "0") matching the slot shown by lspci.
               
               See: <https://libvirt.org/formatdomain.html#device-addresses>
        :param 'DomainDevicesHostdevSubsysPciSourceAddressZpciArgs' zpci: Groups additional addressing attributes for s390x zPCI devices, used when passing through PCI devices on IBM Z systems.
        """
        if bus is not None:
            pulumi.set(__self__, "bus", bus)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if function is not None:
            pulumi.set(__self__, "function", function)
        if multi_function is not None:
            pulumi.set(__self__, "multi_function", multi_function)
        if slot is not None:
            pulumi.set(__self__, "slot", slot)
        if zpci is not None:
            pulumi.set(__self__, "zpci", zpci)

    @_builtins.property
    @pulumi.getter
    def bus(self) -> Optional[_builtins.float]:
        """
        Sets the PCI bus number of the host device to passthrough; the value is usually a hexadecimal or decimal bus index matching the host's PCI topology (for example, "0x03").

        See: <https://libvirt.org/formatdomain.html#device-addresses>
        """
        return pulumi.get(self, "bus")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[_builtins.float]:
        """
        Sets the PCI domain number of the host device (segment), typically "0" on most systems; the value must match the device's domain as reported by tools like lspci.

        See: <https://libvirt.org/formatdomain.html#device-addresses>
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter
    def function(self) -> Optional[_builtins.float]:
        """
        Sets the PCI function number of the host device (07), usually provided as a small integer or hex string (for example, "0" or "0x0") corresponding to the device's function.

        See: <https://libvirt.org/formatdomain.html#device-addresses>
        """
        return pulumi.get(self, "function")

    @_builtins.property
    @pulumi.getter(name="multiFunction")
    def multi_function(self) -> Optional[_builtins.str]:
        """
        Indicates whether the PCI device is part of a multifunction PCI slot; accepts "on"/"off" as yes/no flags.

        See: <https://libvirt.org/formatdomain.html#device-addresses>
        """
        return pulumi.get(self, "multi_function")

    @_builtins.property
    @pulumi.getter
    def slot(self) -> Optional[_builtins.float]:
        """
        Sets the PCI slot number of the host device, usually as a hex or decimal value (for example, "0x00" or "0") matching the slot shown by lspci.

        See: <https://libvirt.org/formatdomain.html#device-addresses>
        """
        return pulumi.get(self, "slot")

    @_builtins.property
    @pulumi.getter
    def zpci(self) -> Optional['outputs.DomainDevicesHostdevSubsysPciSourceAddressZpci']:
        """
        Groups additional addressing attributes for s390x zPCI devices, used when passing through PCI devices on IBM Z systems.
        """
        return pulumi.get(self, "zpci")


@pulumi.output_type
class DomainDevicesHostdevSubsysPciSourceAddressZpci(dict):
    def __init__(__self__, *,
                 fid: Optional[_builtins.float] = None,
                 uid: Optional[_builtins.float] = None):
        """
        :param _builtins.float fid: Sets the function ID (fid) for a zPCI device on s390x, identifying the specific zPCI function to passthrough; the value is user-provided and must match the host's zPCI configuration.
               
               See: <https://libvirt.org/formatdomain.html#device-addresses>
        :param _builtins.float uid: Sets the zPCI function UID for a passed-through PCI device on s390x, identifying the zPCI function within the guest; the value is user-provided and must match the host zPCI configuration.
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        if fid is not None:
            pulumi.set(__self__, "fid", fid)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def fid(self) -> Optional[_builtins.float]:
        """
        Sets the function ID (fid) for a zPCI device on s390x, identifying the specific zPCI function to passthrough; the value is user-provided and must match the host's zPCI configuration.

        See: <https://libvirt.org/formatdomain.html#device-addresses>
        """
        return pulumi.get(self, "fid")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.float]:
        """
        Sets the zPCI function UID for a passed-through PCI device on s390x, identifying the zPCI function within the guest; the value is user-provided and must match the host zPCI configuration.

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class DomainDevicesHostdevSubsysPciTeaming(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 persistent: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Sets the teaming mode for this hostdev (for example "persistent" or "transient") and is required when teaming is configured; valid values are those supported by libvirt for teaming type.
               
               See: <https://libvirt.org/formatdomain.html#teaming-a-virtio-hostdev-nic-pair>
        :param _builtins.str persistent: Controls whether the teaming configuration for this hostdev should survive guest reboots; when true, the team is kept persistent, when false it is transient for the current guest lifecycle.
               
               See: <https://libvirt.org/formatdomain.html#teaming-a-virtio-hostdev-nic-pair>
        """
        pulumi.set(__self__, "type", type)
        if persistent is not None:
            pulumi.set(__self__, "persistent", persistent)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets the teaming mode for this hostdev (for example "persistent" or "transient") and is required when teaming is configured; valid values are those supported by libvirt for teaming type.

        See: <https://libvirt.org/formatdomain.html#teaming-a-virtio-hostdev-nic-pair>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def persistent(self) -> Optional[_builtins.str]:
        """
        Controls whether the teaming configuration for this hostdev should survive guest reboots; when true, the team is kept persistent, when false it is transient for the current guest lifecycle.

        See: <https://libvirt.org/formatdomain.html#teaming-a-virtio-hostdev-nic-pair>
        """
        return pulumi.get(self, "persistent")


@pulumi.output_type
class DomainDevicesHostdevSubsysScsi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rawIo":
            suggest = "raw_io"
        elif key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesHostdevSubsysScsi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesHostdevSubsysScsi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesHostdevSubsysScsi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 raw_io: Optional[_builtins.str] = None,
                 read_only: Optional[_builtins.bool] = None,
                 sgio: Optional[_builtins.str] = None,
                 shareable: Optional[_builtins.bool] = None,
                 source: Optional['outputs.DomainDevicesHostdevSubsysScsiSource'] = None):
        """
        :param _builtins.str raw_io: Controls whether raw I/O is allowed for the SCSI hostdev, typically using a yes/no style value as supported by libvirt (for example "yes" or "no").
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        :param _builtins.bool read_only: Marks the SCSI hostdev as read-only when true by emitting the readonly element; when false or unset, the device is writable and the element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        :param _builtins.str sgio: Sets the SG_IO policy for the SCSI hostdev (e.g. allowing or restricting SG_IO commands), using user-provided values supported by libvirt such as "filtered" or "unfiltered".
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        :param _builtins.bool shareable: Marks the SCSI hostdev as shareable between multiple guests when true by emitting the shareable element; when false or unset, the device is treated as exclusively owned and the element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        :param 'DomainDevicesHostdevSubsysScsiSourceArgs' source: Defines the source characteristics of the SCSI host device to passthrough, such as host adapter, SCSI address, or iSCSI parameters.
        """
        if raw_io is not None:
            pulumi.set(__self__, "raw_io", raw_io)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if sgio is not None:
            pulumi.set(__self__, "sgio", sgio)
        if shareable is not None:
            pulumi.set(__self__, "shareable", shareable)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="rawIo")
    def raw_io(self) -> Optional[_builtins.str]:
        """
        Controls whether raw I/O is allowed for the SCSI hostdev, typically using a yes/no style value as supported by libvirt (for example "yes" or "no").

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "raw_io")

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[_builtins.bool]:
        """
        Marks the SCSI hostdev as read-only when true by emitting the readonly element; when false or unset, the device is writable and the element is omitted.

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "read_only")

    @_builtins.property
    @pulumi.getter
    def sgio(self) -> Optional[_builtins.str]:
        """
        Sets the SG_IO policy for the SCSI hostdev (e.g. allowing or restricting SG_IO commands), using user-provided values supported by libvirt such as "filtered" or "unfiltered".

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "sgio")

    @_builtins.property
    @pulumi.getter
    def shareable(self) -> Optional[_builtins.bool]:
        """
        Marks the SCSI hostdev as shareable between multiple guests when true by emitting the shareable element; when false or unset, the device is treated as exclusively owned and the element is omitted.

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "shareable")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainDevicesHostdevSubsysScsiSource']:
        """
        Defines the source characteristics of the SCSI host device to passthrough, such as host adapter, SCSI address, or iSCSI parameters.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class DomainDevicesHostdevSubsysScsiHost(dict):
    def __init__(__self__, *,
                 model: Optional[_builtins.str] = None,
                 source: Optional['outputs.DomainDevicesHostdevSubsysScsiHostSource'] = None):
        """
        :param _builtins.str model: Sets the model of SCSI host adapter to present to the guest for this hostdev; the value is user-provided and must match a model supported by the hypervisor backend.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param 'DomainDevicesHostdevSubsysScsiHostSourceArgs' source: Defines the source characteristics of the SCSI host adapter passthrough, such as protocol and WWPN.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Sets the model of SCSI host adapter to present to the guest for this hostdev; the value is user-provided and must match a model supported by the hypervisor backend.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainDevicesHostdevSubsysScsiHostSource']:
        """
        Defines the source characteristics of the SCSI host adapter passthrough, such as protocol and WWPN.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class DomainDevicesHostdevSubsysScsiHostSource(dict):
    def __init__(__self__, *,
                 protocol: Optional[_builtins.str] = None,
                 wwpn: Optional[_builtins.str] = None):
        """
        :param _builtins.str protocol: Sets the transport protocol used by the SCSI host adapter source (for example, "fc" for Fibre Channel); the value is user-provided and must be supported by the host.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str wwpn: Sets the World Wide Port Name (WWPN) of the SCSI/Fibre Channel host adapter source as a user-provided string, typically a 16hexdigit identifier like "5005076801401b3f".
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if wwpn is not None:
            pulumi.set(__self__, "wwpn", wwpn)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        Sets the transport protocol used by the SCSI host adapter source (for example, "fc" for Fibre Channel); the value is user-provided and must be supported by the host.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def wwpn(self) -> Optional[_builtins.str]:
        """
        Sets the World Wide Port Name (WWPN) of the SCSI/Fibre Channel host adapter source as a user-provided string, typically a 16hexdigit identifier like "5005076801401b3f".

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "wwpn")


@pulumi.output_type
class DomainDevicesHostdevSubsysScsiSource(dict):
    def __init__(__self__, *,
                 host: Optional['outputs.DomainDevicesHostdevSubsysScsiSourceHost'] = None,
                 iscsi: Optional['outputs.DomainDevicesHostdevSubsysScsiSourceIscsi'] = None):
        """
        :param 'DomainDevicesHostdevSubsysScsiSourceHostArgs' host: Describes a host-side SCSI target used as the source for the SCSI hostdev, including adapter and SCSI address information.
        :param 'DomainDevicesHostdevSubsysScsiSourceIscsiArgs' iscsi: Defines an iSCSI-backed SCSI source for the hostdev, specifying that the passed-through SCSI device is provided by an iSCSI target; additional connection details are given in child elements or attributes.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if iscsi is not None:
            pulumi.set(__self__, "iscsi", iscsi)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional['outputs.DomainDevicesHostdevSubsysScsiSourceHost']:
        """
        Describes a host-side SCSI target used as the source for the SCSI hostdev, including adapter and SCSI address information.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def iscsi(self) -> Optional['outputs.DomainDevicesHostdevSubsysScsiSourceIscsi']:
        """
        Defines an iSCSI-backed SCSI source for the hostdev, specifying that the passed-through SCSI device is provided by an iSCSI target; additional connection details are given in child elements or attributes.
        """
        return pulumi.get(self, "iscsi")


@pulumi.output_type
class DomainDevicesHostdevSubsysScsiSourceHost(dict):
    def __init__(__self__, *,
                 adapter: Optional['outputs.DomainDevicesHostdevSubsysScsiSourceHostAdapter'] = None,
                 address: Optional['outputs.DomainDevicesHostdevSubsysScsiSourceHostAddress'] = None):
        """
        :param 'DomainDevicesHostdevSubsysScsiSourceHostAdapterArgs' adapter: Selects the host SCSI adapter that provides the target/LUN to be passed through to the guest.
        :param 'DomainDevicesHostdevSubsysScsiSourceHostAddressArgs' address: Defines the SCSI address (bus, controller, target, unit) of the host-side device that is being passed through.
        """
        if adapter is not None:
            pulumi.set(__self__, "adapter", adapter)
        if address is not None:
            pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def adapter(self) -> Optional['outputs.DomainDevicesHostdevSubsysScsiSourceHostAdapter']:
        """
        Selects the host SCSI adapter that provides the target/LUN to be passed through to the guest.
        """
        return pulumi.get(self, "adapter")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesHostdevSubsysScsiSourceHostAddress']:
        """
        Defines the SCSI address (bus, controller, target, unit) of the host-side device that is being passed through.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class DomainDevicesHostdevSubsysScsiSourceHostAdapter(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the name of the host SCSI adapter (for example a HBA or SCSI host name) from which the device is sourced; this attribute is required when using the adapter-based SCSI source.
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the name of the host SCSI adapter (for example a HBA or SCSI host name) from which the device is sourced; this attribute is required when using the adapter-based SCSI source.

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesHostdevSubsysScsiSourceHostAddress(dict):
    def __init__(__self__, *,
                 bus: Optional[_builtins.float] = None,
                 controller: Optional[_builtins.float] = None,
                 target: Optional[_builtins.float] = None,
                 unit: Optional[_builtins.float] = None):
        """
        :param _builtins.float bus: Sets the SCSI bus number of the host device to passthrough; the value is a user-provided non-negative integer matching the host SCSI topology (e.g. "0").
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        :param _builtins.float controller: Sets the SCSI controller number of the host device to passthrough; the value is a user-provided non-negative integer matching the host SCSI topology.
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        :param _builtins.float target: Sets the SCSI target ID on the host bus for the device to be passed through; the value is a user-provided non-negative integer (e.g. "0" or "1").
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        :param _builtins.float unit: Sets the SCSI LUN/unit number of the host device to passthrough; the value is a user-provided non-negative integer matching the host LUN (e.g. "0").
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        if bus is not None:
            pulumi.set(__self__, "bus", bus)
        if controller is not None:
            pulumi.set(__self__, "controller", controller)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def bus(self) -> Optional[_builtins.float]:
        """
        Sets the SCSI bus number of the host device to passthrough; the value is a user-provided non-negative integer matching the host SCSI topology (e.g. "0").

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "bus")

    @_builtins.property
    @pulumi.getter
    def controller(self) -> Optional[_builtins.float]:
        """
        Sets the SCSI controller number of the host device to passthrough; the value is a user-provided non-negative integer matching the host SCSI topology.

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "controller")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[_builtins.float]:
        """
        Sets the SCSI target ID on the host bus for the device to be passed through; the value is a user-provided non-negative integer (e.g. "0" or "1").

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.float]:
        """
        Sets the SCSI LUN/unit number of the host device to passthrough; the value is a user-provided non-negative integer matching the host LUN (e.g. "0").

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class DomainDevicesHostdevSubsysScsiSourceIscsi(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 auth: Optional['outputs.DomainDevicesHostdevSubsysScsiSourceIscsiAuth'] = None,
                 hosts: Optional[Sequence['outputs.DomainDevicesHostdevSubsysScsiSourceIscsiHost']] = None,
                 initiator: Optional['outputs.DomainDevicesHostdevSubsysScsiSourceIscsiInitiator'] = None):
        """
        :param _builtins.str name: Sets the iSCSI target name (IQN or other target identifier) that provides the LUNs for this SCSI hostdev; for example, "iqn.2010-10.org.example:storage.lun1".
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param 'DomainDevicesHostdevSubsysScsiSourceIscsiAuthArgs' auth: Configures CHAP authentication parameters for the iSCSI source backing an assigned SCSI host device; include this block only when the target requires authentication.
        :param Sequence['DomainDevicesHostdevSubsysScsiSourceIscsiHostArgs'] hosts: Configures the iSCSI target portal settings (address and transport details) for the SCSI hostdevs backing device.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param 'DomainDevicesHostdevSubsysScsiSourceIscsiInitiatorArgs' initiator: Configures iSCSI initiator information for the SCSI hostdev, including the initiator IQN used to identify the host.
        """
        pulumi.set(__self__, "name", name)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if initiator is not None:
            pulumi.set(__self__, "initiator", initiator)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the iSCSI target name (IQN or other target identifier) that provides the LUNs for this SCSI hostdev; for example, "iqn.2010-10.org.example:storage.lun1".

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional['outputs.DomainDevicesHostdevSubsysScsiSourceIscsiAuth']:
        """
        Configures CHAP authentication parameters for the iSCSI source backing an assigned SCSI host device; include this block only when the target requires authentication.
        """
        return pulumi.get(self, "auth")

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence['outputs.DomainDevicesHostdevSubsysScsiSourceIscsiHost']]:
        """
        Configures the iSCSI target portal settings (address and transport details) for the SCSI hostdevs backing device.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter
    def initiator(self) -> Optional['outputs.DomainDevicesHostdevSubsysScsiSourceIscsiInitiator']:
        """
        Configures iSCSI initiator information for the SCSI hostdev, including the initiator IQN used to identify the host.
        """
        return pulumi.get(self, "initiator")


@pulumi.output_type
class DomainDevicesHostdevSubsysScsiSourceIscsiAuth(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.DomainDevicesHostdevSubsysScsiSourceIscsiAuthSecret'] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param 'DomainDevicesHostdevSubsysScsiSourceIscsiAuthSecretArgs' secret: Configures the libvirt secret object used to hold the iSCSI authentication password for this hostdev; this references an existing libvirt secret, not the clear-text secret.
        :param _builtins.str username: Sets the CHAP username used when authenticating to the iSCSI target for this SCSI hostdev; the value is user-provided (for example, "chapuser1").
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.DomainDevicesHostdevSubsysScsiSourceIscsiAuthSecret']:
        """
        Configures the libvirt secret object used to hold the iSCSI authentication password for this hostdev; this references an existing libvirt secret, not the clear-text secret.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        Sets the CHAP username used when authenticating to the iSCSI target for this SCSI hostdev; the value is user-provided (for example, "chapuser1").

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class DomainDevicesHostdevSubsysScsiSourceIscsiAuthSecret(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 usage: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str usage: Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str uuid: Exposes the UUID of the libvirt secret used for iSCSI authentication; this is computed from the referenced secret rather than configured directly.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def usage(self) -> Optional[_builtins.str]:
        """
        Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "usage")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        Exposes the UUID of the libvirt secret used for iSCSI authentication; this is computed from the referenced secret rather than configured directly.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class DomainDevicesHostdevSubsysScsiSourceIscsiHost(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 socket: Optional[_builtins.str] = None,
                 transport: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Sets the hostname or IP address of the iSCSI target portal (for example, "10.0.0.10" or "iscsi.example.com").
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str port: Sets the TCP port of the iSCSI target portal; if omitted, libvirt/driver defaults (commonly 3260) are used.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str socket: Sets a UNIX domain socket path to connect to an iSCSI target via a local socket instead of TCP; value is a user-provided filesystem path.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str transport: Sets the transport type used to reach the iSCSI target portal; valid values are user-provided strings as supported by the environment (for example, "tcp" or "iser").
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if socket is not None:
            pulumi.set(__self__, "socket", socket)
        if transport is not None:
            pulumi.set(__self__, "transport", transport)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the hostname or IP address of the iSCSI target portal (for example, "10.0.0.10" or "iscsi.example.com").

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        """
        Sets the TCP port of the iSCSI target portal; if omitted, libvirt/driver defaults (commonly 3260) are used.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def socket(self) -> Optional[_builtins.str]:
        """
        Sets a UNIX domain socket path to connect to an iSCSI target via a local socket instead of TCP; value is a user-provided filesystem path.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "socket")

    @_builtins.property
    @pulumi.getter
    def transport(self) -> Optional[_builtins.str]:
        """
        Sets the transport type used to reach the iSCSI target portal; valid values are user-provided strings as supported by the environment (for example, "tcp" or "iser").

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "transport")


@pulumi.output_type
class DomainDevicesHostdevSubsysScsiSourceIscsiInitiator(dict):
    def __init__(__self__, *,
                 iqn: Optional['outputs.DomainDevicesHostdevSubsysScsiSourceIscsiInitiatorIqn'] = None):
        """
        :param 'DomainDevicesHostdevSubsysScsiSourceIscsiInitiatorIqnArgs' iqn: Declares the initiator IQN block for the iSCSI connection; this must be present when specifying an explicit initiator.
        """
        if iqn is not None:
            pulumi.set(__self__, "iqn", iqn)

    @_builtins.property
    @pulumi.getter
    def iqn(self) -> Optional['outputs.DomainDevicesHostdevSubsysScsiSourceIscsiInitiatorIqn']:
        """
        Declares the initiator IQN block for the iSCSI connection; this must be present when specifying an explicit initiator.
        """
        return pulumi.get(self, "iqn")


@pulumi.output_type
class DomainDevicesHostdevSubsysScsiSourceIscsiInitiatorIqn(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the iSCSI initiator name (IQN string) used when logging into the target, such as "iqn.1994-05.com.redhat:client1".
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the iSCSI initiator name (IQN string) used when logging into the target, such as "iqn.1994-05.com.redhat:client1".

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesHostdevSubsysUsb(dict):
    def __init__(__self__, *,
                 source: Optional['outputs.DomainDevicesHostdevSubsysUsbSource'] = None):
        """
        :param 'DomainDevicesHostdevSubsysUsbSourceArgs' source: Sets how the USB host device is identified for passthrough, either by topology (bus/port) or by vendor/product IDs and related options.
        """
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainDevicesHostdevSubsysUsbSource']:
        """
        Sets how the USB host device is identified for passthrough, either by topology (bus/port) or by vendor/product IDs and related options.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class DomainDevicesHostdevSubsysUsbSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "guestReset":
            suggest = "guest_reset"
        elif key == "startUpPolicy":
            suggest = "start_up_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesHostdevSubsysUsbSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesHostdevSubsysUsbSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesHostdevSubsysUsbSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional['outputs.DomainDevicesHostdevSubsysUsbSourceAddress'] = None,
                 guest_reset: Optional[_builtins.str] = None,
                 product: Optional['outputs.DomainDevicesHostdevSubsysUsbSourceProduct'] = None,
                 start_up_policy: Optional[_builtins.str] = None,
                 vendor: Optional['outputs.DomainDevicesHostdevSubsysUsbSourceVendor'] = None):
        """
        :param 'DomainDevicesHostdevSubsysUsbSourceAddressArgs' address: Specifies the physical USB topology of the host device (bus, device, and/or port) used to select which USB device is passed through.
        :param _builtins.str guest_reset: Controls whether a reset is issued to the USB device when it is assigned or re-assigned to the guest; value is user-provided (typically `on`/`off` or `yes`/`no` depending on libvirt version).
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        :param 'DomainDevicesHostdevSubsysUsbSourceProductArgs' product: Selects a USB device for passthrough by its vendor ID, typically used together with `source.product`.
        :param _builtins.str start_up_policy: Sets how strictly libvirt enforces the presence of the USB device at startup; accepts values like `mandatory`, `requisite`, or `optional` depending on libvirt support.
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        :param 'DomainDevicesHostdevSubsysUsbSourceVendorArgs' vendor: Selects a USB device for passthrough by its vendor ID, typically used together with `source.product`.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if guest_reset is not None:
            pulumi.set(__self__, "guest_reset", guest_reset)
        if product is not None:
            pulumi.set(__self__, "product", product)
        if start_up_policy is not None:
            pulumi.set(__self__, "start_up_policy", start_up_policy)
        if vendor is not None:
            pulumi.set(__self__, "vendor", vendor)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesHostdevSubsysUsbSourceAddress']:
        """
        Specifies the physical USB topology of the host device (bus, device, and/or port) used to select which USB device is passed through.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="guestReset")
    def guest_reset(self) -> Optional[_builtins.str]:
        """
        Controls whether a reset is issued to the USB device when it is assigned or re-assigned to the guest; value is user-provided (typically `on`/`off` or `yes`/`no` depending on libvirt version).

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "guest_reset")

    @_builtins.property
    @pulumi.getter
    def product(self) -> Optional['outputs.DomainDevicesHostdevSubsysUsbSourceProduct']:
        """
        Selects a USB device for passthrough by its vendor ID, typically used together with `source.product`.
        """
        return pulumi.get(self, "product")

    @_builtins.property
    @pulumi.getter(name="startUpPolicy")
    def start_up_policy(self) -> Optional[_builtins.str]:
        """
        Sets how strictly libvirt enforces the presence of the USB device at startup; accepts values like `mandatory`, `requisite`, or `optional` depending on libvirt support.

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "start_up_policy")

    @_builtins.property
    @pulumi.getter
    def vendor(self) -> Optional['outputs.DomainDevicesHostdevSubsysUsbSourceVendor']:
        """
        Selects a USB device for passthrough by its vendor ID, typically used together with `source.product`.
        """
        return pulumi.get(self, "vendor")


@pulumi.output_type
class DomainDevicesHostdevSubsysUsbSourceAddress(dict):
    def __init__(__self__, *,
                 bus: Optional[_builtins.float] = None,
                 device: Optional[_builtins.float] = None,
                 port: Optional[_builtins.str] = None):
        """
        :param _builtins.float bus: Sets the numeric USB bus on the host where the device is attached; value is user-provided as reported by tools like `lsusb` (for example, `1`).
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        :param _builtins.float device: Sets the numeric USB device number on the selected bus; value is user-provided based on host enumeration (for example, `2`).
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        :param _builtins.str port: Sets the USB port path on the host (often a dotseparated string like `1` or `1.2`) to identify the device by its hub/port topology.
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        if bus is not None:
            pulumi.set(__self__, "bus", bus)
        if device is not None:
            pulumi.set(__self__, "device", device)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def bus(self) -> Optional[_builtins.float]:
        """
        Sets the numeric USB bus on the host where the device is attached; value is user-provided as reported by tools like `lsusb` (for example, `1`).

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "bus")

    @_builtins.property
    @pulumi.getter
    def device(self) -> Optional[_builtins.float]:
        """
        Sets the numeric USB device number on the selected bus; value is user-provided based on host enumeration (for example, `2`).

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "device")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        """
        Sets the USB port path on the host (often a dotseparated string like `1` or `1.2`) to identify the device by its hub/port topology.

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DomainDevicesHostdevSubsysUsbSourceProduct(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Reports or sets the USB vendor ID (a 4digit hexadecimal string like `0x046d`) used to match the device; when computed, it is derived from the host device metadata.
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Reports or sets the USB vendor ID (a 4digit hexadecimal string like `0x046d`) used to match the device; when computed, it is derived from the host device metadata.

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class DomainDevicesHostdevSubsysUsbSourceVendor(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Reports or sets the USB vendor ID (a 4digit hexadecimal string like `0x046d`) used to match the device; when computed, it is derived from the host device metadata.
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Reports or sets the USB vendor ID (a 4digit hexadecimal string like `0x046d`) used to match the device; when computed, it is derived from the host device metadata.

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class DomainDevicesHub(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 acpi: Optional['outputs.DomainDevicesHubAcpi'] = None,
                 address: Optional['outputs.DomainDevicesHubAddress'] = None,
                 alias: Optional['outputs.DomainDevicesHubAlias'] = None):
        """
        :param _builtins.str type: Specifies the hub type, typically the bus on which the hub is implemented (for example, `usb`); value is user-provided but must be supported by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#hub-devices>
        :param 'DomainDevicesHubAcpiArgs' acpi: Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        :param 'DomainDevicesHubAddressArgs' address: Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        :param 'DomainDevicesHubAliasArgs' alias: Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        pulumi.set(__self__, "type", type)
        if acpi is not None:
            pulumi.set(__self__, "acpi", acpi)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the hub type, typically the bus on which the hub is implemented (for example, `usb`); value is user-provided but must be supported by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#hub-devices>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def acpi(self) -> Optional['outputs.DomainDevicesHubAcpi']:
        """
        Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        """
        return pulumi.get(self, "acpi")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesHubAddress']:
        """
        Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional['outputs.DomainDevicesHubAlias']:
        """
        Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        return pulumi.get(self, "alias")


@pulumi.output_type
class DomainDevicesHubAcpi(dict):
    def __init__(__self__, *,
                 index: Optional[_builtins.float] = None):
        """
        :param _builtins.float index: Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        """
        if index is not None:
            pulumi.set(__self__, "index", index)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "index")


@pulumi.output_type
class DomainDevicesHubAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesHubAlias(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
               
               See: <https://libvirt.org/formatdomain.html#devices>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesInput(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 acpi: Optional['outputs.DomainDevicesInputAcpi'] = None,
                 address: Optional['outputs.DomainDevicesInputAddress'] = None,
                 alias: Optional['outputs.DomainDevicesInputAlias'] = None,
                 bus: Optional[_builtins.str] = None,
                 driver: Optional['outputs.DomainDevicesInputDriver'] = None,
                 model: Optional[_builtins.str] = None,
                 source: Optional['outputs.DomainDevicesInputSource'] = None):
        """
        :param _builtins.str type: Sets the type of input device attached to the guest (for example, tablet, mouse, keyboard); value is user-provided and must be supported by the chosen hypervisor. Example: "tablet" for a USB graphics-tablet-style pointing device.
               
               See: <https://libvirt.org/formatdomain.html#input-devices>
        :param 'DomainDevicesInputAcpiArgs' acpi: Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        :param 'DomainDevicesInputAddressArgs' address: Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        :param 'DomainDevicesInputAliasArgs' alias: Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        :param _builtins.str bus: Selects the bus on which the input device is exposed to the guest, such as "ps2", "usb", "virtio", or "xen" depending on the guest type and model.
               
               See: <https://libvirt.org/formatdomain.html#input-devices>
        :param 'DomainDevicesInputDriverArgs' driver: Configures optional driver-specific settings for this input device, including virtio transport options when using a virtio-based model.
        :param _builtins.str model: Selects the emulated input device model (for example, "ps2", "usb-tablet", "virtio-mouse", or "virtio-keyboard"), determining how the guest OS sees this input device.
               
               See: <https://libvirt.org/formatdomain.html#input-devices>
        :param 'DomainDevicesInputSourceArgs' source: Configures the host-side source backing this input device, such as an evdev device or passthrough from a host input device.
        """
        pulumi.set(__self__, "type", type)
        if acpi is not None:
            pulumi.set(__self__, "acpi", acpi)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if bus is not None:
            pulumi.set(__self__, "bus", bus)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets the type of input device attached to the guest (for example, tablet, mouse, keyboard); value is user-provided and must be supported by the chosen hypervisor. Example: "tablet" for a USB graphics-tablet-style pointing device.

        See: <https://libvirt.org/formatdomain.html#input-devices>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def acpi(self) -> Optional['outputs.DomainDevicesInputAcpi']:
        """
        Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        """
        return pulumi.get(self, "acpi")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesInputAddress']:
        """
        Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional['outputs.DomainDevicesInputAlias']:
        """
        Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def bus(self) -> Optional[_builtins.str]:
        """
        Selects the bus on which the input device is exposed to the guest, such as "ps2", "usb", "virtio", or "xen" depending on the guest type and model.

        See: <https://libvirt.org/formatdomain.html#input-devices>
        """
        return pulumi.get(self, "bus")

    @_builtins.property
    @pulumi.getter
    def driver(self) -> Optional['outputs.DomainDevicesInputDriver']:
        """
        Configures optional driver-specific settings for this input device, including virtio transport options when using a virtio-based model.
        """
        return pulumi.get(self, "driver")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the emulated input device model (for example, "ps2", "usb-tablet", "virtio-mouse", or "virtio-keyboard"), determining how the guest OS sees this input device.

        See: <https://libvirt.org/formatdomain.html#input-devices>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainDevicesInputSource']:
        """
        Configures the host-side source backing this input device, such as an evdev device or passthrough from a host input device.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class DomainDevicesInputAcpi(dict):
    def __init__(__self__, *,
                 index: Optional[_builtins.float] = None):
        """
        :param _builtins.float index: Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        """
        if index is not None:
            pulumi.set(__self__, "index", index)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "index")


@pulumi.output_type
class DomainDevicesInputAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesInputAlias(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
               
               See: <https://libvirt.org/formatdomain.html#devices>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesInputDriver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pagePerVq":
            suggest = "page_per_vq"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInputDriver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInputDriver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInputDriver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ats: Optional[_builtins.str] = None,
                 iommu: Optional[_builtins.str] = None,
                 packed: Optional[_builtins.str] = None,
                 page_per_vq: Optional[_builtins.str] = None):
        """
        :param _builtins.str ats: Enables or disables Address Translation Services (ATS) for a virtio input device, using "on" or "off" when the device is behind an emulated IOMMU.
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.str iommu: Enables or disables use of an emulated IOMMU for this virtio input device, typically with "on" or "off" when integrating with a guest IOMMU.
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.str packed: Toggles use of packed virtqueue format for this virtio input device, usually set to "on" or "off" to match guest driver capabilities.
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.str page_per_vq: Controls whether each virtqueue of this virtio input device uses a separate page-table mapping, typically "on" or "off" for finegrained IOMMU mapping.
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        if ats is not None:
            pulumi.set(__self__, "ats", ats)
        if iommu is not None:
            pulumi.set(__self__, "iommu", iommu)
        if packed is not None:
            pulumi.set(__self__, "packed", packed)
        if page_per_vq is not None:
            pulumi.set(__self__, "page_per_vq", page_per_vq)

    @_builtins.property
    @pulumi.getter
    def ats(self) -> Optional[_builtins.str]:
        """
        Enables or disables Address Translation Services (ATS) for a virtio input device, using "on" or "off" when the device is behind an emulated IOMMU.

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "ats")

    @_builtins.property
    @pulumi.getter
    def iommu(self) -> Optional[_builtins.str]:
        """
        Enables or disables use of an emulated IOMMU for this virtio input device, typically with "on" or "off" when integrating with a guest IOMMU.

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "iommu")

    @_builtins.property
    @pulumi.getter
    def packed(self) -> Optional[_builtins.str]:
        """
        Toggles use of packed virtqueue format for this virtio input device, usually set to "on" or "off" to match guest driver capabilities.

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "packed")

    @_builtins.property
    @pulumi.getter(name="pagePerVq")
    def page_per_vq(self) -> Optional[_builtins.str]:
        """
        Controls whether each virtqueue of this virtio input device uses a separate page-table mapping, typically "on" or "off" for finegrained IOMMU mapping.

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "page_per_vq")


@pulumi.output_type
class DomainDevicesInputSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evDev":
            suggest = "ev_dev"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInputSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInputSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInputSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ev_dev: Optional['outputs.DomainDevicesInputSourceEvDev'] = None,
                 passthrough: Optional['outputs.DomainDevicesInputSourcePassthrough'] = None):
        """
        :param 'DomainDevicesInputSourceEvDevArgs' ev_dev: Attaches the input device to a host evdev device node, allowing direct passthrough of events from that device to the guest.
        :param 'DomainDevicesInputSourcePassthroughArgs' passthrough: Configures the input device as a passthrough device using a host evdev path, allowing low-level event forwarding directly to the guest.
        """
        if ev_dev is not None:
            pulumi.set(__self__, "ev_dev", ev_dev)
        if passthrough is not None:
            pulumi.set(__self__, "passthrough", passthrough)

    @_builtins.property
    @pulumi.getter(name="evDev")
    def ev_dev(self) -> Optional['outputs.DomainDevicesInputSourceEvDev']:
        """
        Attaches the input device to a host evdev device node, allowing direct passthrough of events from that device to the guest.
        """
        return pulumi.get(self, "ev_dev")

    @_builtins.property
    @pulumi.getter
    def passthrough(self) -> Optional['outputs.DomainDevicesInputSourcePassthrough']:
        """
        Configures the input device as a passthrough device using a host evdev path, allowing low-level event forwarding directly to the guest.
        """
        return pulumi.get(self, "passthrough")


@pulumi.output_type
class DomainDevicesInputSourceEvDev(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grabToggle":
            suggest = "grab_toggle"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInputSourceEvDev. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInputSourceEvDev.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInputSourceEvDev.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dev: _builtins.str,
                 grab: Optional[_builtins.str] = None,
                 grab_toggle: Optional[_builtins.str] = None,
                 repeat: Optional[_builtins.str] = None):
        """
        :param _builtins.str dev: Specifies the mandatory path to the host evdev device node (for example, "/dev/input/event3") that backs this input device.
               
               See: <https://libvirt.org/formatdomain.html#input-devices>
        :param _builtins.str grab: Controls whether libvirt/QEMU grabs exclusive access to the host evdev device ("yes" or "no"), preventing it from being used by the host while attached to the guest.
               
               See: <https://libvirt.org/formatdomain.html#input-devices>
        :param _builtins.str grab_toggle: Enables or disables hotkey-based toggling of the grab state for the evdev device, typically using "yes" or "no" if supported.
               
               See: <https://libvirt.org/formatdomain.html#input-devices>
        :param _builtins.str repeat: Controls whether key repeat is handled for this evdev-based input device ("yes" or "no"), affecting how held keys generate repeated events in the guest.
               
               See: <https://libvirt.org/formatdomain.html#input-devices>
        """
        pulumi.set(__self__, "dev", dev)
        if grab is not None:
            pulumi.set(__self__, "grab", grab)
        if grab_toggle is not None:
            pulumi.set(__self__, "grab_toggle", grab_toggle)
        if repeat is not None:
            pulumi.set(__self__, "repeat", repeat)

    @_builtins.property
    @pulumi.getter
    def dev(self) -> _builtins.str:
        """
        Specifies the mandatory path to the host evdev device node (for example, "/dev/input/event3") that backs this input device.

        See: <https://libvirt.org/formatdomain.html#input-devices>
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter
    def grab(self) -> Optional[_builtins.str]:
        """
        Controls whether libvirt/QEMU grabs exclusive access to the host evdev device ("yes" or "no"), preventing it from being used by the host while attached to the guest.

        See: <https://libvirt.org/formatdomain.html#input-devices>
        """
        return pulumi.get(self, "grab")

    @_builtins.property
    @pulumi.getter(name="grabToggle")
    def grab_toggle(self) -> Optional[_builtins.str]:
        """
        Enables or disables hotkey-based toggling of the grab state for the evdev device, typically using "yes" or "no" if supported.

        See: <https://libvirt.org/formatdomain.html#input-devices>
        """
        return pulumi.get(self, "grab_toggle")

    @_builtins.property
    @pulumi.getter
    def repeat(self) -> Optional[_builtins.str]:
        """
        Controls whether key repeat is handled for this evdev-based input device ("yes" or "no"), affecting how held keys generate repeated events in the guest.

        See: <https://libvirt.org/formatdomain.html#input-devices>
        """
        return pulumi.get(self, "repeat")


@pulumi.output_type
class DomainDevicesInputSourcePassthrough(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evDev":
            suggest = "ev_dev"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInputSourcePassthrough. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInputSourcePassthrough.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInputSourcePassthrough.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ev_dev: _builtins.str):
        """
        :param _builtins.str ev_dev: Specifies the mandatory path to the host evdev device node used for passthrough (for example, "/dev/input/event5"); the value is a user-provided absolute device path.
               
               See: <https://libvirt.org/formatdomain.html#input-devices>
        """
        pulumi.set(__self__, "ev_dev", ev_dev)

    @_builtins.property
    @pulumi.getter(name="evDev")
    def ev_dev(self) -> _builtins.str:
        """
        Specifies the mandatory path to the host evdev device node used for passthrough (for example, "/dev/input/event5"); the value is a user-provided absolute device path.

        See: <https://libvirt.org/formatdomain.html#input-devices>
        """
        return pulumi.get(self, "ev_dev")


@pulumi.output_type
class DomainDevicesInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendDomain":
            suggest = "backend_domain"
        elif key == "downScript":
            suggest = "down_script"
        elif key == "filterRef":
            suggest = "filter_ref"
        elif key == "portForwards":
            suggest = "port_forwards"
        elif key == "portOptions":
            suggest = "port_options"
        elif key == "trustGuestRxFilters":
            suggest = "trust_guest_rx_filters"
        elif key == "virtualPort":
            suggest = "virtual_port"
        elif key == "waitForIp":
            suggest = "wait_for_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acpi: Optional['outputs.DomainDevicesInterfaceAcpi'] = None,
                 address: Optional['outputs.DomainDevicesInterfaceAddress'] = None,
                 alias: Optional['outputs.DomainDevicesInterfaceAlias'] = None,
                 backend: Optional['outputs.DomainDevicesInterfaceBackend'] = None,
                 backend_domain: Optional['outputs.DomainDevicesInterfaceBackendDomain'] = None,
                 bandwidth: Optional['outputs.DomainDevicesInterfaceBandwidth'] = None,
                 boot: Optional['outputs.DomainDevicesInterfaceBoot'] = None,
                 coalesce: Optional['outputs.DomainDevicesInterfaceCoalesce'] = None,
                 down_script: Optional['outputs.DomainDevicesInterfaceDownScript'] = None,
                 driver: Optional['outputs.DomainDevicesInterfaceDriver'] = None,
                 filter_ref: Optional['outputs.DomainDevicesInterfaceFilterRef'] = None,
                 guest: Optional['outputs.DomainDevicesInterfaceGuest'] = None,
                 ips: Optional[Sequence['outputs.DomainDevicesInterfaceIp']] = None,
                 link: Optional['outputs.DomainDevicesInterfaceLink'] = None,
                 mac: Optional['outputs.DomainDevicesInterfaceMac'] = None,
                 managed: Optional[_builtins.bool] = None,
                 model: Optional['outputs.DomainDevicesInterfaceModel'] = None,
                 mtu: Optional['outputs.DomainDevicesInterfaceMtu'] = None,
                 port_forwards: Optional[Sequence['outputs.DomainDevicesInterfacePortForward']] = None,
                 port_options: Optional['outputs.DomainDevicesInterfacePortOptions'] = None,
                 rom: Optional['outputs.DomainDevicesInterfaceRom'] = None,
                 routes: Optional[Sequence['outputs.DomainDevicesInterfaceRoute']] = None,
                 script: Optional['outputs.DomainDevicesInterfaceScript'] = None,
                 source: Optional['outputs.DomainDevicesInterfaceSource'] = None,
                 target: Optional['outputs.DomainDevicesInterfaceTarget'] = None,
                 teaming: Optional['outputs.DomainDevicesInterfaceTeaming'] = None,
                 trust_guest_rx_filters: Optional[_builtins.str] = None,
                 tune: Optional['outputs.DomainDevicesInterfaceTune'] = None,
                 virtual_port: Optional['outputs.DomainDevicesInterfaceVirtualPort'] = None,
                 vlan: Optional['outputs.DomainDevicesInterfaceVlan'] = None,
                 wait_for_ip: Optional['outputs.DomainDevicesInterfaceWaitForIp'] = None):
        """
        :param 'DomainDevicesInterfaceAcpiArgs' acpi: Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        :param 'DomainDevicesInterfaceAddressArgs' address: Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        :param 'DomainDevicesInterfaceAliasArgs' alias: Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        :param 'DomainDevicesInterfaceBackendArgs' backend: Configures driver/backend-specific networking options for this interface, such as vhost device path or tap device name.
        :param 'DomainDevicesInterfaceBackendDomainArgs' backend_domain: Attaches the interfaces network backend to a separate driver/backend domain instead of the main host, enabling driver-domain networking setups.
        :param 'DomainDevicesInterfaceBandwidthArgs' bandwidth: Enables per-interface bandwidth quality-of-service limits and priorities for this network interface.
        :param 'DomainDevicesInterfaceBootArgs' boot: Enables boot-order control for this redirected device, allowing it to participate in the device boot sequence.
        :param 'DomainDevicesInterfaceCoalesceArgs' coalesce: Configures coalescing behavior for this interface, allowing control over how packets are grouped before being delivered.
        :param 'DomainDevicesInterfaceDownScriptArgs' down_script: Configures a custom script to be executed when this interface is brought down on the host side.
        :param 'DomainDevicesInterfaceDriverArgs' driver: Configures driverspecific options for this interface, including virtio transport and offload features.
        :param 'DomainDevicesInterfaceFilterRefArgs' filter_ref: Attaches a network filter profile (nwfilter) to the interface, allowing libvirt to enforce traffic filtering rules on this NIC.
        :param 'DomainDevicesInterfaceGuestArgs' guest: Describes how the interface appears inside the guest, including its guest-visible device name and, optionally, the actual device name.
        :param Sequence['DomainDevicesInterfaceIpArgs'] ips: Assigns one or more IP addresses directly to the guest-side interface, including address family, prefix length, and optional peer address.
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        :param 'DomainDevicesInterfaceLinkArgs' link: Controls the administrative link state of the virtual NIC as seen by the guest.
        :param 'DomainDevicesInterfaceMacArgs' mac: Configures the MAC layer attributes for the interface, including its hardware address and optional duplicate-address check behavior.
        :param _builtins.bool managed: Controls whether libvirt manages the lifecycle of the host-side interface (e.g., tap/macvtap); boolean expressed as "yes" or "no", and when omitted libvirt uses its default behavior.
               
               See: <https://libvirt.org/formatdomain.html#network-interfaces>
        :param 'DomainDevicesInterfaceModelArgs' model: Configures the emulated NIC model for the interface, via a nested block that selects the device type (e.g., virtio, e1000).
        :param 'DomainDevicesInterfaceMtuArgs' mtu: Configures MTU settings for the interface via a nested block.
        :param Sequence['DomainDevicesInterfacePortForwardArgs'] port_forwards: Configures host-to-guest port forwarding when using a userspace backend that supports passt; contains address, device, protocol, and port ranges.
               
               See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
        :param 'DomainDevicesInterfacePortOptionsArgs' port_options: Configures per-interface port options (such as isolation) for this NIC.
        :param 'DomainDevicesInterfaceRomArgs' rom: Configures an optional PCI ROM image for the passthrough host device, including whether it is enabled, where it is mapped, and an alternate ROM file.
        :param Sequence['DomainDevicesInterfaceRouteArgs'] routes: Defines a static route associated with this network interface inside the guest, specifying destination, gateway, and related routing parameters.
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        :param 'DomainDevicesInterfaceScriptArgs' script: Configures a custom script to be executed when this interface is brought down on the host side.
        :param 'DomainDevicesInterfaceSourceArgs' source: Selects and configures the backend connectivity source for the interface (such as bridge, direct, user-mode networking, or tunnels).
        :param 'DomainDevicesInterfaceTargetArgs' target: Controls the guest-side interface target settings, such as the name of the tap or virtio-net device visible to the host and/or guest.
        :param 'DomainDevicesInterfaceTeamingArgs' teaming: Configures this PCI hostdev as part of an interface teaming/bonding setup in the guest, pairing it with another interface for failover.
        :param _builtins.str trust_guest_rx_filters: Controls whether the host trusts the guest to configure its own receive packet filters; value is user-provided (commonly "yes" or "no").
               
               See: <https://libvirt.org/formatdomain.html#network-interfaces>
        :param 'DomainDevicesInterfaceTuneArgs' tune: Configures network interface tuning parameters such as socket buffer sizes and backend-specific settings.
        :param 'DomainDevicesInterfaceVirtualPortArgs' virtual_port: Configures virtual port profile information for the interface, used with advanced network setups such as Open vSwitch or SR-IOV.
        :param 'DomainDevicesInterfaceVlanArgs' vlan: Configures one or more VLAN tags for the interface; when present, the interface traffic is tagged according to the contained tag blocks, optionally in trunk mode.
        """
        if acpi is not None:
            pulumi.set(__self__, "acpi", acpi)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if backend is not None:
            pulumi.set(__self__, "backend", backend)
        if backend_domain is not None:
            pulumi.set(__self__, "backend_domain", backend_domain)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if boot is not None:
            pulumi.set(__self__, "boot", boot)
        if coalesce is not None:
            pulumi.set(__self__, "coalesce", coalesce)
        if down_script is not None:
            pulumi.set(__self__, "down_script", down_script)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if filter_ref is not None:
            pulumi.set(__self__, "filter_ref", filter_ref)
        if guest is not None:
            pulumi.set(__self__, "guest", guest)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if managed is not None:
            pulumi.set(__self__, "managed", managed)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if port_forwards is not None:
            pulumi.set(__self__, "port_forwards", port_forwards)
        if port_options is not None:
            pulumi.set(__self__, "port_options", port_options)
        if rom is not None:
            pulumi.set(__self__, "rom", rom)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if script is not None:
            pulumi.set(__self__, "script", script)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if teaming is not None:
            pulumi.set(__self__, "teaming", teaming)
        if trust_guest_rx_filters is not None:
            pulumi.set(__self__, "trust_guest_rx_filters", trust_guest_rx_filters)
        if tune is not None:
            pulumi.set(__self__, "tune", tune)
        if virtual_port is not None:
            pulumi.set(__self__, "virtual_port", virtual_port)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)
        if wait_for_ip is not None:
            pulumi.set(__self__, "wait_for_ip", wait_for_ip)

    @_builtins.property
    @pulumi.getter
    def acpi(self) -> Optional['outputs.DomainDevicesInterfaceAcpi']:
        """
        Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        """
        return pulumi.get(self, "acpi")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesInterfaceAddress']:
        """
        Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional['outputs.DomainDevicesInterfaceAlias']:
        """
        Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def backend(self) -> Optional['outputs.DomainDevicesInterfaceBackend']:
        """
        Configures driver/backend-specific networking options for this interface, such as vhost device path or tap device name.
        """
        return pulumi.get(self, "backend")

    @_builtins.property
    @pulumi.getter(name="backendDomain")
    def backend_domain(self) -> Optional['outputs.DomainDevicesInterfaceBackendDomain']:
        """
        Attaches the interfaces network backend to a separate driver/backend domain instead of the main host, enabling driver-domain networking setups.
        """
        return pulumi.get(self, "backend_domain")

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> Optional['outputs.DomainDevicesInterfaceBandwidth']:
        """
        Enables per-interface bandwidth quality-of-service limits and priorities for this network interface.
        """
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter
    def boot(self) -> Optional['outputs.DomainDevicesInterfaceBoot']:
        """
        Enables boot-order control for this redirected device, allowing it to participate in the device boot sequence.
        """
        return pulumi.get(self, "boot")

    @_builtins.property
    @pulumi.getter
    def coalesce(self) -> Optional['outputs.DomainDevicesInterfaceCoalesce']:
        """
        Configures coalescing behavior for this interface, allowing control over how packets are grouped before being delivered.
        """
        return pulumi.get(self, "coalesce")

    @_builtins.property
    @pulumi.getter(name="downScript")
    def down_script(self) -> Optional['outputs.DomainDevicesInterfaceDownScript']:
        """
        Configures a custom script to be executed when this interface is brought down on the host side.
        """
        return pulumi.get(self, "down_script")

    @_builtins.property
    @pulumi.getter
    def driver(self) -> Optional['outputs.DomainDevicesInterfaceDriver']:
        """
        Configures driverspecific options for this interface, including virtio transport and offload features.
        """
        return pulumi.get(self, "driver")

    @_builtins.property
    @pulumi.getter(name="filterRef")
    def filter_ref(self) -> Optional['outputs.DomainDevicesInterfaceFilterRef']:
        """
        Attaches a network filter profile (nwfilter) to the interface, allowing libvirt to enforce traffic filtering rules on this NIC.
        """
        return pulumi.get(self, "filter_ref")

    @_builtins.property
    @pulumi.getter
    def guest(self) -> Optional['outputs.DomainDevicesInterfaceGuest']:
        """
        Describes how the interface appears inside the guest, including its guest-visible device name and, optionally, the actual device name.
        """
        return pulumi.get(self, "guest")

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Optional[Sequence['outputs.DomainDevicesInterfaceIp']]:
        """
        Assigns one or more IP addresses directly to the guest-side interface, including address family, prefix length, and optional peer address.

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "ips")

    @_builtins.property
    @pulumi.getter
    def link(self) -> Optional['outputs.DomainDevicesInterfaceLink']:
        """
        Controls the administrative link state of the virtual NIC as seen by the guest.
        """
        return pulumi.get(self, "link")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> Optional['outputs.DomainDevicesInterfaceMac']:
        """
        Configures the MAC layer attributes for the interface, including its hardware address and optional duplicate-address check behavior.
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter
    def managed(self) -> Optional[_builtins.bool]:
        """
        Controls whether libvirt manages the lifecycle of the host-side interface (e.g., tap/macvtap); boolean expressed as "yes" or "no", and when omitted libvirt uses its default behavior.

        See: <https://libvirt.org/formatdomain.html#network-interfaces>
        """
        return pulumi.get(self, "managed")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional['outputs.DomainDevicesInterfaceModel']:
        """
        Configures the emulated NIC model for the interface, via a nested block that selects the device type (e.g., virtio, e1000).
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def mtu(self) -> Optional['outputs.DomainDevicesInterfaceMtu']:
        """
        Configures MTU settings for the interface via a nested block.
        """
        return pulumi.get(self, "mtu")

    @_builtins.property
    @pulumi.getter(name="portForwards")
    def port_forwards(self) -> Optional[Sequence['outputs.DomainDevicesInterfacePortForward']]:
        """
        Configures host-to-guest port forwarding when using a userspace backend that supports passt; contains address, device, protocol, and port ranges.

        See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
        """
        return pulumi.get(self, "port_forwards")

    @_builtins.property
    @pulumi.getter(name="portOptions")
    def port_options(self) -> Optional['outputs.DomainDevicesInterfacePortOptions']:
        """
        Configures per-interface port options (such as isolation) for this NIC.
        """
        return pulumi.get(self, "port_options")

    @_builtins.property
    @pulumi.getter
    def rom(self) -> Optional['outputs.DomainDevicesInterfaceRom']:
        """
        Configures an optional PCI ROM image for the passthrough host device, including whether it is enabled, where it is mapped, and an alternate ROM file.
        """
        return pulumi.get(self, "rom")

    @_builtins.property
    @pulumi.getter
    def routes(self) -> Optional[Sequence['outputs.DomainDevicesInterfaceRoute']]:
        """
        Defines a static route associated with this network interface inside the guest, specifying destination, gateway, and related routing parameters.

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "routes")

    @_builtins.property
    @pulumi.getter
    def script(self) -> Optional['outputs.DomainDevicesInterfaceScript']:
        """
        Configures a custom script to be executed when this interface is brought down on the host side.
        """
        return pulumi.get(self, "script")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainDevicesInterfaceSource']:
        """
        Selects and configures the backend connectivity source for the interface (such as bridge, direct, user-mode networking, or tunnels).
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional['outputs.DomainDevicesInterfaceTarget']:
        """
        Controls the guest-side interface target settings, such as the name of the tap or virtio-net device visible to the host and/or guest.
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def teaming(self) -> Optional['outputs.DomainDevicesInterfaceTeaming']:
        """
        Configures this PCI hostdev as part of an interface teaming/bonding setup in the guest, pairing it with another interface for failover.
        """
        return pulumi.get(self, "teaming")

    @_builtins.property
    @pulumi.getter(name="trustGuestRxFilters")
    def trust_guest_rx_filters(self) -> Optional[_builtins.str]:
        """
        Controls whether the host trusts the guest to configure its own receive packet filters; value is user-provided (commonly "yes" or "no").

        See: <https://libvirt.org/formatdomain.html#network-interfaces>
        """
        return pulumi.get(self, "trust_guest_rx_filters")

    @_builtins.property
    @pulumi.getter
    def tune(self) -> Optional['outputs.DomainDevicesInterfaceTune']:
        """
        Configures network interface tuning parameters such as socket buffer sizes and backend-specific settings.
        """
        return pulumi.get(self, "tune")

    @_builtins.property
    @pulumi.getter(name="virtualPort")
    def virtual_port(self) -> Optional['outputs.DomainDevicesInterfaceVirtualPort']:
        """
        Configures virtual port profile information for the interface, used with advanced network setups such as Open vSwitch or SR-IOV.
        """
        return pulumi.get(self, "virtual_port")

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> Optional['outputs.DomainDevicesInterfaceVlan']:
        """
        Configures one or more VLAN tags for the interface; when present, the interface traffic is tagged according to the contained tag blocks, optionally in trunk mode.
        """
        return pulumi.get(self, "vlan")

    @_builtins.property
    @pulumi.getter(name="waitForIp")
    def wait_for_ip(self) -> Optional['outputs.DomainDevicesInterfaceWaitForIp']:
        return pulumi.get(self, "wait_for_ip")


@pulumi.output_type
class DomainDevicesInterfaceAcpi(dict):
    def __init__(__self__, *,
                 index: Optional[_builtins.float] = None):
        """
        :param _builtins.float index: Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        """
        if index is not None:
            pulumi.set(__self__, "index", index)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "index")


@pulumi.output_type
class DomainDevicesInterfaceAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesInterfaceAlias(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
               
               See: <https://libvirt.org/formatdomain.html#devices>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesInterfaceBackend(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logFile":
            suggest = "log_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceBackend. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceBackend.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceBackend.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_file: Optional[_builtins.str] = None,
                 tap: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 vhost: Optional[_builtins.str] = None):
        """
        :param _builtins.str log_file: Sets a path to a host log file where backend-related messages for this interface are written; value is a user-provided filesystem path.
               
               See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
        :param _builtins.str tap: Specifies the tap device to be used by the backend instead of one automatically created (for example, "tap0"); value is a user-provided interface name.
               
               See: <https://libvirt.org/formatdomain.html#setting-network-backend-specific-options>
        :param _builtins.str type: Selects the backend implementation type (for example, "passt" for a passt userspace backend); value must match a backend type supported by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
        :param _builtins.str vhost: Overrides the default vhost device path for this interfaces backend (for example, "/dev/vhost-net"); value is a user-provided path.
               
               See: <https://libvirt.org/formatdomain.html#setting-network-backend-specific-options>
        """
        if log_file is not None:
            pulumi.set(__self__, "log_file", log_file)
        if tap is not None:
            pulumi.set(__self__, "tap", tap)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vhost is not None:
            pulumi.set(__self__, "vhost", vhost)

    @_builtins.property
    @pulumi.getter(name="logFile")
    def log_file(self) -> Optional[_builtins.str]:
        """
        Sets a path to a host log file where backend-related messages for this interface are written; value is a user-provided filesystem path.

        See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
        """
        return pulumi.get(self, "log_file")

    @_builtins.property
    @pulumi.getter
    def tap(self) -> Optional[_builtins.str]:
        """
        Specifies the tap device to be used by the backend instead of one automatically created (for example, "tap0"); value is a user-provided interface name.

        See: <https://libvirt.org/formatdomain.html#setting-network-backend-specific-options>
        """
        return pulumi.get(self, "tap")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Selects the backend implementation type (for example, "passt" for a passt userspace backend); value must match a backend type supported by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def vhost(self) -> Optional[_builtins.str]:
        """
        Overrides the default vhost device path for this interfaces backend (for example, "/dev/vhost-net"); value is a user-provided path.

        See: <https://libvirt.org/formatdomain.html#setting-network-backend-specific-options>
        """
        return pulumi.get(self, "vhost")


@pulumi.output_type
class DomainDevicesInterfaceBackendDomain(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the name of the backend (driver) domain that will host the network backend for this interface; value must match an existing domain name.
               
               See: <https://libvirt.org/formatdomain.html#setting-up-a-network-backend-in-a-driver-domain>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the name of the backend (driver) domain that will host the network backend for this interface; value must match an existing domain name.

        See: <https://libvirt.org/formatdomain.html#setting-up-a-network-backend-in-a-driver-domain>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesInterfaceBandwidth(dict):
    def __init__(__self__, *,
                 inbound: Optional['outputs.DomainDevicesInterfaceBandwidthInbound'] = None,
                 outbound: Optional['outputs.DomainDevicesInterfaceBandwidthOutbound'] = None):
        """
        :param 'DomainDevicesInterfaceBandwidthInboundArgs' inbound: Configures outbound traffic shaping limits for this interface, allowing you to restrict or prioritize egress bandwidth using the child attributes.
        :param 'DomainDevicesInterfaceBandwidthOutboundArgs' outbound: Configures outbound traffic shaping limits for this interface, allowing you to restrict or prioritize egress bandwidth using the child attributes.
        """
        if inbound is not None:
            pulumi.set(__self__, "inbound", inbound)
        if outbound is not None:
            pulumi.set(__self__, "outbound", outbound)

    @_builtins.property
    @pulumi.getter
    def inbound(self) -> Optional['outputs.DomainDevicesInterfaceBandwidthInbound']:
        """
        Configures outbound traffic shaping limits for this interface, allowing you to restrict or prioritize egress bandwidth using the child attributes.
        """
        return pulumi.get(self, "inbound")

    @_builtins.property
    @pulumi.getter
    def outbound(self) -> Optional['outputs.DomainDevicesInterfaceBandwidthOutbound']:
        """
        Configures outbound traffic shaping limits for this interface, allowing you to restrict or prioritize egress bandwidth using the child attributes.
        """
        return pulumi.get(self, "outbound")


@pulumi.output_type
class DomainDevicesInterfaceBandwidthInbound(dict):
    def __init__(__self__, *,
                 average: Optional[_builtins.float] = None,
                 burst: Optional[_builtins.float] = None,
                 floor: Optional[_builtins.float] = None,
                 peak: Optional[_builtins.float] = None):
        """
        :param _builtins.float average: Sets the longterm average outbound bandwidth for this interface in kilobytes per second; the hypervisor shapes egress traffic around this sustained rate.
               
               See: <https://libvirt.org/formatdomain.html#quality-of-service>
        :param _builtins.float burst: Sets the maximum size of a temporary outbound bandwidth burst, in kilobytes, that can exceed the average rate before throttling applies.
               
               See: <https://libvirt.org/formatdomain.html#quality-of-service>
        :param _builtins.float floor: Sets a minimum guaranteed outbound bandwidth for this interface in kilobytes per second, below which the traffic should not be throttled if capacity is available.
               
               See: <https://libvirt.org/formatdomain.html#quality-of-service>
        :param _builtins.float peak: Sets an absolute peak outbound bandwidth limit for this interface in kilobytes per second that cannot be exceeded even during bursts.
               
               See: <https://libvirt.org/formatdomain.html#quality-of-service>
        """
        if average is not None:
            pulumi.set(__self__, "average", average)
        if burst is not None:
            pulumi.set(__self__, "burst", burst)
        if floor is not None:
            pulumi.set(__self__, "floor", floor)
        if peak is not None:
            pulumi.set(__self__, "peak", peak)

    @_builtins.property
    @pulumi.getter
    def average(self) -> Optional[_builtins.float]:
        """
        Sets the longterm average outbound bandwidth for this interface in kilobytes per second; the hypervisor shapes egress traffic around this sustained rate.

        See: <https://libvirt.org/formatdomain.html#quality-of-service>
        """
        return pulumi.get(self, "average")

    @_builtins.property
    @pulumi.getter
    def burst(self) -> Optional[_builtins.float]:
        """
        Sets the maximum size of a temporary outbound bandwidth burst, in kilobytes, that can exceed the average rate before throttling applies.

        See: <https://libvirt.org/formatdomain.html#quality-of-service>
        """
        return pulumi.get(self, "burst")

    @_builtins.property
    @pulumi.getter
    def floor(self) -> Optional[_builtins.float]:
        """
        Sets a minimum guaranteed outbound bandwidth for this interface in kilobytes per second, below which the traffic should not be throttled if capacity is available.

        See: <https://libvirt.org/formatdomain.html#quality-of-service>
        """
        return pulumi.get(self, "floor")

    @_builtins.property
    @pulumi.getter
    def peak(self) -> Optional[_builtins.float]:
        """
        Sets an absolute peak outbound bandwidth limit for this interface in kilobytes per second that cannot be exceeded even during bursts.

        See: <https://libvirt.org/formatdomain.html#quality-of-service>
        """
        return pulumi.get(self, "peak")


@pulumi.output_type
class DomainDevicesInterfaceBandwidthOutbound(dict):
    def __init__(__self__, *,
                 average: Optional[_builtins.float] = None,
                 burst: Optional[_builtins.float] = None,
                 floor: Optional[_builtins.float] = None,
                 peak: Optional[_builtins.float] = None):
        """
        :param _builtins.float average: Sets the longterm average outbound bandwidth for this interface in kilobytes per second; the hypervisor shapes egress traffic around this sustained rate.
               
               See: <https://libvirt.org/formatdomain.html#quality-of-service>
        :param _builtins.float burst: Sets the maximum size of a temporary outbound bandwidth burst, in kilobytes, that can exceed the average rate before throttling applies.
               
               See: <https://libvirt.org/formatdomain.html#quality-of-service>
        :param _builtins.float floor: Sets a minimum guaranteed outbound bandwidth for this interface in kilobytes per second, below which the traffic should not be throttled if capacity is available.
               
               See: <https://libvirt.org/formatdomain.html#quality-of-service>
        :param _builtins.float peak: Sets an absolute peak outbound bandwidth limit for this interface in kilobytes per second that cannot be exceeded even during bursts.
               
               See: <https://libvirt.org/formatdomain.html#quality-of-service>
        """
        if average is not None:
            pulumi.set(__self__, "average", average)
        if burst is not None:
            pulumi.set(__self__, "burst", burst)
        if floor is not None:
            pulumi.set(__self__, "floor", floor)
        if peak is not None:
            pulumi.set(__self__, "peak", peak)

    @_builtins.property
    @pulumi.getter
    def average(self) -> Optional[_builtins.float]:
        """
        Sets the longterm average outbound bandwidth for this interface in kilobytes per second; the hypervisor shapes egress traffic around this sustained rate.

        See: <https://libvirt.org/formatdomain.html#quality-of-service>
        """
        return pulumi.get(self, "average")

    @_builtins.property
    @pulumi.getter
    def burst(self) -> Optional[_builtins.float]:
        """
        Sets the maximum size of a temporary outbound bandwidth burst, in kilobytes, that can exceed the average rate before throttling applies.

        See: <https://libvirt.org/formatdomain.html#quality-of-service>
        """
        return pulumi.get(self, "burst")

    @_builtins.property
    @pulumi.getter
    def floor(self) -> Optional[_builtins.float]:
        """
        Sets a minimum guaranteed outbound bandwidth for this interface in kilobytes per second, below which the traffic should not be throttled if capacity is available.

        See: <https://libvirt.org/formatdomain.html#quality-of-service>
        """
        return pulumi.get(self, "floor")

    @_builtins.property
    @pulumi.getter
    def peak(self) -> Optional[_builtins.float]:
        """
        Sets an absolute peak outbound bandwidth limit for this interface in kilobytes per second that cannot be exceeded even during bursts.

        See: <https://libvirt.org/formatdomain.html#quality-of-service>
        """
        return pulumi.get(self, "peak")


@pulumi.output_type
class DomainDevicesInterfaceBoot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadParm":
            suggest = "load_parm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceBoot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceBoot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceBoot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 order: _builtins.float,
                 load_parm: Optional[_builtins.str] = None):
        """
        :param _builtins.float order: Sets the boot priority for this redirected device, as a positive integer where lower values are tried earlier during guest boot (for example, 1 for first, 2 for second).
               
               See: <https://libvirt.org/formatdomain.html#specifying-boot-order>
        :param _builtins.str load_parm: Sets an optional firmware load parameter string associated with booting from this redirected device, passed to firmware on platforms that support loadparm (e.g. s390x).
               
               See: <https://libvirt.org/formatdomain.html#specifying-boot-order>
        """
        pulumi.set(__self__, "order", order)
        if load_parm is not None:
            pulumi.set(__self__, "load_parm", load_parm)

    @_builtins.property
    @pulumi.getter
    def order(self) -> _builtins.float:
        """
        Sets the boot priority for this redirected device, as a positive integer where lower values are tried earlier during guest boot (for example, 1 for first, 2 for second).

        See: <https://libvirt.org/formatdomain.html#specifying-boot-order>
        """
        return pulumi.get(self, "order")

    @_builtins.property
    @pulumi.getter(name="loadParm")
    def load_parm(self) -> Optional[_builtins.str]:
        """
        Sets an optional firmware load parameter string associated with booting from this redirected device, passed to firmware on platforms that support loadparm (e.g. s390x).

        See: <https://libvirt.org/formatdomain.html#specifying-boot-order>
        """
        return pulumi.get(self, "load_parm")


@pulumi.output_type
class DomainDevicesInterfaceCoalesce(dict):
    def __init__(__self__, *,
                 rx: Optional['outputs.DomainDevicesInterfaceCoalesceRx'] = None):
        """
        :param 'DomainDevicesInterfaceCoalesceRxArgs' rx: Configures receiveside coalescing parameters for this interface.
        """
        if rx is not None:
            pulumi.set(__self__, "rx", rx)

    @_builtins.property
    @pulumi.getter
    def rx(self) -> Optional['outputs.DomainDevicesInterfaceCoalesceRx']:
        """
        Configures receiveside coalescing parameters for this interface.
        """
        return pulumi.get(self, "rx")


@pulumi.output_type
class DomainDevicesInterfaceCoalesceRx(dict):
    def __init__(__self__, *,
                 frames: Optional['outputs.DomainDevicesInterfaceCoalesceRxFrames'] = None):
        """
        :param 'DomainDevicesInterfaceCoalesceRxFramesArgs' frames: Configures coalescing based on the number of received frames before an interrupt or notification is generated.
        """
        if frames is not None:
            pulumi.set(__self__, "frames", frames)

    @_builtins.property
    @pulumi.getter
    def frames(self) -> Optional['outputs.DomainDevicesInterfaceCoalesceRxFrames']:
        """
        Configures coalescing based on the number of received frames before an interrupt or notification is generated.
        """
        return pulumi.get(self, "frames")


@pulumi.output_type
class DomainDevicesInterfaceCoalesceRxFrames(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None):
        """
        :param _builtins.float max: Sets the maximum number of received frames that may be coalesced before triggering processing; value is a nonnegative integer in frames.
               
               See: <https://libvirt.org/formatdomain.html#coalesce-settings>
        """
        if max is not None:
            pulumi.set(__self__, "max", max)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        """
        Sets the maximum number of received frames that may be coalesced before triggering processing; value is a nonnegative integer in frames.

        See: <https://libvirt.org/formatdomain.html#coalesce-settings>
        """
        return pulumi.get(self, "max")


@pulumi.output_type
class DomainDevicesInterfaceDownScript(dict):
    def __init__(__self__, *,
                 path: _builtins.str):
        """
        :param _builtins.str path: Sets the absolute or relative filesystem path to the script that is run when the interface is torn down (for example, "/etc/qemu-ifdown").
               
               See: <https://libvirt.org/formatdomain.html#generic-ethernet-connection>
        """
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the absolute or relative filesystem path to the script that is run when the interface is torn down (for example, "/etc/qemu-ifdown").

        See: <https://libvirt.org/formatdomain.html#generic-ethernet-connection>
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DomainDevicesInterfaceDriver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventIdx":
            suggest = "event_idx"
        elif key == "ioEventFd":
            suggest = "io_event_fd"
        elif key == "pagePerVq":
            suggest = "page_per_vq"
        elif key == "rssHashReport":
            suggest = "rss_hash_report"
        elif key == "rxQueueSize":
            suggest = "rx_queue_size"
        elif key == "txMode":
            suggest = "tx_mode"
        elif key == "txQueueSize":
            suggest = "tx_queue_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceDriver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceDriver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceDriver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ats: Optional[_builtins.str] = None,
                 event_idx: Optional[_builtins.str] = None,
                 guest: Optional['outputs.DomainDevicesInterfaceDriverGuest'] = None,
                 host: Optional['outputs.DomainDevicesInterfaceDriverHost'] = None,
                 io_event_fd: Optional[_builtins.str] = None,
                 iommu: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 packed: Optional[_builtins.str] = None,
                 page_per_vq: Optional[_builtins.str] = None,
                 queues: Optional[_builtins.float] = None,
                 rss: Optional[_builtins.str] = None,
                 rss_hash_report: Optional[_builtins.str] = None,
                 rx_queue_size: Optional[_builtins.float] = None,
                 tx_mode: Optional[_builtins.str] = None,
                 tx_queue_size: Optional[_builtins.float] = None):
        """
        :param _builtins.str ats: Enables or disables Address Translation Service (ATS) for a virtio interface when used with an emulated IOMMU; value is typically "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.str event_idx: Enables or disables virtio event index optimization for this interface; value is typically "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        :param 'DomainDevicesInterfaceDriverGuestArgs' guest: Configures guestvisible offload capabilities advertised by this interfaces driver.
        :param 'DomainDevicesInterfaceDriverHostArgs' host: Groups driver-specific offload and tuning options that apply to the host side of a virtio network interface; individual attributes within this block are user-provided.
        :param _builtins.str io_event_fd: Configures whether ioeventfd is used for the virtio network interface, enabling eventfd-based notification for I/O; value is user-provided, usually a boolean-like on/off.
               
               See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        :param _builtins.str iommu: Configures whether the virtio network device uses an emulated IOMMU for DMA translation; value is user-provided, typically on/off or yes/no.
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.str name: Sets the driver name/type for the network interface backend (for example, a specific vhost or virtio implementation); value is user-provided string.
               
               See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        :param _builtins.str packed: Configures whether the virtio network interface uses packed virtqueue format instead of split queues; value is user-provided, typically on/off or yes/no.
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.str page_per_vq: Configures whether each virtqueue of the virtio network interface uses a dedicated page (page_per_vq); value is user-provided, typically on/off or yes/no.
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.float queues: Sets the number of virtio queues for the network interface to support multiqueue networking; value is user-provided positive integer (for example, 4 or 8).
               
               See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        :param _builtins.str rss: Configures whether Receive Side Scaling (RSS) is enabled for the virtio network interface, distributing traffic across multiple queues; value is user-provided, typically on/off or yes/no.
               
               See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        :param _builtins.str rss_hash_report: Configures whether the virtio network interface reports RSS hash information to the guest; value is user-provided, typically on/off or yes/no.
               
               See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        :param _builtins.float rx_queue_size: Sets the size (number of descriptors) of the receive queue for the virtio network interface; value is user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        :param _builtins.str tx_mode: Sets the transmit mode for a virtio network interface driver; valid values are user-provided but typically include modes like 'iothread' or 'timer' depending on QEMU support.
               
               See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        :param _builtins.float tx_queue_size: Sets the size (number of descriptors) of the transmit queue for a virtio network interface driver; value is a user-provided positive integer tuned for performance.
               
               See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        """
        if ats is not None:
            pulumi.set(__self__, "ats", ats)
        if event_idx is not None:
            pulumi.set(__self__, "event_idx", event_idx)
        if guest is not None:
            pulumi.set(__self__, "guest", guest)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if io_event_fd is not None:
            pulumi.set(__self__, "io_event_fd", io_event_fd)
        if iommu is not None:
            pulumi.set(__self__, "iommu", iommu)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if packed is not None:
            pulumi.set(__self__, "packed", packed)
        if page_per_vq is not None:
            pulumi.set(__self__, "page_per_vq", page_per_vq)
        if queues is not None:
            pulumi.set(__self__, "queues", queues)
        if rss is not None:
            pulumi.set(__self__, "rss", rss)
        if rss_hash_report is not None:
            pulumi.set(__self__, "rss_hash_report", rss_hash_report)
        if rx_queue_size is not None:
            pulumi.set(__self__, "rx_queue_size", rx_queue_size)
        if tx_mode is not None:
            pulumi.set(__self__, "tx_mode", tx_mode)
        if tx_queue_size is not None:
            pulumi.set(__self__, "tx_queue_size", tx_queue_size)

    @_builtins.property
    @pulumi.getter
    def ats(self) -> Optional[_builtins.str]:
        """
        Enables or disables Address Translation Service (ATS) for a virtio interface when used with an emulated IOMMU; value is typically "on" or "off".

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "ats")

    @_builtins.property
    @pulumi.getter(name="eventIdx")
    def event_idx(self) -> Optional[_builtins.str]:
        """
        Enables or disables virtio event index optimization for this interface; value is typically "on" or "off".

        See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        """
        return pulumi.get(self, "event_idx")

    @_builtins.property
    @pulumi.getter
    def guest(self) -> Optional['outputs.DomainDevicesInterfaceDriverGuest']:
        """
        Configures guestvisible offload capabilities advertised by this interfaces driver.
        """
        return pulumi.get(self, "guest")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional['outputs.DomainDevicesInterfaceDriverHost']:
        """
        Groups driver-specific offload and tuning options that apply to the host side of a virtio network interface; individual attributes within this block are user-provided.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter(name="ioEventFd")
    def io_event_fd(self) -> Optional[_builtins.str]:
        """
        Configures whether ioeventfd is used for the virtio network interface, enabling eventfd-based notification for I/O; value is user-provided, usually a boolean-like on/off.

        See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        """
        return pulumi.get(self, "io_event_fd")

    @_builtins.property
    @pulumi.getter
    def iommu(self) -> Optional[_builtins.str]:
        """
        Configures whether the virtio network device uses an emulated IOMMU for DMA translation; value is user-provided, typically on/off or yes/no.

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "iommu")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the driver name/type for the network interface backend (for example, a specific vhost or virtio implementation); value is user-provided string.

        See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def packed(self) -> Optional[_builtins.str]:
        """
        Configures whether the virtio network interface uses packed virtqueue format instead of split queues; value is user-provided, typically on/off or yes/no.

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "packed")

    @_builtins.property
    @pulumi.getter(name="pagePerVq")
    def page_per_vq(self) -> Optional[_builtins.str]:
        """
        Configures whether each virtqueue of the virtio network interface uses a dedicated page (page_per_vq); value is user-provided, typically on/off or yes/no.

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "page_per_vq")

    @_builtins.property
    @pulumi.getter
    def queues(self) -> Optional[_builtins.float]:
        """
        Sets the number of virtio queues for the network interface to support multiqueue networking; value is user-provided positive integer (for example, 4 or 8).

        See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        """
        return pulumi.get(self, "queues")

    @_builtins.property
    @pulumi.getter
    def rss(self) -> Optional[_builtins.str]:
        """
        Configures whether Receive Side Scaling (RSS) is enabled for the virtio network interface, distributing traffic across multiple queues; value is user-provided, typically on/off or yes/no.

        See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        """
        return pulumi.get(self, "rss")

    @_builtins.property
    @pulumi.getter(name="rssHashReport")
    def rss_hash_report(self) -> Optional[_builtins.str]:
        """
        Configures whether the virtio network interface reports RSS hash information to the guest; value is user-provided, typically on/off or yes/no.

        See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        """
        return pulumi.get(self, "rss_hash_report")

    @_builtins.property
    @pulumi.getter(name="rxQueueSize")
    def rx_queue_size(self) -> Optional[_builtins.float]:
        """
        Sets the size (number of descriptors) of the receive queue for the virtio network interface; value is user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        """
        return pulumi.get(self, "rx_queue_size")

    @_builtins.property
    @pulumi.getter(name="txMode")
    def tx_mode(self) -> Optional[_builtins.str]:
        """
        Sets the transmit mode for a virtio network interface driver; valid values are user-provided but typically include modes like 'iothread' or 'timer' depending on QEMU support.

        See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        """
        return pulumi.get(self, "tx_mode")

    @_builtins.property
    @pulumi.getter(name="txQueueSize")
    def tx_queue_size(self) -> Optional[_builtins.float]:
        """
        Sets the size (number of descriptors) of the transmit queue for a virtio network interface driver; value is a user-provided positive integer tuned for performance.

        See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        """
        return pulumi.get(self, "tx_queue_size")


@pulumi.output_type
class DomainDevicesInterfaceDriverGuest(dict):
    def __init__(__self__, *,
                 csum: Optional[_builtins.str] = None,
                 ecn: Optional[_builtins.str] = None,
                 tso4: Optional[_builtins.str] = None,
                 tso6: Optional[_builtins.str] = None,
                 ufo: Optional[_builtins.str] = None):
        """
        :param _builtins.str csum: Enables or disables checksum offload as advertised to the guest, controlling whether the guest is expected to handle checksums in software; value is typically "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        :param _builtins.str ecn: Enables or disables ECN (Explicit Congestion Notification) offload features as advertised to the guest; value is typically "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        :param _builtins.str tso4: Configures whether TCP segmentation offload (TSO) for IPv4 is enabled on the guest side of a virtio network interface driver; value is user-provided, typically a boolean-like on/off or yes/no.
               
               See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        :param _builtins.str tso6: Configures whether TCP segmentation offload (TSO) for IPv6 is enabled on the guest side of a virtio network interface driver; value is user-provided, typically a boolean-like on/off or yes/no.
               
               See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        :param _builtins.str ufo: Configures whether UDP fragmentation offload (UFO) is enabled on the guest side of a virtio network interface driver; value is user-provided, typically a boolean-like on/off or yes/no.
               
               See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        """
        if csum is not None:
            pulumi.set(__self__, "csum", csum)
        if ecn is not None:
            pulumi.set(__self__, "ecn", ecn)
        if tso4 is not None:
            pulumi.set(__self__, "tso4", tso4)
        if tso6 is not None:
            pulumi.set(__self__, "tso6", tso6)
        if ufo is not None:
            pulumi.set(__self__, "ufo", ufo)

    @_builtins.property
    @pulumi.getter
    def csum(self) -> Optional[_builtins.str]:
        """
        Enables or disables checksum offload as advertised to the guest, controlling whether the guest is expected to handle checksums in software; value is typically "on" or "off".

        See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        """
        return pulumi.get(self, "csum")

    @_builtins.property
    @pulumi.getter
    def ecn(self) -> Optional[_builtins.str]:
        """
        Enables or disables ECN (Explicit Congestion Notification) offload features as advertised to the guest; value is typically "on" or "off".

        See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        """
        return pulumi.get(self, "ecn")

    @_builtins.property
    @pulumi.getter
    def tso4(self) -> Optional[_builtins.str]:
        """
        Configures whether TCP segmentation offload (TSO) for IPv4 is enabled on the guest side of a virtio network interface driver; value is user-provided, typically a boolean-like on/off or yes/no.

        See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        """
        return pulumi.get(self, "tso4")

    @_builtins.property
    @pulumi.getter
    def tso6(self) -> Optional[_builtins.str]:
        """
        Configures whether TCP segmentation offload (TSO) for IPv6 is enabled on the guest side of a virtio network interface driver; value is user-provided, typically a boolean-like on/off or yes/no.

        See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        """
        return pulumi.get(self, "tso6")

    @_builtins.property
    @pulumi.getter
    def ufo(self) -> Optional[_builtins.str]:
        """
        Configures whether UDP fragmentation offload (UFO) is enabled on the guest side of a virtio network interface driver; value is user-provided, typically a boolean-like on/off or yes/no.

        See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        """
        return pulumi.get(self, "ufo")


@pulumi.output_type
class DomainDevicesInterfaceDriverHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mrgRxBuf":
            suggest = "mrg_rx_buf"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceDriverHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceDriverHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceDriverHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 csum: Optional[_builtins.str] = None,
                 ecn: Optional[_builtins.str] = None,
                 gso: Optional[_builtins.str] = None,
                 mrg_rx_buf: Optional[_builtins.str] = None,
                 tso4: Optional[_builtins.str] = None,
                 tso6: Optional[_builtins.str] = None,
                 ufo: Optional[_builtins.str] = None):
        """
        :param _builtins.str csum: Configures whether checksum offload is enabled on the host side of a virtio network interface driver; value is user-provided, typically on/off or yes/no.
               
               See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        :param _builtins.str ecn: Configures whether Explicit Congestion Notification (ECN) offload is enabled on the host side of a virtio network interface driver; value is user-provided, typically on/off or yes/no.
               
               See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        :param _builtins.str gso: Configures whether generic segmentation offload (GSO) is enabled on the host side of a virtio network interface driver; value is user-provided, typically on/off or yes/no.
               
               See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        :param _builtins.str mrg_rx_buf: Configures whether mergeable receive buffers (mrg_rxbuf) are enabled on the host side of a virtio network interface driver; value is user-provided, typically on/off or yes/no.
               
               See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        :param _builtins.str tso4: Configures whether TCP segmentation offload (TSO) for IPv4 is enabled on the host side of a virtio network interface driver; value is user-provided, typically on/off or yes/no.
               
               See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        :param _builtins.str tso6: Configures whether TCP segmentation offload (TSO) for IPv6 is enabled on the host side of a virtio network interface driver; value is user-provided, typically on/off or yes/no.
               
               See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        :param _builtins.str ufo: Configures whether UDP fragmentation offload (UFO) is enabled on the host side of a virtio network interface driver; value is user-provided, typically on/off or yes/no.
               
               See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        """
        if csum is not None:
            pulumi.set(__self__, "csum", csum)
        if ecn is not None:
            pulumi.set(__self__, "ecn", ecn)
        if gso is not None:
            pulumi.set(__self__, "gso", gso)
        if mrg_rx_buf is not None:
            pulumi.set(__self__, "mrg_rx_buf", mrg_rx_buf)
        if tso4 is not None:
            pulumi.set(__self__, "tso4", tso4)
        if tso6 is not None:
            pulumi.set(__self__, "tso6", tso6)
        if ufo is not None:
            pulumi.set(__self__, "ufo", ufo)

    @_builtins.property
    @pulumi.getter
    def csum(self) -> Optional[_builtins.str]:
        """
        Configures whether checksum offload is enabled on the host side of a virtio network interface driver; value is user-provided, typically on/off or yes/no.

        See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        """
        return pulumi.get(self, "csum")

    @_builtins.property
    @pulumi.getter
    def ecn(self) -> Optional[_builtins.str]:
        """
        Configures whether Explicit Congestion Notification (ECN) offload is enabled on the host side of a virtio network interface driver; value is user-provided, typically on/off or yes/no.

        See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        """
        return pulumi.get(self, "ecn")

    @_builtins.property
    @pulumi.getter
    def gso(self) -> Optional[_builtins.str]:
        """
        Configures whether generic segmentation offload (GSO) is enabled on the host side of a virtio network interface driver; value is user-provided, typically on/off or yes/no.

        See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        """
        return pulumi.get(self, "gso")

    @_builtins.property
    @pulumi.getter(name="mrgRxBuf")
    def mrg_rx_buf(self) -> Optional[_builtins.str]:
        """
        Configures whether mergeable receive buffers (mrg_rxbuf) are enabled on the host side of a virtio network interface driver; value is user-provided, typically on/off or yes/no.

        See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        """
        return pulumi.get(self, "mrg_rx_buf")

    @_builtins.property
    @pulumi.getter
    def tso4(self) -> Optional[_builtins.str]:
        """
        Configures whether TCP segmentation offload (TSO) for IPv4 is enabled on the host side of a virtio network interface driver; value is user-provided, typically on/off or yes/no.

        See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        """
        return pulumi.get(self, "tso4")

    @_builtins.property
    @pulumi.getter
    def tso6(self) -> Optional[_builtins.str]:
        """
        Configures whether TCP segmentation offload (TSO) for IPv6 is enabled on the host side of a virtio network interface driver; value is user-provided, typically on/off or yes/no.

        See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        """
        return pulumi.get(self, "tso6")

    @_builtins.property
    @pulumi.getter
    def ufo(self) -> Optional[_builtins.str]:
        """
        Configures whether UDP fragmentation offload (UFO) is enabled on the host side of a virtio network interface driver; value is user-provided, typically on/off or yes/no.

        See: <https://libvirt.org/formatdomain.html#setting-nic-driver-specific-options>
        """
        return pulumi.get(self, "ufo")


@pulumi.output_type
class DomainDevicesInterfaceFilterRef(dict):
    def __init__(__self__, *,
                 filter: _builtins.str,
                 parameters: Optional[Sequence['outputs.DomainDevicesInterfaceFilterRefParameter']] = None):
        """
        :param _builtins.str filter: Specifies the name of the nwfilter profile to apply to this interface; value is a user-provided filter name that must refer to an existing nwfilter definition (for example, "clean-traffic").
               
               See: <https://libvirt.org/formatdomain.html#traffic-filtering-with-nwfilter>
        :param Sequence['DomainDevicesInterfaceFilterRefParameterArgs'] parameters: Provides one or more parameter overrides for the selected nwfilter, each supplying a named value used by the filters rules.
               
               See: <https://libvirt.org/formatdomain.html#traffic-filtering-with-nwfilter>
        """
        pulumi.set(__self__, "filter", filter)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> _builtins.str:
        """
        Specifies the name of the nwfilter profile to apply to this interface; value is a user-provided filter name that must refer to an existing nwfilter definition (for example, "clean-traffic").

        See: <https://libvirt.org/formatdomain.html#traffic-filtering-with-nwfilter>
        """
        return pulumi.get(self, "filter")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.DomainDevicesInterfaceFilterRefParameter']]:
        """
        Provides one or more parameter overrides for the selected nwfilter, each supplying a named value used by the filters rules.

        See: <https://libvirt.org/formatdomain.html#traffic-filtering-with-nwfilter>
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DomainDevicesInterfaceFilterRefParameter(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Sets the parameter name passed into the nwfilter definition; value is user-provided and must match a parameter expected by the filter (for example, "IP", "MAC").
               
               See: <https://libvirt.org/formatdomain.html#traffic-filtering-with-nwfilter>
        :param _builtins.str value: Sets the value for the named nwfilter parameter; value is user-provided and typically encodes an address, port, or other match value (for example, "192.168.122.1").
               
               See: <https://libvirt.org/formatdomain.html#traffic-filtering-with-nwfilter>
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the parameter name passed into the nwfilter definition; value is user-provided and must match a parameter expected by the filter (for example, "IP", "MAC").

        See: <https://libvirt.org/formatdomain.html#traffic-filtering-with-nwfilter>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Sets the value for the named nwfilter parameter; value is user-provided and typically encodes an address, port, or other match value (for example, "192.168.122.1").

        See: <https://libvirt.org/formatdomain.html#traffic-filtering-with-nwfilter>
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainDevicesInterfaceGuest(dict):
    def __init__(__self__, *,
                 actual: Optional[_builtins.str] = None,
                 dev: Optional[_builtins.str] = None):
        """
        :param _builtins.str actual: Sets the actual interface name inside the guest when it differs from the nominal guest.dev name; value is user-provided (for example, "ens3").
               
               See: <https://libvirt.org/formatdomain.html#network-interfaces>
        :param _builtins.str dev: Sets the guest-visible network interface name (e.g. Linux device name) for this NIC; value is user-provided (for example, "eth0").
               
               See: <https://libvirt.org/formatdomain.html#network-interfaces>
        """
        if actual is not None:
            pulumi.set(__self__, "actual", actual)
        if dev is not None:
            pulumi.set(__self__, "dev", dev)

    @_builtins.property
    @pulumi.getter
    def actual(self) -> Optional[_builtins.str]:
        """
        Sets the actual interface name inside the guest when it differs from the nominal guest.dev name; value is user-provided (for example, "ens3").

        See: <https://libvirt.org/formatdomain.html#network-interfaces>
        """
        return pulumi.get(self, "actual")

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional[_builtins.str]:
        """
        Sets the guest-visible network interface name (e.g. Linux device name) for this NIC; value is user-provided (for example, "eth0").

        See: <https://libvirt.org/formatdomain.html#network-interfaces>
        """
        return pulumi.get(self, "dev")


@pulumi.output_type
class DomainDevicesInterfaceIp(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 family: Optional[_builtins.str] = None,
                 peer: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.float] = None):
        """
        :param _builtins.str address: Sets the IP address assigned to the interface in the guest; must be a valid IPv4 or IPv6 address string (for example, "192.168.122.10" or "2001:db8::10").
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        :param _builtins.str family: Selects the address family for the interface IP, typically "ipv4" or "ipv6"; if omitted, libvirt infers it from the address format.
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        :param _builtins.str peer: Sets the peer address for point-to-point style links, as a valid IPv4 or IPv6 address string; value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        :param _builtins.float prefix: Sets the prefix length (CIDR) for the interface IP address as a non-negative integer (for example, 24 for "192.168.122.0/24").
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        pulumi.set(__self__, "address", address)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if peer is not None:
            pulumi.set(__self__, "peer", peer)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        Sets the IP address assigned to the interface in the guest; must be a valid IPv4 or IPv6 address string (for example, "192.168.122.10" or "2001:db8::10").

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def family(self) -> Optional[_builtins.str]:
        """
        Selects the address family for the interface IP, typically "ipv4" or "ipv6"; if omitted, libvirt infers it from the address format.

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "family")

    @_builtins.property
    @pulumi.getter
    def peer(self) -> Optional[_builtins.str]:
        """
        Sets the peer address for point-to-point style links, as a valid IPv4 or IPv6 address string; value is user-provided.

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "peer")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.float]:
        """
        Sets the prefix length (CIDR) for the interface IP address as a non-negative integer (for example, 24 for "192.168.122.0/24").

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class DomainDevicesInterfaceLink(dict):
    def __init__(__self__, *,
                 state: _builtins.str):
        """
        :param _builtins.str state: Sets the virtual link state for the NIC, with valid values "up" or "down" (when "down", the interface behaves as if unplugged in the guest).
               
               See: <https://libvirt.org/formatdomain.html#modifying-virtual-link-state>
        """
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        Sets the virtual link state for the NIC, with valid values "up" or "down" (when "down", the interface behaves as if unplugged in the guest).

        See: <https://libvirt.org/formatdomain.html#modifying-virtual-link-state>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainDevicesInterfaceMac(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 check: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: Sets the MAC address of the NIC as a 6-byte hexadecimal address string (for example, "52:54:00:ab:cd:ef"); must be unique per interface on the same network.
               
               See: <https://libvirt.org/formatdomain.html#network-interfaces>
        :param _builtins.str check: Controls how libvirt handles MAC address conflicts for this NIC; valid values are implementation-defined strings such as "none" or "duplicate" where supported, and are user-provided.
               
               See: <https://libvirt.org/formatdomain.html#network-interfaces>
        :param _builtins.str type: Sets the MAC address type for the interface; value is user-provided (for example, vendor-specific type strings) and is optional.
        """
        pulumi.set(__self__, "address", address)
        if check is not None:
            pulumi.set(__self__, "check", check)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        Sets the MAC address of the NIC as a 6-byte hexadecimal address string (for example, "52:54:00:ab:cd:ef"); must be unique per interface on the same network.

        See: <https://libvirt.org/formatdomain.html#network-interfaces>
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def check(self) -> Optional[_builtins.str]:
        """
        Controls how libvirt handles MAC address conflicts for this NIC; valid values are implementation-defined strings such as "none" or "duplicate" where supported, and are user-provided.

        See: <https://libvirt.org/formatdomain.html#network-interfaces>
        """
        return pulumi.get(self, "check")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Sets the MAC address type for the interface; value is user-provided (for example, vendor-specific type strings) and is optional.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainDevicesInterfaceModel(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: Sets the NIC model name to present to the guest; valid values are user-provided model identifiers such as "virtio", "e1000", "rtl8139", etc.
               
               See: <https://libvirt.org/formatdomain.html#setting-the-nic-model>
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets the NIC model name to present to the guest; valid values are user-provided model identifiers such as "virtio", "e1000", "rtl8139", etc.

        See: <https://libvirt.org/formatdomain.html#setting-the-nic-model>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainDevicesInterfaceMtu(dict):
    def __init__(__self__, *,
                 size: _builtins.float):
        """
        :param _builtins.float size: Sets the MTU size for the virtual network link as a non-negative integer (for example, 1500 or 9000).
               
               See: <https://libvirt.org/formatdomain.html#mtu-configuration>
        """
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.float:
        """
        Sets the MTU size for the virtual network link as a non-negative integer (for example, 1500 or 9000).

        See: <https://libvirt.org/formatdomain.html#mtu-configuration>
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class DomainDevicesInterfacePortForward(dict):
    def __init__(__self__, *,
                 proto: _builtins.str,
                 address: Optional[_builtins.str] = None,
                 dev: Optional[_builtins.str] = None,
                 ranges: Optional[Sequence['outputs.DomainDevicesInterfacePortForwardRange']] = None):
        """
        :param _builtins.str proto: Sets the IP protocol used for the forwarding rule, typically "tcp" or "udp"; value is required and user-provided.
               
               See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
        :param _builtins.str address: Sets the host IP address to listen on for forwarded ports; value is user-provided IPv4 or IPv6 address.
               
               See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
        :param _builtins.str dev: Selects the host network device whose addresses are used as the source for forwarded connections; value is a user-provided interface name (for example, "eth0").
               
               See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
        :param Sequence['DomainDevicesInterfacePortForwardRangeArgs'] ranges: Defines one or more port ranges to forward from host to guest for the selected protocol.
               
               See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
        """
        pulumi.set(__self__, "proto", proto)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if ranges is not None:
            pulumi.set(__self__, "ranges", ranges)

    @_builtins.property
    @pulumi.getter
    def proto(self) -> _builtins.str:
        """
        Sets the IP protocol used for the forwarding rule, typically "tcp" or "udp"; value is required and user-provided.

        See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
        """
        return pulumi.get(self, "proto")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Sets the host IP address to listen on for forwarded ports; value is user-provided IPv4 or IPv6 address.

        See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional[_builtins.str]:
        """
        Selects the host network device whose addresses are used as the source for forwarded connections; value is a user-provided interface name (for example, "eth0").

        See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter
    def ranges(self) -> Optional[Sequence['outputs.DomainDevicesInterfacePortForwardRange']]:
        """
        Defines one or more port ranges to forward from host to guest for the selected protocol.

        See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
        """
        return pulumi.get(self, "ranges")


@pulumi.output_type
class DomainDevicesInterfacePortForwardRange(dict):
    def __init__(__self__, *,
                 start: _builtins.float,
                 end: Optional[_builtins.float] = None,
                 exclude: Optional[_builtins.str] = None,
                 to: Optional[_builtins.float] = None):
        """
        :param _builtins.float start: Sets the first host port in the forwarded range; must be an integer in the valid TCP/UDP port range (165535).
               
               See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
        :param _builtins.float end: Sets the last port in the forwarded range (inclusive); if omitted, the range effectively applies only to the start port.
               
               See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
        :param _builtins.str exclude: Indicates that this range is an exclusion from previously defined inclusive ranges; value is user-provided (for example, "yes" or "true") and treated as a presence/flag.
               
               See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
        :param _builtins.float to: Sets the guest port to which traffic is forwarded; if omitted, the guest port defaults to the same number as the host start port.
               
               See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
        """
        pulumi.set(__self__, "start", start)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if exclude is not None:
            pulumi.set(__self__, "exclude", exclude)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def start(self) -> _builtins.float:
        """
        Sets the first host port in the forwarded range; must be an integer in the valid TCP/UDP port range (165535).

        See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
        """
        return pulumi.get(self, "start")

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[_builtins.float]:
        """
        Sets the last port in the forwarded range (inclusive); if omitted, the range effectively applies only to the start port.

        See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter
    def exclude(self) -> Optional[_builtins.str]:
        """
        Indicates that this range is an exclusion from previously defined inclusive ranges; value is user-provided (for example, "yes" or "true") and treated as a presence/flag.

        See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
        """
        return pulumi.get(self, "exclude")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.float]:
        """
        Sets the guest port to which traffic is forwarded; if omitted, the guest port defaults to the same number as the host start port.

        See: <https://libvirt.org/formatdomain.html#userspace-connection-using-passt>
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class DomainDevicesInterfacePortOptions(dict):
    def __init__(__self__, *,
                 isolated: Optional[_builtins.str] = None):
        """
        :param _builtins.str isolated: Controls whether this interfaces traffic is isolated from other guests on the same virtual network; boolean-like string where "yes" isolates and "no" (or omission) does not.
               
               See: <https://libvirt.org/formatdomain.html#isolating-guests-network-traffic-from-each-other>
        """
        if isolated is not None:
            pulumi.set(__self__, "isolated", isolated)

    @_builtins.property
    @pulumi.getter
    def isolated(self) -> Optional[_builtins.str]:
        """
        Controls whether this interfaces traffic is isolated from other guests on the same virtual network; boolean-like string where "yes" isolates and "no" (or omission) does not.

        See: <https://libvirt.org/formatdomain.html#isolating-guests-network-traffic-from-each-other>
        """
        return pulumi.get(self, "isolated")


@pulumi.output_type
class DomainDevicesInterfaceRom(dict):
    def __init__(__self__, *,
                 bar: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.str] = None,
                 file: Optional[_builtins.str] = None):
        """
        :param _builtins.str bar: Controls whether the devices ROM is exposed in PCI BAR space, typically "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#interface-rom-bios-configuration>
        :param _builtins.str enabled: Enables or disables use of the ROM image for the host device, as a user-provided string flag (for example, "on"/"off" or "yes"/"no" depending on libvirt expectations).
               
               See: <https://libvirt.org/formatdomain.html#interface-rom-bios-configuration>
        :param _builtins.str file: Specifies a path to a custom ROM file to use for the passthrough device (for example, "/usr/share/roms/nic.rom"); value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#interface-rom-bios-configuration>
        """
        if bar is not None:
            pulumi.set(__self__, "bar", bar)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if file is not None:
            pulumi.set(__self__, "file", file)

    @_builtins.property
    @pulumi.getter
    def bar(self) -> Optional[_builtins.str]:
        """
        Controls whether the devices ROM is exposed in PCI BAR space, typically "on" or "off".

        See: <https://libvirt.org/formatdomain.html#interface-rom-bios-configuration>
        """
        return pulumi.get(self, "bar")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.str]:
        """
        Enables or disables use of the ROM image for the host device, as a user-provided string flag (for example, "on"/"off" or "yes"/"no" depending on libvirt expectations).

        See: <https://libvirt.org/formatdomain.html#interface-rom-bios-configuration>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional[_builtins.str]:
        """
        Specifies a path to a custom ROM file to use for the passthrough device (for example, "/usr/share/roms/nic.rom"); value is user-provided.

        See: <https://libvirt.org/formatdomain.html#interface-rom-bios-configuration>
        """
        return pulumi.get(self, "file")


@pulumi.output_type
class DomainDevicesInterfaceRoute(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 gateway: _builtins.str,
                 family: Optional[_builtins.str] = None,
                 metric: Optional[_builtins.float] = None,
                 netmask: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.float] = None):
        """
        :param _builtins.str address: Sets the destination network address for the static route, as an IPv4 or IPv6 address depending on the family (for example, "192.168.10.0" or "2001:db8::").
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        :param _builtins.str gateway: Sets the gateway IP address used for the static route (must be in the same family as the route address, for example "192.168.10.1").
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        :param _builtins.str family: Specifies the address family for the route, typically "ipv4" or "ipv6"; if omitted, libvirt infers it from the address format.
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        :param _builtins.float metric: Sets an optional numeric route metric (preference) for the static route, as a non-negative integer where lower values are preferred.
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        :param _builtins.str netmask: Specifies the netmask for an IPv4 static route as a dotted-quad mask (for example, "255.255.255.0"); use prefix instead for IPv6 or CIDR-style configuration.
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        :param _builtins.float prefix: Specifies the prefix length for the route (for example, 24 for "192.168.10.0/24" or 64 for "2001:db8::/64"), used instead of netmask for CIDR-style configuration.
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "gateway", gateway)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        Sets the destination network address for the static route, as an IPv4 or IPv6 address depending on the family (for example, "192.168.10.0" or "2001:db8::").

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> _builtins.str:
        """
        Sets the gateway IP address used for the static route (must be in the same family as the route address, for example "192.168.10.1").

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def family(self) -> Optional[_builtins.str]:
        """
        Specifies the address family for the route, typically "ipv4" or "ipv6"; if omitted, libvirt infers it from the address format.

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "family")

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[_builtins.float]:
        """
        Sets an optional numeric route metric (preference) for the static route, as a non-negative integer where lower values are preferred.

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> Optional[_builtins.str]:
        """
        Specifies the netmask for an IPv4 static route as a dotted-quad mask (for example, "255.255.255.0"); use prefix instead for IPv6 or CIDR-style configuration.

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.float]:
        """
        Specifies the prefix length for the route (for example, 24 for "192.168.10.0/24" or 64 for "2001:db8::/64"), used instead of netmask for CIDR-style configuration.

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class DomainDevicesInterfaceScript(dict):
    def __init__(__self__, *,
                 path: _builtins.str):
        """
        :param _builtins.str path: Sets the absolute or relative filesystem path to the script that is run when the interface is torn down (for example, "/etc/qemu-ifdown").
               
               See: <https://libvirt.org/formatdomain.html#generic-ethernet-connection>
        """
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the absolute or relative filesystem path to the script that is run when the interface is torn down (for example, "/etc/qemu-ifdown").

        See: <https://libvirt.org/formatdomain.html#generic-ethernet-connection>
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DomainDevicesInterfaceSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vhostUser":
            suggest = "vhost_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bridge: Optional['outputs.DomainDevicesInterfaceSourceBridge'] = None,
                 client: Optional['outputs.DomainDevicesInterfaceSourceClient'] = None,
                 direct: Optional['outputs.DomainDevicesInterfaceSourceDirect'] = None,
                 ethernet: Optional['outputs.DomainDevicesInterfaceSourceEthernet'] = None,
                 hostdev: Optional['outputs.DomainDevicesInterfaceSourceHostdev'] = None,
                 internal: Optional['outputs.DomainDevicesInterfaceSourceInternal'] = None,
                 mcast: Optional['outputs.DomainDevicesInterfaceSourceMcast'] = None,
                 network: Optional['outputs.DomainDevicesInterfaceSourceNetwork'] = None,
                 null: Optional[_builtins.bool] = None,
                 server: Optional['outputs.DomainDevicesInterfaceSourceServer'] = None,
                 udp: Optional['outputs.DomainDevicesInterfaceSourceUdp'] = None,
                 user: Optional['outputs.DomainDevicesInterfaceSourceUser'] = None,
                 vdpa: Optional['outputs.DomainDevicesInterfaceSourceVdpa'] = None,
                 vds: Optional['outputs.DomainDevicesInterfaceSourceVds'] = None,
                 vhost_user: Optional['outputs.DomainDevicesInterfaceSourceVhostUser'] = None):
        """
        :param 'DomainDevicesInterfaceSourceBridgeArgs' bridge: Configures this interface to attach to a host bridge device, making the guest appear directly on the bridged LAN.
        :param 'DomainDevicesInterfaceSourceClientArgs' client: Configures this interface as a client endpoint of a point-to-point tunnel (such as TCP, UDP, or multicast tunnel) using a remote address and port.
        :param 'DomainDevicesInterfaceSourceDirectArgs' direct: Configures this interface for direct macvtap-style attachment to a physical host NIC, bypassing a software bridge for near-raw access.
        :param 'DomainDevicesInterfaceSourceEthernetArgs' ethernet: Enables configuration of a generic ethernet/tap interface whose lower-level setup is handled outside libvirt (IP addresses, routes, etc. defined in nested attributes).
        :param 'DomainDevicesInterfaceSourceHostdevArgs' hostdev: Enables use of a host device as the backing for this network interface, allowing PCI or similar passthrough as configured in nested attributes.
        :param 'DomainDevicesInterfaceSourceInternalArgs' internal: Configures the interface to connect to an internal network name rather than an external bridge or hostdev device, typically used for libvirt-internal or hypervisor-specific networks.
        :param 'DomainDevicesInterfaceSourceMcastArgs' mcast: Configures a multicast tunnel network backend for the interface, using a multicast group as the virtual network segment shared with other VMs.
        :param 'DomainDevicesInterfaceSourceNetworkArgs' network: Attaches the interface to a libvirt-managed virtual network, optionally via a specific bridge or port group.
        :param _builtins.bool null: When true, configures the interface as a null/unconnected network interface with no backing network; when false or unset, the element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#null-network-interface>
        :param 'DomainDevicesInterfaceSourceServerArgs' server: Configures a TCP tunnel network backend where this interface connects to or listens on a TCP server endpoint to form a virtual network.
        :param 'DomainDevicesInterfaceSourceUdpArgs' udp: Configures a UDP unicast tunnel network backend for the interface, using UDP endpoints to connect VMs into a virtual network.
        :param 'DomainDevicesInterfaceSourceUserArgs' user: Selects a userspace SLIRP-style backend as the source for the network interface, providing NAT without needing host privileges.
        :param 'DomainDevicesInterfaceSourceVdpaArgs' vdpa: Selects a vDPA device as the source of the interface, enabling virtio-compliant hardware offload for the guest NIC.
        :param 'DomainDevicesInterfaceSourceVdsArgs' vds: Connects the interface to a VMware Distributed Switch (VDS) as its network source, using VMware-specific identifiers.
        :param 'DomainDevicesInterfaceSourceVhostUserArgs' vhost_user: Selects a vhost-user backend as the source for the virtio network interface, connecting it to an external userspace process via a character device.
        """
        if bridge is not None:
            pulumi.set(__self__, "bridge", bridge)
        if client is not None:
            pulumi.set(__self__, "client", client)
        if direct is not None:
            pulumi.set(__self__, "direct", direct)
        if ethernet is not None:
            pulumi.set(__self__, "ethernet", ethernet)
        if hostdev is not None:
            pulumi.set(__self__, "hostdev", hostdev)
        if internal is not None:
            pulumi.set(__self__, "internal", internal)
        if mcast is not None:
            pulumi.set(__self__, "mcast", mcast)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if null is not None:
            pulumi.set(__self__, "null", null)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)
        if user is not None:
            pulumi.set(__self__, "user", user)
        if vdpa is not None:
            pulumi.set(__self__, "vdpa", vdpa)
        if vds is not None:
            pulumi.set(__self__, "vds", vds)
        if vhost_user is not None:
            pulumi.set(__self__, "vhost_user", vhost_user)

    @_builtins.property
    @pulumi.getter
    def bridge(self) -> Optional['outputs.DomainDevicesInterfaceSourceBridge']:
        """
        Configures this interface to attach to a host bridge device, making the guest appear directly on the bridged LAN.
        """
        return pulumi.get(self, "bridge")

    @_builtins.property
    @pulumi.getter
    def client(self) -> Optional['outputs.DomainDevicesInterfaceSourceClient']:
        """
        Configures this interface as a client endpoint of a point-to-point tunnel (such as TCP, UDP, or multicast tunnel) using a remote address and port.
        """
        return pulumi.get(self, "client")

    @_builtins.property
    @pulumi.getter
    def direct(self) -> Optional['outputs.DomainDevicesInterfaceSourceDirect']:
        """
        Configures this interface for direct macvtap-style attachment to a physical host NIC, bypassing a software bridge for near-raw access.
        """
        return pulumi.get(self, "direct")

    @_builtins.property
    @pulumi.getter
    def ethernet(self) -> Optional['outputs.DomainDevicesInterfaceSourceEthernet']:
        """
        Enables configuration of a generic ethernet/tap interface whose lower-level setup is handled outside libvirt (IP addresses, routes, etc. defined in nested attributes).
        """
        return pulumi.get(self, "ethernet")

    @_builtins.property
    @pulumi.getter
    def hostdev(self) -> Optional['outputs.DomainDevicesInterfaceSourceHostdev']:
        """
        Enables use of a host device as the backing for this network interface, allowing PCI or similar passthrough as configured in nested attributes.
        """
        return pulumi.get(self, "hostdev")

    @_builtins.property
    @pulumi.getter
    def internal(self) -> Optional['outputs.DomainDevicesInterfaceSourceInternal']:
        """
        Configures the interface to connect to an internal network name rather than an external bridge or hostdev device, typically used for libvirt-internal or hypervisor-specific networks.
        """
        return pulumi.get(self, "internal")

    @_builtins.property
    @pulumi.getter
    def mcast(self) -> Optional['outputs.DomainDevicesInterfaceSourceMcast']:
        """
        Configures a multicast tunnel network backend for the interface, using a multicast group as the virtual network segment shared with other VMs.
        """
        return pulumi.get(self, "mcast")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional['outputs.DomainDevicesInterfaceSourceNetwork']:
        """
        Attaches the interface to a libvirt-managed virtual network, optionally via a specific bridge or port group.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def null(self) -> Optional[_builtins.bool]:
        """
        When true, configures the interface as a null/unconnected network interface with no backing network; when false or unset, the element is omitted.

        See: <https://libvirt.org/formatdomain.html#null-network-interface>
        """
        return pulumi.get(self, "null")

    @_builtins.property
    @pulumi.getter
    def server(self) -> Optional['outputs.DomainDevicesInterfaceSourceServer']:
        """
        Configures a TCP tunnel network backend where this interface connects to or listens on a TCP server endpoint to form a virtual network.
        """
        return pulumi.get(self, "server")

    @_builtins.property
    @pulumi.getter
    def udp(self) -> Optional['outputs.DomainDevicesInterfaceSourceUdp']:
        """
        Configures a UDP unicast tunnel network backend for the interface, using UDP endpoints to connect VMs into a virtual network.
        """
        return pulumi.get(self, "udp")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional['outputs.DomainDevicesInterfaceSourceUser']:
        """
        Selects a userspace SLIRP-style backend as the source for the network interface, providing NAT without needing host privileges.
        """
        return pulumi.get(self, "user")

    @_builtins.property
    @pulumi.getter
    def vdpa(self) -> Optional['outputs.DomainDevicesInterfaceSourceVdpa']:
        """
        Selects a vDPA device as the source of the interface, enabling virtio-compliant hardware offload for the guest NIC.
        """
        return pulumi.get(self, "vdpa")

    @_builtins.property
    @pulumi.getter
    def vds(self) -> Optional['outputs.DomainDevicesInterfaceSourceVds']:
        """
        Connects the interface to a VMware Distributed Switch (VDS) as its network source, using VMware-specific identifiers.
        """
        return pulumi.get(self, "vds")

    @_builtins.property
    @pulumi.getter(name="vhostUser")
    def vhost_user(self) -> Optional['outputs.DomainDevicesInterfaceSourceVhostUser']:
        """
        Selects a vhost-user backend as the source for the virtio network interface, connecting it to an external userspace process via a character device.
        """
        return pulumi.get(self, "vhost_user")


@pulumi.output_type
class DomainDevicesInterfaceSourceBridge(dict):
    def __init__(__self__, *,
                 bridge: _builtins.str):
        """
        :param _builtins.str bridge: Sets the name of the existing host bridge device to which the interface connects (for example, "br0").
               
               See: <https://libvirt.org/formatdomain.html#bridge-to-lan>
        """
        pulumi.set(__self__, "bridge", bridge)

    @_builtins.property
    @pulumi.getter
    def bridge(self) -> _builtins.str:
        """
        Sets the name of the existing host bridge device to which the interface connects (for example, "br0").

        See: <https://libvirt.org/formatdomain.html#bridge-to-lan>
        """
        return pulumi.get(self, "bridge")


@pulumi.output_type
class DomainDevicesInterfaceSourceClient(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 local: Optional['outputs.DomainDevicesInterfaceSourceClientLocal'] = None,
                 port: Optional[_builtins.float] = None):
        """
        :param _builtins.str address: Sets the remote peers IP or hostname for the tunnel client connection (user-provided, e.g. "10.0.0.1" or "example.com").
               
               See: <https://libvirt.org/formatdomain.html#tcp-tunnel>
        :param 'DomainDevicesInterfaceSourceClientLocalArgs' local: Configures the local (listening) endpoint for a UDP tunnel-backed network interface, enabling the guest-side address/port to be fixed.
        :param _builtins.float port: Sets the remote port number for the tunnels client connection, as a decimal TCP or UDP port (for example, 1194).
               
               See: <https://libvirt.org/formatdomain.html#tcp-tunnel>
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if local is not None:
            pulumi.set(__self__, "local", local)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Sets the remote peers IP or hostname for the tunnel client connection (user-provided, e.g. "10.0.0.1" or "example.com").

        See: <https://libvirt.org/formatdomain.html#tcp-tunnel>
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def local(self) -> Optional['outputs.DomainDevicesInterfaceSourceClientLocal']:
        """
        Configures the local (listening) endpoint for a UDP tunnel-backed network interface, enabling the guest-side address/port to be fixed.
        """
        return pulumi.get(self, "local")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.float]:
        """
        Sets the remote port number for the tunnels client connection, as a decimal TCP or UDP port (for example, 1194).

        See: <https://libvirt.org/formatdomain.html#tcp-tunnel>
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DomainDevicesInterfaceSourceClientLocal(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 port: Optional[_builtins.float] = None):
        """
        :param _builtins.str address: Sets the local IP address on which the UDP tunnel-backed interface listens; value is user-provided (e.g. "0.0.0.0" or a specific host address).
               
               See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
        :param _builtins.float port: Sets the local UDP port on which the tunnel-backed interface listens; value is a user-provided non-negative integer (e.g. 5000).
               
               See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Sets the local IP address on which the UDP tunnel-backed interface listens; value is user-provided (e.g. "0.0.0.0" or a specific host address).

        See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.float]:
        """
        Sets the local UDP port on which the tunnel-backed interface listens; value is a user-provided non-negative integer (e.g. 5000).

        See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DomainDevicesInterfaceSourceDirect(dict):
    def __init__(__self__, *,
                 dev: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str dev: Sets the name of the host network interface (e.g. `eth0`, `eno1`) that is directly attached to the guest via a macvtap direct interface.
               
               See: <https://libvirt.org/formatdomain.html#direct-attachment-to-physical-interface>
        :param _builtins.str mode: Sets the direct attachment mode for a macvtap direct interface; valid values are user-provided strings such as `vepa`, `bridge`, `private`, or `passthrough` as supported by libvirt/qemu.
               
               See: <https://libvirt.org/formatdomain.html#direct-attachment-to-physical-interface>
        """
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional[_builtins.str]:
        """
        Sets the name of the host network interface (e.g. `eth0`, `eno1`) that is directly attached to the guest via a macvtap direct interface.

        See: <https://libvirt.org/formatdomain.html#direct-attachment-to-physical-interface>
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the direct attachment mode for a macvtap direct interface; valid values are user-provided strings such as `vepa`, `bridge`, `private`, or `passthrough` as supported by libvirt/qemu.

        See: <https://libvirt.org/formatdomain.html#direct-attachment-to-physical-interface>
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DomainDevicesInterfaceSourceEthernet(dict):
    def __init__(__self__, *,
                 ips: Optional[Sequence['outputs.DomainDevicesInterfaceSourceEthernetIp']] = None,
                 routes: Optional[Sequence['outputs.DomainDevicesInterfaceSourceEthernetRoute']] = None):
        """
        :param Sequence['DomainDevicesInterfaceSourceEthernetIpArgs'] ips: Configures an IP address to assign inside the guest for this ethernet interface, including address, family, prefix, and optional peer.
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        :param Sequence['DomainDevicesInterfaceSourceEthernetRouteArgs'] routes: Defines a static route associated with this ethernet interface inside the guest, including destination, gateway, and optional metric or netmask/prefix.
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Optional[Sequence['outputs.DomainDevicesInterfaceSourceEthernetIp']]:
        """
        Configures an IP address to assign inside the guest for this ethernet interface, including address, family, prefix, and optional peer.

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "ips")

    @_builtins.property
    @pulumi.getter
    def routes(self) -> Optional[Sequence['outputs.DomainDevicesInterfaceSourceEthernetRoute']]:
        """
        Defines a static route associated with this ethernet interface inside the guest, including destination, gateway, and optional metric or netmask/prefix.

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "routes")


@pulumi.output_type
class DomainDevicesInterfaceSourceEthernetIp(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 family: Optional[_builtins.str] = None,
                 peer: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.float] = None):
        """
        :param _builtins.str address: Sets the IP address assigned to the interface in the guest; must be a valid IPv4 or IPv6 address string (for example, "192.168.122.10" or "2001:db8::10").
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        :param _builtins.str family: Selects the address family for the interface IP, typically "ipv4" or "ipv6"; if omitted, libvirt infers it from the address format.
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        :param _builtins.str peer: Sets the peer address for point-to-point style links, as a valid IPv4 or IPv6 address string; value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        :param _builtins.float prefix: Sets the prefix length (CIDR) for the interface IP address as a non-negative integer (for example, 24 for "192.168.122.0/24").
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        pulumi.set(__self__, "address", address)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if peer is not None:
            pulumi.set(__self__, "peer", peer)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        Sets the IP address assigned to the interface in the guest; must be a valid IPv4 or IPv6 address string (for example, "192.168.122.10" or "2001:db8::10").

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def family(self) -> Optional[_builtins.str]:
        """
        Selects the address family for the interface IP, typically "ipv4" or "ipv6"; if omitted, libvirt infers it from the address format.

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "family")

    @_builtins.property
    @pulumi.getter
    def peer(self) -> Optional[_builtins.str]:
        """
        Sets the peer address for point-to-point style links, as a valid IPv4 or IPv6 address string; value is user-provided.

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "peer")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.float]:
        """
        Sets the prefix length (CIDR) for the interface IP address as a non-negative integer (for example, 24 for "192.168.122.0/24").

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class DomainDevicesInterfaceSourceEthernetRoute(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 gateway: _builtins.str,
                 family: Optional[_builtins.str] = None,
                 metric: Optional[_builtins.float] = None,
                 netmask: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.float] = None):
        """
        :param _builtins.str address: Sets the destination network address for the static route, as an IPv4 or IPv6 address depending on the family (for example, "192.168.10.0" or "2001:db8::").
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        :param _builtins.str gateway: Sets the gateway IP address used for the static route (must be in the same family as the route address, for example "192.168.10.1").
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        :param _builtins.str family: Specifies the address family for the route, typically "ipv4" or "ipv6"; if omitted, libvirt infers it from the address format.
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        :param _builtins.float metric: Sets an optional numeric route metric (preference) for the static route, as a non-negative integer where lower values are preferred.
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        :param _builtins.str netmask: Specifies the netmask for an IPv4 static route as a dotted-quad mask (for example, "255.255.255.0"); use prefix instead for IPv6 or CIDR-style configuration.
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        :param _builtins.float prefix: Specifies the prefix length for the route (for example, 24 for "192.168.10.0/24" or 64 for "2001:db8::/64"), used instead of netmask for CIDR-style configuration.
               
               See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "gateway", gateway)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        Sets the destination network address for the static route, as an IPv4 or IPv6 address depending on the family (for example, "192.168.10.0" or "2001:db8::").

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> _builtins.str:
        """
        Sets the gateway IP address used for the static route (must be in the same family as the route address, for example "192.168.10.1").

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def family(self) -> Optional[_builtins.str]:
        """
        Specifies the address family for the route, typically "ipv4" or "ipv6"; if omitted, libvirt infers it from the address format.

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "family")

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[_builtins.float]:
        """
        Sets an optional numeric route metric (preference) for the static route, as a non-negative integer where lower values are preferred.

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> Optional[_builtins.str]:
        """
        Specifies the netmask for an IPv4 static route as a dotted-quad mask (for example, "255.255.255.0"); use prefix instead for IPv6 or CIDR-style configuration.

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.float]:
        """
        Specifies the prefix length for the route (for example, 24 for "192.168.10.0/24" or 64 for "2001:db8::/64"), used instead of netmask for CIDR-style configuration.

        See: <https://libvirt.org/formatdomain.html#ip-configuration>
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class DomainDevicesInterfaceSourceHostdev(dict):
    def __init__(__self__, *,
                 pci: Optional['outputs.DomainDevicesInterfaceSourceHostdevPci'] = None,
                 usb: Optional['outputs.DomainDevicesInterfaceSourceHostdevUsb'] = None):
        """
        :param 'DomainDevicesInterfaceSourceHostdevPciArgs' pci: Groups the source configuration for the PCI device being passed through, including its PCI address on the host.
        :param 'DomainDevicesInterfaceSourceHostdevUsbArgs' usb: Sets how the USB host device is identified for passthrough, either by topology (bus/port) or by vendor/product IDs and related options.
        """
        if pci is not None:
            pulumi.set(__self__, "pci", pci)
        if usb is not None:
            pulumi.set(__self__, "usb", usb)

    @_builtins.property
    @pulumi.getter
    def pci(self) -> Optional['outputs.DomainDevicesInterfaceSourceHostdevPci']:
        """
        Groups the source configuration for the PCI device being passed through, including its PCI address on the host.
        """
        return pulumi.get(self, "pci")

    @_builtins.property
    @pulumi.getter
    def usb(self) -> Optional['outputs.DomainDevicesInterfaceSourceHostdevUsb']:
        """
        Sets how the USB host device is identified for passthrough, either by topology (bus/port) or by vendor/product IDs and related options.
        """
        return pulumi.get(self, "usb")


@pulumi.output_type
class DomainDevicesInterfaceSourceHostdevPci(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "writeFiltering":
            suggest = "write_filtering"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceSourceHostdevPci. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceSourceHostdevPci.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceSourceHostdevPci.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional['outputs.DomainDevicesInterfaceSourceHostdevPciAddress'] = None,
                 write_filtering: Optional[_builtins.str] = None):
        """
        :param 'DomainDevicesInterfaceSourceHostdevPciAddressArgs' address: Defines the host PCI address of the device to passthrough, typically via domain, bus, slot, and function (and optional zPCI info on s390x).
        :param _builtins.str write_filtering: Controls whether write filtering is enabled for a PCI passthrough device, typically to restrict or filter MMIO/PCI configuration writes; accepts user-provided value as defined by libvirt (for example "on" or "off").
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if write_filtering is not None:
            pulumi.set(__self__, "write_filtering", write_filtering)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesInterfaceSourceHostdevPciAddress']:
        """
        Defines the host PCI address of the device to passthrough, typically via domain, bus, slot, and function (and optional zPCI info on s390x).
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="writeFiltering")
    def write_filtering(self) -> Optional[_builtins.str]:
        """
        Controls whether write filtering is enabled for a PCI passthrough device, typically to restrict or filter MMIO/PCI configuration writes; accepts user-provided value as defined by libvirt (for example "on" or "off").

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "write_filtering")


@pulumi.output_type
class DomainDevicesInterfaceSourceHostdevPciAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "multiFunction":
            suggest = "multi_function"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceSourceHostdevPciAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceSourceHostdevPciAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceSourceHostdevPciAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bus: Optional[_builtins.float] = None,
                 domain: Optional[_builtins.float] = None,
                 function: Optional[_builtins.float] = None,
                 multi_function: Optional[_builtins.str] = None,
                 slot: Optional[_builtins.float] = None,
                 zpci: Optional['outputs.DomainDevicesInterfaceSourceHostdevPciAddressZpci'] = None):
        """
        :param _builtins.float bus: Sets the PCI bus number of the host device to passthrough; the value is usually a hexadecimal or decimal bus index matching the host's PCI topology (for example, "0x03").
               
               See: <https://libvirt.org/formatdomain.html#device-addresses>
        :param _builtins.float domain: Sets the PCI domain number of the host device (segment), typically "0" on most systems; the value must match the device's domain as reported by tools like lspci.
               
               See: <https://libvirt.org/formatdomain.html#device-addresses>
        :param _builtins.float function: Sets the PCI function number of the host device (07), usually provided as a small integer or hex string (for example, "0" or "0x0") corresponding to the device's function.
               
               See: <https://libvirt.org/formatdomain.html#device-addresses>
        :param _builtins.str multi_function: Indicates whether the PCI device is part of a multifunction PCI slot; accepts "on"/"off" as yes/no flags.
               
               See: <https://libvirt.org/formatdomain.html#device-addresses>
        :param _builtins.float slot: Sets the PCI slot number of the host device, usually as a hex or decimal value (for example, "0x00" or "0") matching the slot shown by lspci.
               
               See: <https://libvirt.org/formatdomain.html#device-addresses>
        :param 'DomainDevicesInterfaceSourceHostdevPciAddressZpciArgs' zpci: Groups additional addressing attributes for s390x zPCI devices, used when passing through PCI devices on IBM Z systems.
        """
        if bus is not None:
            pulumi.set(__self__, "bus", bus)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if function is not None:
            pulumi.set(__self__, "function", function)
        if multi_function is not None:
            pulumi.set(__self__, "multi_function", multi_function)
        if slot is not None:
            pulumi.set(__self__, "slot", slot)
        if zpci is not None:
            pulumi.set(__self__, "zpci", zpci)

    @_builtins.property
    @pulumi.getter
    def bus(self) -> Optional[_builtins.float]:
        """
        Sets the PCI bus number of the host device to passthrough; the value is usually a hexadecimal or decimal bus index matching the host's PCI topology (for example, "0x03").

        See: <https://libvirt.org/formatdomain.html#device-addresses>
        """
        return pulumi.get(self, "bus")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[_builtins.float]:
        """
        Sets the PCI domain number of the host device (segment), typically "0" on most systems; the value must match the device's domain as reported by tools like lspci.

        See: <https://libvirt.org/formatdomain.html#device-addresses>
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter
    def function(self) -> Optional[_builtins.float]:
        """
        Sets the PCI function number of the host device (07), usually provided as a small integer or hex string (for example, "0" or "0x0") corresponding to the device's function.

        See: <https://libvirt.org/formatdomain.html#device-addresses>
        """
        return pulumi.get(self, "function")

    @_builtins.property
    @pulumi.getter(name="multiFunction")
    def multi_function(self) -> Optional[_builtins.str]:
        """
        Indicates whether the PCI device is part of a multifunction PCI slot; accepts "on"/"off" as yes/no flags.

        See: <https://libvirt.org/formatdomain.html#device-addresses>
        """
        return pulumi.get(self, "multi_function")

    @_builtins.property
    @pulumi.getter
    def slot(self) -> Optional[_builtins.float]:
        """
        Sets the PCI slot number of the host device, usually as a hex or decimal value (for example, "0x00" or "0") matching the slot shown by lspci.

        See: <https://libvirt.org/formatdomain.html#device-addresses>
        """
        return pulumi.get(self, "slot")

    @_builtins.property
    @pulumi.getter
    def zpci(self) -> Optional['outputs.DomainDevicesInterfaceSourceHostdevPciAddressZpci']:
        """
        Groups additional addressing attributes for s390x zPCI devices, used when passing through PCI devices on IBM Z systems.
        """
        return pulumi.get(self, "zpci")


@pulumi.output_type
class DomainDevicesInterfaceSourceHostdevPciAddressZpci(dict):
    def __init__(__self__, *,
                 fid: Optional[_builtins.float] = None,
                 uid: Optional[_builtins.float] = None):
        """
        :param _builtins.float fid: Sets the function ID (fid) for a zPCI device on s390x, identifying the specific zPCI function to passthrough; the value is user-provided and must match the host's zPCI configuration.
               
               See: <https://libvirt.org/formatdomain.html#device-addresses>
        :param _builtins.float uid: Sets the zPCI function UID for a passed-through PCI device on s390x, identifying the zPCI function within the guest; the value is user-provided and must match the host zPCI configuration.
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        if fid is not None:
            pulumi.set(__self__, "fid", fid)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def fid(self) -> Optional[_builtins.float]:
        """
        Sets the function ID (fid) for a zPCI device on s390x, identifying the specific zPCI function to passthrough; the value is user-provided and must match the host's zPCI configuration.

        See: <https://libvirt.org/formatdomain.html#device-addresses>
        """
        return pulumi.get(self, "fid")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.float]:
        """
        Sets the zPCI function UID for a passed-through PCI device on s390x, identifying the zPCI function within the guest; the value is user-provided and must match the host zPCI configuration.

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class DomainDevicesInterfaceSourceHostdevUsb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "guestReset":
            suggest = "guest_reset"
        elif key == "startUpPolicy":
            suggest = "start_up_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceSourceHostdevUsb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceSourceHostdevUsb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceSourceHostdevUsb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional['outputs.DomainDevicesInterfaceSourceHostdevUsbAddress'] = None,
                 guest_reset: Optional[_builtins.str] = None,
                 product: Optional['outputs.DomainDevicesInterfaceSourceHostdevUsbProduct'] = None,
                 start_up_policy: Optional[_builtins.str] = None,
                 vendor: Optional['outputs.DomainDevicesInterfaceSourceHostdevUsbVendor'] = None):
        """
        :param 'DomainDevicesInterfaceSourceHostdevUsbAddressArgs' address: Specifies the physical USB topology of the host device (bus, device, and/or port) used to select which USB device is passed through.
        :param _builtins.str guest_reset: Controls whether a reset is issued to the USB device when it is assigned or re-assigned to the guest; value is user-provided (typically `on`/`off` or `yes`/`no` depending on libvirt version).
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        :param 'DomainDevicesInterfaceSourceHostdevUsbProductArgs' product: Selects a USB device for passthrough by its vendor ID, typically used together with `source.product`.
        :param _builtins.str start_up_policy: Sets how strictly libvirt enforces the presence of the USB device at startup; accepts values like `mandatory`, `requisite`, or `optional` depending on libvirt support.
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        :param 'DomainDevicesInterfaceSourceHostdevUsbVendorArgs' vendor: Selects a USB device for passthrough by its vendor ID, typically used together with `source.product`.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if guest_reset is not None:
            pulumi.set(__self__, "guest_reset", guest_reset)
        if product is not None:
            pulumi.set(__self__, "product", product)
        if start_up_policy is not None:
            pulumi.set(__self__, "start_up_policy", start_up_policy)
        if vendor is not None:
            pulumi.set(__self__, "vendor", vendor)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesInterfaceSourceHostdevUsbAddress']:
        """
        Specifies the physical USB topology of the host device (bus, device, and/or port) used to select which USB device is passed through.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="guestReset")
    def guest_reset(self) -> Optional[_builtins.str]:
        """
        Controls whether a reset is issued to the USB device when it is assigned or re-assigned to the guest; value is user-provided (typically `on`/`off` or `yes`/`no` depending on libvirt version).

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "guest_reset")

    @_builtins.property
    @pulumi.getter
    def product(self) -> Optional['outputs.DomainDevicesInterfaceSourceHostdevUsbProduct']:
        """
        Selects a USB device for passthrough by its vendor ID, typically used together with `source.product`.
        """
        return pulumi.get(self, "product")

    @_builtins.property
    @pulumi.getter(name="startUpPolicy")
    def start_up_policy(self) -> Optional[_builtins.str]:
        """
        Sets how strictly libvirt enforces the presence of the USB device at startup; accepts values like `mandatory`, `requisite`, or `optional` depending on libvirt support.

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "start_up_policy")

    @_builtins.property
    @pulumi.getter
    def vendor(self) -> Optional['outputs.DomainDevicesInterfaceSourceHostdevUsbVendor']:
        """
        Selects a USB device for passthrough by its vendor ID, typically used together with `source.product`.
        """
        return pulumi.get(self, "vendor")


@pulumi.output_type
class DomainDevicesInterfaceSourceHostdevUsbAddress(dict):
    def __init__(__self__, *,
                 bus: Optional[_builtins.float] = None,
                 device: Optional[_builtins.float] = None,
                 port: Optional[_builtins.str] = None):
        """
        :param _builtins.float bus: Sets the numeric USB bus on the host where the device is attached; value is user-provided as reported by tools like `lsusb` (for example, `1`).
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        :param _builtins.float device: Sets the numeric USB device number on the selected bus; value is user-provided based on host enumeration (for example, `2`).
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        :param _builtins.str port: Sets the USB port path on the host (often a dotseparated string like `1` or `1.2`) to identify the device by its hub/port topology.
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        if bus is not None:
            pulumi.set(__self__, "bus", bus)
        if device is not None:
            pulumi.set(__self__, "device", device)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def bus(self) -> Optional[_builtins.float]:
        """
        Sets the numeric USB bus on the host where the device is attached; value is user-provided as reported by tools like `lsusb` (for example, `1`).

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "bus")

    @_builtins.property
    @pulumi.getter
    def device(self) -> Optional[_builtins.float]:
        """
        Sets the numeric USB device number on the selected bus; value is user-provided based on host enumeration (for example, `2`).

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "device")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        """
        Sets the USB port path on the host (often a dotseparated string like `1` or `1.2`) to identify the device by its hub/port topology.

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DomainDevicesInterfaceSourceHostdevUsbProduct(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Reports or sets the USB vendor ID (a 4digit hexadecimal string like `0x046d`) used to match the device; when computed, it is derived from the host device metadata.
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Reports or sets the USB vendor ID (a 4digit hexadecimal string like `0x046d`) used to match the device; when computed, it is derived from the host device metadata.

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class DomainDevicesInterfaceSourceHostdevUsbVendor(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Reports or sets the USB vendor ID (a 4digit hexadecimal string like `0x046d`) used to match the device; when computed, it is derived from the host device metadata.
               
               See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Reports or sets the USB vendor ID (a 4digit hexadecimal string like `0x046d`) used to match the device; when computed, it is derived from the host device metadata.

        See: <https://libvirt.org/formatdomain.html#usb-pci-scsi-devices>
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class DomainDevicesInterfaceSourceInternal(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Sets the name of the internal network that the interface connects to; value is user-provided and must match the identifier used by the underlying hypervisor for that internal network.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the name of the internal network that the interface connects to; value is user-provided and must match the identifier used by the underlying hypervisor for that internal network.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesInterfaceSourceMcast(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 local: Optional['outputs.DomainDevicesInterfaceSourceMcastLocal'] = None,
                 port: Optional[_builtins.float] = None):
        """
        :param _builtins.str address: Sets the remote multicast group IP address that this interface joins for the multicast tunnel (user-provided unicast/multicast address, e.g. 239.x.x.x).
               
               See: <https://libvirt.org/formatdomain.html#multicast-tunnel>
        :param 'DomainDevicesInterfaceSourceMcastLocalArgs' local: Configures the local (listening) endpoint for a UDP tunnel-backed network interface, enabling the guest-side address/port to be fixed.
        :param _builtins.float port: Sets the remote UDP port used for the multicast tunnel (user-provided integer port number, e.g. 5000).
               
               See: <https://libvirt.org/formatdomain.html#multicast-tunnel>
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if local is not None:
            pulumi.set(__self__, "local", local)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Sets the remote multicast group IP address that this interface joins for the multicast tunnel (user-provided unicast/multicast address, e.g. 239.x.x.x).

        See: <https://libvirt.org/formatdomain.html#multicast-tunnel>
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def local(self) -> Optional['outputs.DomainDevicesInterfaceSourceMcastLocal']:
        """
        Configures the local (listening) endpoint for a UDP tunnel-backed network interface, enabling the guest-side address/port to be fixed.
        """
        return pulumi.get(self, "local")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.float]:
        """
        Sets the remote UDP port used for the multicast tunnel (user-provided integer port number, e.g. 5000).

        See: <https://libvirt.org/formatdomain.html#multicast-tunnel>
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DomainDevicesInterfaceSourceMcastLocal(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 port: Optional[_builtins.float] = None):
        """
        :param _builtins.str address: Sets the local IP address on which the UDP tunnel-backed interface listens; value is user-provided (e.g. "0.0.0.0" or a specific host address).
               
               See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
        :param _builtins.float port: Sets the local UDP port on which the tunnel-backed interface listens; value is a user-provided non-negative integer (e.g. 5000).
               
               See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Sets the local IP address on which the UDP tunnel-backed interface listens; value is user-provided (e.g. "0.0.0.0" or a specific host address).

        See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.float]:
        """
        Sets the local UDP port on which the tunnel-backed interface listens; value is a user-provided non-negative integer (e.g. 5000).

        See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DomainDevicesInterfaceSourceNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portGroup":
            suggest = "port_group"
        elif key == "portId":
            suggest = "port_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceSourceNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceSourceNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceSourceNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bridge: Optional[_builtins.str] = None,
                 network: Optional[_builtins.str] = None,
                 port_group: Optional[_builtins.str] = None,
                 port_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str bridge: Sets the name of an existing host bridge device to use as the backing for this network interface (user-provided bridge name, e.g. "br0").
               
               See: <https://libvirt.org/formatdomain.html#bridge-to-lan>
        :param _builtins.str network: Sets the name of the libvirt virtual network to connect this interface to (must match a defined libvirt network name).
               
               See: <https://libvirt.org/formatdomain.html#virtual-network>
        :param _builtins.str port_group: Selects a specific portgroup within the referenced libvirt virtual network for this interface, typically to apply different QoS or VLAN settings (user-provided portgroup name).
               
               See: <https://libvirt.org/formatnetwork.html#portgroups>
        :param _builtins.str port_id: Sets a backend-specific port identifier for integration with external networking (e.g. Open vSwitch or SDN controllers), using a user-provided opaque ID string.
               
               See: <https://libvirt.org/formatdomain.html#virtual-network>
        """
        if bridge is not None:
            pulumi.set(__self__, "bridge", bridge)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if port_group is not None:
            pulumi.set(__self__, "port_group", port_group)
        if port_id is not None:
            pulumi.set(__self__, "port_id", port_id)

    @_builtins.property
    @pulumi.getter
    def bridge(self) -> Optional[_builtins.str]:
        """
        Sets the name of an existing host bridge device to use as the backing for this network interface (user-provided bridge name, e.g. "br0").

        See: <https://libvirt.org/formatdomain.html#bridge-to-lan>
        """
        return pulumi.get(self, "bridge")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        Sets the name of the libvirt virtual network to connect this interface to (must match a defined libvirt network name).

        See: <https://libvirt.org/formatdomain.html#virtual-network>
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="portGroup")
    def port_group(self) -> Optional[_builtins.str]:
        """
        Selects a specific portgroup within the referenced libvirt virtual network for this interface, typically to apply different QoS or VLAN settings (user-provided portgroup name).

        See: <https://libvirt.org/formatnetwork.html#portgroups>
        """
        return pulumi.get(self, "port_group")

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> Optional[_builtins.str]:
        """
        Sets a backend-specific port identifier for integration with external networking (e.g. Open vSwitch or SDN controllers), using a user-provided opaque ID string.

        See: <https://libvirt.org/formatdomain.html#virtual-network>
        """
        return pulumi.get(self, "port_id")


@pulumi.output_type
class DomainDevicesInterfaceSourceServer(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 local: Optional['outputs.DomainDevicesInterfaceSourceServerLocal'] = None,
                 port: Optional[_builtins.float] = None):
        """
        :param _builtins.str address: Sets the remote or local TCP IP address for the TCP-tunnel server endpoint backing this interface (user-provided IP or hostname).
               
               See: <https://libvirt.org/formatdomain.html#tcp-tunnel>
        :param 'DomainDevicesInterfaceSourceServerLocalArgs' local: Configures the local (listening) endpoint for a UDP tunnel-backed network interface, enabling the guest-side address/port to be fixed.
        :param _builtins.float port: Sets the remote or listening TCP port used for the TCP tunnel backing this interface (user-provided integer port).
               
               See: <https://libvirt.org/formatdomain.html#tcp-tunnel>
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if local is not None:
            pulumi.set(__self__, "local", local)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Sets the remote or local TCP IP address for the TCP-tunnel server endpoint backing this interface (user-provided IP or hostname).

        See: <https://libvirt.org/formatdomain.html#tcp-tunnel>
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def local(self) -> Optional['outputs.DomainDevicesInterfaceSourceServerLocal']:
        """
        Configures the local (listening) endpoint for a UDP tunnel-backed network interface, enabling the guest-side address/port to be fixed.
        """
        return pulumi.get(self, "local")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.float]:
        """
        Sets the remote or listening TCP port used for the TCP tunnel backing this interface (user-provided integer port).

        See: <https://libvirt.org/formatdomain.html#tcp-tunnel>
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DomainDevicesInterfaceSourceServerLocal(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 port: Optional[_builtins.float] = None):
        """
        :param _builtins.str address: Sets the local IP address on which the UDP tunnel-backed interface listens; value is user-provided (e.g. "0.0.0.0" or a specific host address).
               
               See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
        :param _builtins.float port: Sets the local UDP port on which the tunnel-backed interface listens; value is a user-provided non-negative integer (e.g. 5000).
               
               See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Sets the local IP address on which the UDP tunnel-backed interface listens; value is user-provided (e.g. "0.0.0.0" or a specific host address).

        See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.float]:
        """
        Sets the local UDP port on which the tunnel-backed interface listens; value is a user-provided non-negative integer (e.g. 5000).

        See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DomainDevicesInterfaceSourceUdp(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 local: Optional['outputs.DomainDevicesInterfaceSourceUdpLocal'] = None,
                 port: Optional[_builtins.float] = None):
        """
        :param _builtins.str address: Sets the remote UDP endpoint IP address or hostname for the UDP unicast tunnel backing this interface (user-provided address).
               
               See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
        :param 'DomainDevicesInterfaceSourceUdpLocalArgs' local: Configures the local (listening) endpoint for a UDP tunnel-backed network interface, enabling the guest-side address/port to be fixed.
        :param _builtins.float port: Sets the remote UDP port to which the tunnel-backed network interface sends packets; value is a user-provided non-negative integer (e.g. 5000).
               
               See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if local is not None:
            pulumi.set(__self__, "local", local)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Sets the remote UDP endpoint IP address or hostname for the UDP unicast tunnel backing this interface (user-provided address).

        See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def local(self) -> Optional['outputs.DomainDevicesInterfaceSourceUdpLocal']:
        """
        Configures the local (listening) endpoint for a UDP tunnel-backed network interface, enabling the guest-side address/port to be fixed.
        """
        return pulumi.get(self, "local")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.float]:
        """
        Sets the remote UDP port to which the tunnel-backed network interface sends packets; value is a user-provided non-negative integer (e.g. 5000).

        See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DomainDevicesInterfaceSourceUdpLocal(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 port: Optional[_builtins.float] = None):
        """
        :param _builtins.str address: Sets the local IP address on which the UDP tunnel-backed interface listens; value is user-provided (e.g. "0.0.0.0" or a specific host address).
               
               See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
        :param _builtins.float port: Sets the local UDP port on which the tunnel-backed interface listens; value is a user-provided non-negative integer (e.g. 5000).
               
               See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Sets the local IP address on which the UDP tunnel-backed interface listens; value is user-provided (e.g. "0.0.0.0" or a specific host address).

        See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.float]:
        """
        Sets the local UDP port on which the tunnel-backed interface listens; value is a user-provided non-negative integer (e.g. 5000).

        See: <https://libvirt.org/formatdomain.html#udp-unicast-tunnel>
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DomainDevicesInterfaceSourceUser(dict):
    def __init__(__self__, *,
                 dev: Optional[_builtins.str] = None):
        """
        :param _builtins.str dev: Sets an optional host-side device name or identifier for the user-mode (SLIRP) networking backend; value is user-provided and normally omitted.
               
               See: <https://libvirt.org/formatdomain.html#userspace-connection-using-slirp>
        """
        if dev is not None:
            pulumi.set(__self__, "dev", dev)

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional[_builtins.str]:
        """
        Sets an optional host-side device name or identifier for the user-mode (SLIRP) networking backend; value is user-provided and normally omitted.

        See: <https://libvirt.org/formatdomain.html#userspace-connection-using-slirp>
        """
        return pulumi.get(self, "dev")


@pulumi.output_type
class DomainDevicesInterfaceSourceVdpa(dict):
    def __init__(__self__, *,
                 device: Optional[_builtins.str] = None):
        """
        :param _builtins.str device: Sets the path or name of the vDPA device (e.g. "/dev/vhost-vdpaX") used as the source for the interface; value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#vdpa-devices>
        """
        if device is not None:
            pulumi.set(__self__, "device", device)

    @_builtins.property
    @pulumi.getter
    def device(self) -> Optional[_builtins.str]:
        """
        Sets the path or name of the vDPA device (e.g. "/dev/vhost-vdpaX") used as the source for the interface; value is user-provided.

        See: <https://libvirt.org/formatdomain.html#vdpa-devices>
        """
        return pulumi.get(self, "device")


@pulumi.output_type
class DomainDevicesInterfaceSourceVds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "switchId":
            suggest = "switch_id"
        elif key == "connectionId":
            suggest = "connection_id"
        elif key == "portGroupId":
            suggest = "port_group_id"
        elif key == "portId":
            suggest = "port_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceSourceVds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceSourceVds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceSourceVds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 switch_id: _builtins.str,
                 connection_id: Optional[_builtins.float] = None,
                 port_group_id: Optional[_builtins.str] = None,
                 port_id: Optional[_builtins.float] = None):
        """
        :param _builtins.str switch_id: Sets the VMware Distributed Switch identifier to which the interface connects; this is required and must be a user-provided VDS ID.
               
               See: <https://libvirt.org/formatdomain.html#vmware-distributed-switch>
        :param _builtins.float connection_id: Sets the VDS connection identifier that associates the interface with a particular distributed switch connection; value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#vmware-distributed-switch>
        :param _builtins.str port_group_id: Sets the VDS port group identifier that determines which distributed port group the interface attaches to; value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#vmware-distributed-switch>
        :param _builtins.float port_id: Sets a specific VDS port identifier within the distributed switch to attach this interface to; value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#vmware-distributed-switch>
        """
        pulumi.set(__self__, "switch_id", switch_id)
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if port_group_id is not None:
            pulumi.set(__self__, "port_group_id", port_group_id)
        if port_id is not None:
            pulumi.set(__self__, "port_id", port_id)

    @_builtins.property
    @pulumi.getter(name="switchId")
    def switch_id(self) -> _builtins.str:
        """
        Sets the VMware Distributed Switch identifier to which the interface connects; this is required and must be a user-provided VDS ID.

        See: <https://libvirt.org/formatdomain.html#vmware-distributed-switch>
        """
        return pulumi.get(self, "switch_id")

    @_builtins.property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[_builtins.float]:
        """
        Sets the VDS connection identifier that associates the interface with a particular distributed switch connection; value is user-provided.

        See: <https://libvirt.org/formatdomain.html#vmware-distributed-switch>
        """
        return pulumi.get(self, "connection_id")

    @_builtins.property
    @pulumi.getter(name="portGroupId")
    def port_group_id(self) -> Optional[_builtins.str]:
        """
        Sets the VDS port group identifier that determines which distributed port group the interface attaches to; value is user-provided.

        See: <https://libvirt.org/formatdomain.html#vmware-distributed-switch>
        """
        return pulumi.get(self, "port_group_id")

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> Optional[_builtins.float]:
        """
        Sets a specific VDS port identifier within the distributed switch to attach this interface to; value is user-provided.

        See: <https://libvirt.org/formatdomain.html#vmware-distributed-switch>
        """
        return pulumi.get(self, "port_id")


@pulumi.output_type
class DomainDevicesInterfaceSourceVhostUser(dict):
    def __init__(__self__, *,
                 dev: _builtins.str,
                 chardev: Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardev'] = None):
        """
        :param _builtins.str dev: Sets the vhost-user device path for the interface, typically the UNIX socket path used by the vhost-user backend (for example, "/var/run/vhost-user.sock").
               
               See: <https://libvirt.org/formatdomain.html#vhost-user-connection>
        :param 'DomainDevicesInterfaceSourceVhostUserChardevArgs' chardev: Defines the source endpoint for the EGD backend, such as a socket path or network address, depending on the chosen protocol.
        """
        pulumi.set(__self__, "dev", dev)
        if chardev is not None:
            pulumi.set(__self__, "chardev", chardev)

    @_builtins.property
    @pulumi.getter
    def dev(self) -> _builtins.str:
        """
        Sets the vhost-user device path for the interface, typically the UNIX socket path used by the vhost-user backend (for example, "/var/run/vhost-user.sock").

        See: <https://libvirt.org/formatdomain.html#vhost-user-connection>
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter
    def chardev(self) -> Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardev']:
        """
        Defines the source endpoint for the EGD backend, such as a socket path or network address, depending on the chosen protocol.
        """
        return pulumi.get(self, "chardev")


@pulumi.output_type
class DomainDevicesInterfaceSourceVhostUserChardev(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "qemuvdAgent":
            suggest = "qemuvd_agent"
        elif key == "spicePort":
            suggest = "spice_port"
        elif key == "spiceVmc":
            suggest = "spice_vmc"
        elif key == "stdIo":
            suggest = "std_io"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceSourceVhostUserChardev. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceSourceVhostUserChardev.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceSourceVhostUserChardev.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbus: Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevDbus'] = None,
                 dev: Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevDev'] = None,
                 file: Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevFile'] = None,
                 nmdm: Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevNmdm'] = None,
                 null: Optional[_builtins.bool] = None,
                 pipe: Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevPipe'] = None,
                 pty: Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevPty'] = None,
                 qemuvd_agent: Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevQemuvdAgent'] = None,
                 spice_port: Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevSpicePort'] = None,
                 spice_vmc: Optional[_builtins.bool] = None,
                 std_io: Optional[_builtins.bool] = None,
                 tcp: Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevTcp'] = None,
                 udp: Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevUdp'] = None,
                 unix: Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevUnix'] = None,
                 vc: Optional[_builtins.bool] = None):
        """
        :param 'DomainDevicesInterfaceSourceVhostUserChardevDbusArgs' dbus: Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        :param 'DomainDevicesInterfaceSourceVhostUserChardevDevArgs' dev: Configures an EGD RNG backend that reads entropy from a host character device node.
        :param 'DomainDevicesInterfaceSourceVhostUserChardevFileArgs' file: Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        :param 'DomainDevicesInterfaceSourceVhostUserChardevNmdmArgs' nmdm: Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        :param _builtins.bool null: Enables use of a null backend for the EGD RNG source, discarding all data written and providing no entropy; when this boolean is true the <Null> source is emitted, and when false or unset it is omitted.
        :param 'DomainDevicesInterfaceSourceVhostUserChardevPipeArgs' pipe: Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        :param 'DomainDevicesInterfaceSourceVhostUserChardevPtyArgs' pty: Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        :param 'DomainDevicesInterfaceSourceVhostUserChardevQemuvdAgentArgs' qemuvd_agent: Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        :param 'DomainDevicesInterfaceSourceVhostUserChardevSpicePortArgs' spice_port: Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        :param _builtins.bool spice_vmc: Enables using a SPICE virtio serial management channel (spicevmc) as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.bool std_io: Enables using the QEMU process standard I/O stream as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesInterfaceSourceVhostUserChardevTcpArgs' tcp: Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        :param 'DomainDevicesInterfaceSourceVhostUserChardevUdpArgs' udp: Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        :param 'DomainDevicesInterfaceSourceVhostUserChardevUnixArgs' unix: Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        :param _builtins.bool vc: Enables use of a virtual console device as the entropy source for the EGD RNG backend when set (presence-only element; omitting it disables this source).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if dbus is not None:
            pulumi.set(__self__, "dbus", dbus)
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if nmdm is not None:
            pulumi.set(__self__, "nmdm", nmdm)
        if null is not None:
            pulumi.set(__self__, "null", null)
        if pipe is not None:
            pulumi.set(__self__, "pipe", pipe)
        if pty is not None:
            pulumi.set(__self__, "pty", pty)
        if qemuvd_agent is not None:
            pulumi.set(__self__, "qemuvd_agent", qemuvd_agent)
        if spice_port is not None:
            pulumi.set(__self__, "spice_port", spice_port)
        if spice_vmc is not None:
            pulumi.set(__self__, "spice_vmc", spice_vmc)
        if std_io is not None:
            pulumi.set(__self__, "std_io", std_io)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)
        if unix is not None:
            pulumi.set(__self__, "unix", unix)
        if vc is not None:
            pulumi.set(__self__, "vc", vc)

    @_builtins.property
    @pulumi.getter
    def dbus(self) -> Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevDbus']:
        """
        Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        """
        return pulumi.get(self, "dbus")

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevDev']:
        """
        Configures an EGD RNG backend that reads entropy from a host character device node.
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevFile']:
        """
        Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def nmdm(self) -> Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevNmdm']:
        """
        Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        """
        return pulumi.get(self, "nmdm")

    @_builtins.property
    @pulumi.getter
    def null(self) -> Optional[_builtins.bool]:
        """
        Enables use of a null backend for the EGD RNG source, discarding all data written and providing no entropy; when this boolean is true the <Null> source is emitted, and when false or unset it is omitted.
        """
        return pulumi.get(self, "null")

    @_builtins.property
    @pulumi.getter
    def pipe(self) -> Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevPipe']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        """
        return pulumi.get(self, "pipe")

    @_builtins.property
    @pulumi.getter
    def pty(self) -> Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevPty']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        """
        return pulumi.get(self, "pty")

    @_builtins.property
    @pulumi.getter(name="qemuvdAgent")
    def qemuvd_agent(self) -> Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevQemuvdAgent']:
        """
        Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        """
        return pulumi.get(self, "qemuvd_agent")

    @_builtins.property
    @pulumi.getter(name="spicePort")
    def spice_port(self) -> Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevSpicePort']:
        """
        Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        """
        return pulumi.get(self, "spice_port")

    @_builtins.property
    @pulumi.getter(name="spiceVmc")
    def spice_vmc(self) -> Optional[_builtins.bool]:
        """
        Enables using a SPICE virtio serial management channel (spicevmc) as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "spice_vmc")

    @_builtins.property
    @pulumi.getter(name="stdIo")
    def std_io(self) -> Optional[_builtins.bool]:
        """
        Enables using the QEMU process standard I/O stream as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "std_io")

    @_builtins.property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevTcp']:
        """
        Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        """
        return pulumi.get(self, "tcp")

    @_builtins.property
    @pulumi.getter
    def udp(self) -> Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevUdp']:
        """
        Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        """
        return pulumi.get(self, "udp")

    @_builtins.property
    @pulumi.getter
    def unix(self) -> Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevUnix']:
        """
        Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        """
        return pulumi.get(self, "unix")

    @_builtins.property
    @pulumi.getter
    def vc(self) -> Optional[_builtins.bool]:
        """
        Enables use of a virtual console device as the entropy source for the EGD RNG backend when set (presence-only element; omitting it disables this source).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "vc")


@pulumi.output_type
class DomainDevicesInterfaceSourceVhostUserChardevDbus(dict):
    def __init__(__self__, *,
                 channel: Optional[_builtins.str] = None):
        """
        :param _builtins.str channel: Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.str]:
        """
        Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesInterfaceSourceVhostUserChardevDev(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceSourceVhostUserChardevDev. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceSourceVhostUserChardevDev.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceSourceVhostUserChardevDev.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesInterfaceSourceVhostUserChardevDevSecLabel']] = None):
        """
        :param _builtins.str path: Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesInterfaceSourceVhostUserChardevDevSecLabelArgs'] sec_labels: Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesInterfaceSourceVhostUserChardevDevSecLabel']]:
        """
        Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesInterfaceSourceVhostUserChardevDevSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceSourceVhostUserChardevDevSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceSourceVhostUserChardevDevSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceSourceVhostUserChardevDevSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesInterfaceSourceVhostUserChardevFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceSourceVhostUserChardevFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceSourceVhostUserChardevFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceSourceVhostUserChardevFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 append: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesInterfaceSourceVhostUserChardevFileSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str append: Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
               
               See: <https://libvirt.org/formatdomain.html#device-logfile>
        :param Sequence['DomainDevicesInterfaceSourceVhostUserChardevFileSecLabelArgs'] sec_labels: Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def append(self) -> Optional[_builtins.str]:
        """
        Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.

        See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        return pulumi.get(self, "append")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesInterfaceSourceVhostUserChardevFileSecLabel']]:
        """
        Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesInterfaceSourceVhostUserChardevFileSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceSourceVhostUserChardevFileSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceSourceVhostUserChardevFileSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceSourceVhostUserChardevFileSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesInterfaceSourceVhostUserChardevNmdm(dict):
    def __init__(__self__, *,
                 master: _builtins.str,
                 slave: _builtins.str):
        """
        :param _builtins.str master: Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        :param _builtins.str slave: Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        pulumi.set(__self__, "master", master)
        pulumi.set(__self__, "slave", slave)

    @_builtins.property
    @pulumi.getter
    def master(self) -> _builtins.str:
        """
        Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "master")

    @_builtins.property
    @pulumi.getter
    def slave(self) -> _builtins.str:
        """
        Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "slave")


@pulumi.output_type
class DomainDevicesInterfaceSourceVhostUserChardevPipe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceSourceVhostUserChardevPipe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceSourceVhostUserChardevPipe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceSourceVhostUserChardevPipe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesInterfaceSourceVhostUserChardevPipeSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesInterfaceSourceVhostUserChardevPipeSecLabelArgs'] sec_labels: Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesInterfaceSourceVhostUserChardevPipeSecLabel']]:
        """
        Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesInterfaceSourceVhostUserChardevPipeSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceSourceVhostUserChardevPipeSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceSourceVhostUserChardevPipeSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceSourceVhostUserChardevPipeSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesInterfaceSourceVhostUserChardevPty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceSourceVhostUserChardevPty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceSourceVhostUserChardevPty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceSourceVhostUserChardevPty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesInterfaceSourceVhostUserChardevPtySecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesInterfaceSourceVhostUserChardevPtySecLabelArgs'] sec_labels: Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesInterfaceSourceVhostUserChardevPtySecLabel']]:
        """
        Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesInterfaceSourceVhostUserChardevPtySecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceSourceVhostUserChardevPtySecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceSourceVhostUserChardevPtySecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceSourceVhostUserChardevPtySecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesInterfaceSourceVhostUserChardevQemuvdAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clipBoard":
            suggest = "clip_board"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceSourceVhostUserChardevQemuvdAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceSourceVhostUserChardevQemuvdAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceSourceVhostUserChardevQemuvdAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clip_board: Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevQemuvdAgentClipBoard'] = None,
                 mouse: Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevQemuvdAgentMouse'] = None):
        """
        :param 'DomainDevicesInterfaceSourceVhostUserChardevQemuvdAgentClipBoardArgs' clip_board: Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        :param 'DomainDevicesInterfaceSourceVhostUserChardevQemuvdAgentMouseArgs' mouse: Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        if clip_board is not None:
            pulumi.set(__self__, "clip_board", clip_board)
        if mouse is not None:
            pulumi.set(__self__, "mouse", mouse)

    @_builtins.property
    @pulumi.getter(name="clipBoard")
    def clip_board(self) -> Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevQemuvdAgentClipBoard']:
        """
        Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        """
        return pulumi.get(self, "clip_board")

    @_builtins.property
    @pulumi.getter
    def mouse(self) -> Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevQemuvdAgentMouse']:
        """
        Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        return pulumi.get(self, "mouse")


@pulumi.output_type
class DomainDevicesInterfaceSourceVhostUserChardevQemuvdAgentClipBoard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyPaste":
            suggest = "copy_paste"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceSourceVhostUserChardevQemuvdAgentClipBoard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceSourceVhostUserChardevQemuvdAgentClipBoard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceSourceVhostUserChardevQemuvdAgentClipBoard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_paste: _builtins.str):
        """
        :param _builtins.str copy_paste: Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "copy_paste", copy_paste)

    @_builtins.property
    @pulumi.getter(name="copyPaste")
    def copy_paste(self) -> _builtins.str:
        """
        Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "copy_paste")


@pulumi.output_type
class DomainDevicesInterfaceSourceVhostUserChardevQemuvdAgentMouse(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DomainDevicesInterfaceSourceVhostUserChardevSpicePort(dict):
    def __init__(__self__, *,
                 channel: _builtins.str):
        """
        :param _builtins.str channel: Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesInterfaceSourceVhostUserChardevTcp(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevTcpReconnect'] = None,
                 service: Optional[_builtins.str] = None,
                 tls: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str mode: Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesInterfaceSourceVhostUserChardevTcpReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param _builtins.str service: Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str tls: Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevTcpReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[_builtins.str]:
        """
        Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class DomainDevicesInterfaceSourceVhostUserChardevTcpReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesInterfaceSourceVhostUserChardevUdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindHost":
            suggest = "bind_host"
        elif key == "bindService":
            suggest = "bind_service"
        elif key == "connectHost":
            suggest = "connect_host"
        elif key == "connectService":
            suggest = "connect_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceSourceVhostUserChardevUdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceSourceVhostUserChardevUdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceSourceVhostUserChardevUdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bind_host: _builtins.str,
                 bind_service: _builtins.str,
                 connect_host: _builtins.str,
                 connect_service: _builtins.str):
        """
        :param _builtins.str bind_host: Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str bind_service: Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_host: Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_service: Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "bind_host", bind_host)
        pulumi.set(__self__, "bind_service", bind_service)
        pulumi.set(__self__, "connect_host", connect_host)
        pulumi.set(__self__, "connect_service", connect_service)

    @_builtins.property
    @pulumi.getter(name="bindHost")
    def bind_host(self) -> _builtins.str:
        """
        Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_host")

    @_builtins.property
    @pulumi.getter(name="bindService")
    def bind_service(self) -> _builtins.str:
        """
        Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_service")

    @_builtins.property
    @pulumi.getter(name="connectHost")
    def connect_host(self) -> _builtins.str:
        """
        Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_host")

    @_builtins.property
    @pulumi.getter(name="connectService")
    def connect_service(self) -> _builtins.str:
        """
        Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_service")


@pulumi.output_type
class DomainDevicesInterfaceSourceVhostUserChardevUnix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceSourceVhostUserChardevUnix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceSourceVhostUserChardevUnix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceSourceVhostUserChardevUnix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevUnixReconnect'] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesInterfaceSourceVhostUserChardevUnixSecLabel']] = None):
        """
        :param _builtins.str mode: Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str path: Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesInterfaceSourceVhostUserChardevUnixReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param Sequence['DomainDevicesInterfaceSourceVhostUserChardevUnixSecLabelArgs'] sec_labels: Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesInterfaceSourceVhostUserChardevUnixReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesInterfaceSourceVhostUserChardevUnixSecLabel']]:
        """
        Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesInterfaceSourceVhostUserChardevUnixReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesInterfaceSourceVhostUserChardevUnixSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceSourceVhostUserChardevUnixSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceSourceVhostUserChardevUnixSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceSourceVhostUserChardevUnixSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesInterfaceTarget(dict):
    def __init__(__self__, *,
                 dev: _builtins.str,
                 managed: Optional[_builtins.bool] = None):
        """
        :param _builtins.str dev: Sets the target device name for the interface (for example, "vnet0" or "tap0") that will be created or used on the host.
               
               See: <https://libvirt.org/formatdomain.html#overriding-the-target-element>
        :param _builtins.bool managed: Controls whether libvirt manages the lifecycle of the target device; boolean is encoded as "yes" or "no" in XML.
               
               See: <https://libvirt.org/formatdomain.html#generic-ethernet-connection>
        """
        pulumi.set(__self__, "dev", dev)
        if managed is not None:
            pulumi.set(__self__, "managed", managed)

    @_builtins.property
    @pulumi.getter
    def dev(self) -> _builtins.str:
        """
        Sets the target device name for the interface (for example, "vnet0" or "tap0") that will be created or used on the host.

        See: <https://libvirt.org/formatdomain.html#overriding-the-target-element>
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter
    def managed(self) -> Optional[_builtins.bool]:
        """
        Controls whether libvirt manages the lifecycle of the target device; boolean is encoded as "yes" or "no" in XML.

        See: <https://libvirt.org/formatdomain.html#generic-ethernet-connection>
        """
        return pulumi.get(self, "managed")


@pulumi.output_type
class DomainDevicesInterfaceTeaming(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 persistent: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Sets the teaming mode for this hostdev (for example "persistent" or "transient") and is required when teaming is configured; valid values are those supported by libvirt for teaming type.
               
               See: <https://libvirt.org/formatdomain.html#teaming-a-virtio-hostdev-nic-pair>
        :param _builtins.str persistent: Controls whether the teaming configuration for this hostdev should survive guest reboots; when true, the team is kept persistent, when false it is transient for the current guest lifecycle.
               
               See: <https://libvirt.org/formatdomain.html#teaming-a-virtio-hostdev-nic-pair>
        """
        pulumi.set(__self__, "type", type)
        if persistent is not None:
            pulumi.set(__self__, "persistent", persistent)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets the teaming mode for this hostdev (for example "persistent" or "transient") and is required when teaming is configured; valid values are those supported by libvirt for teaming type.

        See: <https://libvirt.org/formatdomain.html#teaming-a-virtio-hostdev-nic-pair>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def persistent(self) -> Optional[_builtins.str]:
        """
        Controls whether the teaming configuration for this hostdev should survive guest reboots; when true, the team is kept persistent, when false it is transient for the current guest lifecycle.

        See: <https://libvirt.org/formatdomain.html#teaming-a-virtio-hostdev-nic-pair>
        """
        return pulumi.get(self, "persistent")


@pulumi.output_type
class DomainDevicesInterfaceTune(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sndBuf":
            suggest = "snd_buf"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceTune. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceTune.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceTune.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 snd_buf: _builtins.float):
        """
        :param _builtins.float snd_buf: Sets the send buffer (sndbuf) size, in bytes, for the interface backend; value is a user-provided non-negative integer (for example, 1048576).
               
               See: <https://libvirt.org/formatdomain.html#setting-network-backend-specific-options>
        """
        pulumi.set(__self__, "snd_buf", snd_buf)

    @_builtins.property
    @pulumi.getter(name="sndBuf")
    def snd_buf(self) -> _builtins.float:
        """
        Sets the send buffer (sndbuf) size, in bytes, for the interface backend; value is a user-provided non-negative integer (for example, 1048576).

        See: <https://libvirt.org/formatdomain.html#setting-network-backend-specific-options>
        """
        return pulumi.get(self, "snd_buf")


@pulumi.output_type
class DomainDevicesInterfaceVirtualPort(dict):
    def __init__(__self__, *,
                 params: Optional['outputs.DomainDevicesInterfaceVirtualPortParams'] = None):
        """
        :param 'DomainDevicesInterfaceVirtualPortParamsArgs' params: Provides backend-specific parameter set for the virtual port profile; concrete attributes depend on the underlying virtual switch or network driver.
        """
        if params is not None:
            pulumi.set(__self__, "params", params)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional['outputs.DomainDevicesInterfaceVirtualPortParams']:
        """
        Provides backend-specific parameter set for the virtual port profile; concrete attributes depend on the underlying virtual switch or network driver.
        """
        return pulumi.get(self, "params")


@pulumi.output_type
class DomainDevicesInterfaceVirtualPortParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "midoNet":
            suggest = "mido_net"
        elif key == "openVSwitch":
            suggest = "open_v_switch"
        elif key == "vnTag8011qbh":
            suggest = "vn_tag8011qbh"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceVirtualPortParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceVirtualPortParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceVirtualPortParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any: Optional['outputs.DomainDevicesInterfaceVirtualPortParamsAny'] = None,
                 mido_net: Optional['outputs.DomainDevicesInterfaceVirtualPortParamsMidoNet'] = None,
                 open_v_switch: Optional['outputs.DomainDevicesInterfaceVirtualPortParamsOpenVSwitch'] = None,
                 vepa8021qbg: Optional['outputs.DomainDevicesInterfaceVirtualPortParamsVepa8021qbg'] = None,
                 vn_tag8011qbh: Optional['outputs.DomainDevicesInterfaceVirtualPortParamsVnTag8011qbh'] = None):
        """
        :param 'DomainDevicesInterfaceVirtualPortParamsAnyArgs' any: Enables a generic "any" virtual port profile parameter block, allowing arbitrary identification fields understood by the network backend.
        :param 'DomainDevicesInterfaceVirtualPortParamsMidoNetArgs' mido_net: Enables Midonet-specific virtual port parameters for this interface; only one virtual_port parameters block (Midonet, Open vSwitch, VEPA8021QBG, VNTag8011QBH, or Any) should be set at a time.
        :param 'DomainDevicesInterfaceVirtualPortParamsOpenVSwitchArgs' open_v_switch: Enables Open vSwitch-specific virtual port parameters for this interface; only one virtual_port parameters block (Midonet, Open vSwitch, VEPA8021QBG, VNTag8011QBH, or Any) should be set at a time.
        :param 'DomainDevicesInterfaceVirtualPortParamsVepa8021qbgArgs' vepa8021qbg: Enables 802.1Qbg VEPA virtual port profile parameters for this interface; only one virtual_port parameters block (VEPA8021QBG, VNTag8011QBH, Midonet, Open vSwitch, or Any) should be set at a time.
        :param 'DomainDevicesInterfaceVirtualPortParamsVnTag8011qbhArgs' vn_tag8011qbh: Enables 802.1Qbh VN-Tag virtual port profile parameters for this interface; only one virtual_port parameters block (VNTag8011QBH, VEPA8021QBG, Midonet, Open vSwitch, or Any) should be set at a time.
        """
        if any is not None:
            pulumi.set(__self__, "any", any)
        if mido_net is not None:
            pulumi.set(__self__, "mido_net", mido_net)
        if open_v_switch is not None:
            pulumi.set(__self__, "open_v_switch", open_v_switch)
        if vepa8021qbg is not None:
            pulumi.set(__self__, "vepa8021qbg", vepa8021qbg)
        if vn_tag8011qbh is not None:
            pulumi.set(__self__, "vn_tag8011qbh", vn_tag8011qbh)

    @_builtins.property
    @pulumi.getter
    def any(self) -> Optional['outputs.DomainDevicesInterfaceVirtualPortParamsAny']:
        """
        Enables a generic "any" virtual port profile parameter block, allowing arbitrary identification fields understood by the network backend.
        """
        return pulumi.get(self, "any")

    @_builtins.property
    @pulumi.getter(name="midoNet")
    def mido_net(self) -> Optional['outputs.DomainDevicesInterfaceVirtualPortParamsMidoNet']:
        """
        Enables Midonet-specific virtual port parameters for this interface; only one virtual_port parameters block (Midonet, Open vSwitch, VEPA8021QBG, VNTag8011QBH, or Any) should be set at a time.
        """
        return pulumi.get(self, "mido_net")

    @_builtins.property
    @pulumi.getter(name="openVSwitch")
    def open_v_switch(self) -> Optional['outputs.DomainDevicesInterfaceVirtualPortParamsOpenVSwitch']:
        """
        Enables Open vSwitch-specific virtual port parameters for this interface; only one virtual_port parameters block (Midonet, Open vSwitch, VEPA8021QBG, VNTag8011QBH, or Any) should be set at a time.
        """
        return pulumi.get(self, "open_v_switch")

    @_builtins.property
    @pulumi.getter
    def vepa8021qbg(self) -> Optional['outputs.DomainDevicesInterfaceVirtualPortParamsVepa8021qbg']:
        """
        Enables 802.1Qbg VEPA virtual port profile parameters for this interface; only one virtual_port parameters block (VEPA8021QBG, VNTag8011QBH, Midonet, Open vSwitch, or Any) should be set at a time.
        """
        return pulumi.get(self, "vepa8021qbg")

    @_builtins.property
    @pulumi.getter(name="vnTag8011qbh")
    def vn_tag8011qbh(self) -> Optional['outputs.DomainDevicesInterfaceVirtualPortParamsVnTag8011qbh']:
        """
        Enables 802.1Qbh VN-Tag virtual port profile parameters for this interface; only one virtual_port parameters block (VNTag8011QBH, VEPA8021QBG, Midonet, Open vSwitch, or Any) should be set at a time.
        """
        return pulumi.get(self, "vn_tag8011qbh")


@pulumi.output_type
class DomainDevicesInterfaceVirtualPortParamsAny(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceId":
            suggest = "instance_id"
        elif key == "interfaceId":
            suggest = "interface_id"
        elif key == "managerId":
            suggest = "manager_id"
        elif key == "profileId":
            suggest = "profile_id"
        elif key == "typeId":
            suggest = "type_id"
        elif key == "typeIdVersion":
            suggest = "type_id_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceVirtualPortParamsAny. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceVirtualPortParamsAny.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceVirtualPortParamsAny.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_id: Optional[_builtins.str] = None,
                 interface_id: Optional[_builtins.str] = None,
                 manager_id: Optional[_builtins.float] = None,
                 profile_id: Optional[_builtins.str] = None,
                 type_id: Optional[_builtins.float] = None,
                 type_id_version: Optional[_builtins.float] = None):
        """
        :param _builtins.str instance_id: Sets an opaque instance identifier for the virtual port profile, used by some network platforms to uniquely track the interface; value is user-provided (often a UUID-like string).
               
               See: <https://libvirt.org/formatdomain.html#virtual-network>
        :param _builtins.str interface_id: Sets an opaque interface identifier for the virtual port profile, typically used by SDN or virtual switch controllers; value is user-provided (often a UUID or similar).
               
               See: <https://libvirt.org/formatdomain.html#virtual-network>
        :param _builtins.float manager_id: Sets an opaque manager identifier for the virtual port profile, identifying the controlling network manager or switch domain; value is user-provided integer or string as expected by the backend.
               
               See: <https://libvirt.org/formatdomain.html#virtual-network>
        :param _builtins.str profile_id: Sets the opaque profile identifier passed to a generic 802.1Qbh/any virtual port profile; the value is user-provided and interpreted by the underlying switch or SDN controller (for example, "profile-1").
               
               See: <https://libvirt.org/formatdomain.html#virtual-network>
        :param _builtins.float type_id: Sets the 802.1Qbh profile type identifier for a generic virtual port profile; the value is user-provided (typically a numeric or UUID-like identifier defined by the switch implementation).
               
               See: <https://libvirt.org/formatdomain.html#virtual-network>
        :param _builtins.float type_id_version: Sets the version of the 802.1Qbh profile type for a generic virtual port profile; the value is user-provided and must match what the upstream switch expects (for example, "1").
               
               See: <https://libvirt.org/formatdomain.html#virtual-network>
        """
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if interface_id is not None:
            pulumi.set(__self__, "interface_id", interface_id)
        if manager_id is not None:
            pulumi.set(__self__, "manager_id", manager_id)
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)
        if type_id is not None:
            pulumi.set(__self__, "type_id", type_id)
        if type_id_version is not None:
            pulumi.set(__self__, "type_id_version", type_id_version)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[_builtins.str]:
        """
        Sets an opaque instance identifier for the virtual port profile, used by some network platforms to uniquely track the interface; value is user-provided (often a UUID-like string).

        See: <https://libvirt.org/formatdomain.html#virtual-network>
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="interfaceId")
    def interface_id(self) -> Optional[_builtins.str]:
        """
        Sets an opaque interface identifier for the virtual port profile, typically used by SDN or virtual switch controllers; value is user-provided (often a UUID or similar).

        See: <https://libvirt.org/formatdomain.html#virtual-network>
        """
        return pulumi.get(self, "interface_id")

    @_builtins.property
    @pulumi.getter(name="managerId")
    def manager_id(self) -> Optional[_builtins.float]:
        """
        Sets an opaque manager identifier for the virtual port profile, identifying the controlling network manager or switch domain; value is user-provided integer or string as expected by the backend.

        See: <https://libvirt.org/formatdomain.html#virtual-network>
        """
        return pulumi.get(self, "manager_id")

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[_builtins.str]:
        """
        Sets the opaque profile identifier passed to a generic 802.1Qbh/any virtual port profile; the value is user-provided and interpreted by the underlying switch or SDN controller (for example, "profile-1").

        See: <https://libvirt.org/formatdomain.html#virtual-network>
        """
        return pulumi.get(self, "profile_id")

    @_builtins.property
    @pulumi.getter(name="typeId")
    def type_id(self) -> Optional[_builtins.float]:
        """
        Sets the 802.1Qbh profile type identifier for a generic virtual port profile; the value is user-provided (typically a numeric or UUID-like identifier defined by the switch implementation).

        See: <https://libvirt.org/formatdomain.html#virtual-network>
        """
        return pulumi.get(self, "type_id")

    @_builtins.property
    @pulumi.getter(name="typeIdVersion")
    def type_id_version(self) -> Optional[_builtins.float]:
        """
        Sets the version of the 802.1Qbh profile type for a generic virtual port profile; the value is user-provided and must match what the upstream switch expects (for example, "1").

        See: <https://libvirt.org/formatdomain.html#virtual-network>
        """
        return pulumi.get(self, "type_id_version")


@pulumi.output_type
class DomainDevicesInterfaceVirtualPortParamsMidoNet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "interfaceId":
            suggest = "interface_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceVirtualPortParamsMidoNet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceVirtualPortParamsMidoNet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceVirtualPortParamsMidoNet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interface_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str interface_id: Sets the Midonet virtual interface identifier associated with this NIC; the value is user-provided and must match the interface ID configured in Midonet.
               
               See: <https://libvirt.org/formatdomain.html#virtual-network>
        """
        if interface_id is not None:
            pulumi.set(__self__, "interface_id", interface_id)

    @_builtins.property
    @pulumi.getter(name="interfaceId")
    def interface_id(self) -> Optional[_builtins.str]:
        """
        Sets the Midonet virtual interface identifier associated with this NIC; the value is user-provided and must match the interface ID configured in Midonet.

        See: <https://libvirt.org/formatdomain.html#virtual-network>
        """
        return pulumi.get(self, "interface_id")


@pulumi.output_type
class DomainDevicesInterfaceVirtualPortParamsOpenVSwitch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "interfaceId":
            suggest = "interface_id"
        elif key == "profileId":
            suggest = "profile_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceVirtualPortParamsOpenVSwitch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceVirtualPortParamsOpenVSwitch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceVirtualPortParamsOpenVSwitch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interface_id: Optional[_builtins.str] = None,
                 profile_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str interface_id: Sets the Open vSwitch interface identifier for this NIC, typically matching the external port identifier known to OVS (for example, a UUID string).
               
               See: <https://libvirt.org/formatdomain.html#virtual-network>
        :param _builtins.str profile_id: Sets the Open vSwitch profile identifier for this virtual port, used by OVS or its controller; the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#virtual-network>
        """
        if interface_id is not None:
            pulumi.set(__self__, "interface_id", interface_id)
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)

    @_builtins.property
    @pulumi.getter(name="interfaceId")
    def interface_id(self) -> Optional[_builtins.str]:
        """
        Sets the Open vSwitch interface identifier for this NIC, typically matching the external port identifier known to OVS (for example, a UUID string).

        See: <https://libvirt.org/formatdomain.html#virtual-network>
        """
        return pulumi.get(self, "interface_id")

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[_builtins.str]:
        """
        Sets the Open vSwitch profile identifier for this virtual port, used by OVS or its controller; the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#virtual-network>
        """
        return pulumi.get(self, "profile_id")


@pulumi.output_type
class DomainDevicesInterfaceVirtualPortParamsVepa8021qbg(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceId":
            suggest = "instance_id"
        elif key == "managerId":
            suggest = "manager_id"
        elif key == "typeId":
            suggest = "type_id"
        elif key == "typeIdVersion":
            suggest = "type_id_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceVirtualPortParamsVepa8021qbg. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceVirtualPortParamsVepa8021qbg.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceVirtualPortParamsVepa8021qbg.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_id: Optional[_builtins.str] = None,
                 manager_id: Optional[_builtins.float] = None,
                 type_id: Optional[_builtins.float] = None,
                 type_id_version: Optional[_builtins.float] = None):
        """
        :param _builtins.str instance_id: Sets the 802.1Qbg instance identifier for this VEPA virtual port, typically a UUID or other unique ID required by the edge switch.
               
               See: <https://libvirt.org/formatdomain.html#virtual-network>
        :param _builtins.float manager_id: Sets the 802.1Qbg manager identifier for this VEPA virtual port, usually a numeric ID designating the managing entity on the switch.
               
               See: <https://libvirt.org/formatdomain.html#virtual-network>
        :param _builtins.float type_id: Sets the 802.1Qbg type identifier used by the VEPA manager to classify the virtual port profile; the value is user-provided and must match the switch configuration.
               
               See: <https://libvirt.org/formatdomain.html#virtual-network>
        :param _builtins.float type_id_version: Sets the version of the 802.1Qbg profile type for this VEPA virtual port; the value is user-provided (for example, "1").
               
               See: <https://libvirt.org/formatdomain.html#virtual-network>
        """
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if manager_id is not None:
            pulumi.set(__self__, "manager_id", manager_id)
        if type_id is not None:
            pulumi.set(__self__, "type_id", type_id)
        if type_id_version is not None:
            pulumi.set(__self__, "type_id_version", type_id_version)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[_builtins.str]:
        """
        Sets the 802.1Qbg instance identifier for this VEPA virtual port, typically a UUID or other unique ID required by the edge switch.

        See: <https://libvirt.org/formatdomain.html#virtual-network>
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="managerId")
    def manager_id(self) -> Optional[_builtins.float]:
        """
        Sets the 802.1Qbg manager identifier for this VEPA virtual port, usually a numeric ID designating the managing entity on the switch.

        See: <https://libvirt.org/formatdomain.html#virtual-network>
        """
        return pulumi.get(self, "manager_id")

    @_builtins.property
    @pulumi.getter(name="typeId")
    def type_id(self) -> Optional[_builtins.float]:
        """
        Sets the 802.1Qbg type identifier used by the VEPA manager to classify the virtual port profile; the value is user-provided and must match the switch configuration.

        See: <https://libvirt.org/formatdomain.html#virtual-network>
        """
        return pulumi.get(self, "type_id")

    @_builtins.property
    @pulumi.getter(name="typeIdVersion")
    def type_id_version(self) -> Optional[_builtins.float]:
        """
        Sets the version of the 802.1Qbg profile type for this VEPA virtual port; the value is user-provided (for example, "1").

        See: <https://libvirt.org/formatdomain.html#virtual-network>
        """
        return pulumi.get(self, "type_id_version")


@pulumi.output_type
class DomainDevicesInterfaceVirtualPortParamsVnTag8011qbh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "profileId":
            suggest = "profile_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceVirtualPortParamsVnTag8011qbh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceVirtualPortParamsVnTag8011qbh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceVirtualPortParamsVnTag8011qbh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 profile_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str profile_id: Sets the 802.1Qbh VN-Tag profile identifier associated with this virtual port; the value is user-provided and must match the upstream fabric configuration.
               
               See: <https://libvirt.org/formatdomain.html#virtual-network>
        """
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[_builtins.str]:
        """
        Sets the 802.1Qbh VN-Tag profile identifier associated with this virtual port; the value is user-provided and must match the upstream fabric configuration.

        See: <https://libvirt.org/formatdomain.html#virtual-network>
        """
        return pulumi.get(self, "profile_id")


@pulumi.output_type
class DomainDevicesInterfaceVlan(dict):
    def __init__(__self__, *,
                 tags: Optional[Sequence['outputs.DomainDevicesInterfaceVlanTag']] = None,
                 trunk: Optional[_builtins.str] = None):
        """
        :param Sequence['DomainDevicesInterfaceVlanTagArgs'] tags: Defines a single VLAN tag entry for this interface; multiple entries can be specified to tag the interface with several VLAN IDs when trunking is enabled.
               
               See: <https://libvirt.org/formatdomain.html#setting-vlan-tag-on-supported-network-types-only>
        :param _builtins.str trunk: Controls whether the interface operates in VLAN trunk mode (when set, multiple tag entries are allowed and all are applied); this is a presence/yes-no style flag whose valid value is typically "yes" when trunking is desired.
               
               See: <https://libvirt.org/formatdomain.html#setting-vlan-tag-on-supported-network-types-only>
        """
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if trunk is not None:
            pulumi.set(__self__, "trunk", trunk)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.DomainDevicesInterfaceVlanTag']]:
        """
        Defines a single VLAN tag entry for this interface; multiple entries can be specified to tag the interface with several VLAN IDs when trunking is enabled.

        See: <https://libvirt.org/formatdomain.html#setting-vlan-tag-on-supported-network-types-only>
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def trunk(self) -> Optional[_builtins.str]:
        """
        Controls whether the interface operates in VLAN trunk mode (when set, multiple tag entries are allowed and all are applied); this is a presence/yes-no style flag whose valid value is typically "yes" when trunking is desired.

        See: <https://libvirt.org/formatdomain.html#setting-vlan-tag-on-supported-network-types-only>
        """
        return pulumi.get(self, "trunk")


@pulumi.output_type
class DomainDevicesInterfaceVlanTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nativeMode":
            suggest = "native_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesInterfaceVlanTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesInterfaceVlanTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesInterfaceVlanTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[_builtins.float] = None,
                 native_mode: Optional[_builtins.str] = None):
        """
        :param _builtins.float id: Reports the VLAN ID associated with this tag; this is computed from the underlying XML and must be a valid VLAN tag (typically in the range 14094).
               
               See: <https://libvirt.org/formatdomain.html#setting-vlan-tag-on-supported-network-types-only>
        :param _builtins.str native_mode: Sets how this VLAN tag is treated as the native (untagged) VLAN on the port, using user-provided values such as "tagged" or "untagged" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#setting-vlan-tag-on-supported-network-types-only>
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if native_mode is not None:
            pulumi.set(__self__, "native_mode", native_mode)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.float]:
        """
        Reports the VLAN ID associated with this tag; this is computed from the underlying XML and must be a valid VLAN tag (typically in the range 14094).

        See: <https://libvirt.org/formatdomain.html#setting-vlan-tag-on-supported-network-types-only>
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="nativeMode")
    def native_mode(self) -> Optional[_builtins.str]:
        """
        Sets how this VLAN tag is treated as the native (untagged) VLAN on the port, using user-provided values such as "tagged" or "untagged" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#setting-vlan-tag-on-supported-network-types-only>
        """
        return pulumi.get(self, "native_mode")


@pulumi.output_type
class DomainDevicesInterfaceWaitForIp(dict):
    def __init__(__self__, *,
                 source: Optional[_builtins.str] = None,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str source: Source to query for IP addresses: 'lease', 'agent', or 'any'. Default: 'any'.
        :param _builtins.float timeout: Maximum time to wait for IP address in seconds. Default: 300.
        """
        if source is not None:
            pulumi.set(__self__, "source", source)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        Source to query for IP addresses: 'lease', 'agent', or 'any'. Default: 'any'.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Maximum time to wait for IP address in seconds. Default: 300.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesIommu(dict):
    def __init__(__self__, *,
                 model: _builtins.str,
                 acpi: Optional['outputs.DomainDevicesIommuAcpi'] = None,
                 address: Optional['outputs.DomainDevicesIommuAddress'] = None,
                 alias: Optional['outputs.DomainDevicesIommuAlias'] = None,
                 driver: Optional['outputs.DomainDevicesIommuDriver'] = None):
        """
        :param _builtins.str model: Selects the IOMMU model to expose to the guest; valid values include "intel", "smmuv3", and "virtio" depending on architecture and QEMU version.
               
               See: <https://libvirt.org/formatdomain.html#iommu-devices>
        :param 'DomainDevicesIommuAcpiArgs' acpi: Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        :param 'DomainDevicesIommuAddressArgs' address: Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        :param 'DomainDevicesIommuAliasArgs' alias: Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        :param 'DomainDevicesIommuDriverArgs' driver: Configures model-specific driver options for the IOMMU, such as address width, interrupt remapping, and caching behavior.
        """
        pulumi.set(__self__, "model", model)
        if acpi is not None:
            pulumi.set(__self__, "acpi", acpi)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)

    @_builtins.property
    @pulumi.getter
    def model(self) -> _builtins.str:
        """
        Selects the IOMMU model to expose to the guest; valid values include "intel", "smmuv3", and "virtio" depending on architecture and QEMU version.

        See: <https://libvirt.org/formatdomain.html#iommu-devices>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def acpi(self) -> Optional['outputs.DomainDevicesIommuAcpi']:
        """
        Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        """
        return pulumi.get(self, "acpi")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesIommuAddress']:
        """
        Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional['outputs.DomainDevicesIommuAlias']:
        """
        Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def driver(self) -> Optional['outputs.DomainDevicesIommuDriver']:
        """
        Configures model-specific driver options for the IOMMU, such as address width, interrupt remapping, and caching behavior.
        """
        return pulumi.get(self, "driver")


@pulumi.output_type
class DomainDevicesIommuAcpi(dict):
    def __init__(__self__, *,
                 index: Optional[_builtins.float] = None):
        """
        :param _builtins.float index: Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        """
        if index is not None:
            pulumi.set(__self__, "index", index)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "index")


@pulumi.output_type
class DomainDevicesIommuAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesIommuAlias(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
               
               See: <https://libvirt.org/formatdomain.html#devices>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesIommuDriver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awBits":
            suggest = "aw_bits"
        elif key == "cachingMode":
            suggest = "caching_mode"
        elif key == "dmaTranslation":
            suggest = "dma_translation"
        elif key == "intRemap":
            suggest = "int_remap"
        elif key == "xtSup":
            suggest = "xt_sup"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesIommuDriver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesIommuDriver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesIommuDriver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aw_bits: Optional[_builtins.float] = None,
                 caching_mode: Optional[_builtins.str] = None,
                 dma_translation: Optional[_builtins.str] = None,
                 eim: Optional[_builtins.str] = None,
                 int_remap: Optional[_builtins.str] = None,
                 iotlb: Optional[_builtins.str] = None,
                 passthrough: Optional[_builtins.str] = None,
                 xt_sup: Optional[_builtins.str] = None):
        """
        :param _builtins.float aw_bits: Sets the IOMMU address width in bits (aw_bits) used for DMA mappings; value is a positive integer appropriate to the chosen IOMMU model (for example, 39 or 48).
               
               See: <https://libvirt.org/formatdomain.html#iommu-devices>
        :param _builtins.str caching_mode: Enables or disables IOMMU page table caching mode, with valid values "on" or "off" (presence controls whether the device advertises caching to the guest).
               
               See: <https://libvirt.org/formatdomain.html#iommu-devices>
        :param _builtins.str dma_translation: Controls whether DMA translation is performed by the IOMMU, with valid values "on" or "off" (for example, "off" can approximate passthrough behavior).
               
               See: <https://libvirt.org/formatdomain.html#iommu-devices>
        :param _builtins.str eim: Toggles extended interrupt mode (EIM) support for the IOMMU, with valid values "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#iommu-devices>
        :param _builtins.str int_remap: Enables or disables interrupt remapping for the IOMMU, with valid values "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#iommu-devices>
        :param _builtins.str iotlb: Controls whether the IOMMU exposes an IOTLB (I/O TLB) interface to the guest, with valid values "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#iommu-devices>
        :param _builtins.str passthrough: Selects passthrough mode for the IOMMU so that guest devices can bypass translation, with valid values "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#iommu-devices>
        :param _builtins.str xt_sup: Toggles support for extended translation (xtsup) features of the IOMMU, with valid values "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#iommu-devices>
        """
        if aw_bits is not None:
            pulumi.set(__self__, "aw_bits", aw_bits)
        if caching_mode is not None:
            pulumi.set(__self__, "caching_mode", caching_mode)
        if dma_translation is not None:
            pulumi.set(__self__, "dma_translation", dma_translation)
        if eim is not None:
            pulumi.set(__self__, "eim", eim)
        if int_remap is not None:
            pulumi.set(__self__, "int_remap", int_remap)
        if iotlb is not None:
            pulumi.set(__self__, "iotlb", iotlb)
        if passthrough is not None:
            pulumi.set(__self__, "passthrough", passthrough)
        if xt_sup is not None:
            pulumi.set(__self__, "xt_sup", xt_sup)

    @_builtins.property
    @pulumi.getter(name="awBits")
    def aw_bits(self) -> Optional[_builtins.float]:
        """
        Sets the IOMMU address width in bits (aw_bits) used for DMA mappings; value is a positive integer appropriate to the chosen IOMMU model (for example, 39 or 48).

        See: <https://libvirt.org/formatdomain.html#iommu-devices>
        """
        return pulumi.get(self, "aw_bits")

    @_builtins.property
    @pulumi.getter(name="cachingMode")
    def caching_mode(self) -> Optional[_builtins.str]:
        """
        Enables or disables IOMMU page table caching mode, with valid values "on" or "off" (presence controls whether the device advertises caching to the guest).

        See: <https://libvirt.org/formatdomain.html#iommu-devices>
        """
        return pulumi.get(self, "caching_mode")

    @_builtins.property
    @pulumi.getter(name="dmaTranslation")
    def dma_translation(self) -> Optional[_builtins.str]:
        """
        Controls whether DMA translation is performed by the IOMMU, with valid values "on" or "off" (for example, "off" can approximate passthrough behavior).

        See: <https://libvirt.org/formatdomain.html#iommu-devices>
        """
        return pulumi.get(self, "dma_translation")

    @_builtins.property
    @pulumi.getter
    def eim(self) -> Optional[_builtins.str]:
        """
        Toggles extended interrupt mode (EIM) support for the IOMMU, with valid values "on" or "off".

        See: <https://libvirt.org/formatdomain.html#iommu-devices>
        """
        return pulumi.get(self, "eim")

    @_builtins.property
    @pulumi.getter(name="intRemap")
    def int_remap(self) -> Optional[_builtins.str]:
        """
        Enables or disables interrupt remapping for the IOMMU, with valid values "on" or "off".

        See: <https://libvirt.org/formatdomain.html#iommu-devices>
        """
        return pulumi.get(self, "int_remap")

    @_builtins.property
    @pulumi.getter
    def iotlb(self) -> Optional[_builtins.str]:
        """
        Controls whether the IOMMU exposes an IOTLB (I/O TLB) interface to the guest, with valid values "on" or "off".

        See: <https://libvirt.org/formatdomain.html#iommu-devices>
        """
        return pulumi.get(self, "iotlb")

    @_builtins.property
    @pulumi.getter
    def passthrough(self) -> Optional[_builtins.str]:
        """
        Selects passthrough mode for the IOMMU so that guest devices can bypass translation, with valid values "on" or "off".

        See: <https://libvirt.org/formatdomain.html#iommu-devices>
        """
        return pulumi.get(self, "passthrough")

    @_builtins.property
    @pulumi.getter(name="xtSup")
    def xt_sup(self) -> Optional[_builtins.str]:
        """
        Toggles support for extended translation (xtsup) features of the IOMMU, with valid values "on" or "off".

        See: <https://libvirt.org/formatdomain.html#iommu-devices>
        """
        return pulumi.get(self, "xt_sup")


@pulumi.output_type
class DomainDevicesLease(dict):
    def __init__(__self__, *,
                 lockspace: _builtins.str,
                 key: Optional[_builtins.str] = None,
                 target: Optional['outputs.DomainDevicesLeaseTarget'] = None):
        """
        :param _builtins.str lockspace: Sets the lockspace name in which this lease key is managed; value is a user-provided string chosen according to the lock manager configuration.
               
               See: <https://libvirt.org/formatdomain.html#device-leases>
        :param _builtins.str key: Reports the key string that uniquely identifies this lease in the lock manager; when omitted in config it is computed, but if set it must be a user-provided opaque identifier such as "vm1-disk1".
               
               See: <https://libvirt.org/formatdomain.html#device-leases>
        :param 'DomainDevicesLeaseTargetArgs' target: Configures the target device or resource path associated with this lease (for example, a disk path or volume name); value is user-provided.
        """
        pulumi.set(__self__, "lockspace", lockspace)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def lockspace(self) -> _builtins.str:
        """
        Sets the lockspace name in which this lease key is managed; value is a user-provided string chosen according to the lock manager configuration.

        See: <https://libvirt.org/formatdomain.html#device-leases>
        """
        return pulumi.get(self, "lockspace")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        Reports the key string that uniquely identifies this lease in the lock manager; when omitted in config it is computed, but if set it must be a user-provided opaque identifier such as "vm1-disk1".

        See: <https://libvirt.org/formatdomain.html#device-leases>
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional['outputs.DomainDevicesLeaseTarget']:
        """
        Configures the target device or resource path associated with this lease (for example, a disk path or volume name); value is user-provided.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class DomainDevicesLeaseTarget(dict):
    def __init__(__self__, *,
                 path: _builtins.str,
                 offset: Optional[_builtins.float] = None):
        """
        :param _builtins.str path: Sets the path to the file or block device used as the lease target that must be acquired before the domain is allowed to start.
               
               See: <https://libvirt.org/formatdomain.html#device-leases>
        :param _builtins.float offset: Sets an optional byte offset within the lease target file or device where this VMs lease record starts; value is user-provided and typically a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#device-leases>
        """
        pulumi.set(__self__, "path", path)
        if offset is not None:
            pulumi.set(__self__, "offset", offset)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the path to the file or block device used as the lease target that must be acquired before the domain is allowed to start.

        See: <https://libvirt.org/formatdomain.html#device-leases>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def offset(self) -> Optional[_builtins.float]:
        """
        Sets an optional byte offset within the lease target file or device where this VMs lease record starts; value is user-provided and typically a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#device-leases>
        """
        return pulumi.get(self, "offset")


@pulumi.output_type
class DomainDevicesMemBalloon(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoDeflate":
            suggest = "auto_deflate"
        elif key == "freePageReporting":
            suggest = "free_page_reporting"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesMemBalloon. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesMemBalloon.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesMemBalloon.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 model: _builtins.str,
                 acpi: Optional['outputs.DomainDevicesMemBalloonAcpi'] = None,
                 address: Optional['outputs.DomainDevicesMemBalloonAddress'] = None,
                 alias: Optional['outputs.DomainDevicesMemBalloonAlias'] = None,
                 auto_deflate: Optional[_builtins.str] = None,
                 driver: Optional['outputs.DomainDevicesMemBalloonDriver'] = None,
                 free_page_reporting: Optional[_builtins.str] = None,
                 stats: Optional['outputs.DomainDevicesMemBalloonStats'] = None):
        """
        :param _builtins.str model: Sets the balloon device model, commonly virtio for QEMU/KVM; value is user-provided and must be supported by the hypervisor (for example, "virtio").
               
               See: <https://libvirt.org/formatdomain.html#memory-balloon-device>
        :param 'DomainDevicesMemBalloonAcpiArgs' acpi: Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        :param 'DomainDevicesMemBalloonAddressArgs' address: Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        :param 'DomainDevicesMemBalloonAliasArgs' alias: Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        :param _builtins.str auto_deflate: Enables or disables automatic deflation of the balloon to return memory to the guest when it is needed, using a yes/no string flag.
               
               See: <https://libvirt.org/formatdomain.html#memory-balloon-device>
        :param 'DomainDevicesMemBalloonDriverArgs' driver: Configures driver-specific options for the memory balloons virtio transport, such as IOMMU and ATS behavior.
        :param _builtins.str free_page_reporting: Enables or disables free page reporting for the balloon device, allowing the guest to report unused pages back to the host, using a yes/no string flag.
               
               See: <https://libvirt.org/formatdomain.html#memory-balloon-device>
        :param 'DomainDevicesMemBalloonStatsArgs' stats: Configures collection of balloon statistics such as how often the host polls the guest for memory usage information.
        """
        pulumi.set(__self__, "model", model)
        if acpi is not None:
            pulumi.set(__self__, "acpi", acpi)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if auto_deflate is not None:
            pulumi.set(__self__, "auto_deflate", auto_deflate)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if free_page_reporting is not None:
            pulumi.set(__self__, "free_page_reporting", free_page_reporting)
        if stats is not None:
            pulumi.set(__self__, "stats", stats)

    @_builtins.property
    @pulumi.getter
    def model(self) -> _builtins.str:
        """
        Sets the balloon device model, commonly virtio for QEMU/KVM; value is user-provided and must be supported by the hypervisor (for example, "virtio").

        See: <https://libvirt.org/formatdomain.html#memory-balloon-device>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def acpi(self) -> Optional['outputs.DomainDevicesMemBalloonAcpi']:
        """
        Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        """
        return pulumi.get(self, "acpi")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesMemBalloonAddress']:
        """
        Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional['outputs.DomainDevicesMemBalloonAlias']:
        """
        Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter(name="autoDeflate")
    def auto_deflate(self) -> Optional[_builtins.str]:
        """
        Enables or disables automatic deflation of the balloon to return memory to the guest when it is needed, using a yes/no string flag.

        See: <https://libvirt.org/formatdomain.html#memory-balloon-device>
        """
        return pulumi.get(self, "auto_deflate")

    @_builtins.property
    @pulumi.getter
    def driver(self) -> Optional['outputs.DomainDevicesMemBalloonDriver']:
        """
        Configures driver-specific options for the memory balloons virtio transport, such as IOMMU and ATS behavior.
        """
        return pulumi.get(self, "driver")

    @_builtins.property
    @pulumi.getter(name="freePageReporting")
    def free_page_reporting(self) -> Optional[_builtins.str]:
        """
        Enables or disables free page reporting for the balloon device, allowing the guest to report unused pages back to the host, using a yes/no string flag.

        See: <https://libvirt.org/formatdomain.html#memory-balloon-device>
        """
        return pulumi.get(self, "free_page_reporting")

    @_builtins.property
    @pulumi.getter
    def stats(self) -> Optional['outputs.DomainDevicesMemBalloonStats']:
        """
        Configures collection of balloon statistics such as how often the host polls the guest for memory usage information.
        """
        return pulumi.get(self, "stats")


@pulumi.output_type
class DomainDevicesMemBalloonAcpi(dict):
    def __init__(__self__, *,
                 index: Optional[_builtins.float] = None):
        """
        :param _builtins.float index: Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        """
        if index is not None:
            pulumi.set(__self__, "index", index)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "index")


@pulumi.output_type
class DomainDevicesMemBalloonAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesMemBalloonAlias(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
               
               See: <https://libvirt.org/formatdomain.html#devices>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesMemBalloonDriver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pagePerVq":
            suggest = "page_per_vq"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesMemBalloonDriver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesMemBalloonDriver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesMemBalloonDriver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ats: Optional[_builtins.str] = None,
                 iommu: Optional[_builtins.str] = None,
                 packed: Optional[_builtins.str] = None,
                 page_per_vq: Optional[_builtins.str] = None):
        """
        :param _builtins.str ats: Enables or disables Address Translation Service (ATS) support for the virtio balloon device using a yes/no string flag.
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.str iommu: Enables or disables use of an emulated IOMMU for the virtio balloon device using a yes/no string flag.
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.str packed: Enables or disables packed virtqueue layout for the virtio balloon using a yes/no string flag.
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.str page_per_vq: Enables or disables allocation of a separate page per virtqueue for the virtio balloon using a yes/no string flag.
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        if ats is not None:
            pulumi.set(__self__, "ats", ats)
        if iommu is not None:
            pulumi.set(__self__, "iommu", iommu)
        if packed is not None:
            pulumi.set(__self__, "packed", packed)
        if page_per_vq is not None:
            pulumi.set(__self__, "page_per_vq", page_per_vq)

    @_builtins.property
    @pulumi.getter
    def ats(self) -> Optional[_builtins.str]:
        """
        Enables or disables Address Translation Service (ATS) support for the virtio balloon device using a yes/no string flag.

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "ats")

    @_builtins.property
    @pulumi.getter
    def iommu(self) -> Optional[_builtins.str]:
        """
        Enables or disables use of an emulated IOMMU for the virtio balloon device using a yes/no string flag.

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "iommu")

    @_builtins.property
    @pulumi.getter
    def packed(self) -> Optional[_builtins.str]:
        """
        Enables or disables packed virtqueue layout for the virtio balloon using a yes/no string flag.

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "packed")

    @_builtins.property
    @pulumi.getter(name="pagePerVq")
    def page_per_vq(self) -> Optional[_builtins.str]:
        """
        Enables or disables allocation of a separate page per virtqueue for the virtio balloon using a yes/no string flag.

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "page_per_vq")


@pulumi.output_type
class DomainDevicesMemBalloonStats(dict):
    def __init__(__self__, *,
                 period: _builtins.float):
        """
        :param _builtins.float period: Sets the polling period in seconds for collecting memory balloon statistics; use 0 to disable statistics, or a positive integer interval.
               
               See: <https://libvirt.org/formatdomain.html#memory-balloon-device>
        """
        pulumi.set(__self__, "period", period)

    @_builtins.property
    @pulumi.getter
    def period(self) -> _builtins.float:
        """
        Sets the polling period in seconds for collecting memory balloon statistics; use 0 to disable statistics, or a positive integer interval.

        See: <https://libvirt.org/formatdomain.html#memory-balloon-device>
        """
        return pulumi.get(self, "period")


@pulumi.output_type
class DomainDevicesMemorydev(dict):
    def __init__(__self__, *,
                 model: _builtins.str,
                 access: Optional[_builtins.str] = None,
                 acpi: Optional['outputs.DomainDevicesMemorydevAcpi'] = None,
                 address: Optional['outputs.DomainDevicesMemorydevAddress'] = None,
                 alias: Optional['outputs.DomainDevicesMemorydevAlias'] = None,
                 discard: Optional[_builtins.str] = None,
                 source: Optional['outputs.DomainDevicesMemorydevSource'] = None,
                 target: Optional['outputs.DomainDevicesMemorydevTarget'] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str model: Selects the memory device model, such as "dimm", "nvdimm", "virtio-mem", or "virtio-pmem", determining how the guest sees and manages this memory; the value must be one of the models supported by libvirt/QEMU.
               
               See: <https://libvirt.org/formatdomain.html#memory-devices>
        :param _builtins.str access: Sets the access mode for the memory device (for example, "shared" or "private") controlling whether memory can be shared between guests/host; value must be one of the access modes supported by libvirt for memory devices.
               
               See: <https://libvirt.org/formatdomain.html#memory-devices>
        :param 'DomainDevicesMemorydevAcpiArgs' acpi: Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        :param 'DomainDevicesMemorydevAddressArgs' address: Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        :param 'DomainDevicesMemorydevAliasArgs' alias: Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        :param _builtins.str discard: Controls whether discarded/trimmed guest memory for this device is actually discarded (e.g. "yes"/"no" depending on model); the exact accepted values are modelspecific and userprovided.
               
               See: <https://libvirt.org/formatdomain.html#memory-devices>
        :param 'DomainDevicesMemorydevSourceArgs' source: Defines the source backing for the memory device, such as a file, block device, or host NUMA configuration, depending on the chosen model.
        :param 'DomainDevicesMemorydevTargetArgs' target: Describes how the memory device is presented to the guest, including label/namespace, size, and NUMA placement depending on model.
        :param _builtins.str uuid: Exposes the libvirt-assigned UUID of the memory device; this value is computed by libvirt and cannot be set by the user.
               
               See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        pulumi.set(__self__, "model", model)
        if access is not None:
            pulumi.set(__self__, "access", access)
        if acpi is not None:
            pulumi.set(__self__, "acpi", acpi)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if discard is not None:
            pulumi.set(__self__, "discard", discard)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def model(self) -> _builtins.str:
        """
        Selects the memory device model, such as "dimm", "nvdimm", "virtio-mem", or "virtio-pmem", determining how the guest sees and manages this memory; the value must be one of the models supported by libvirt/QEMU.

        See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def access(self) -> Optional[_builtins.str]:
        """
        Sets the access mode for the memory device (for example, "shared" or "private") controlling whether memory can be shared between guests/host; value must be one of the access modes supported by libvirt for memory devices.

        See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        return pulumi.get(self, "access")

    @_builtins.property
    @pulumi.getter
    def acpi(self) -> Optional['outputs.DomainDevicesMemorydevAcpi']:
        """
        Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        """
        return pulumi.get(self, "acpi")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesMemorydevAddress']:
        """
        Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional['outputs.DomainDevicesMemorydevAlias']:
        """
        Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def discard(self) -> Optional[_builtins.str]:
        """
        Controls whether discarded/trimmed guest memory for this device is actually discarded (e.g. "yes"/"no" depending on model); the exact accepted values are modelspecific and userprovided.

        See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        return pulumi.get(self, "discard")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainDevicesMemorydevSource']:
        """
        Defines the source backing for the memory device, such as a file, block device, or host NUMA configuration, depending on the chosen model.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional['outputs.DomainDevicesMemorydevTarget']:
        """
        Describes how the memory device is presented to the guest, including label/namespace, size, and NUMA placement depending on model.
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        Exposes the libvirt-assigned UUID of the memory device; this value is computed by libvirt and cannot be set by the user.

        See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class DomainDevicesMemorydevAcpi(dict):
    def __init__(__self__, *,
                 index: Optional[_builtins.float] = None):
        """
        :param _builtins.float index: Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        """
        if index is not None:
            pulumi.set(__self__, "index", index)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "index")


@pulumi.output_type
class DomainDevicesMemorydevAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesMemorydevAlias(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
               
               See: <https://libvirt.org/formatdomain.html#devices>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesMemorydevSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alignSize":
            suggest = "align_size"
        elif key == "alignSizeUnit":
            suggest = "align_size_unit"
        elif key == "nodeMask":
            suggest = "node_mask"
        elif key == "pageSize":
            suggest = "page_size"
        elif key == "pageSizeUnit":
            suggest = "page_size_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesMemorydevSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesMemorydevSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesMemorydevSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 align_size: Optional[_builtins.float] = None,
                 align_size_unit: Optional[_builtins.str] = None,
                 node_mask: Optional[_builtins.str] = None,
                 page_size: Optional[_builtins.float] = None,
                 page_size_unit: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 pmem: Optional[_builtins.bool] = None):
        """
        :param _builtins.float align_size: Sets the alignment size value for the backing storage or mapping of this memory device, together with align_size_unit forming a size with units; the numeric value is userprovided (for example, 2 or 1024).
               
               See: <https://libvirt.org/formatdomain.html#memory-devices>
        :param _builtins.str align_size_unit: Specifies the unit for source.align_size (for example, "B", "KiB", "MiB", "GiB"), encoded via the pagesize/alignsize attribute; the value is userprovided but must be a valid libvirt size unit.
               
               See: <https://libvirt.org/formatdomain.html#memory-devices>
        :param _builtins.str node_mask: Constrains the backing of this memory device to a given host NUMA node set, using a nodemask string (for example, "0-1" or "1,3").
               
               See: <https://libvirt.org/formatdomain.html#memory-devices>
        :param _builtins.float page_size: Sets the page size used for backing this memory device, as a numeric value combined with page_size_unit (for example, 2048 or 1048576).
               
               See: <https://libvirt.org/formatdomain.html#memory-devices>
        :param _builtins.str page_size_unit: Specifies the unit for source.page_size (for example, "B", "KiB", "MiB"), encoded via the pagesize attribute; the value is userprovided but must be a valid libvirt size unit.
               
               See: <https://libvirt.org/formatdomain.html#memory-devices>
        :param _builtins.str path: Provides the host path to the backing object for this memory device, such as a file or special device node (for example, "/dev/dax0.0" or "/mem/pool0").
               
               See: <https://libvirt.org/formatdomain.html#memory-devices>
        :param _builtins.bool pmem: Enables persistent memory mode for the source when set (presence-only), indicating that the backing is treated as persistent (PMEM); omitting or setting false leaves PMEM mode disabled.
               
               See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        if align_size is not None:
            pulumi.set(__self__, "align_size", align_size)
        if align_size_unit is not None:
            pulumi.set(__self__, "align_size_unit", align_size_unit)
        if node_mask is not None:
            pulumi.set(__self__, "node_mask", node_mask)
        if page_size is not None:
            pulumi.set(__self__, "page_size", page_size)
        if page_size_unit is not None:
            pulumi.set(__self__, "page_size_unit", page_size_unit)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if pmem is not None:
            pulumi.set(__self__, "pmem", pmem)

    @_builtins.property
    @pulumi.getter(name="alignSize")
    def align_size(self) -> Optional[_builtins.float]:
        """
        Sets the alignment size value for the backing storage or mapping of this memory device, together with align_size_unit forming a size with units; the numeric value is userprovided (for example, 2 or 1024).

        See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        return pulumi.get(self, "align_size")

    @_builtins.property
    @pulumi.getter(name="alignSizeUnit")
    def align_size_unit(self) -> Optional[_builtins.str]:
        """
        Specifies the unit for source.align_size (for example, "B", "KiB", "MiB", "GiB"), encoded via the pagesize/alignsize attribute; the value is userprovided but must be a valid libvirt size unit.

        See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        return pulumi.get(self, "align_size_unit")

    @_builtins.property
    @pulumi.getter(name="nodeMask")
    def node_mask(self) -> Optional[_builtins.str]:
        """
        Constrains the backing of this memory device to a given host NUMA node set, using a nodemask string (for example, "0-1" or "1,3").

        See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        return pulumi.get(self, "node_mask")

    @_builtins.property
    @pulumi.getter(name="pageSize")
    def page_size(self) -> Optional[_builtins.float]:
        """
        Sets the page size used for backing this memory device, as a numeric value combined with page_size_unit (for example, 2048 or 1048576).

        See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        return pulumi.get(self, "page_size")

    @_builtins.property
    @pulumi.getter(name="pageSizeUnit")
    def page_size_unit(self) -> Optional[_builtins.str]:
        """
        Specifies the unit for source.page_size (for example, "B", "KiB", "MiB"), encoded via the pagesize attribute; the value is userprovided but must be a valid libvirt size unit.

        See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        return pulumi.get(self, "page_size_unit")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Provides the host path to the backing object for this memory device, such as a file or special device node (for example, "/dev/dax0.0" or "/mem/pool0").

        See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def pmem(self) -> Optional[_builtins.bool]:
        """
        Enables persistent memory mode for the source when set (presence-only), indicating that the backing is treated as persistent (PMEM); omitting or setting false leaves PMEM mode disabled.

        See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        return pulumi.get(self, "pmem")


@pulumi.output_type
class DomainDevicesMemorydevTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockUnit":
            suggest = "block_unit"
        elif key == "dynamicMemslots":
            suggest = "dynamic_memslots"
        elif key == "readOnly":
            suggest = "read_only"
        elif key == "requestedUnit":
            suggest = "requested_unit"
        elif key == "sizeUnit":
            suggest = "size_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesMemorydevTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesMemorydevTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesMemorydevTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional['outputs.DomainDevicesMemorydevTargetAddress'] = None,
                 block: Optional[_builtins.float] = None,
                 block_unit: Optional[_builtins.str] = None,
                 dynamic_memslots: Optional[_builtins.str] = None,
                 label: Optional['outputs.DomainDevicesMemorydevTargetLabel'] = None,
                 node: Optional[_builtins.float] = None,
                 read_only: Optional[_builtins.bool] = None,
                 requested: Optional[_builtins.float] = None,
                 requested_unit: Optional[_builtins.str] = None,
                 size: Optional[_builtins.float] = None,
                 size_unit: Optional[_builtins.str] = None):
        """
        :param 'DomainDevicesMemorydevTargetAddressArgs' address: Defines the in-guest address for the memory device (such as the guest physical base address for NVDIMM/virtiopmem), with subattributes such as base.
        :param _builtins.float block: Specifies the size value for a memory block unit associated with this memory device (for example, 128 or 512), combined with block_unit to form a full size with units.
               
               See: <https://libvirt.org/formatdomain.html#memory-devices>
        :param _builtins.str block_unit: Sets the unit for target.block (for example, "MiB" or "GiB"), encoded via the block attribute; the value is userprovided but must be a valid libvirt size unit.
               
               See: <https://libvirt.org/formatdomain.html#memory-devices>
        :param _builtins.str dynamic_memslots: Configures the number of dynamic memory slots available for this memory devices target, controlling how many hotplug operations are allowed; value is user-provided and must be a nonnegative integer when specified.
               
               See: <https://libvirt.org/formatdomain.html#memory-devices>
        :param 'DomainDevicesMemorydevTargetLabelArgs' label: Configures the label region for an NVDIMM/pmem-style memory device target, enabling use of a separate label area that stores metadata about the persistent memory namespace.
        :param _builtins.float node: Selects the NUMA node on which to place the memory provided by this device, using a zero-based node index; value is user-provided and must refer to an existing host NUMA node.
               
               See: <https://libvirt.org/formatdomain.html#memory-devices>
        :param _builtins.bool read_only: Controls whether this memory device target is exposed as read-only to the guest; when set to true the readonly flag is emitted, when false or unset it is omitted.
               
               See: <https://libvirt.org/formatdomain.html#memory-devices>
        :param _builtins.float requested: Sets the amount of memory the guest initially requests from this device, distinct from the maximum size; value is user-provided and interpreted together with `requested_unit`.
               
               See: <https://libvirt.org/formatdomain.html#memory-devices>
        :param _builtins.str requested_unit: Sets the unit for `requested` (for example `KiB`, `MiB`, `GiB`); the raw value is user-provided and passed directly to libvirt.
               
               See: <https://libvirt.org/formatdomain.html#memory-devices>
        :param _builtins.float size: Sets the total capacity of this memory devices target, i.e. how much addressable memory it provides to the guest; value is user-provided and interpreted together with `size_unit`.
               
               See: <https://libvirt.org/formatdomain.html#memory-devices>
        :param _builtins.str size_unit: Sets the unit for `size` (for example `KiB`, `MiB`, `GiB`); the raw value is user-provided and passed directly to libvirt.
               
               See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if block_unit is not None:
            pulumi.set(__self__, "block_unit", block_unit)
        if dynamic_memslots is not None:
            pulumi.set(__self__, "dynamic_memslots", dynamic_memslots)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if node is not None:
            pulumi.set(__self__, "node", node)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if requested is not None:
            pulumi.set(__self__, "requested", requested)
        if requested_unit is not None:
            pulumi.set(__self__, "requested_unit", requested_unit)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if size_unit is not None:
            pulumi.set(__self__, "size_unit", size_unit)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesMemorydevTargetAddress']:
        """
        Defines the in-guest address for the memory device (such as the guest physical base address for NVDIMM/virtiopmem), with subattributes such as base.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional[_builtins.float]:
        """
        Specifies the size value for a memory block unit associated with this memory device (for example, 128 or 512), combined with block_unit to form a full size with units.

        See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        return pulumi.get(self, "block")

    @_builtins.property
    @pulumi.getter(name="blockUnit")
    def block_unit(self) -> Optional[_builtins.str]:
        """
        Sets the unit for target.block (for example, "MiB" or "GiB"), encoded via the block attribute; the value is userprovided but must be a valid libvirt size unit.

        See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        return pulumi.get(self, "block_unit")

    @_builtins.property
    @pulumi.getter(name="dynamicMemslots")
    def dynamic_memslots(self) -> Optional[_builtins.str]:
        """
        Configures the number of dynamic memory slots available for this memory devices target, controlling how many hotplug operations are allowed; value is user-provided and must be a nonnegative integer when specified.

        See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        return pulumi.get(self, "dynamic_memslots")

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional['outputs.DomainDevicesMemorydevTargetLabel']:
        """
        Configures the label region for an NVDIMM/pmem-style memory device target, enabling use of a separate label area that stores metadata about the persistent memory namespace.
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter
    def node(self) -> Optional[_builtins.float]:
        """
        Selects the NUMA node on which to place the memory provided by this device, using a zero-based node index; value is user-provided and must refer to an existing host NUMA node.

        See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        return pulumi.get(self, "node")

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[_builtins.bool]:
        """
        Controls whether this memory device target is exposed as read-only to the guest; when set to true the readonly flag is emitted, when false or unset it is omitted.

        See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        return pulumi.get(self, "read_only")

    @_builtins.property
    @pulumi.getter
    def requested(self) -> Optional[_builtins.float]:
        """
        Sets the amount of memory the guest initially requests from this device, distinct from the maximum size; value is user-provided and interpreted together with `requested_unit`.

        See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        return pulumi.get(self, "requested")

    @_builtins.property
    @pulumi.getter(name="requestedUnit")
    def requested_unit(self) -> Optional[_builtins.str]:
        """
        Sets the unit for `requested` (for example `KiB`, `MiB`, `GiB`); the raw value is user-provided and passed directly to libvirt.

        See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        return pulumi.get(self, "requested_unit")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.float]:
        """
        Sets the total capacity of this memory devices target, i.e. how much addressable memory it provides to the guest; value is user-provided and interpreted together with `size_unit`.

        See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="sizeUnit")
    def size_unit(self) -> Optional[_builtins.str]:
        """
        Sets the unit for `size` (for example `KiB`, `MiB`, `GiB`); the raw value is user-provided and passed directly to libvirt.

        See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        return pulumi.get(self, "size_unit")


@pulumi.output_type
class DomainDevicesMemorydevTargetAddress(dict):
    def __init__(__self__, *,
                 base: Optional[_builtins.float] = None):
        """
        :param _builtins.float base: Sets the base guest physical address for this memory device in hexadecimal or numeric form (for example, "0x140000000" or "5368709120"), determining where the memory is mapped in the guest.
               
               See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        if base is not None:
            pulumi.set(__self__, "base", base)

    @_builtins.property
    @pulumi.getter
    def base(self) -> Optional[_builtins.float]:
        """
        Sets the base guest physical address for this memory device in hexadecimal or numeric form (for example, "0x140000000" or "5368709120"), determining where the memory is mapped in the guest.

        See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        return pulumi.get(self, "base")


@pulumi.output_type
class DomainDevicesMemorydevTargetLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeUnit":
            suggest = "size_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesMemorydevTargetLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesMemorydevTargetLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesMemorydevTargetLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size: Optional[_builtins.float] = None,
                 size_unit: Optional[_builtins.str] = None):
        """
        :param _builtins.float size: Sets the size of the label region associated with this memory device target; value is user-provided and interpreted together with `label.size_unit`.
               
               See: <https://libvirt.org/formatdomain.html#memory-devices>
        :param _builtins.str size_unit: Sets the unit for `label.size` (for example `KiB`, `MiB`, `GiB`); the raw value is user-provided and passed directly to libvirt.
               
               See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        if size is not None:
            pulumi.set(__self__, "size", size)
        if size_unit is not None:
            pulumi.set(__self__, "size_unit", size_unit)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.float]:
        """
        Sets the size of the label region associated with this memory device target; value is user-provided and interpreted together with `label.size_unit`.

        See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="sizeUnit")
    def size_unit(self) -> Optional[_builtins.str]:
        """
        Sets the unit for `label.size` (for example `KiB`, `MiB`, `GiB`); the raw value is user-provided and passed directly to libvirt.

        See: <https://libvirt.org/formatdomain.html#memory-devices>
        """
        return pulumi.get(self, "size_unit")


@pulumi.output_type
class DomainDevicesNvram(dict):
    def __init__(__self__, *,
                 acpi: Optional['outputs.DomainDevicesNvramAcpi'] = None,
                 address: Optional['outputs.DomainDevicesNvramAddress'] = None,
                 alias: Optional['outputs.DomainDevicesNvramAlias'] = None):
        """
        :param 'DomainDevicesNvramAcpiArgs' acpi: Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        :param 'DomainDevicesNvramAddressArgs' address: Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        :param 'DomainDevicesNvramAliasArgs' alias: Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        if acpi is not None:
            pulumi.set(__self__, "acpi", acpi)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)

    @_builtins.property
    @pulumi.getter
    def acpi(self) -> Optional['outputs.DomainDevicesNvramAcpi']:
        """
        Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        """
        return pulumi.get(self, "acpi")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesNvramAddress']:
        """
        Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional['outputs.DomainDevicesNvramAlias']:
        """
        Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        return pulumi.get(self, "alias")


@pulumi.output_type
class DomainDevicesNvramAcpi(dict):
    def __init__(__self__, *,
                 index: Optional[_builtins.float] = None):
        """
        :param _builtins.float index: Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        """
        if index is not None:
            pulumi.set(__self__, "index", index)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "index")


@pulumi.output_type
class DomainDevicesNvramAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesNvramAlias(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
               
               See: <https://libvirt.org/formatdomain.html#devices>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesPanic(dict):
    def __init__(__self__, *,
                 acpi: Optional['outputs.DomainDevicesPanicAcpi'] = None,
                 address: Optional['outputs.DomainDevicesPanicAddress'] = None,
                 alias: Optional['outputs.DomainDevicesPanicAlias'] = None,
                 model: Optional[_builtins.str] = None):
        """
        :param 'DomainDevicesPanicAcpiArgs' acpi: Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        :param 'DomainDevicesPanicAddressArgs' address: Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        :param 'DomainDevicesPanicAliasArgs' alias: Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        :param _builtins.str model: Selects the model of panic device to use; valid values are hypervisor-specific (for QEMU usually "isa" or "pseries"), and if omitted libvirt chooses a suitable default for the guest type.
               
               See: <https://libvirt.org/formatdomain.html#panic-device>
        """
        if acpi is not None:
            pulumi.set(__self__, "acpi", acpi)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if model is not None:
            pulumi.set(__self__, "model", model)

    @_builtins.property
    @pulumi.getter
    def acpi(self) -> Optional['outputs.DomainDevicesPanicAcpi']:
        """
        Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        """
        return pulumi.get(self, "acpi")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesPanicAddress']:
        """
        Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional['outputs.DomainDevicesPanicAlias']:
        """
        Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the model of panic device to use; valid values are hypervisor-specific (for QEMU usually "isa" or "pseries"), and if omitted libvirt chooses a suitable default for the guest type.

        See: <https://libvirt.org/formatdomain.html#panic-device>
        """
        return pulumi.get(self, "model")


@pulumi.output_type
class DomainDevicesPanicAcpi(dict):
    def __init__(__self__, *,
                 index: Optional[_builtins.float] = None):
        """
        :param _builtins.float index: Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        """
        if index is not None:
            pulumi.set(__self__, "index", index)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "index")


@pulumi.output_type
class DomainDevicesPanicAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesPanicAlias(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
               
               See: <https://libvirt.org/formatdomain.html#devices>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesParallel(dict):
    def __init__(__self__, *,
                 acpi: Optional['outputs.DomainDevicesParallelAcpi'] = None,
                 address: Optional['outputs.DomainDevicesParallelAddress'] = None,
                 alias: Optional['outputs.DomainDevicesParallelAlias'] = None,
                 log: Optional['outputs.DomainDevicesParallelLog'] = None,
                 protocol: Optional['outputs.DomainDevicesParallelProtocol'] = None,
                 source: Optional['outputs.DomainDevicesParallelSource'] = None,
                 target: Optional['outputs.DomainDevicesParallelTarget'] = None):
        """
        :param 'DomainDevicesParallelAcpiArgs' acpi: Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        :param 'DomainDevicesParallelAddressArgs' address: Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        :param 'DomainDevicesParallelAliasArgs' alias: Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        :param 'DomainDevicesParallelLogArgs' log: Enables logging of data sent through the channel to a host file and configures how that logging behaves.
        :param 'DomainDevicesParallelProtocolArgs' protocol: Configures the transport protocol used by the EGD backend connection.
        :param 'DomainDevicesParallelSourceArgs' source: Defines the source endpoint for the EGD backend, such as a socket path or network address, depending on the chosen protocol.
        :param 'DomainDevicesParallelTargetArgs' target: Configures the guest-visible parallel port endpoint to which this device is attached (such as which logical parallel adapter/port in the guest).
        """
        if acpi is not None:
            pulumi.set(__self__, "acpi", acpi)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if log is not None:
            pulumi.set(__self__, "log", log)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def acpi(self) -> Optional['outputs.DomainDevicesParallelAcpi']:
        """
        Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        """
        return pulumi.get(self, "acpi")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesParallelAddress']:
        """
        Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional['outputs.DomainDevicesParallelAlias']:
        """
        Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def log(self) -> Optional['outputs.DomainDevicesParallelLog']:
        """
        Enables logging of data sent through the channel to a host file and configures how that logging behaves.
        """
        return pulumi.get(self, "log")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional['outputs.DomainDevicesParallelProtocol']:
        """
        Configures the transport protocol used by the EGD backend connection.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainDevicesParallelSource']:
        """
        Defines the source endpoint for the EGD backend, such as a socket path or network address, depending on the chosen protocol.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional['outputs.DomainDevicesParallelTarget']:
        """
        Configures the guest-visible parallel port endpoint to which this device is attached (such as which logical parallel adapter/port in the guest).
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class DomainDevicesParallelAcpi(dict):
    def __init__(__self__, *,
                 index: Optional[_builtins.float] = None):
        """
        :param _builtins.float index: Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        """
        if index is not None:
            pulumi.set(__self__, "index", index)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "index")


@pulumi.output_type
class DomainDevicesParallelAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesParallelAlias(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
               
               See: <https://libvirt.org/formatdomain.html#devices>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesParallelLog(dict):
    def __init__(__self__, *,
                 file: _builtins.str,
                 append: Optional[_builtins.str] = None):
        """
        :param _builtins.str file: Sets the absolute or relative path of the host file where channel I/O is logged.
               
               See: <https://libvirt.org/formatdomain.html#device-logfile>
        :param _builtins.str append: Controls whether the channel log file is appended to (`"yes"`) or truncated (`"no"`) on start; this is a yes/no string flag.
               
               See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        pulumi.set(__self__, "file", file)
        if append is not None:
            pulumi.set(__self__, "append", append)

    @_builtins.property
    @pulumi.getter
    def file(self) -> _builtins.str:
        """
        Sets the absolute or relative path of the host file where channel I/O is logged.

        See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def append(self) -> Optional[_builtins.str]:
        """
        Controls whether the channel log file is appended to (`"yes"`) or truncated (`"no"`) on start; this is a yes/no string flag.

        See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        return pulumi.get(self, "append")


@pulumi.output_type
class DomainDevicesParallelProtocol(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: Sets the EGD transport type, such as "tcp" or "unix"; value is a user-provided string supported by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets the EGD transport type, such as "tcp" or "unix"; value is a user-provided string supported by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainDevicesParallelSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "qemuvdAgent":
            suggest = "qemuvd_agent"
        elif key == "spicePort":
            suggest = "spice_port"
        elif key == "spiceVmc":
            suggest = "spice_vmc"
        elif key == "stdIo":
            suggest = "std_io"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesParallelSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesParallelSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesParallelSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbus: Optional['outputs.DomainDevicesParallelSourceDbus'] = None,
                 dev: Optional['outputs.DomainDevicesParallelSourceDev'] = None,
                 file: Optional['outputs.DomainDevicesParallelSourceFile'] = None,
                 nmdm: Optional['outputs.DomainDevicesParallelSourceNmdm'] = None,
                 null: Optional[_builtins.bool] = None,
                 pipe: Optional['outputs.DomainDevicesParallelSourcePipe'] = None,
                 pty: Optional['outputs.DomainDevicesParallelSourcePty'] = None,
                 qemuvd_agent: Optional['outputs.DomainDevicesParallelSourceQemuvdAgent'] = None,
                 spice_port: Optional['outputs.DomainDevicesParallelSourceSpicePort'] = None,
                 spice_vmc: Optional[_builtins.bool] = None,
                 std_io: Optional[_builtins.bool] = None,
                 tcp: Optional['outputs.DomainDevicesParallelSourceTcp'] = None,
                 udp: Optional['outputs.DomainDevicesParallelSourceUdp'] = None,
                 unix: Optional['outputs.DomainDevicesParallelSourceUnix'] = None,
                 vc: Optional[_builtins.bool] = None):
        """
        :param 'DomainDevicesParallelSourceDbusArgs' dbus: Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        :param 'DomainDevicesParallelSourceDevArgs' dev: Configures an EGD RNG backend that reads entropy from a host character device node.
        :param 'DomainDevicesParallelSourceFileArgs' file: Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        :param 'DomainDevicesParallelSourceNmdmArgs' nmdm: Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        :param _builtins.bool null: Enables use of a null backend for the EGD RNG source, discarding all data written and providing no entropy; when this boolean is true the <Null> source is emitted, and when false or unset it is omitted.
        :param 'DomainDevicesParallelSourcePipeArgs' pipe: Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        :param 'DomainDevicesParallelSourcePtyArgs' pty: Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        :param 'DomainDevicesParallelSourceQemuvdAgentArgs' qemuvd_agent: Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        :param 'DomainDevicesParallelSourceSpicePortArgs' spice_port: Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        :param _builtins.bool spice_vmc: Enables using a SPICE virtio serial management channel (spicevmc) as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.bool std_io: Enables using the QEMU process standard I/O stream as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesParallelSourceTcpArgs' tcp: Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        :param 'DomainDevicesParallelSourceUdpArgs' udp: Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        :param 'DomainDevicesParallelSourceUnixArgs' unix: Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        :param _builtins.bool vc: Enables use of a virtual console device as the entropy source for the EGD RNG backend when set (presence-only element; omitting it disables this source).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if dbus is not None:
            pulumi.set(__self__, "dbus", dbus)
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if nmdm is not None:
            pulumi.set(__self__, "nmdm", nmdm)
        if null is not None:
            pulumi.set(__self__, "null", null)
        if pipe is not None:
            pulumi.set(__self__, "pipe", pipe)
        if pty is not None:
            pulumi.set(__self__, "pty", pty)
        if qemuvd_agent is not None:
            pulumi.set(__self__, "qemuvd_agent", qemuvd_agent)
        if spice_port is not None:
            pulumi.set(__self__, "spice_port", spice_port)
        if spice_vmc is not None:
            pulumi.set(__self__, "spice_vmc", spice_vmc)
        if std_io is not None:
            pulumi.set(__self__, "std_io", std_io)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)
        if unix is not None:
            pulumi.set(__self__, "unix", unix)
        if vc is not None:
            pulumi.set(__self__, "vc", vc)

    @_builtins.property
    @pulumi.getter
    def dbus(self) -> Optional['outputs.DomainDevicesParallelSourceDbus']:
        """
        Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        """
        return pulumi.get(self, "dbus")

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional['outputs.DomainDevicesParallelSourceDev']:
        """
        Configures an EGD RNG backend that reads entropy from a host character device node.
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.DomainDevicesParallelSourceFile']:
        """
        Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def nmdm(self) -> Optional['outputs.DomainDevicesParallelSourceNmdm']:
        """
        Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        """
        return pulumi.get(self, "nmdm")

    @_builtins.property
    @pulumi.getter
    def null(self) -> Optional[_builtins.bool]:
        """
        Enables use of a null backend for the EGD RNG source, discarding all data written and providing no entropy; when this boolean is true the <Null> source is emitted, and when false or unset it is omitted.
        """
        return pulumi.get(self, "null")

    @_builtins.property
    @pulumi.getter
    def pipe(self) -> Optional['outputs.DomainDevicesParallelSourcePipe']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        """
        return pulumi.get(self, "pipe")

    @_builtins.property
    @pulumi.getter
    def pty(self) -> Optional['outputs.DomainDevicesParallelSourcePty']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        """
        return pulumi.get(self, "pty")

    @_builtins.property
    @pulumi.getter(name="qemuvdAgent")
    def qemuvd_agent(self) -> Optional['outputs.DomainDevicesParallelSourceQemuvdAgent']:
        """
        Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        """
        return pulumi.get(self, "qemuvd_agent")

    @_builtins.property
    @pulumi.getter(name="spicePort")
    def spice_port(self) -> Optional['outputs.DomainDevicesParallelSourceSpicePort']:
        """
        Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        """
        return pulumi.get(self, "spice_port")

    @_builtins.property
    @pulumi.getter(name="spiceVmc")
    def spice_vmc(self) -> Optional[_builtins.bool]:
        """
        Enables using a SPICE virtio serial management channel (spicevmc) as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "spice_vmc")

    @_builtins.property
    @pulumi.getter(name="stdIo")
    def std_io(self) -> Optional[_builtins.bool]:
        """
        Enables using the QEMU process standard I/O stream as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "std_io")

    @_builtins.property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.DomainDevicesParallelSourceTcp']:
        """
        Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        """
        return pulumi.get(self, "tcp")

    @_builtins.property
    @pulumi.getter
    def udp(self) -> Optional['outputs.DomainDevicesParallelSourceUdp']:
        """
        Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        """
        return pulumi.get(self, "udp")

    @_builtins.property
    @pulumi.getter
    def unix(self) -> Optional['outputs.DomainDevicesParallelSourceUnix']:
        """
        Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        """
        return pulumi.get(self, "unix")

    @_builtins.property
    @pulumi.getter
    def vc(self) -> Optional[_builtins.bool]:
        """
        Enables use of a virtual console device as the entropy source for the EGD RNG backend when set (presence-only element; omitting it disables this source).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "vc")


@pulumi.output_type
class DomainDevicesParallelSourceDbus(dict):
    def __init__(__self__, *,
                 channel: Optional[_builtins.str] = None):
        """
        :param _builtins.str channel: Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.str]:
        """
        Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesParallelSourceDev(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesParallelSourceDev. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesParallelSourceDev.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesParallelSourceDev.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesParallelSourceDevSecLabel']] = None):
        """
        :param _builtins.str path: Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesParallelSourceDevSecLabelArgs'] sec_labels: Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesParallelSourceDevSecLabel']]:
        """
        Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesParallelSourceDevSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesParallelSourceDevSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesParallelSourceDevSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesParallelSourceDevSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesParallelSourceFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesParallelSourceFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesParallelSourceFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesParallelSourceFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 append: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesParallelSourceFileSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str append: Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
               
               See: <https://libvirt.org/formatdomain.html#device-logfile>
        :param Sequence['DomainDevicesParallelSourceFileSecLabelArgs'] sec_labels: Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def append(self) -> Optional[_builtins.str]:
        """
        Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.

        See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        return pulumi.get(self, "append")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesParallelSourceFileSecLabel']]:
        """
        Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesParallelSourceFileSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesParallelSourceFileSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesParallelSourceFileSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesParallelSourceFileSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesParallelSourceNmdm(dict):
    def __init__(__self__, *,
                 master: _builtins.str,
                 slave: _builtins.str):
        """
        :param _builtins.str master: Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        :param _builtins.str slave: Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        pulumi.set(__self__, "master", master)
        pulumi.set(__self__, "slave", slave)

    @_builtins.property
    @pulumi.getter
    def master(self) -> _builtins.str:
        """
        Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "master")

    @_builtins.property
    @pulumi.getter
    def slave(self) -> _builtins.str:
        """
        Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "slave")


@pulumi.output_type
class DomainDevicesParallelSourcePipe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesParallelSourcePipe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesParallelSourcePipe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesParallelSourcePipe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesParallelSourcePipeSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesParallelSourcePipeSecLabelArgs'] sec_labels: Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesParallelSourcePipeSecLabel']]:
        """
        Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesParallelSourcePipeSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesParallelSourcePipeSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesParallelSourcePipeSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesParallelSourcePipeSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesParallelSourcePty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesParallelSourcePty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesParallelSourcePty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesParallelSourcePty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesParallelSourcePtySecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesParallelSourcePtySecLabelArgs'] sec_labels: Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesParallelSourcePtySecLabel']]:
        """
        Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesParallelSourcePtySecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesParallelSourcePtySecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesParallelSourcePtySecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesParallelSourcePtySecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesParallelSourceQemuvdAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clipBoard":
            suggest = "clip_board"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesParallelSourceQemuvdAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesParallelSourceQemuvdAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesParallelSourceQemuvdAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clip_board: Optional['outputs.DomainDevicesParallelSourceQemuvdAgentClipBoard'] = None,
                 mouse: Optional['outputs.DomainDevicesParallelSourceQemuvdAgentMouse'] = None):
        """
        :param 'DomainDevicesParallelSourceQemuvdAgentClipBoardArgs' clip_board: Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        :param 'DomainDevicesParallelSourceQemuvdAgentMouseArgs' mouse: Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        if clip_board is not None:
            pulumi.set(__self__, "clip_board", clip_board)
        if mouse is not None:
            pulumi.set(__self__, "mouse", mouse)

    @_builtins.property
    @pulumi.getter(name="clipBoard")
    def clip_board(self) -> Optional['outputs.DomainDevicesParallelSourceQemuvdAgentClipBoard']:
        """
        Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        """
        return pulumi.get(self, "clip_board")

    @_builtins.property
    @pulumi.getter
    def mouse(self) -> Optional['outputs.DomainDevicesParallelSourceQemuvdAgentMouse']:
        """
        Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        return pulumi.get(self, "mouse")


@pulumi.output_type
class DomainDevicesParallelSourceQemuvdAgentClipBoard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyPaste":
            suggest = "copy_paste"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesParallelSourceQemuvdAgentClipBoard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesParallelSourceQemuvdAgentClipBoard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesParallelSourceQemuvdAgentClipBoard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_paste: _builtins.str):
        """
        :param _builtins.str copy_paste: Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "copy_paste", copy_paste)

    @_builtins.property
    @pulumi.getter(name="copyPaste")
    def copy_paste(self) -> _builtins.str:
        """
        Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "copy_paste")


@pulumi.output_type
class DomainDevicesParallelSourceQemuvdAgentMouse(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DomainDevicesParallelSourceSpicePort(dict):
    def __init__(__self__, *,
                 channel: _builtins.str):
        """
        :param _builtins.str channel: Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesParallelSourceTcp(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesParallelSourceTcpReconnect'] = None,
                 service: Optional[_builtins.str] = None,
                 tls: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str mode: Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesParallelSourceTcpReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param _builtins.str service: Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str tls: Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesParallelSourceTcpReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[_builtins.str]:
        """
        Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class DomainDevicesParallelSourceTcpReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesParallelSourceUdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindHost":
            suggest = "bind_host"
        elif key == "bindService":
            suggest = "bind_service"
        elif key == "connectHost":
            suggest = "connect_host"
        elif key == "connectService":
            suggest = "connect_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesParallelSourceUdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesParallelSourceUdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesParallelSourceUdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bind_host: _builtins.str,
                 bind_service: _builtins.str,
                 connect_host: _builtins.str,
                 connect_service: _builtins.str):
        """
        :param _builtins.str bind_host: Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str bind_service: Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_host: Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_service: Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "bind_host", bind_host)
        pulumi.set(__self__, "bind_service", bind_service)
        pulumi.set(__self__, "connect_host", connect_host)
        pulumi.set(__self__, "connect_service", connect_service)

    @_builtins.property
    @pulumi.getter(name="bindHost")
    def bind_host(self) -> _builtins.str:
        """
        Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_host")

    @_builtins.property
    @pulumi.getter(name="bindService")
    def bind_service(self) -> _builtins.str:
        """
        Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_service")

    @_builtins.property
    @pulumi.getter(name="connectHost")
    def connect_host(self) -> _builtins.str:
        """
        Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_host")

    @_builtins.property
    @pulumi.getter(name="connectService")
    def connect_service(self) -> _builtins.str:
        """
        Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_service")


@pulumi.output_type
class DomainDevicesParallelSourceUnix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesParallelSourceUnix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesParallelSourceUnix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesParallelSourceUnix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesParallelSourceUnixReconnect'] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesParallelSourceUnixSecLabel']] = None):
        """
        :param _builtins.str mode: Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str path: Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesParallelSourceUnixReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param Sequence['DomainDevicesParallelSourceUnixSecLabelArgs'] sec_labels: Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesParallelSourceUnixReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesParallelSourceUnixSecLabel']]:
        """
        Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesParallelSourceUnixReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesParallelSourceUnixSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesParallelSourceUnixSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesParallelSourceUnixSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesParallelSourceUnixSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesParallelTarget(dict):
    def __init__(__self__, *,
                 port: Optional[_builtins.float] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.float port: Sets the guest parallel port number (non-negative integer, usually 0, 1, or 2) that this device is exposed as.
               
               See: <https://libvirt.org/formatdomain.html#parallel-port>
        :param _builtins.str type: Defines the kind of guest-facing target for the parallel device (for example a specific controller/model type); the exact value is user-provided and driver-specific.
               
               See: <https://libvirt.org/formatdomain.html#parallel-port>
        """
        if port is not None:
            pulumi.set(__self__, "port", port)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.float]:
        """
        Sets the guest parallel port number (non-negative integer, usually 0, 1, or 2) that this device is exposed as.

        See: <https://libvirt.org/formatdomain.html#parallel-port>
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Defines the kind of guest-facing target for the parallel device (for example a specific controller/model type); the exact value is user-provided and driver-specific.

        See: <https://libvirt.org/formatdomain.html#parallel-port>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainDevicesPstore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeUnit":
            suggest = "size_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesPstore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesPstore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesPstore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend: _builtins.str,
                 path: _builtins.str,
                 size: _builtins.float,
                 acpi: Optional['outputs.DomainDevicesPstoreAcpi'] = None,
                 address: Optional['outputs.DomainDevicesPstoreAddress'] = None,
                 alias: Optional['outputs.DomainDevicesPstoreAlias'] = None,
                 size_unit: Optional[_builtins.str] = None):
        """
        :param _builtins.str backend: Selects the pstore backend implementation used by the guest (currently "acpi-erst" is supported); this attribute is required.
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        :param _builtins.str path: Sets the host path (file or block device) used as the persistent storage area for pstore logs (for example "/var/lib/libvirt/pstore.img").
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        :param _builtins.float size: Defines the capacity of the pstore log storage, as a numeric value interpreted together with size_unit (for example 16 with size_unit="MiB").
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        :param 'DomainDevicesPstoreAcpiArgs' acpi: Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        :param 'DomainDevicesPstoreAddressArgs' address: Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        :param 'DomainDevicesPstoreAliasArgs' alias: Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        :param _builtins.str size_unit: Specifies the unit for the pstore size value (for example "KiB", "MiB", or "GiB"); if omitted, libvirt applies its default unit handling.
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        """
        pulumi.set(__self__, "backend", backend)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "size", size)
        if acpi is not None:
            pulumi.set(__self__, "acpi", acpi)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if size_unit is not None:
            pulumi.set(__self__, "size_unit", size_unit)

    @_builtins.property
    @pulumi.getter
    def backend(self) -> _builtins.str:
        """
        Selects the pstore backend implementation used by the guest (currently "acpi-erst" is supported); this attribute is required.

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "backend")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the host path (file or block device) used as the persistent storage area for pstore logs (for example "/var/lib/libvirt/pstore.img").

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.float:
        """
        Defines the capacity of the pstore log storage, as a numeric value interpreted together with size_unit (for example 16 with size_unit="MiB").

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def acpi(self) -> Optional['outputs.DomainDevicesPstoreAcpi']:
        """
        Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        """
        return pulumi.get(self, "acpi")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesPstoreAddress']:
        """
        Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional['outputs.DomainDevicesPstoreAlias']:
        """
        Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter(name="sizeUnit")
    def size_unit(self) -> Optional[_builtins.str]:
        """
        Specifies the unit for the pstore size value (for example "KiB", "MiB", or "GiB"); if omitted, libvirt applies its default unit handling.

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "size_unit")


@pulumi.output_type
class DomainDevicesPstoreAcpi(dict):
    def __init__(__self__, *,
                 index: Optional[_builtins.float] = None):
        """
        :param _builtins.float index: Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        """
        if index is not None:
            pulumi.set(__self__, "index", index)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "index")


@pulumi.output_type
class DomainDevicesPstoreAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesPstoreAlias(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
               
               See: <https://libvirt.org/formatdomain.html#devices>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesRedirDev(dict):
    def __init__(__self__, *,
                 acpi: Optional['outputs.DomainDevicesRedirDevAcpi'] = None,
                 address: Optional['outputs.DomainDevicesRedirDevAddress'] = None,
                 alias: Optional['outputs.DomainDevicesRedirDevAlias'] = None,
                 boot: Optional['outputs.DomainDevicesRedirDevBoot'] = None,
                 bus: Optional[_builtins.str] = None,
                 protocol: Optional['outputs.DomainDevicesRedirDevProtocol'] = None,
                 source: Optional['outputs.DomainDevicesRedirDevSource'] = None):
        """
        :param 'DomainDevicesRedirDevAcpiArgs' acpi: Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        :param 'DomainDevicesRedirDevAddressArgs' address: Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        :param 'DomainDevicesRedirDevAliasArgs' alias: Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        :param 'DomainDevicesRedirDevBootArgs' boot: Enables boot-order control for this redirected device, allowing it to participate in the device boot sequence.
        :param _builtins.str bus: Selects the bus type used by the redirected device, typically "usb" for USB redirection as required by libvirt; other values are not supported for redirdev.
               
               See: <https://libvirt.org/formatdomain.html#redirected-devices>
        :param 'DomainDevicesRedirDevProtocolArgs' protocol: Configures the transport protocol used by the EGD backend connection.
        :param 'DomainDevicesRedirDevSourceArgs' source: Defines the source endpoint for the EGD backend, such as a socket path or network address, depending on the chosen protocol.
        """
        if acpi is not None:
            pulumi.set(__self__, "acpi", acpi)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if boot is not None:
            pulumi.set(__self__, "boot", boot)
        if bus is not None:
            pulumi.set(__self__, "bus", bus)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def acpi(self) -> Optional['outputs.DomainDevicesRedirDevAcpi']:
        """
        Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        """
        return pulumi.get(self, "acpi")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesRedirDevAddress']:
        """
        Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional['outputs.DomainDevicesRedirDevAlias']:
        """
        Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def boot(self) -> Optional['outputs.DomainDevicesRedirDevBoot']:
        """
        Enables boot-order control for this redirected device, allowing it to participate in the device boot sequence.
        """
        return pulumi.get(self, "boot")

    @_builtins.property
    @pulumi.getter
    def bus(self) -> Optional[_builtins.str]:
        """
        Selects the bus type used by the redirected device, typically "usb" for USB redirection as required by libvirt; other values are not supported for redirdev.

        See: <https://libvirt.org/formatdomain.html#redirected-devices>
        """
        return pulumi.get(self, "bus")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional['outputs.DomainDevicesRedirDevProtocol']:
        """
        Configures the transport protocol used by the EGD backend connection.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainDevicesRedirDevSource']:
        """
        Defines the source endpoint for the EGD backend, such as a socket path or network address, depending on the chosen protocol.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class DomainDevicesRedirDevAcpi(dict):
    def __init__(__self__, *,
                 index: Optional[_builtins.float] = None):
        """
        :param _builtins.float index: Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        """
        if index is not None:
            pulumi.set(__self__, "index", index)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "index")


@pulumi.output_type
class DomainDevicesRedirDevAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesRedirDevAlias(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
               
               See: <https://libvirt.org/formatdomain.html#devices>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesRedirDevBoot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadParm":
            suggest = "load_parm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRedirDevBoot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRedirDevBoot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRedirDevBoot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 order: _builtins.float,
                 load_parm: Optional[_builtins.str] = None):
        """
        :param _builtins.float order: Sets the boot priority for this redirected device, as a positive integer where lower values are tried earlier during guest boot (for example, 1 for first, 2 for second).
               
               See: <https://libvirt.org/formatdomain.html#specifying-boot-order>
        :param _builtins.str load_parm: Sets an optional firmware load parameter string associated with booting from this redirected device, passed to firmware on platforms that support loadparm (e.g. s390x).
               
               See: <https://libvirt.org/formatdomain.html#specifying-boot-order>
        """
        pulumi.set(__self__, "order", order)
        if load_parm is not None:
            pulumi.set(__self__, "load_parm", load_parm)

    @_builtins.property
    @pulumi.getter
    def order(self) -> _builtins.float:
        """
        Sets the boot priority for this redirected device, as a positive integer where lower values are tried earlier during guest boot (for example, 1 for first, 2 for second).

        See: <https://libvirt.org/formatdomain.html#specifying-boot-order>
        """
        return pulumi.get(self, "order")

    @_builtins.property
    @pulumi.getter(name="loadParm")
    def load_parm(self) -> Optional[_builtins.str]:
        """
        Sets an optional firmware load parameter string associated with booting from this redirected device, passed to firmware on platforms that support loadparm (e.g. s390x).

        See: <https://libvirt.org/formatdomain.html#specifying-boot-order>
        """
        return pulumi.get(self, "load_parm")


@pulumi.output_type
class DomainDevicesRedirDevProtocol(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: Sets the EGD transport type, such as "tcp" or "unix"; value is a user-provided string supported by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets the EGD transport type, such as "tcp" or "unix"; value is a user-provided string supported by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainDevicesRedirDevSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "qemuvdAgent":
            suggest = "qemuvd_agent"
        elif key == "spicePort":
            suggest = "spice_port"
        elif key == "spiceVmc":
            suggest = "spice_vmc"
        elif key == "stdIo":
            suggest = "std_io"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRedirDevSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRedirDevSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRedirDevSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbus: Optional['outputs.DomainDevicesRedirDevSourceDbus'] = None,
                 dev: Optional['outputs.DomainDevicesRedirDevSourceDev'] = None,
                 file: Optional['outputs.DomainDevicesRedirDevSourceFile'] = None,
                 nmdm: Optional['outputs.DomainDevicesRedirDevSourceNmdm'] = None,
                 null: Optional[_builtins.bool] = None,
                 pipe: Optional['outputs.DomainDevicesRedirDevSourcePipe'] = None,
                 pty: Optional['outputs.DomainDevicesRedirDevSourcePty'] = None,
                 qemuvd_agent: Optional['outputs.DomainDevicesRedirDevSourceQemuvdAgent'] = None,
                 spice_port: Optional['outputs.DomainDevicesRedirDevSourceSpicePort'] = None,
                 spice_vmc: Optional[_builtins.bool] = None,
                 std_io: Optional[_builtins.bool] = None,
                 tcp: Optional['outputs.DomainDevicesRedirDevSourceTcp'] = None,
                 udp: Optional['outputs.DomainDevicesRedirDevSourceUdp'] = None,
                 unix: Optional['outputs.DomainDevicesRedirDevSourceUnix'] = None,
                 vc: Optional[_builtins.bool] = None):
        """
        :param 'DomainDevicesRedirDevSourceDbusArgs' dbus: Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        :param 'DomainDevicesRedirDevSourceDevArgs' dev: Configures an EGD RNG backend that reads entropy from a host character device node.
        :param 'DomainDevicesRedirDevSourceFileArgs' file: Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        :param 'DomainDevicesRedirDevSourceNmdmArgs' nmdm: Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        :param _builtins.bool null: Enables use of a null backend for the EGD RNG source, discarding all data written and providing no entropy; when this boolean is true the <Null> source is emitted, and when false or unset it is omitted.
        :param 'DomainDevicesRedirDevSourcePipeArgs' pipe: Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        :param 'DomainDevicesRedirDevSourcePtyArgs' pty: Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        :param 'DomainDevicesRedirDevSourceQemuvdAgentArgs' qemuvd_agent: Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        :param 'DomainDevicesRedirDevSourceSpicePortArgs' spice_port: Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        :param _builtins.bool spice_vmc: Enables using a SPICE virtio serial management channel (spicevmc) as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.bool std_io: Enables using the QEMU process standard I/O stream as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesRedirDevSourceTcpArgs' tcp: Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        :param 'DomainDevicesRedirDevSourceUdpArgs' udp: Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        :param 'DomainDevicesRedirDevSourceUnixArgs' unix: Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        :param _builtins.bool vc: Enables use of a virtual console device as the entropy source for the EGD RNG backend when set (presence-only element; omitting it disables this source).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if dbus is not None:
            pulumi.set(__self__, "dbus", dbus)
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if nmdm is not None:
            pulumi.set(__self__, "nmdm", nmdm)
        if null is not None:
            pulumi.set(__self__, "null", null)
        if pipe is not None:
            pulumi.set(__self__, "pipe", pipe)
        if pty is not None:
            pulumi.set(__self__, "pty", pty)
        if qemuvd_agent is not None:
            pulumi.set(__self__, "qemuvd_agent", qemuvd_agent)
        if spice_port is not None:
            pulumi.set(__self__, "spice_port", spice_port)
        if spice_vmc is not None:
            pulumi.set(__self__, "spice_vmc", spice_vmc)
        if std_io is not None:
            pulumi.set(__self__, "std_io", std_io)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)
        if unix is not None:
            pulumi.set(__self__, "unix", unix)
        if vc is not None:
            pulumi.set(__self__, "vc", vc)

    @_builtins.property
    @pulumi.getter
    def dbus(self) -> Optional['outputs.DomainDevicesRedirDevSourceDbus']:
        """
        Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        """
        return pulumi.get(self, "dbus")

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional['outputs.DomainDevicesRedirDevSourceDev']:
        """
        Configures an EGD RNG backend that reads entropy from a host character device node.
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.DomainDevicesRedirDevSourceFile']:
        """
        Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def nmdm(self) -> Optional['outputs.DomainDevicesRedirDevSourceNmdm']:
        """
        Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        """
        return pulumi.get(self, "nmdm")

    @_builtins.property
    @pulumi.getter
    def null(self) -> Optional[_builtins.bool]:
        """
        Enables use of a null backend for the EGD RNG source, discarding all data written and providing no entropy; when this boolean is true the <Null> source is emitted, and when false or unset it is omitted.
        """
        return pulumi.get(self, "null")

    @_builtins.property
    @pulumi.getter
    def pipe(self) -> Optional['outputs.DomainDevicesRedirDevSourcePipe']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        """
        return pulumi.get(self, "pipe")

    @_builtins.property
    @pulumi.getter
    def pty(self) -> Optional['outputs.DomainDevicesRedirDevSourcePty']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        """
        return pulumi.get(self, "pty")

    @_builtins.property
    @pulumi.getter(name="qemuvdAgent")
    def qemuvd_agent(self) -> Optional['outputs.DomainDevicesRedirDevSourceQemuvdAgent']:
        """
        Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        """
        return pulumi.get(self, "qemuvd_agent")

    @_builtins.property
    @pulumi.getter(name="spicePort")
    def spice_port(self) -> Optional['outputs.DomainDevicesRedirDevSourceSpicePort']:
        """
        Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        """
        return pulumi.get(self, "spice_port")

    @_builtins.property
    @pulumi.getter(name="spiceVmc")
    def spice_vmc(self) -> Optional[_builtins.bool]:
        """
        Enables using a SPICE virtio serial management channel (spicevmc) as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "spice_vmc")

    @_builtins.property
    @pulumi.getter(name="stdIo")
    def std_io(self) -> Optional[_builtins.bool]:
        """
        Enables using the QEMU process standard I/O stream as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "std_io")

    @_builtins.property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.DomainDevicesRedirDevSourceTcp']:
        """
        Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        """
        return pulumi.get(self, "tcp")

    @_builtins.property
    @pulumi.getter
    def udp(self) -> Optional['outputs.DomainDevicesRedirDevSourceUdp']:
        """
        Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        """
        return pulumi.get(self, "udp")

    @_builtins.property
    @pulumi.getter
    def unix(self) -> Optional['outputs.DomainDevicesRedirDevSourceUnix']:
        """
        Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        """
        return pulumi.get(self, "unix")

    @_builtins.property
    @pulumi.getter
    def vc(self) -> Optional[_builtins.bool]:
        """
        Enables use of a virtual console device as the entropy source for the EGD RNG backend when set (presence-only element; omitting it disables this source).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "vc")


@pulumi.output_type
class DomainDevicesRedirDevSourceDbus(dict):
    def __init__(__self__, *,
                 channel: Optional[_builtins.str] = None):
        """
        :param _builtins.str channel: Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.str]:
        """
        Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesRedirDevSourceDev(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRedirDevSourceDev. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRedirDevSourceDev.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRedirDevSourceDev.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesRedirDevSourceDevSecLabel']] = None):
        """
        :param _builtins.str path: Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesRedirDevSourceDevSecLabelArgs'] sec_labels: Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesRedirDevSourceDevSecLabel']]:
        """
        Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesRedirDevSourceDevSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRedirDevSourceDevSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRedirDevSourceDevSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRedirDevSourceDevSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesRedirDevSourceFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRedirDevSourceFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRedirDevSourceFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRedirDevSourceFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 append: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesRedirDevSourceFileSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str append: Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
               
               See: <https://libvirt.org/formatdomain.html#device-logfile>
        :param Sequence['DomainDevicesRedirDevSourceFileSecLabelArgs'] sec_labels: Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def append(self) -> Optional[_builtins.str]:
        """
        Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.

        See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        return pulumi.get(self, "append")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesRedirDevSourceFileSecLabel']]:
        """
        Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesRedirDevSourceFileSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRedirDevSourceFileSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRedirDevSourceFileSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRedirDevSourceFileSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesRedirDevSourceNmdm(dict):
    def __init__(__self__, *,
                 master: _builtins.str,
                 slave: _builtins.str):
        """
        :param _builtins.str master: Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        :param _builtins.str slave: Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        pulumi.set(__self__, "master", master)
        pulumi.set(__self__, "slave", slave)

    @_builtins.property
    @pulumi.getter
    def master(self) -> _builtins.str:
        """
        Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "master")

    @_builtins.property
    @pulumi.getter
    def slave(self) -> _builtins.str:
        """
        Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "slave")


@pulumi.output_type
class DomainDevicesRedirDevSourcePipe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRedirDevSourcePipe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRedirDevSourcePipe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRedirDevSourcePipe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesRedirDevSourcePipeSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesRedirDevSourcePipeSecLabelArgs'] sec_labels: Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesRedirDevSourcePipeSecLabel']]:
        """
        Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesRedirDevSourcePipeSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRedirDevSourcePipeSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRedirDevSourcePipeSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRedirDevSourcePipeSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesRedirDevSourcePty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRedirDevSourcePty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRedirDevSourcePty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRedirDevSourcePty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesRedirDevSourcePtySecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesRedirDevSourcePtySecLabelArgs'] sec_labels: Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesRedirDevSourcePtySecLabel']]:
        """
        Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesRedirDevSourcePtySecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRedirDevSourcePtySecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRedirDevSourcePtySecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRedirDevSourcePtySecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesRedirDevSourceQemuvdAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clipBoard":
            suggest = "clip_board"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRedirDevSourceQemuvdAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRedirDevSourceQemuvdAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRedirDevSourceQemuvdAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clip_board: Optional['outputs.DomainDevicesRedirDevSourceQemuvdAgentClipBoard'] = None,
                 mouse: Optional['outputs.DomainDevicesRedirDevSourceQemuvdAgentMouse'] = None):
        """
        :param 'DomainDevicesRedirDevSourceQemuvdAgentClipBoardArgs' clip_board: Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        :param 'DomainDevicesRedirDevSourceQemuvdAgentMouseArgs' mouse: Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        if clip_board is not None:
            pulumi.set(__self__, "clip_board", clip_board)
        if mouse is not None:
            pulumi.set(__self__, "mouse", mouse)

    @_builtins.property
    @pulumi.getter(name="clipBoard")
    def clip_board(self) -> Optional['outputs.DomainDevicesRedirDevSourceQemuvdAgentClipBoard']:
        """
        Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        """
        return pulumi.get(self, "clip_board")

    @_builtins.property
    @pulumi.getter
    def mouse(self) -> Optional['outputs.DomainDevicesRedirDevSourceQemuvdAgentMouse']:
        """
        Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        return pulumi.get(self, "mouse")


@pulumi.output_type
class DomainDevicesRedirDevSourceQemuvdAgentClipBoard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyPaste":
            suggest = "copy_paste"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRedirDevSourceQemuvdAgentClipBoard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRedirDevSourceQemuvdAgentClipBoard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRedirDevSourceQemuvdAgentClipBoard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_paste: _builtins.str):
        """
        :param _builtins.str copy_paste: Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "copy_paste", copy_paste)

    @_builtins.property
    @pulumi.getter(name="copyPaste")
    def copy_paste(self) -> _builtins.str:
        """
        Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "copy_paste")


@pulumi.output_type
class DomainDevicesRedirDevSourceQemuvdAgentMouse(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DomainDevicesRedirDevSourceSpicePort(dict):
    def __init__(__self__, *,
                 channel: _builtins.str):
        """
        :param _builtins.str channel: Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesRedirDevSourceTcp(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesRedirDevSourceTcpReconnect'] = None,
                 service: Optional[_builtins.str] = None,
                 tls: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str mode: Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesRedirDevSourceTcpReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param _builtins.str service: Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str tls: Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesRedirDevSourceTcpReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[_builtins.str]:
        """
        Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class DomainDevicesRedirDevSourceTcpReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesRedirDevSourceUdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindHost":
            suggest = "bind_host"
        elif key == "bindService":
            suggest = "bind_service"
        elif key == "connectHost":
            suggest = "connect_host"
        elif key == "connectService":
            suggest = "connect_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRedirDevSourceUdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRedirDevSourceUdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRedirDevSourceUdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bind_host: _builtins.str,
                 bind_service: _builtins.str,
                 connect_host: _builtins.str,
                 connect_service: _builtins.str):
        """
        :param _builtins.str bind_host: Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str bind_service: Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_host: Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_service: Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "bind_host", bind_host)
        pulumi.set(__self__, "bind_service", bind_service)
        pulumi.set(__self__, "connect_host", connect_host)
        pulumi.set(__self__, "connect_service", connect_service)

    @_builtins.property
    @pulumi.getter(name="bindHost")
    def bind_host(self) -> _builtins.str:
        """
        Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_host")

    @_builtins.property
    @pulumi.getter(name="bindService")
    def bind_service(self) -> _builtins.str:
        """
        Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_service")

    @_builtins.property
    @pulumi.getter(name="connectHost")
    def connect_host(self) -> _builtins.str:
        """
        Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_host")

    @_builtins.property
    @pulumi.getter(name="connectService")
    def connect_service(self) -> _builtins.str:
        """
        Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_service")


@pulumi.output_type
class DomainDevicesRedirDevSourceUnix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRedirDevSourceUnix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRedirDevSourceUnix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRedirDevSourceUnix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesRedirDevSourceUnixReconnect'] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesRedirDevSourceUnixSecLabel']] = None):
        """
        :param _builtins.str mode: Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str path: Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesRedirDevSourceUnixReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param Sequence['DomainDevicesRedirDevSourceUnixSecLabelArgs'] sec_labels: Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesRedirDevSourceUnixReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesRedirDevSourceUnixSecLabel']]:
        """
        Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesRedirDevSourceUnixReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesRedirDevSourceUnixSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRedirDevSourceUnixSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRedirDevSourceUnixSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRedirDevSourceUnixSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesRedirFilter(dict):
    def __init__(__self__, *,
                 usbs: Optional[Sequence['outputs.DomainDevicesRedirFilterUsb']] = None):
        """
        :param Sequence['DomainDevicesRedirFilterUsbArgs'] usbs: Defines a single USB device match rule within the redirection filter, optionally matching by class, vendor, product, and version.
               
               See: <https://libvirt.org/formatdomain.html#redirected-devices>
        """
        if usbs is not None:
            pulumi.set(__self__, "usbs", usbs)

    @_builtins.property
    @pulumi.getter
    def usbs(self) -> Optional[Sequence['outputs.DomainDevicesRedirFilterUsb']]:
        """
        Defines a single USB device match rule within the redirection filter, optionally matching by class, vendor, product, and version.

        See: <https://libvirt.org/formatdomain.html#redirected-devices>
        """
        return pulumi.get(self, "usbs")


@pulumi.output_type
class DomainDevicesRedirFilterUsb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "class":
            suggest = "class_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRedirFilterUsb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRedirFilterUsb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRedirFilterUsb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow: _builtins.str,
                 class_: Optional[_builtins.float] = None,
                 product: Optional[_builtins.float] = None,
                 vendor: Optional[_builtins.float] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str allow: Sets whether USB devices matching this rule are allowed or blocked by the redirection filter; valid values are "yes" or "no".
               
               See: <https://libvirt.org/formatdomain.html#redirected-devices>
        :param _builtins.float class_: Sets the USB device class code used to match devices for this filter rule; value is a user-provided numeric class identifier (for example "0x08" for mass storage).
               
               See: <https://libvirt.org/formatdomain.html#redirected-devices>
        :param _builtins.float product: Sets the USB product ID to match for this filter rule; value is a user-provided numeric product identifier, typically in hex (for example "0x1234").
               
               See: <https://libvirt.org/formatdomain.html#redirected-devices>
        :param _builtins.float vendor: Sets the USB vendor ID to match for this filter rule; value is a user-provided numeric vendor identifier, typically in hex (for example "0x046d").
               
               See: <https://libvirt.org/formatdomain.html#redirected-devices>
        :param _builtins.str version: Sets the USB device version (bcdDevice) to match for this filter rule; value is a user-provided numeric version identifier (for example "0x0100").
               
               See: <https://libvirt.org/formatdomain.html#redirected-devices>
        """
        pulumi.set(__self__, "allow", allow)
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if product is not None:
            pulumi.set(__self__, "product", product)
        if vendor is not None:
            pulumi.set(__self__, "vendor", vendor)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> _builtins.str:
        """
        Sets whether USB devices matching this rule are allowed or blocked by the redirection filter; valid values are "yes" or "no".

        See: <https://libvirt.org/formatdomain.html#redirected-devices>
        """
        return pulumi.get(self, "allow")

    @_builtins.property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[_builtins.float]:
        """
        Sets the USB device class code used to match devices for this filter rule; value is a user-provided numeric class identifier (for example "0x08" for mass storage).

        See: <https://libvirt.org/formatdomain.html#redirected-devices>
        """
        return pulumi.get(self, "class_")

    @_builtins.property
    @pulumi.getter
    def product(self) -> Optional[_builtins.float]:
        """
        Sets the USB product ID to match for this filter rule; value is a user-provided numeric product identifier, typically in hex (for example "0x1234").

        See: <https://libvirt.org/formatdomain.html#redirected-devices>
        """
        return pulumi.get(self, "product")

    @_builtins.property
    @pulumi.getter
    def vendor(self) -> Optional[_builtins.float]:
        """
        Sets the USB vendor ID to match for this filter rule; value is a user-provided numeric vendor identifier, typically in hex (for example "0x046d").

        See: <https://libvirt.org/formatdomain.html#redirected-devices>
        """
        return pulumi.get(self, "vendor")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Sets the USB device version (bcdDevice) to match for this filter rule; value is a user-provided numeric version identifier (for example "0x0100").

        See: <https://libvirt.org/formatdomain.html#redirected-devices>
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DomainDevicesRng(dict):
    def __init__(__self__, *,
                 model: _builtins.str,
                 acpi: Optional['outputs.DomainDevicesRngAcpi'] = None,
                 address: Optional['outputs.DomainDevicesRngAddress'] = None,
                 alias: Optional['outputs.DomainDevicesRngAlias'] = None,
                 backend: Optional['outputs.DomainDevicesRngBackend'] = None,
                 driver: Optional['outputs.DomainDevicesRngDriver'] = None,
                 rate: Optional['outputs.DomainDevicesRngRate'] = None):
        """
        :param _builtins.str model: Sets the RNG device model, for example "virtio" for a paravirtual RNG; the value is required and must be a model supported by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesRngAcpiArgs' acpi: Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        :param 'DomainDevicesRngAddressArgs' address: Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        :param 'DomainDevicesRngAliasArgs' alias: Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        :param 'DomainDevicesRngBackendArgs' backend: Configures the entropy backend that the RNG device uses, such as a built-in source or an external EGD-compatible source.
        :param 'DomainDevicesRngDriverArgs' driver: Configures virtio transportspecific driver options for the RNG device, such as IOMMU and ATS behavior.
        :param 'DomainDevicesRngRateArgs' rate: Configures optional rate limiting for the RNG device, constraining how much entropy is delivered to the guest over time.
        """
        pulumi.set(__self__, "model", model)
        if acpi is not None:
            pulumi.set(__self__, "acpi", acpi)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if backend is not None:
            pulumi.set(__self__, "backend", backend)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if rate is not None:
            pulumi.set(__self__, "rate", rate)

    @_builtins.property
    @pulumi.getter
    def model(self) -> _builtins.str:
        """
        Sets the RNG device model, for example "virtio" for a paravirtual RNG; the value is required and must be a model supported by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def acpi(self) -> Optional['outputs.DomainDevicesRngAcpi']:
        """
        Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        """
        return pulumi.get(self, "acpi")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesRngAddress']:
        """
        Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional['outputs.DomainDevicesRngAlias']:
        """
        Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def backend(self) -> Optional['outputs.DomainDevicesRngBackend']:
        """
        Configures the entropy backend that the RNG device uses, such as a built-in source or an external EGD-compatible source.
        """
        return pulumi.get(self, "backend")

    @_builtins.property
    @pulumi.getter
    def driver(self) -> Optional['outputs.DomainDevicesRngDriver']:
        """
        Configures virtio transportspecific driver options for the RNG device, such as IOMMU and ATS behavior.
        """
        return pulumi.get(self, "driver")

    @_builtins.property
    @pulumi.getter
    def rate(self) -> Optional['outputs.DomainDevicesRngRate']:
        """
        Configures optional rate limiting for the RNG device, constraining how much entropy is delivered to the guest over time.
        """
        return pulumi.get(self, "rate")


@pulumi.output_type
class DomainDevicesRngAcpi(dict):
    def __init__(__self__, *,
                 index: Optional[_builtins.float] = None):
        """
        :param _builtins.float index: Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        """
        if index is not None:
            pulumi.set(__self__, "index", index)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "index")


@pulumi.output_type
class DomainDevicesRngAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesRngAlias(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
               
               See: <https://libvirt.org/formatdomain.html#devices>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesRngBackend(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "builtIn":
            suggest = "built_in"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRngBackend. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRngBackend.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRngBackend.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 built_in: Optional[_builtins.bool] = None,
                 egd: Optional['outputs.DomainDevicesRngBackendEgd'] = None,
                 random: Optional[_builtins.str] = None):
        """
        :param _builtins.bool built_in: Enables use of the hypervisors built-in RNG backend when set (presence-only); omit this field to avoid configuring a built-in backend.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesRngBackendEgdArgs' egd: Configures an external entropy gathering daemon (EGD) as the RNG backend, including protocol and source details.
        :param _builtins.str random: Selects the host random backend for the RNG device, typically mapping to a host RNG source such as /dev/random or /dev/urandom; details are user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if built_in is not None:
            pulumi.set(__self__, "built_in", built_in)
        if egd is not None:
            pulumi.set(__self__, "egd", egd)
        if random is not None:
            pulumi.set(__self__, "random", random)

    @_builtins.property
    @pulumi.getter(name="builtIn")
    def built_in(self) -> Optional[_builtins.bool]:
        """
        Enables use of the hypervisors built-in RNG backend when set (presence-only); omit this field to avoid configuring a built-in backend.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "built_in")

    @_builtins.property
    @pulumi.getter
    def egd(self) -> Optional['outputs.DomainDevicesRngBackendEgd']:
        """
        Configures an external entropy gathering daemon (EGD) as the RNG backend, including protocol and source details.
        """
        return pulumi.get(self, "egd")

    @_builtins.property
    @pulumi.getter
    def random(self) -> Optional[_builtins.str]:
        """
        Selects the host random backend for the RNG device, typically mapping to a host RNG source such as /dev/random or /dev/urandom; details are user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "random")


@pulumi.output_type
class DomainDevicesRngBackendEgd(dict):
    def __init__(__self__, *,
                 protocol: Optional['outputs.DomainDevicesRngBackendEgdProtocol'] = None,
                 source: Optional['outputs.DomainDevicesRngBackendEgdSource'] = None):
        """
        :param 'DomainDevicesRngBackendEgdProtocolArgs' protocol: Configures the transport protocol used by the EGD backend connection.
        :param 'DomainDevicesRngBackendEgdSourceArgs' source: Defines the source endpoint for the EGD backend, such as a socket path or network address, depending on the chosen protocol.
        """
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional['outputs.DomainDevicesRngBackendEgdProtocol']:
        """
        Configures the transport protocol used by the EGD backend connection.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainDevicesRngBackendEgdSource']:
        """
        Defines the source endpoint for the EGD backend, such as a socket path or network address, depending on the chosen protocol.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class DomainDevicesRngBackendEgdProtocol(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: Sets the EGD transport type, such as "tcp" or "unix"; value is a user-provided string supported by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets the EGD transport type, such as "tcp" or "unix"; value is a user-provided string supported by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainDevicesRngBackendEgdSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "qemuvdAgent":
            suggest = "qemuvd_agent"
        elif key == "spicePort":
            suggest = "spice_port"
        elif key == "spiceVmc":
            suggest = "spice_vmc"
        elif key == "stdIo":
            suggest = "std_io"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRngBackendEgdSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRngBackendEgdSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRngBackendEgdSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbus: Optional['outputs.DomainDevicesRngBackendEgdSourceDbus'] = None,
                 dev: Optional['outputs.DomainDevicesRngBackendEgdSourceDev'] = None,
                 file: Optional['outputs.DomainDevicesRngBackendEgdSourceFile'] = None,
                 nmdm: Optional['outputs.DomainDevicesRngBackendEgdSourceNmdm'] = None,
                 null: Optional[_builtins.bool] = None,
                 pipe: Optional['outputs.DomainDevicesRngBackendEgdSourcePipe'] = None,
                 pty: Optional['outputs.DomainDevicesRngBackendEgdSourcePty'] = None,
                 qemuvd_agent: Optional['outputs.DomainDevicesRngBackendEgdSourceQemuvdAgent'] = None,
                 spice_port: Optional['outputs.DomainDevicesRngBackendEgdSourceSpicePort'] = None,
                 spice_vmc: Optional[_builtins.bool] = None,
                 std_io: Optional[_builtins.bool] = None,
                 tcp: Optional['outputs.DomainDevicesRngBackendEgdSourceTcp'] = None,
                 udp: Optional['outputs.DomainDevicesRngBackendEgdSourceUdp'] = None,
                 unix: Optional['outputs.DomainDevicesRngBackendEgdSourceUnix'] = None,
                 vc: Optional[_builtins.bool] = None):
        """
        :param 'DomainDevicesRngBackendEgdSourceDbusArgs' dbus: Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        :param 'DomainDevicesRngBackendEgdSourceDevArgs' dev: Configures an EGD RNG backend that reads entropy from a host character device node.
        :param 'DomainDevicesRngBackendEgdSourceFileArgs' file: Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        :param 'DomainDevicesRngBackendEgdSourceNmdmArgs' nmdm: Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        :param _builtins.bool null: Enables use of a null backend for the EGD RNG source, discarding all data written and providing no entropy; when this boolean is true the <Null> source is emitted, and when false or unset it is omitted.
        :param 'DomainDevicesRngBackendEgdSourcePipeArgs' pipe: Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        :param 'DomainDevicesRngBackendEgdSourcePtyArgs' pty: Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        :param 'DomainDevicesRngBackendEgdSourceQemuvdAgentArgs' qemuvd_agent: Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        :param 'DomainDevicesRngBackendEgdSourceSpicePortArgs' spice_port: Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        :param _builtins.bool spice_vmc: Enables using a SPICE virtio serial management channel (spicevmc) as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.bool std_io: Enables using the QEMU process standard I/O stream as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesRngBackendEgdSourceTcpArgs' tcp: Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        :param 'DomainDevicesRngBackendEgdSourceUdpArgs' udp: Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        :param 'DomainDevicesRngBackendEgdSourceUnixArgs' unix: Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        :param _builtins.bool vc: Enables use of a virtual console device as the entropy source for the EGD RNG backend when set (presence-only element; omitting it disables this source).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if dbus is not None:
            pulumi.set(__self__, "dbus", dbus)
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if nmdm is not None:
            pulumi.set(__self__, "nmdm", nmdm)
        if null is not None:
            pulumi.set(__self__, "null", null)
        if pipe is not None:
            pulumi.set(__self__, "pipe", pipe)
        if pty is not None:
            pulumi.set(__self__, "pty", pty)
        if qemuvd_agent is not None:
            pulumi.set(__self__, "qemuvd_agent", qemuvd_agent)
        if spice_port is not None:
            pulumi.set(__self__, "spice_port", spice_port)
        if spice_vmc is not None:
            pulumi.set(__self__, "spice_vmc", spice_vmc)
        if std_io is not None:
            pulumi.set(__self__, "std_io", std_io)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)
        if unix is not None:
            pulumi.set(__self__, "unix", unix)
        if vc is not None:
            pulumi.set(__self__, "vc", vc)

    @_builtins.property
    @pulumi.getter
    def dbus(self) -> Optional['outputs.DomainDevicesRngBackendEgdSourceDbus']:
        """
        Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        """
        return pulumi.get(self, "dbus")

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional['outputs.DomainDevicesRngBackendEgdSourceDev']:
        """
        Configures an EGD RNG backend that reads entropy from a host character device node.
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.DomainDevicesRngBackendEgdSourceFile']:
        """
        Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def nmdm(self) -> Optional['outputs.DomainDevicesRngBackendEgdSourceNmdm']:
        """
        Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        """
        return pulumi.get(self, "nmdm")

    @_builtins.property
    @pulumi.getter
    def null(self) -> Optional[_builtins.bool]:
        """
        Enables use of a null backend for the EGD RNG source, discarding all data written and providing no entropy; when this boolean is true the <Null> source is emitted, and when false or unset it is omitted.
        """
        return pulumi.get(self, "null")

    @_builtins.property
    @pulumi.getter
    def pipe(self) -> Optional['outputs.DomainDevicesRngBackendEgdSourcePipe']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        """
        return pulumi.get(self, "pipe")

    @_builtins.property
    @pulumi.getter
    def pty(self) -> Optional['outputs.DomainDevicesRngBackendEgdSourcePty']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        """
        return pulumi.get(self, "pty")

    @_builtins.property
    @pulumi.getter(name="qemuvdAgent")
    def qemuvd_agent(self) -> Optional['outputs.DomainDevicesRngBackendEgdSourceQemuvdAgent']:
        """
        Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        """
        return pulumi.get(self, "qemuvd_agent")

    @_builtins.property
    @pulumi.getter(name="spicePort")
    def spice_port(self) -> Optional['outputs.DomainDevicesRngBackendEgdSourceSpicePort']:
        """
        Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        """
        return pulumi.get(self, "spice_port")

    @_builtins.property
    @pulumi.getter(name="spiceVmc")
    def spice_vmc(self) -> Optional[_builtins.bool]:
        """
        Enables using a SPICE virtio serial management channel (spicevmc) as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "spice_vmc")

    @_builtins.property
    @pulumi.getter(name="stdIo")
    def std_io(self) -> Optional[_builtins.bool]:
        """
        Enables using the QEMU process standard I/O stream as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "std_io")

    @_builtins.property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.DomainDevicesRngBackendEgdSourceTcp']:
        """
        Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        """
        return pulumi.get(self, "tcp")

    @_builtins.property
    @pulumi.getter
    def udp(self) -> Optional['outputs.DomainDevicesRngBackendEgdSourceUdp']:
        """
        Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        """
        return pulumi.get(self, "udp")

    @_builtins.property
    @pulumi.getter
    def unix(self) -> Optional['outputs.DomainDevicesRngBackendEgdSourceUnix']:
        """
        Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        """
        return pulumi.get(self, "unix")

    @_builtins.property
    @pulumi.getter
    def vc(self) -> Optional[_builtins.bool]:
        """
        Enables use of a virtual console device as the entropy source for the EGD RNG backend when set (presence-only element; omitting it disables this source).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "vc")


@pulumi.output_type
class DomainDevicesRngBackendEgdSourceDbus(dict):
    def __init__(__self__, *,
                 channel: Optional[_builtins.str] = None):
        """
        :param _builtins.str channel: Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.str]:
        """
        Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesRngBackendEgdSourceDev(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRngBackendEgdSourceDev. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRngBackendEgdSourceDev.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRngBackendEgdSourceDev.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesRngBackendEgdSourceDevSecLabel']] = None):
        """
        :param _builtins.str path: Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesRngBackendEgdSourceDevSecLabelArgs'] sec_labels: Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesRngBackendEgdSourceDevSecLabel']]:
        """
        Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesRngBackendEgdSourceDevSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRngBackendEgdSourceDevSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRngBackendEgdSourceDevSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRngBackendEgdSourceDevSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesRngBackendEgdSourceFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRngBackendEgdSourceFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRngBackendEgdSourceFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRngBackendEgdSourceFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 append: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesRngBackendEgdSourceFileSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str append: Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
               
               See: <https://libvirt.org/formatdomain.html#device-logfile>
        :param Sequence['DomainDevicesRngBackendEgdSourceFileSecLabelArgs'] sec_labels: Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def append(self) -> Optional[_builtins.str]:
        """
        Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.

        See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        return pulumi.get(self, "append")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesRngBackendEgdSourceFileSecLabel']]:
        """
        Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesRngBackendEgdSourceFileSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRngBackendEgdSourceFileSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRngBackendEgdSourceFileSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRngBackendEgdSourceFileSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesRngBackendEgdSourceNmdm(dict):
    def __init__(__self__, *,
                 master: _builtins.str,
                 slave: _builtins.str):
        """
        :param _builtins.str master: Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        :param _builtins.str slave: Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        pulumi.set(__self__, "master", master)
        pulumi.set(__self__, "slave", slave)

    @_builtins.property
    @pulumi.getter
    def master(self) -> _builtins.str:
        """
        Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "master")

    @_builtins.property
    @pulumi.getter
    def slave(self) -> _builtins.str:
        """
        Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "slave")


@pulumi.output_type
class DomainDevicesRngBackendEgdSourcePipe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRngBackendEgdSourcePipe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRngBackendEgdSourcePipe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRngBackendEgdSourcePipe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesRngBackendEgdSourcePipeSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesRngBackendEgdSourcePipeSecLabelArgs'] sec_labels: Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesRngBackendEgdSourcePipeSecLabel']]:
        """
        Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesRngBackendEgdSourcePipeSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRngBackendEgdSourcePipeSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRngBackendEgdSourcePipeSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRngBackendEgdSourcePipeSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesRngBackendEgdSourcePty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRngBackendEgdSourcePty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRngBackendEgdSourcePty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRngBackendEgdSourcePty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesRngBackendEgdSourcePtySecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesRngBackendEgdSourcePtySecLabelArgs'] sec_labels: Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesRngBackendEgdSourcePtySecLabel']]:
        """
        Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesRngBackendEgdSourcePtySecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRngBackendEgdSourcePtySecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRngBackendEgdSourcePtySecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRngBackendEgdSourcePtySecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesRngBackendEgdSourceQemuvdAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clipBoard":
            suggest = "clip_board"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRngBackendEgdSourceQemuvdAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRngBackendEgdSourceQemuvdAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRngBackendEgdSourceQemuvdAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clip_board: Optional['outputs.DomainDevicesRngBackendEgdSourceQemuvdAgentClipBoard'] = None,
                 mouse: Optional['outputs.DomainDevicesRngBackendEgdSourceQemuvdAgentMouse'] = None):
        """
        :param 'DomainDevicesRngBackendEgdSourceQemuvdAgentClipBoardArgs' clip_board: Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        :param 'DomainDevicesRngBackendEgdSourceQemuvdAgentMouseArgs' mouse: Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        if clip_board is not None:
            pulumi.set(__self__, "clip_board", clip_board)
        if mouse is not None:
            pulumi.set(__self__, "mouse", mouse)

    @_builtins.property
    @pulumi.getter(name="clipBoard")
    def clip_board(self) -> Optional['outputs.DomainDevicesRngBackendEgdSourceQemuvdAgentClipBoard']:
        """
        Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        """
        return pulumi.get(self, "clip_board")

    @_builtins.property
    @pulumi.getter
    def mouse(self) -> Optional['outputs.DomainDevicesRngBackendEgdSourceQemuvdAgentMouse']:
        """
        Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        return pulumi.get(self, "mouse")


@pulumi.output_type
class DomainDevicesRngBackendEgdSourceQemuvdAgentClipBoard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyPaste":
            suggest = "copy_paste"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRngBackendEgdSourceQemuvdAgentClipBoard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRngBackendEgdSourceQemuvdAgentClipBoard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRngBackendEgdSourceQemuvdAgentClipBoard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_paste: _builtins.str):
        """
        :param _builtins.str copy_paste: Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "copy_paste", copy_paste)

    @_builtins.property
    @pulumi.getter(name="copyPaste")
    def copy_paste(self) -> _builtins.str:
        """
        Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "copy_paste")


@pulumi.output_type
class DomainDevicesRngBackendEgdSourceQemuvdAgentMouse(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DomainDevicesRngBackendEgdSourceSpicePort(dict):
    def __init__(__self__, *,
                 channel: _builtins.str):
        """
        :param _builtins.str channel: Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesRngBackendEgdSourceTcp(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesRngBackendEgdSourceTcpReconnect'] = None,
                 service: Optional[_builtins.str] = None,
                 tls: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str mode: Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesRngBackendEgdSourceTcpReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param _builtins.str service: Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str tls: Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesRngBackendEgdSourceTcpReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[_builtins.str]:
        """
        Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class DomainDevicesRngBackendEgdSourceTcpReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesRngBackendEgdSourceUdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindHost":
            suggest = "bind_host"
        elif key == "bindService":
            suggest = "bind_service"
        elif key == "connectHost":
            suggest = "connect_host"
        elif key == "connectService":
            suggest = "connect_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRngBackendEgdSourceUdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRngBackendEgdSourceUdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRngBackendEgdSourceUdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bind_host: _builtins.str,
                 bind_service: _builtins.str,
                 connect_host: _builtins.str,
                 connect_service: _builtins.str):
        """
        :param _builtins.str bind_host: Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str bind_service: Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_host: Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_service: Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "bind_host", bind_host)
        pulumi.set(__self__, "bind_service", bind_service)
        pulumi.set(__self__, "connect_host", connect_host)
        pulumi.set(__self__, "connect_service", connect_service)

    @_builtins.property
    @pulumi.getter(name="bindHost")
    def bind_host(self) -> _builtins.str:
        """
        Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_host")

    @_builtins.property
    @pulumi.getter(name="bindService")
    def bind_service(self) -> _builtins.str:
        """
        Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_service")

    @_builtins.property
    @pulumi.getter(name="connectHost")
    def connect_host(self) -> _builtins.str:
        """
        Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_host")

    @_builtins.property
    @pulumi.getter(name="connectService")
    def connect_service(self) -> _builtins.str:
        """
        Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_service")


@pulumi.output_type
class DomainDevicesRngBackendEgdSourceUnix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRngBackendEgdSourceUnix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRngBackendEgdSourceUnix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRngBackendEgdSourceUnix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesRngBackendEgdSourceUnixReconnect'] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesRngBackendEgdSourceUnixSecLabel']] = None):
        """
        :param _builtins.str mode: Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str path: Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesRngBackendEgdSourceUnixReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param Sequence['DomainDevicesRngBackendEgdSourceUnixSecLabelArgs'] sec_labels: Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesRngBackendEgdSourceUnixReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesRngBackendEgdSourceUnixSecLabel']]:
        """
        Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesRngBackendEgdSourceUnixReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesRngBackendEgdSourceUnixSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRngBackendEgdSourceUnixSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRngBackendEgdSourceUnixSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRngBackendEgdSourceUnixSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesRngDriver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pagePerVq":
            suggest = "page_per_vq"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesRngDriver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesRngDriver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesRngDriver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ats: Optional[_builtins.str] = None,
                 iommu: Optional[_builtins.str] = None,
                 packed: Optional[_builtins.str] = None,
                 page_per_vq: Optional[_builtins.str] = None):
        """
        :param _builtins.str ats: Enables or disables address translation services (ATS) for the virtio RNG device when used behind an emulated IOMMU; accepts "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.str iommu: Enables or disables use of the emulated IOMMU for the virtio RNG device; accepts "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.str packed: Enables or disables the packed virtqueue layout for the virtio RNG device; accepts "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.str page_per_vq: Controls whether each virtqueue of the virtio RNG device uses a dedicated page, which can improve isolation at the cost of memory; accepts "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        if ats is not None:
            pulumi.set(__self__, "ats", ats)
        if iommu is not None:
            pulumi.set(__self__, "iommu", iommu)
        if packed is not None:
            pulumi.set(__self__, "packed", packed)
        if page_per_vq is not None:
            pulumi.set(__self__, "page_per_vq", page_per_vq)

    @_builtins.property
    @pulumi.getter
    def ats(self) -> Optional[_builtins.str]:
        """
        Enables or disables address translation services (ATS) for the virtio RNG device when used behind an emulated IOMMU; accepts "on" or "off".

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "ats")

    @_builtins.property
    @pulumi.getter
    def iommu(self) -> Optional[_builtins.str]:
        """
        Enables or disables use of the emulated IOMMU for the virtio RNG device; accepts "on" or "off".

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "iommu")

    @_builtins.property
    @pulumi.getter
    def packed(self) -> Optional[_builtins.str]:
        """
        Enables or disables the packed virtqueue layout for the virtio RNG device; accepts "on" or "off".

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "packed")

    @_builtins.property
    @pulumi.getter(name="pagePerVq")
    def page_per_vq(self) -> Optional[_builtins.str]:
        """
        Controls whether each virtqueue of the virtio RNG device uses a dedicated page, which can improve isolation at the cost of memory; accepts "on" or "off".

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "page_per_vq")


@pulumi.output_type
class DomainDevicesRngRate(dict):
    def __init__(__self__, *,
                 bytes: _builtins.float,
                 period: Optional[_builtins.float] = None):
        """
        :param _builtins.float bytes: Sets the maximum number of bytes of random data the RNG device may deliver per period; required and must be a positive integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float period: Sets the length of the rate limiting period in seconds for the RNG device; optional, user-provided nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "bytes", bytes)
        if period is not None:
            pulumi.set(__self__, "period", period)

    @_builtins.property
    @pulumi.getter
    def bytes(self) -> _builtins.float:
        """
        Sets the maximum number of bytes of random data the RNG device may deliver per period; required and must be a positive integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bytes")

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[_builtins.float]:
        """
        Sets the length of the rate limiting period in seconds for the RNG device; optional, user-provided nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "period")


@pulumi.output_type
class DomainDevicesSerial(dict):
    def __init__(__self__, *,
                 acpi: Optional['outputs.DomainDevicesSerialAcpi'] = None,
                 address: Optional['outputs.DomainDevicesSerialAddress'] = None,
                 alias: Optional['outputs.DomainDevicesSerialAlias'] = None,
                 log: Optional['outputs.DomainDevicesSerialLog'] = None,
                 protocol: Optional['outputs.DomainDevicesSerialProtocol'] = None,
                 source: Optional['outputs.DomainDevicesSerialSource'] = None,
                 target: Optional['outputs.DomainDevicesSerialTarget'] = None):
        """
        :param 'DomainDevicesSerialAcpiArgs' acpi: Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        :param 'DomainDevicesSerialAddressArgs' address: Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        :param 'DomainDevicesSerialAliasArgs' alias: Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        :param 'DomainDevicesSerialLogArgs' log: Enables logging of data sent through the channel to a host file and configures how that logging behaves.
        :param 'DomainDevicesSerialProtocolArgs' protocol: Configures the transport protocol used by the EGD backend connection.
        :param 'DomainDevicesSerialSourceArgs' source: Defines the source endpoint for the EGD backend, such as a socket path or network address, depending on the chosen protocol.
        :param 'DomainDevicesSerialTargetArgs' target: Configures the guest-visible target of the serial device, such as the port number and, where applicable, the subtype (for example, "isa-serial" port 0).
        """
        if acpi is not None:
            pulumi.set(__self__, "acpi", acpi)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if log is not None:
            pulumi.set(__self__, "log", log)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def acpi(self) -> Optional['outputs.DomainDevicesSerialAcpi']:
        """
        Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        """
        return pulumi.get(self, "acpi")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesSerialAddress']:
        """
        Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional['outputs.DomainDevicesSerialAlias']:
        """
        Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def log(self) -> Optional['outputs.DomainDevicesSerialLog']:
        """
        Enables logging of data sent through the channel to a host file and configures how that logging behaves.
        """
        return pulumi.get(self, "log")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional['outputs.DomainDevicesSerialProtocol']:
        """
        Configures the transport protocol used by the EGD backend connection.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainDevicesSerialSource']:
        """
        Defines the source endpoint for the EGD backend, such as a socket path or network address, depending on the chosen protocol.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional['outputs.DomainDevicesSerialTarget']:
        """
        Configures the guest-visible target of the serial device, such as the port number and, where applicable, the subtype (for example, "isa-serial" port 0).
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class DomainDevicesSerialAcpi(dict):
    def __init__(__self__, *,
                 index: Optional[_builtins.float] = None):
        """
        :param _builtins.float index: Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        """
        if index is not None:
            pulumi.set(__self__, "index", index)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "index")


@pulumi.output_type
class DomainDevicesSerialAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesSerialAlias(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
               
               See: <https://libvirt.org/formatdomain.html#devices>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesSerialLog(dict):
    def __init__(__self__, *,
                 file: _builtins.str,
                 append: Optional[_builtins.str] = None):
        """
        :param _builtins.str file: Sets the absolute or relative path of the host file where channel I/O is logged.
               
               See: <https://libvirt.org/formatdomain.html#device-logfile>
        :param _builtins.str append: Controls whether the channel log file is appended to (`"yes"`) or truncated (`"no"`) on start; this is a yes/no string flag.
               
               See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        pulumi.set(__self__, "file", file)
        if append is not None:
            pulumi.set(__self__, "append", append)

    @_builtins.property
    @pulumi.getter
    def file(self) -> _builtins.str:
        """
        Sets the absolute or relative path of the host file where channel I/O is logged.

        See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def append(self) -> Optional[_builtins.str]:
        """
        Controls whether the channel log file is appended to (`"yes"`) or truncated (`"no"`) on start; this is a yes/no string flag.

        See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        return pulumi.get(self, "append")


@pulumi.output_type
class DomainDevicesSerialProtocol(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: Sets the EGD transport type, such as "tcp" or "unix"; value is a user-provided string supported by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets the EGD transport type, such as "tcp" or "unix"; value is a user-provided string supported by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainDevicesSerialSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "qemuvdAgent":
            suggest = "qemuvd_agent"
        elif key == "spicePort":
            suggest = "spice_port"
        elif key == "spiceVmc":
            suggest = "spice_vmc"
        elif key == "stdIo":
            suggest = "std_io"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSerialSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSerialSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSerialSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbus: Optional['outputs.DomainDevicesSerialSourceDbus'] = None,
                 dev: Optional['outputs.DomainDevicesSerialSourceDev'] = None,
                 file: Optional['outputs.DomainDevicesSerialSourceFile'] = None,
                 nmdm: Optional['outputs.DomainDevicesSerialSourceNmdm'] = None,
                 null: Optional[_builtins.bool] = None,
                 pipe: Optional['outputs.DomainDevicesSerialSourcePipe'] = None,
                 pty: Optional['outputs.DomainDevicesSerialSourcePty'] = None,
                 qemuvd_agent: Optional['outputs.DomainDevicesSerialSourceQemuvdAgent'] = None,
                 spice_port: Optional['outputs.DomainDevicesSerialSourceSpicePort'] = None,
                 spice_vmc: Optional[_builtins.bool] = None,
                 std_io: Optional[_builtins.bool] = None,
                 tcp: Optional['outputs.DomainDevicesSerialSourceTcp'] = None,
                 udp: Optional['outputs.DomainDevicesSerialSourceUdp'] = None,
                 unix: Optional['outputs.DomainDevicesSerialSourceUnix'] = None,
                 vc: Optional[_builtins.bool] = None):
        """
        :param 'DomainDevicesSerialSourceDbusArgs' dbus: Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        :param 'DomainDevicesSerialSourceDevArgs' dev: Configures an EGD RNG backend that reads entropy from a host character device node.
        :param 'DomainDevicesSerialSourceFileArgs' file: Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        :param 'DomainDevicesSerialSourceNmdmArgs' nmdm: Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        :param _builtins.bool null: Enables use of a null backend for the EGD RNG source, discarding all data written and providing no entropy; when this boolean is true the <Null> source is emitted, and when false or unset it is omitted.
        :param 'DomainDevicesSerialSourcePipeArgs' pipe: Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        :param 'DomainDevicesSerialSourcePtyArgs' pty: Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        :param 'DomainDevicesSerialSourceQemuvdAgentArgs' qemuvd_agent: Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        :param 'DomainDevicesSerialSourceSpicePortArgs' spice_port: Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        :param _builtins.bool spice_vmc: Enables using a SPICE virtio serial management channel (spicevmc) as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.bool std_io: Enables using the QEMU process standard I/O stream as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesSerialSourceTcpArgs' tcp: Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        :param 'DomainDevicesSerialSourceUdpArgs' udp: Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        :param 'DomainDevicesSerialSourceUnixArgs' unix: Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        :param _builtins.bool vc: Enables use of a virtual console device as the entropy source for the EGD RNG backend when set (presence-only element; omitting it disables this source).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if dbus is not None:
            pulumi.set(__self__, "dbus", dbus)
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if nmdm is not None:
            pulumi.set(__self__, "nmdm", nmdm)
        if null is not None:
            pulumi.set(__self__, "null", null)
        if pipe is not None:
            pulumi.set(__self__, "pipe", pipe)
        if pty is not None:
            pulumi.set(__self__, "pty", pty)
        if qemuvd_agent is not None:
            pulumi.set(__self__, "qemuvd_agent", qemuvd_agent)
        if spice_port is not None:
            pulumi.set(__self__, "spice_port", spice_port)
        if spice_vmc is not None:
            pulumi.set(__self__, "spice_vmc", spice_vmc)
        if std_io is not None:
            pulumi.set(__self__, "std_io", std_io)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)
        if unix is not None:
            pulumi.set(__self__, "unix", unix)
        if vc is not None:
            pulumi.set(__self__, "vc", vc)

    @_builtins.property
    @pulumi.getter
    def dbus(self) -> Optional['outputs.DomainDevicesSerialSourceDbus']:
        """
        Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        """
        return pulumi.get(self, "dbus")

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional['outputs.DomainDevicesSerialSourceDev']:
        """
        Configures an EGD RNG backend that reads entropy from a host character device node.
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.DomainDevicesSerialSourceFile']:
        """
        Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def nmdm(self) -> Optional['outputs.DomainDevicesSerialSourceNmdm']:
        """
        Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        """
        return pulumi.get(self, "nmdm")

    @_builtins.property
    @pulumi.getter
    def null(self) -> Optional[_builtins.bool]:
        """
        Enables use of a null backend for the EGD RNG source, discarding all data written and providing no entropy; when this boolean is true the <Null> source is emitted, and when false or unset it is omitted.
        """
        return pulumi.get(self, "null")

    @_builtins.property
    @pulumi.getter
    def pipe(self) -> Optional['outputs.DomainDevicesSerialSourcePipe']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        """
        return pulumi.get(self, "pipe")

    @_builtins.property
    @pulumi.getter
    def pty(self) -> Optional['outputs.DomainDevicesSerialSourcePty']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        """
        return pulumi.get(self, "pty")

    @_builtins.property
    @pulumi.getter(name="qemuvdAgent")
    def qemuvd_agent(self) -> Optional['outputs.DomainDevicesSerialSourceQemuvdAgent']:
        """
        Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        """
        return pulumi.get(self, "qemuvd_agent")

    @_builtins.property
    @pulumi.getter(name="spicePort")
    def spice_port(self) -> Optional['outputs.DomainDevicesSerialSourceSpicePort']:
        """
        Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        """
        return pulumi.get(self, "spice_port")

    @_builtins.property
    @pulumi.getter(name="spiceVmc")
    def spice_vmc(self) -> Optional[_builtins.bool]:
        """
        Enables using a SPICE virtio serial management channel (spicevmc) as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "spice_vmc")

    @_builtins.property
    @pulumi.getter(name="stdIo")
    def std_io(self) -> Optional[_builtins.bool]:
        """
        Enables using the QEMU process standard I/O stream as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "std_io")

    @_builtins.property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.DomainDevicesSerialSourceTcp']:
        """
        Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        """
        return pulumi.get(self, "tcp")

    @_builtins.property
    @pulumi.getter
    def udp(self) -> Optional['outputs.DomainDevicesSerialSourceUdp']:
        """
        Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        """
        return pulumi.get(self, "udp")

    @_builtins.property
    @pulumi.getter
    def unix(self) -> Optional['outputs.DomainDevicesSerialSourceUnix']:
        """
        Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        """
        return pulumi.get(self, "unix")

    @_builtins.property
    @pulumi.getter
    def vc(self) -> Optional[_builtins.bool]:
        """
        Enables use of a virtual console device as the entropy source for the EGD RNG backend when set (presence-only element; omitting it disables this source).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "vc")


@pulumi.output_type
class DomainDevicesSerialSourceDbus(dict):
    def __init__(__self__, *,
                 channel: Optional[_builtins.str] = None):
        """
        :param _builtins.str channel: Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.str]:
        """
        Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesSerialSourceDev(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSerialSourceDev. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSerialSourceDev.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSerialSourceDev.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesSerialSourceDevSecLabel']] = None):
        """
        :param _builtins.str path: Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesSerialSourceDevSecLabelArgs'] sec_labels: Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesSerialSourceDevSecLabel']]:
        """
        Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesSerialSourceDevSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSerialSourceDevSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSerialSourceDevSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSerialSourceDevSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesSerialSourceFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSerialSourceFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSerialSourceFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSerialSourceFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 append: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesSerialSourceFileSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str append: Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
               
               See: <https://libvirt.org/formatdomain.html#device-logfile>
        :param Sequence['DomainDevicesSerialSourceFileSecLabelArgs'] sec_labels: Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def append(self) -> Optional[_builtins.str]:
        """
        Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.

        See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        return pulumi.get(self, "append")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesSerialSourceFileSecLabel']]:
        """
        Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesSerialSourceFileSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSerialSourceFileSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSerialSourceFileSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSerialSourceFileSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesSerialSourceNmdm(dict):
    def __init__(__self__, *,
                 master: _builtins.str,
                 slave: _builtins.str):
        """
        :param _builtins.str master: Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        :param _builtins.str slave: Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        pulumi.set(__self__, "master", master)
        pulumi.set(__self__, "slave", slave)

    @_builtins.property
    @pulumi.getter
    def master(self) -> _builtins.str:
        """
        Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "master")

    @_builtins.property
    @pulumi.getter
    def slave(self) -> _builtins.str:
        """
        Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "slave")


@pulumi.output_type
class DomainDevicesSerialSourcePipe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSerialSourcePipe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSerialSourcePipe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSerialSourcePipe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesSerialSourcePipeSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesSerialSourcePipeSecLabelArgs'] sec_labels: Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesSerialSourcePipeSecLabel']]:
        """
        Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesSerialSourcePipeSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSerialSourcePipeSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSerialSourcePipeSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSerialSourcePipeSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesSerialSourcePty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSerialSourcePty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSerialSourcePty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSerialSourcePty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesSerialSourcePtySecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesSerialSourcePtySecLabelArgs'] sec_labels: Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesSerialSourcePtySecLabel']]:
        """
        Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesSerialSourcePtySecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSerialSourcePtySecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSerialSourcePtySecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSerialSourcePtySecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesSerialSourceQemuvdAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clipBoard":
            suggest = "clip_board"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSerialSourceQemuvdAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSerialSourceQemuvdAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSerialSourceQemuvdAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clip_board: Optional['outputs.DomainDevicesSerialSourceQemuvdAgentClipBoard'] = None,
                 mouse: Optional['outputs.DomainDevicesSerialSourceQemuvdAgentMouse'] = None):
        """
        :param 'DomainDevicesSerialSourceQemuvdAgentClipBoardArgs' clip_board: Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        :param 'DomainDevicesSerialSourceQemuvdAgentMouseArgs' mouse: Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        if clip_board is not None:
            pulumi.set(__self__, "clip_board", clip_board)
        if mouse is not None:
            pulumi.set(__self__, "mouse", mouse)

    @_builtins.property
    @pulumi.getter(name="clipBoard")
    def clip_board(self) -> Optional['outputs.DomainDevicesSerialSourceQemuvdAgentClipBoard']:
        """
        Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        """
        return pulumi.get(self, "clip_board")

    @_builtins.property
    @pulumi.getter
    def mouse(self) -> Optional['outputs.DomainDevicesSerialSourceQemuvdAgentMouse']:
        """
        Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        return pulumi.get(self, "mouse")


@pulumi.output_type
class DomainDevicesSerialSourceQemuvdAgentClipBoard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyPaste":
            suggest = "copy_paste"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSerialSourceQemuvdAgentClipBoard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSerialSourceQemuvdAgentClipBoard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSerialSourceQemuvdAgentClipBoard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_paste: _builtins.str):
        """
        :param _builtins.str copy_paste: Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "copy_paste", copy_paste)

    @_builtins.property
    @pulumi.getter(name="copyPaste")
    def copy_paste(self) -> _builtins.str:
        """
        Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "copy_paste")


@pulumi.output_type
class DomainDevicesSerialSourceQemuvdAgentMouse(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DomainDevicesSerialSourceSpicePort(dict):
    def __init__(__self__, *,
                 channel: _builtins.str):
        """
        :param _builtins.str channel: Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesSerialSourceTcp(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesSerialSourceTcpReconnect'] = None,
                 service: Optional[_builtins.str] = None,
                 tls: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str mode: Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesSerialSourceTcpReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param _builtins.str service: Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str tls: Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesSerialSourceTcpReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[_builtins.str]:
        """
        Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class DomainDevicesSerialSourceTcpReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesSerialSourceUdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindHost":
            suggest = "bind_host"
        elif key == "bindService":
            suggest = "bind_service"
        elif key == "connectHost":
            suggest = "connect_host"
        elif key == "connectService":
            suggest = "connect_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSerialSourceUdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSerialSourceUdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSerialSourceUdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bind_host: _builtins.str,
                 bind_service: _builtins.str,
                 connect_host: _builtins.str,
                 connect_service: _builtins.str):
        """
        :param _builtins.str bind_host: Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str bind_service: Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_host: Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_service: Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "bind_host", bind_host)
        pulumi.set(__self__, "bind_service", bind_service)
        pulumi.set(__self__, "connect_host", connect_host)
        pulumi.set(__self__, "connect_service", connect_service)

    @_builtins.property
    @pulumi.getter(name="bindHost")
    def bind_host(self) -> _builtins.str:
        """
        Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_host")

    @_builtins.property
    @pulumi.getter(name="bindService")
    def bind_service(self) -> _builtins.str:
        """
        Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_service")

    @_builtins.property
    @pulumi.getter(name="connectHost")
    def connect_host(self) -> _builtins.str:
        """
        Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_host")

    @_builtins.property
    @pulumi.getter(name="connectService")
    def connect_service(self) -> _builtins.str:
        """
        Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_service")


@pulumi.output_type
class DomainDevicesSerialSourceUnix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSerialSourceUnix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSerialSourceUnix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSerialSourceUnix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesSerialSourceUnixReconnect'] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesSerialSourceUnixSecLabel']] = None):
        """
        :param _builtins.str mode: Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str path: Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesSerialSourceUnixReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param Sequence['DomainDevicesSerialSourceUnixSecLabelArgs'] sec_labels: Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesSerialSourceUnixReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesSerialSourceUnixSecLabel']]:
        """
        Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesSerialSourceUnixReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesSerialSourceUnixSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSerialSourceUnixSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSerialSourceUnixSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSerialSourceUnixSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesSerialTarget(dict):
    def __init__(__self__, *,
                 model: Optional['outputs.DomainDevicesSerialTargetModel'] = None,
                 port: Optional[_builtins.float] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param 'DomainDevicesSerialTargetModelArgs' model: Configures the hardware model of the serial port target, allowing selection of different emulated serial controller types where supported.
        :param _builtins.float port: Sets the guest-visible serial port number starting from 0; typically 03 depending on how many serial ports the guest OS supports.
               
               See: <https://libvirt.org/formatdomain.html#serial-port>
        :param _builtins.str type: Selects the type of serial controller for this target; valid values include "isa-serial", "pci-serial", "usb-serial", "spapr-vty", "sclp-serial", "sclplmconsole", and "system-serial".
               
               See: <https://libvirt.org/formatdomain.html#serial-port>
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional['outputs.DomainDevicesSerialTargetModel']:
        """
        Configures the hardware model of the serial port target, allowing selection of different emulated serial controller types where supported.
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.float]:
        """
        Sets the guest-visible serial port number starting from 0; typically 03 depending on how many serial ports the guest OS supports.

        See: <https://libvirt.org/formatdomain.html#serial-port>
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Selects the type of serial controller for this target; valid values include "isa-serial", "pci-serial", "usb-serial", "spapr-vty", "sclp-serial", "sclplmconsole", and "system-serial".

        See: <https://libvirt.org/formatdomain.html#serial-port>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainDevicesSerialTargetModel(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Sets the serial controller model name (user-provided string, e.g. "isa-serial" or "pci-serial"), as accepted by the underlying hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#serial-port>
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the serial controller model name (user-provided string, e.g. "isa-serial" or "pci-serial"), as accepted by the underlying hypervisor.

        See: <https://libvirt.org/formatdomain.html#serial-port>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesShmem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeUnit":
            suggest = "size_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesShmem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesShmem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesShmem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 acpi: Optional['outputs.DomainDevicesShmemAcpi'] = None,
                 address: Optional['outputs.DomainDevicesShmemAddress'] = None,
                 alias: Optional['outputs.DomainDevicesShmemAlias'] = None,
                 model: Optional['outputs.DomainDevicesShmemModel'] = None,
                 msi: Optional['outputs.DomainDevicesShmemMsi'] = None,
                 role: Optional[_builtins.str] = None,
                 server: Optional['outputs.DomainDevicesShmemServer'] = None,
                 size: Optional[_builtins.float] = None,
                 size_unit: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Specifies the logical name of the shared memory region; this must be unique across shmem devices and is used to match peers.
               
               See: <https://libvirt.org/formatdomain.html#shared-memory-device>
        :param 'DomainDevicesShmemAcpiArgs' acpi: Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        :param 'DomainDevicesShmemAddressArgs' address: Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        :param 'DomainDevicesShmemAliasArgs' alias: Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        :param 'DomainDevicesShmemModelArgs' model: Selects which shmem device model to use (e.g. "ivshmem-plain" or "ivshmem-doorbell") depending on the desired feature set.
        :param 'DomainDevicesShmemMsiArgs' msi: Enables and configures MSI interrupt support for the shared memory device to signal events using MSI/MSI-X.
        :param _builtins.str role: Sets the device role in the shared memory configuration, typically "guest" or "host" style roles depending on model; value is user-provided according to hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#shared-memory-device>
        :param 'DomainDevicesShmemServerArgs' server: Configures this shared memory device as a server endpoint, providing details about how the backing memory is hosted.
        :param _builtins.float size: Sets the shared memory region size; the value is user-provided and interpreted together with `size_unit` (for example, `1024` with unit `KiB`).
               
               See: <https://libvirt.org/formatdomain.html#shared-memory-device>
        :param _builtins.str size_unit: Sets the unit for the shared memory size (for example `B`, `KiB`, `MiB`, `GiB`); if omitted, libvirt applies its own default unit.
               
               See: <https://libvirt.org/formatdomain.html#shared-memory-device>
        """
        pulumi.set(__self__, "name", name)
        if acpi is not None:
            pulumi.set(__self__, "acpi", acpi)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if msi is not None:
            pulumi.set(__self__, "msi", msi)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if size_unit is not None:
            pulumi.set(__self__, "size_unit", size_unit)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the logical name of the shared memory region; this must be unique across shmem devices and is used to match peers.

        See: <https://libvirt.org/formatdomain.html#shared-memory-device>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def acpi(self) -> Optional['outputs.DomainDevicesShmemAcpi']:
        """
        Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        """
        return pulumi.get(self, "acpi")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesShmemAddress']:
        """
        Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional['outputs.DomainDevicesShmemAlias']:
        """
        Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional['outputs.DomainDevicesShmemModel']:
        """
        Selects which shmem device model to use (e.g. "ivshmem-plain" or "ivshmem-doorbell") depending on the desired feature set.
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def msi(self) -> Optional['outputs.DomainDevicesShmemMsi']:
        """
        Enables and configures MSI interrupt support for the shared memory device to signal events using MSI/MSI-X.
        """
        return pulumi.get(self, "msi")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        Sets the device role in the shared memory configuration, typically "guest" or "host" style roles depending on model; value is user-provided according to hypervisor support.

        See: <https://libvirt.org/formatdomain.html#shared-memory-device>
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter
    def server(self) -> Optional['outputs.DomainDevicesShmemServer']:
        """
        Configures this shared memory device as a server endpoint, providing details about how the backing memory is hosted.
        """
        return pulumi.get(self, "server")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.float]:
        """
        Sets the shared memory region size; the value is user-provided and interpreted together with `size_unit` (for example, `1024` with unit `KiB`).

        See: <https://libvirt.org/formatdomain.html#shared-memory-device>
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="sizeUnit")
    def size_unit(self) -> Optional[_builtins.str]:
        """
        Sets the unit for the shared memory size (for example `B`, `KiB`, `MiB`, `GiB`); if omitted, libvirt applies its own default unit.

        See: <https://libvirt.org/formatdomain.html#shared-memory-device>
        """
        return pulumi.get(self, "size_unit")


@pulumi.output_type
class DomainDevicesShmemAcpi(dict):
    def __init__(__self__, *,
                 index: Optional[_builtins.float] = None):
        """
        :param _builtins.float index: Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        """
        if index is not None:
            pulumi.set(__self__, "index", index)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "index")


@pulumi.output_type
class DomainDevicesShmemAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesShmemAlias(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
               
               See: <https://libvirt.org/formatdomain.html#devices>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesShmemModel(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: Sets the shared memory model type; valid values include "ivshmem-plain" and "ivshmem-doorbell" as supported by QEMU.
               
               See: <https://libvirt.org/formatdomain.html#shared-memory-device>
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets the shared memory model type; valid values include "ivshmem-plain" and "ivshmem-doorbell" as supported by QEMU.

        See: <https://libvirt.org/formatdomain.html#shared-memory-device>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainDevicesShmemMsi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ioEventFd":
            suggest = "io_event_fd"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesShmemMsi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesShmemMsi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesShmemMsi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.str] = None,
                 io_event_fd: Optional[_builtins.str] = None,
                 vectors: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Toggles MSI support for the shared memory device; accepts "on"/"off" (or "yes"/"no") as a string flag depending on driver support.
               
               See: <https://libvirt.org/formatdomain.html#shared-memory-device>
        :param _builtins.str io_event_fd: Enables or disables ioeventfd usage for MSI signaling; value is a string yes/no-style flag interpreted by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#shared-memory-device>
        :param _builtins.float vectors: Sets the number of MSI vectors (interrupts) allocated for this shared memory device as a positive integer.
               
               See: <https://libvirt.org/formatdomain.html#shared-memory-device>
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if io_event_fd is not None:
            pulumi.set(__self__, "io_event_fd", io_event_fd)
        if vectors is not None:
            pulumi.set(__self__, "vectors", vectors)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.str]:
        """
        Toggles MSI support for the shared memory device; accepts "on"/"off" (or "yes"/"no") as a string flag depending on driver support.

        See: <https://libvirt.org/formatdomain.html#shared-memory-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="ioEventFd")
    def io_event_fd(self) -> Optional[_builtins.str]:
        """
        Enables or disables ioeventfd usage for MSI signaling; value is a string yes/no-style flag interpreted by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#shared-memory-device>
        """
        return pulumi.get(self, "io_event_fd")

    @_builtins.property
    @pulumi.getter
    def vectors(self) -> Optional[_builtins.float]:
        """
        Sets the number of MSI vectors (interrupts) allocated for this shared memory device as a positive integer.

        See: <https://libvirt.org/formatdomain.html#shared-memory-device>
        """
        return pulumi.get(self, "vectors")


@pulumi.output_type
class DomainDevicesShmemServer(dict):
    def __init__(__self__, *,
                 path: Optional[_builtins.str] = None):
        """
        :param _builtins.str path: Sets the filesystem path used by the shmem server (for example, a memory-backend or socket path) as a user-provided string.
               
               See: <https://libvirt.org/formatdomain.html#shared-memory-device>
        """
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Sets the filesystem path used by the shmem server (for example, a memory-backend or socket path) as a user-provided string.

        See: <https://libvirt.org/formatdomain.html#shared-memory-device>
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DomainDevicesSmartcard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostCerts":
            suggest = "host_certs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSmartcard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSmartcard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSmartcard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acpi: Optional['outputs.DomainDevicesSmartcardAcpi'] = None,
                 address: Optional['outputs.DomainDevicesSmartcardAddress'] = None,
                 alias: Optional['outputs.DomainDevicesSmartcardAlias'] = None,
                 database: Optional[_builtins.str] = None,
                 host: Optional[_builtins.bool] = None,
                 host_certs: Optional[Sequence['outputs.DomainDevicesSmartcardHostCert']] = None,
                 passthrough: Optional['outputs.DomainDevicesSmartcardPassthrough'] = None,
                 protocol: Optional['outputs.DomainDevicesSmartcardProtocol'] = None):
        """
        :param 'DomainDevicesSmartcardAcpiArgs' acpi: Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        :param 'DomainDevicesSmartcardAddressArgs' address: Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        :param 'DomainDevicesSmartcardAliasArgs' alias: Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        :param _builtins.str database: Sets the NSS database directory used for the smartcards certificate store; value is a user-provided path such as `/etc/pki/nssdb`.
               
               See: <https://libvirt.org/formatdomain.html#smartcard-devices>
        :param _builtins.bool host: Enables the host-certificates smartcard mode when set (element is present), so the guest uses certificates from the hosts smartcard database.
               
               See: <https://libvirt.org/formatdomain.html#smartcard-devices>
        :param Sequence['DomainDevicesSmartcardHostCertArgs'] host_certs: Lists one or more certificate files that should be exposed to the guest when using host-certificates smartcard mode.
               
               See: <https://libvirt.org/formatdomain.html#smartcard-devices>
        :param 'DomainDevicesSmartcardPassthroughArgs' passthrough: Defines the source endpoint for the EGD backend, such as a socket path or network address, depending on the chosen protocol.
        :param 'DomainDevicesSmartcardProtocolArgs' protocol: Configures the transport protocol used by the EGD backend connection.
        """
        if acpi is not None:
            pulumi.set(__self__, "acpi", acpi)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if host_certs is not None:
            pulumi.set(__self__, "host_certs", host_certs)
        if passthrough is not None:
            pulumi.set(__self__, "passthrough", passthrough)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def acpi(self) -> Optional['outputs.DomainDevicesSmartcardAcpi']:
        """
        Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        """
        return pulumi.get(self, "acpi")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesSmartcardAddress']:
        """
        Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional['outputs.DomainDevicesSmartcardAlias']:
        """
        Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        Sets the NSS database directory used for the smartcards certificate store; value is a user-provided path such as `/etc/pki/nssdb`.

        See: <https://libvirt.org/formatdomain.html#smartcard-devices>
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.bool]:
        """
        Enables the host-certificates smartcard mode when set (element is present), so the guest uses certificates from the hosts smartcard database.

        See: <https://libvirt.org/formatdomain.html#smartcard-devices>
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter(name="hostCerts")
    def host_certs(self) -> Optional[Sequence['outputs.DomainDevicesSmartcardHostCert']]:
        """
        Lists one or more certificate files that should be exposed to the guest when using host-certificates smartcard mode.

        See: <https://libvirt.org/formatdomain.html#smartcard-devices>
        """
        return pulumi.get(self, "host_certs")

    @_builtins.property
    @pulumi.getter
    def passthrough(self) -> Optional['outputs.DomainDevicesSmartcardPassthrough']:
        """
        Defines the source endpoint for the EGD backend, such as a socket path or network address, depending on the chosen protocol.
        """
        return pulumi.get(self, "passthrough")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional['outputs.DomainDevicesSmartcardProtocol']:
        """
        Configures the transport protocol used by the EGD backend connection.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class DomainDevicesSmartcardAcpi(dict):
    def __init__(__self__, *,
                 index: Optional[_builtins.float] = None):
        """
        :param _builtins.float index: Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        """
        if index is not None:
            pulumi.set(__self__, "index", index)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "index")


@pulumi.output_type
class DomainDevicesSmartcardAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesSmartcardAlias(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
               
               See: <https://libvirt.org/formatdomain.html#devices>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesSmartcardHostCert(dict):
    def __init__(__self__, *,
                 file: _builtins.str):
        """
        :param _builtins.str file: Sets the path to a certificate file included in the host-certificates smartcard configuration; value is a user-provided filesystem path.
               
               See: <https://libvirt.org/formatdomain.html#smartcard-devices>
        """
        pulumi.set(__self__, "file", file)

    @_builtins.property
    @pulumi.getter
    def file(self) -> _builtins.str:
        """
        Sets the path to a certificate file included in the host-certificates smartcard configuration; value is a user-provided filesystem path.

        See: <https://libvirt.org/formatdomain.html#smartcard-devices>
        """
        return pulumi.get(self, "file")


@pulumi.output_type
class DomainDevicesSmartcardPassthrough(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "qemuvdAgent":
            suggest = "qemuvd_agent"
        elif key == "spicePort":
            suggest = "spice_port"
        elif key == "spiceVmc":
            suggest = "spice_vmc"
        elif key == "stdIo":
            suggest = "std_io"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSmartcardPassthrough. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSmartcardPassthrough.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSmartcardPassthrough.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbus: Optional['outputs.DomainDevicesSmartcardPassthroughDbus'] = None,
                 dev: Optional['outputs.DomainDevicesSmartcardPassthroughDev'] = None,
                 file: Optional['outputs.DomainDevicesSmartcardPassthroughFile'] = None,
                 nmdm: Optional['outputs.DomainDevicesSmartcardPassthroughNmdm'] = None,
                 null: Optional[_builtins.bool] = None,
                 pipe: Optional['outputs.DomainDevicesSmartcardPassthroughPipe'] = None,
                 pty: Optional['outputs.DomainDevicesSmartcardPassthroughPty'] = None,
                 qemuvd_agent: Optional['outputs.DomainDevicesSmartcardPassthroughQemuvdAgent'] = None,
                 spice_port: Optional['outputs.DomainDevicesSmartcardPassthroughSpicePort'] = None,
                 spice_vmc: Optional[_builtins.bool] = None,
                 std_io: Optional[_builtins.bool] = None,
                 tcp: Optional['outputs.DomainDevicesSmartcardPassthroughTcp'] = None,
                 udp: Optional['outputs.DomainDevicesSmartcardPassthroughUdp'] = None,
                 unix: Optional['outputs.DomainDevicesSmartcardPassthroughUnix'] = None,
                 vc: Optional[_builtins.bool] = None):
        """
        :param 'DomainDevicesSmartcardPassthroughDbusArgs' dbus: Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        :param 'DomainDevicesSmartcardPassthroughDevArgs' dev: Configures an EGD RNG backend that reads entropy from a host character device node.
        :param 'DomainDevicesSmartcardPassthroughFileArgs' file: Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        :param 'DomainDevicesSmartcardPassthroughNmdmArgs' nmdm: Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        :param _builtins.bool null: Enables use of a null backend for the EGD RNG source, discarding all data written and providing no entropy; when this boolean is true the <Null> source is emitted, and when false or unset it is omitted.
        :param 'DomainDevicesSmartcardPassthroughPipeArgs' pipe: Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        :param 'DomainDevicesSmartcardPassthroughPtyArgs' pty: Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        :param 'DomainDevicesSmartcardPassthroughQemuvdAgentArgs' qemuvd_agent: Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        :param 'DomainDevicesSmartcardPassthroughSpicePortArgs' spice_port: Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        :param _builtins.bool spice_vmc: Enables using a SPICE virtio serial management channel (spicevmc) as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.bool std_io: Enables using the QEMU process standard I/O stream as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesSmartcardPassthroughTcpArgs' tcp: Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        :param 'DomainDevicesSmartcardPassthroughUdpArgs' udp: Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        :param 'DomainDevicesSmartcardPassthroughUnixArgs' unix: Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        :param _builtins.bool vc: Enables use of a virtual console device as the entropy source for the EGD RNG backend when set (presence-only element; omitting it disables this source).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if dbus is not None:
            pulumi.set(__self__, "dbus", dbus)
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if nmdm is not None:
            pulumi.set(__self__, "nmdm", nmdm)
        if null is not None:
            pulumi.set(__self__, "null", null)
        if pipe is not None:
            pulumi.set(__self__, "pipe", pipe)
        if pty is not None:
            pulumi.set(__self__, "pty", pty)
        if qemuvd_agent is not None:
            pulumi.set(__self__, "qemuvd_agent", qemuvd_agent)
        if spice_port is not None:
            pulumi.set(__self__, "spice_port", spice_port)
        if spice_vmc is not None:
            pulumi.set(__self__, "spice_vmc", spice_vmc)
        if std_io is not None:
            pulumi.set(__self__, "std_io", std_io)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)
        if unix is not None:
            pulumi.set(__self__, "unix", unix)
        if vc is not None:
            pulumi.set(__self__, "vc", vc)

    @_builtins.property
    @pulumi.getter
    def dbus(self) -> Optional['outputs.DomainDevicesSmartcardPassthroughDbus']:
        """
        Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        """
        return pulumi.get(self, "dbus")

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional['outputs.DomainDevicesSmartcardPassthroughDev']:
        """
        Configures an EGD RNG backend that reads entropy from a host character device node.
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.DomainDevicesSmartcardPassthroughFile']:
        """
        Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def nmdm(self) -> Optional['outputs.DomainDevicesSmartcardPassthroughNmdm']:
        """
        Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        """
        return pulumi.get(self, "nmdm")

    @_builtins.property
    @pulumi.getter
    def null(self) -> Optional[_builtins.bool]:
        """
        Enables use of a null backend for the EGD RNG source, discarding all data written and providing no entropy; when this boolean is true the <Null> source is emitted, and when false or unset it is omitted.
        """
        return pulumi.get(self, "null")

    @_builtins.property
    @pulumi.getter
    def pipe(self) -> Optional['outputs.DomainDevicesSmartcardPassthroughPipe']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        """
        return pulumi.get(self, "pipe")

    @_builtins.property
    @pulumi.getter
    def pty(self) -> Optional['outputs.DomainDevicesSmartcardPassthroughPty']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        """
        return pulumi.get(self, "pty")

    @_builtins.property
    @pulumi.getter(name="qemuvdAgent")
    def qemuvd_agent(self) -> Optional['outputs.DomainDevicesSmartcardPassthroughQemuvdAgent']:
        """
        Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        """
        return pulumi.get(self, "qemuvd_agent")

    @_builtins.property
    @pulumi.getter(name="spicePort")
    def spice_port(self) -> Optional['outputs.DomainDevicesSmartcardPassthroughSpicePort']:
        """
        Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        """
        return pulumi.get(self, "spice_port")

    @_builtins.property
    @pulumi.getter(name="spiceVmc")
    def spice_vmc(self) -> Optional[_builtins.bool]:
        """
        Enables using a SPICE virtio serial management channel (spicevmc) as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "spice_vmc")

    @_builtins.property
    @pulumi.getter(name="stdIo")
    def std_io(self) -> Optional[_builtins.bool]:
        """
        Enables using the QEMU process standard I/O stream as the entropy source for the EGD RNG backend when set to true; when false or unset, the element is omitted.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "std_io")

    @_builtins.property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.DomainDevicesSmartcardPassthroughTcp']:
        """
        Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        """
        return pulumi.get(self, "tcp")

    @_builtins.property
    @pulumi.getter
    def udp(self) -> Optional['outputs.DomainDevicesSmartcardPassthroughUdp']:
        """
        Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        """
        return pulumi.get(self, "udp")

    @_builtins.property
    @pulumi.getter
    def unix(self) -> Optional['outputs.DomainDevicesSmartcardPassthroughUnix']:
        """
        Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        """
        return pulumi.get(self, "unix")

    @_builtins.property
    @pulumi.getter
    def vc(self) -> Optional[_builtins.bool]:
        """
        Enables use of a virtual console device as the entropy source for the EGD RNG backend when set (presence-only element; omitting it disables this source).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "vc")


@pulumi.output_type
class DomainDevicesSmartcardPassthroughDbus(dict):
    def __init__(__self__, *,
                 channel: Optional[_builtins.str] = None):
        """
        :param _builtins.str channel: Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.str]:
        """
        Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesSmartcardPassthroughDev(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSmartcardPassthroughDev. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSmartcardPassthroughDev.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSmartcardPassthroughDev.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesSmartcardPassthroughDevSecLabel']] = None):
        """
        :param _builtins.str path: Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesSmartcardPassthroughDevSecLabelArgs'] sec_labels: Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesSmartcardPassthroughDevSecLabel']]:
        """
        Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesSmartcardPassthroughDevSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSmartcardPassthroughDevSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSmartcardPassthroughDevSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSmartcardPassthroughDevSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesSmartcardPassthroughFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSmartcardPassthroughFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSmartcardPassthroughFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSmartcardPassthroughFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 append: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesSmartcardPassthroughFileSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str append: Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
               
               See: <https://libvirt.org/formatdomain.html#device-logfile>
        :param Sequence['DomainDevicesSmartcardPassthroughFileSecLabelArgs'] sec_labels: Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def append(self) -> Optional[_builtins.str]:
        """
        Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.

        See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        return pulumi.get(self, "append")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesSmartcardPassthroughFileSecLabel']]:
        """
        Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesSmartcardPassthroughFileSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSmartcardPassthroughFileSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSmartcardPassthroughFileSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSmartcardPassthroughFileSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesSmartcardPassthroughNmdm(dict):
    def __init__(__self__, *,
                 master: _builtins.str,
                 slave: _builtins.str):
        """
        :param _builtins.str master: Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        :param _builtins.str slave: Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        pulumi.set(__self__, "master", master)
        pulumi.set(__self__, "slave", slave)

    @_builtins.property
    @pulumi.getter
    def master(self) -> _builtins.str:
        """
        Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "master")

    @_builtins.property
    @pulumi.getter
    def slave(self) -> _builtins.str:
        """
        Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "slave")


@pulumi.output_type
class DomainDevicesSmartcardPassthroughPipe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSmartcardPassthroughPipe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSmartcardPassthroughPipe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSmartcardPassthroughPipe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesSmartcardPassthroughPipeSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesSmartcardPassthroughPipeSecLabelArgs'] sec_labels: Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesSmartcardPassthroughPipeSecLabel']]:
        """
        Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesSmartcardPassthroughPipeSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSmartcardPassthroughPipeSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSmartcardPassthroughPipeSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSmartcardPassthroughPipeSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesSmartcardPassthroughPty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSmartcardPassthroughPty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSmartcardPassthroughPty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSmartcardPassthroughPty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesSmartcardPassthroughPtySecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesSmartcardPassthroughPtySecLabelArgs'] sec_labels: Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesSmartcardPassthroughPtySecLabel']]:
        """
        Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesSmartcardPassthroughPtySecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSmartcardPassthroughPtySecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSmartcardPassthroughPtySecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSmartcardPassthroughPtySecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesSmartcardPassthroughQemuvdAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clipBoard":
            suggest = "clip_board"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSmartcardPassthroughQemuvdAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSmartcardPassthroughQemuvdAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSmartcardPassthroughQemuvdAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clip_board: Optional['outputs.DomainDevicesSmartcardPassthroughQemuvdAgentClipBoard'] = None,
                 mouse: Optional['outputs.DomainDevicesSmartcardPassthroughQemuvdAgentMouse'] = None):
        """
        :param 'DomainDevicesSmartcardPassthroughQemuvdAgentClipBoardArgs' clip_board: Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        :param 'DomainDevicesSmartcardPassthroughQemuvdAgentMouseArgs' mouse: Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        if clip_board is not None:
            pulumi.set(__self__, "clip_board", clip_board)
        if mouse is not None:
            pulumi.set(__self__, "mouse", mouse)

    @_builtins.property
    @pulumi.getter(name="clipBoard")
    def clip_board(self) -> Optional['outputs.DomainDevicesSmartcardPassthroughQemuvdAgentClipBoard']:
        """
        Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        """
        return pulumi.get(self, "clip_board")

    @_builtins.property
    @pulumi.getter
    def mouse(self) -> Optional['outputs.DomainDevicesSmartcardPassthroughQemuvdAgentMouse']:
        """
        Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        return pulumi.get(self, "mouse")


@pulumi.output_type
class DomainDevicesSmartcardPassthroughQemuvdAgentClipBoard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyPaste":
            suggest = "copy_paste"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSmartcardPassthroughQemuvdAgentClipBoard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSmartcardPassthroughQemuvdAgentClipBoard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSmartcardPassthroughQemuvdAgentClipBoard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_paste: _builtins.str):
        """
        :param _builtins.str copy_paste: Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "copy_paste", copy_paste)

    @_builtins.property
    @pulumi.getter(name="copyPaste")
    def copy_paste(self) -> _builtins.str:
        """
        Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "copy_paste")


@pulumi.output_type
class DomainDevicesSmartcardPassthroughQemuvdAgentMouse(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DomainDevicesSmartcardPassthroughSpicePort(dict):
    def __init__(__self__, *,
                 channel: _builtins.str):
        """
        :param _builtins.str channel: Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesSmartcardPassthroughTcp(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesSmartcardPassthroughTcpReconnect'] = None,
                 service: Optional[_builtins.str] = None,
                 tls: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str mode: Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesSmartcardPassthroughTcpReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param _builtins.str service: Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str tls: Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesSmartcardPassthroughTcpReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[_builtins.str]:
        """
        Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class DomainDevicesSmartcardPassthroughTcpReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesSmartcardPassthroughUdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindHost":
            suggest = "bind_host"
        elif key == "bindService":
            suggest = "bind_service"
        elif key == "connectHost":
            suggest = "connect_host"
        elif key == "connectService":
            suggest = "connect_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSmartcardPassthroughUdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSmartcardPassthroughUdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSmartcardPassthroughUdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bind_host: _builtins.str,
                 bind_service: _builtins.str,
                 connect_host: _builtins.str,
                 connect_service: _builtins.str):
        """
        :param _builtins.str bind_host: Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str bind_service: Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_host: Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_service: Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "bind_host", bind_host)
        pulumi.set(__self__, "bind_service", bind_service)
        pulumi.set(__self__, "connect_host", connect_host)
        pulumi.set(__self__, "connect_service", connect_service)

    @_builtins.property
    @pulumi.getter(name="bindHost")
    def bind_host(self) -> _builtins.str:
        """
        Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_host")

    @_builtins.property
    @pulumi.getter(name="bindService")
    def bind_service(self) -> _builtins.str:
        """
        Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_service")

    @_builtins.property
    @pulumi.getter(name="connectHost")
    def connect_host(self) -> _builtins.str:
        """
        Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_host")

    @_builtins.property
    @pulumi.getter(name="connectService")
    def connect_service(self) -> _builtins.str:
        """
        Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_service")


@pulumi.output_type
class DomainDevicesSmartcardPassthroughUnix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSmartcardPassthroughUnix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSmartcardPassthroughUnix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSmartcardPassthroughUnix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesSmartcardPassthroughUnixReconnect'] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesSmartcardPassthroughUnixSecLabel']] = None):
        """
        :param _builtins.str mode: Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str path: Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesSmartcardPassthroughUnixReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param Sequence['DomainDevicesSmartcardPassthroughUnixSecLabelArgs'] sec_labels: Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesSmartcardPassthroughUnixReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesSmartcardPassthroughUnixSecLabel']]:
        """
        Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesSmartcardPassthroughUnixReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesSmartcardPassthroughUnixSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSmartcardPassthroughUnixSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSmartcardPassthroughUnixSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSmartcardPassthroughUnixSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesSmartcardProtocol(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: Sets the EGD transport type, such as "tcp" or "unix"; value is a user-provided string supported by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets the EGD transport type, such as "tcp" or "unix"; value is a user-provided string supported by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainDevicesSound(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "multiChannel":
            suggest = "multi_channel"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSound. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSound.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSound.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 model: _builtins.str,
                 acpi: Optional['outputs.DomainDevicesSoundAcpi'] = None,
                 address: Optional['outputs.DomainDevicesSoundAddress'] = None,
                 alias: Optional['outputs.DomainDevicesSoundAlias'] = None,
                 audio: Optional['outputs.DomainDevicesSoundAudio'] = None,
                 codecs: Optional[Sequence['outputs.DomainDevicesSoundCodec']] = None,
                 driver: Optional['outputs.DomainDevicesSoundDriver'] = None,
                 multi_channel: Optional[_builtins.str] = None,
                 streams: Optional[_builtins.float] = None):
        """
        :param _builtins.str model: Sets the emulated sound card model presented to the guest; valid values include "ac97", "es1370", "sb16", "ich6", "ich7", "ich9", "pcspk", and "virtio".
               
               See: <https://libvirt.org/formatdomain.html#sound-devices>
        :param 'DomainDevicesSoundAcpiArgs' acpi: Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        :param 'DomainDevicesSoundAddressArgs' address: Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        :param 'DomainDevicesSoundAliasArgs' alias: Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        :param 'DomainDevicesSoundAudioArgs' audio: Associates the sound device with a specific host audio backend instance (by ID) when multiple audio backends are defined.
        :param Sequence['DomainDevicesSoundCodecArgs'] codecs: Configures the audio codec parameters for the sound device; contents and allowed values depend on the selected model and hypervisor support.
        :param 'DomainDevicesSoundDriverArgs' driver: Configures virtio transportrelated driver options for virtio-based sound devices.
        :param _builtins.str multi_channel: Sets whether the emulated sound device exposes multichannel audio support; accepts a boolean-like value (for example, "on"/"off" or "yes"/"no") as supported by the chosen sound model and hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#sound-devices>
        :param _builtins.float streams: Sets the maximum number of simultaneous audio streams the sound device can handle; value is user-provided and must be a non-negative integer supported by the selected sound model.
               
               See: <https://libvirt.org/formatdomain.html#sound-devices>
        """
        pulumi.set(__self__, "model", model)
        if acpi is not None:
            pulumi.set(__self__, "acpi", acpi)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if audio is not None:
            pulumi.set(__self__, "audio", audio)
        if codecs is not None:
            pulumi.set(__self__, "codecs", codecs)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if multi_channel is not None:
            pulumi.set(__self__, "multi_channel", multi_channel)
        if streams is not None:
            pulumi.set(__self__, "streams", streams)

    @_builtins.property
    @pulumi.getter
    def model(self) -> _builtins.str:
        """
        Sets the emulated sound card model presented to the guest; valid values include "ac97", "es1370", "sb16", "ich6", "ich7", "ich9", "pcspk", and "virtio".

        See: <https://libvirt.org/formatdomain.html#sound-devices>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def acpi(self) -> Optional['outputs.DomainDevicesSoundAcpi']:
        """
        Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        """
        return pulumi.get(self, "acpi")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesSoundAddress']:
        """
        Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional['outputs.DomainDevicesSoundAlias']:
        """
        Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def audio(self) -> Optional['outputs.DomainDevicesSoundAudio']:
        """
        Associates the sound device with a specific host audio backend instance (by ID) when multiple audio backends are defined.
        """
        return pulumi.get(self, "audio")

    @_builtins.property
    @pulumi.getter
    def codecs(self) -> Optional[Sequence['outputs.DomainDevicesSoundCodec']]:
        """
        Configures the audio codec parameters for the sound device; contents and allowed values depend on the selected model and hypervisor support.
        """
        return pulumi.get(self, "codecs")

    @_builtins.property
    @pulumi.getter
    def driver(self) -> Optional['outputs.DomainDevicesSoundDriver']:
        """
        Configures virtio transportrelated driver options for virtio-based sound devices.
        """
        return pulumi.get(self, "driver")

    @_builtins.property
    @pulumi.getter(name="multiChannel")
    def multi_channel(self) -> Optional[_builtins.str]:
        """
        Sets whether the emulated sound device exposes multichannel audio support; accepts a boolean-like value (for example, "on"/"off" or "yes"/"no") as supported by the chosen sound model and hypervisor.

        See: <https://libvirt.org/formatdomain.html#sound-devices>
        """
        return pulumi.get(self, "multi_channel")

    @_builtins.property
    @pulumi.getter
    def streams(self) -> Optional[_builtins.float]:
        """
        Sets the maximum number of simultaneous audio streams the sound device can handle; value is user-provided and must be a non-negative integer supported by the selected sound model.

        See: <https://libvirt.org/formatdomain.html#sound-devices>
        """
        return pulumi.get(self, "streams")


@pulumi.output_type
class DomainDevicesSoundAcpi(dict):
    def __init__(__self__, *,
                 index: Optional[_builtins.float] = None):
        """
        :param _builtins.float index: Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        """
        if index is not None:
            pulumi.set(__self__, "index", index)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "index")


@pulumi.output_type
class DomainDevicesSoundAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesSoundAlias(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
               
               See: <https://libvirt.org/formatdomain.html#devices>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesSoundAudio(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.float] = None):
        """
        :param _builtins.float id: Exposes the numeric ID of the audio backend instance bound to this sound device; this is computed from the audio backend configuration and not set by the user.
               
               See: <https://libvirt.org/formatdomain.html#audio-backends>
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.float]:
        """
        Exposes the numeric ID of the audio backend instance bound to this sound device; this is computed from the audio backend configuration and not set by the user.

        See: <https://libvirt.org/formatdomain.html#audio-backends>
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class DomainDevicesSoundCodec(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: Sets the audio codec type used by the sound device (for example, a specific codec profile or format string supported by the chosen sound model).
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets the audio codec type used by the sound device (for example, a specific codec profile or format string supported by the chosen sound model).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainDevicesSoundDriver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pagePerVq":
            suggest = "page_per_vq"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesSoundDriver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesSoundDriver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesSoundDriver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ats: Optional[_builtins.str] = None,
                 iommu: Optional[_builtins.str] = None,
                 packed: Optional[_builtins.str] = None,
                 page_per_vq: Optional[_builtins.str] = None):
        """
        :param _builtins.str ats: Enables or disables Address Translation Service (ATS) support for a virtio-based sound device; value is typically "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.str iommu: Enables or disables use of the emulated IOMMU for the virtio-based sound device; value is typically "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.str packed: Enables or disables packed virtqueue format for a virtio-based sound device to potentially improve performance; value is typically "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.str page_per_vq: Enables or disables allocation of a separate page per virtqueue for the virtio-based sound device; value is typically "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        if ats is not None:
            pulumi.set(__self__, "ats", ats)
        if iommu is not None:
            pulumi.set(__self__, "iommu", iommu)
        if packed is not None:
            pulumi.set(__self__, "packed", packed)
        if page_per_vq is not None:
            pulumi.set(__self__, "page_per_vq", page_per_vq)

    @_builtins.property
    @pulumi.getter
    def ats(self) -> Optional[_builtins.str]:
        """
        Enables or disables Address Translation Service (ATS) support for a virtio-based sound device; value is typically "on" or "off".

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "ats")

    @_builtins.property
    @pulumi.getter
    def iommu(self) -> Optional[_builtins.str]:
        """
        Enables or disables use of the emulated IOMMU for the virtio-based sound device; value is typically "on" or "off".

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "iommu")

    @_builtins.property
    @pulumi.getter
    def packed(self) -> Optional[_builtins.str]:
        """
        Enables or disables packed virtqueue format for a virtio-based sound device to potentially improve performance; value is typically "on" or "off".

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "packed")

    @_builtins.property
    @pulumi.getter(name="pagePerVq")
    def page_per_vq(self) -> Optional[_builtins.str]:
        """
        Enables or disables allocation of a separate page per virtqueue for the virtio-based sound device; value is typically "on" or "off".

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "page_per_vq")


@pulumi.output_type
class DomainDevicesTpm(dict):
    def __init__(__self__, *,
                 acpi: Optional['outputs.DomainDevicesTpmAcpi'] = None,
                 address: Optional['outputs.DomainDevicesTpmAddress'] = None,
                 alias: Optional['outputs.DomainDevicesTpmAlias'] = None,
                 backend: Optional['outputs.DomainDevicesTpmBackend'] = None,
                 model: Optional[_builtins.str] = None):
        """
        :param 'DomainDevicesTpmAcpiArgs' acpi: Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        :param 'DomainDevicesTpmAddressArgs' address: Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        :param 'DomainDevicesTpmAliasArgs' alias: Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        :param 'DomainDevicesTpmBackendArgs' backend: Selects and configures the TPM backend type used by the guest (for example, emulator vs passthrough) and its backend-specific options.
        :param _builtins.str model: Sets the TPM device model exposed to the guest, such as `tpm-tis`, `tpm-crb`, or `tpm-spapr`; the exact allowed values depend on the guest architecture and QEMU support.
               
               See: <https://libvirt.org/formatdomain.html#tpm-device>
        """
        if acpi is not None:
            pulumi.set(__self__, "acpi", acpi)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if backend is not None:
            pulumi.set(__self__, "backend", backend)
        if model is not None:
            pulumi.set(__self__, "model", model)

    @_builtins.property
    @pulumi.getter
    def acpi(self) -> Optional['outputs.DomainDevicesTpmAcpi']:
        """
        Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        """
        return pulumi.get(self, "acpi")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesTpmAddress']:
        """
        Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional['outputs.DomainDevicesTpmAlias']:
        """
        Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def backend(self) -> Optional['outputs.DomainDevicesTpmBackend']:
        """
        Selects and configures the TPM backend type used by the guest (for example, emulator vs passthrough) and its backend-specific options.
        """
        return pulumi.get(self, "backend")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Sets the TPM device model exposed to the guest, such as `tpm-tis`, `tpm-crb`, or `tpm-spapr`; the exact allowed values depend on the guest architecture and QEMU support.

        See: <https://libvirt.org/formatdomain.html#tpm-device>
        """
        return pulumi.get(self, "model")


@pulumi.output_type
class DomainDevicesTpmAcpi(dict):
    def __init__(__self__, *,
                 index: Optional[_builtins.float] = None):
        """
        :param _builtins.float index: Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        """
        if index is not None:
            pulumi.set(__self__, "index", index)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "index")


@pulumi.output_type
class DomainDevicesTpmAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesTpmAlias(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
               
               See: <https://libvirt.org/formatdomain.html#devices>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesTpmBackend(dict):
    def __init__(__self__, *,
                 emulator: Optional['outputs.DomainDevicesTpmBackendEmulator'] = None,
                 external: Optional['outputs.DomainDevicesTpmBackendExternal'] = None,
                 passthrough: Optional['outputs.DomainDevicesTpmBackendPassthrough'] = None):
        """
        :param 'DomainDevicesTpmBackendEmulatorArgs' emulator: Configures a software-emulated TPM backend (such as swtpm), including its PCR banks, persistence, encryption, and debug behavior.
        :param 'DomainDevicesTpmBackendExternalArgs' external: Selects an external TPM backend, where libvirt connects the guest to an already running TPM service rather than spawning an emulator.
        :param 'DomainDevicesTpmBackendPassthroughArgs' passthrough: Configures a TPM backend of type `passthrough`, which exposes a host TPM device directly to the guest instead of using an emulator.
        """
        if emulator is not None:
            pulumi.set(__self__, "emulator", emulator)
        if external is not None:
            pulumi.set(__self__, "external", external)
        if passthrough is not None:
            pulumi.set(__self__, "passthrough", passthrough)

    @_builtins.property
    @pulumi.getter
    def emulator(self) -> Optional['outputs.DomainDevicesTpmBackendEmulator']:
        """
        Configures a software-emulated TPM backend (such as swtpm), including its PCR banks, persistence, encryption, and debug behavior.
        """
        return pulumi.get(self, "emulator")

    @_builtins.property
    @pulumi.getter
    def external(self) -> Optional['outputs.DomainDevicesTpmBackendExternal']:
        """
        Selects an external TPM backend, where libvirt connects the guest to an already running TPM service rather than spawning an emulator.
        """
        return pulumi.get(self, "external")

    @_builtins.property
    @pulumi.getter
    def passthrough(self) -> Optional['outputs.DomainDevicesTpmBackendPassthrough']:
        """
        Configures a TPM backend of type `passthrough`, which exposes a host TPM device directly to the guest instead of using an emulator.
        """
        return pulumi.get(self, "passthrough")


@pulumi.output_type
class DomainDevicesTpmBackendEmulator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activePcrBanks":
            suggest = "active_pcr_banks"
        elif key == "persistentState":
            suggest = "persistent_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesTpmBackendEmulator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesTpmBackendEmulator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesTpmBackendEmulator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_pcr_banks: Optional['outputs.DomainDevicesTpmBackendEmulatorActivePcrBanks'] = None,
                 debug: Optional[_builtins.float] = None,
                 encryption: Optional['outputs.DomainDevicesTpmBackendEmulatorEncryption'] = None,
                 persistent_state: Optional[_builtins.str] = None,
                 profile: Optional['outputs.DomainDevicesTpmBackendEmulatorProfile'] = None,
                 source: Optional['outputs.DomainDevicesTpmBackendEmulatorSource'] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param 'DomainDevicesTpmBackendEmulatorActivePcrBanksArgs' active_pcr_banks: Defines which PCR banks are active in the emulated TPM backend by enabling specific hash algorithms as child elements.
        :param _builtins.float debug: Enables or configures debug output for the emulated TPM backend; accepts a backend-specific value such as a boolean-like flag or debug level.
               
               See: <https://libvirt.org/formatdomain.html#tpm-device>
        :param 'DomainDevicesTpmBackendEmulatorEncryptionArgs' encryption: Enables encrypted state storage for the emulated TPM and points to the secret that protects the TPM state at rest.
        :param _builtins.str persistent_state: Controls whether the emulated TPM keeps its state persistently across guest reboots; accepts a boolean-like value (for example, "yes"/"no").
               
               See: <https://libvirt.org/formatdomain.html#tpm-device>
        :param 'DomainDevicesTpmBackendEmulatorProfileArgs' profile: Selects the TPM profile or version used by the emulator (for example, "1.2" or "2.0"), with allowed values depending on the emulator implementation.
        :param 'DomainDevicesTpmBackendEmulatorSourceArgs' source: Configures the source location for the TPM emulator state, using either a directory or file sub-block.
        :param _builtins.str version: Sets the TPM version that the emulator exposes to the guest; valid values are "1.2" or "2.0".
               
               See: <https://libvirt.org/formatdomain.html#tpm-device>
        """
        if active_pcr_banks is not None:
            pulumi.set(__self__, "active_pcr_banks", active_pcr_banks)
        if debug is not None:
            pulumi.set(__self__, "debug", debug)
        if encryption is not None:
            pulumi.set(__self__, "encryption", encryption)
        if persistent_state is not None:
            pulumi.set(__self__, "persistent_state", persistent_state)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="activePcrBanks")
    def active_pcr_banks(self) -> Optional['outputs.DomainDevicesTpmBackendEmulatorActivePcrBanks']:
        """
        Defines which PCR banks are active in the emulated TPM backend by enabling specific hash algorithms as child elements.
        """
        return pulumi.get(self, "active_pcr_banks")

    @_builtins.property
    @pulumi.getter
    def debug(self) -> Optional[_builtins.float]:
        """
        Enables or configures debug output for the emulated TPM backend; accepts a backend-specific value such as a boolean-like flag or debug level.

        See: <https://libvirt.org/formatdomain.html#tpm-device>
        """
        return pulumi.get(self, "debug")

    @_builtins.property
    @pulumi.getter
    def encryption(self) -> Optional['outputs.DomainDevicesTpmBackendEmulatorEncryption']:
        """
        Enables encrypted state storage for the emulated TPM and points to the secret that protects the TPM state at rest.
        """
        return pulumi.get(self, "encryption")

    @_builtins.property
    @pulumi.getter(name="persistentState")
    def persistent_state(self) -> Optional[_builtins.str]:
        """
        Controls whether the emulated TPM keeps its state persistently across guest reboots; accepts a boolean-like value (for example, "yes"/"no").

        See: <https://libvirt.org/formatdomain.html#tpm-device>
        """
        return pulumi.get(self, "persistent_state")

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional['outputs.DomainDevicesTpmBackendEmulatorProfile']:
        """
        Selects the TPM profile or version used by the emulator (for example, "1.2" or "2.0"), with allowed values depending on the emulator implementation.
        """
        return pulumi.get(self, "profile")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainDevicesTpmBackendEmulatorSource']:
        """
        Configures the source location for the TPM emulator state, using either a directory or file sub-block.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Sets the TPM version that the emulator exposes to the guest; valid values are "1.2" or "2.0".

        See: <https://libvirt.org/formatdomain.html#tpm-device>
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DomainDevicesTpmBackendEmulatorActivePcrBanks(dict):
    def __init__(__self__, *,
                 sha1: Optional[_builtins.bool] = None,
                 sha256: Optional[_builtins.bool] = None,
                 sha384: Optional[_builtins.bool] = None,
                 sha512: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool sha1: Presence-only flag that enables a SHA1 PCR bank in the emulated TPM when set to true; omitting or setting false leaves it disabled.
               
               See: <https://libvirt.org/formatdomain.html#tpm-device>
        :param _builtins.bool sha256: Presence-only flag that enables a SHA256 PCR bank in the emulated TPM when set to true; omitting or setting false leaves it disabled.
               
               See: <https://libvirt.org/formatdomain.html#tpm-device>
        :param _builtins.bool sha384: Presence-only flag that enables a SHA384 PCR bank in the emulated TPM when set to true; omitting or setting false leaves it disabled.
               
               See: <https://libvirt.org/formatdomain.html#tpm-device>
        :param _builtins.bool sha512: Presence-only flag that enables a SHA512 PCR bank in the emulated TPM when set to true; omitting or setting false leaves it disabled.
               
               See: <https://libvirt.org/formatdomain.html#tpm-device>
        """
        if sha1 is not None:
            pulumi.set(__self__, "sha1", sha1)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)
        if sha384 is not None:
            pulumi.set(__self__, "sha384", sha384)
        if sha512 is not None:
            pulumi.set(__self__, "sha512", sha512)

    @_builtins.property
    @pulumi.getter
    def sha1(self) -> Optional[_builtins.bool]:
        """
        Presence-only flag that enables a SHA1 PCR bank in the emulated TPM when set to true; omitting or setting false leaves it disabled.

        See: <https://libvirt.org/formatdomain.html#tpm-device>
        """
        return pulumi.get(self, "sha1")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[_builtins.bool]:
        """
        Presence-only flag that enables a SHA256 PCR bank in the emulated TPM when set to true; omitting or setting false leaves it disabled.

        See: <https://libvirt.org/formatdomain.html#tpm-device>
        """
        return pulumi.get(self, "sha256")

    @_builtins.property
    @pulumi.getter
    def sha384(self) -> Optional[_builtins.bool]:
        """
        Presence-only flag that enables a SHA384 PCR bank in the emulated TPM when set to true; omitting or setting false leaves it disabled.

        See: <https://libvirt.org/formatdomain.html#tpm-device>
        """
        return pulumi.get(self, "sha384")

    @_builtins.property
    @pulumi.getter
    def sha512(self) -> Optional[_builtins.bool]:
        """
        Presence-only flag that enables a SHA512 PCR bank in the emulated TPM when set to true; omitting or setting false leaves it disabled.

        See: <https://libvirt.org/formatdomain.html#tpm-device>
        """
        return pulumi.get(self, "sha512")


@pulumi.output_type
class DomainDevicesTpmBackendEmulatorEncryption(dict):
    def __init__(__self__, *,
                 secret: _builtins.str):
        """
        :param _builtins.str secret: Specifies the identifier of the libvirt secret used to encrypt the emulated TPMs persistent state; value is user-provided and must match a defined secret.
               
               See: <https://libvirt.org/formatdomain.html#tpm-device>
        """
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        Specifies the identifier of the libvirt secret used to encrypt the emulated TPMs persistent state; value is user-provided and must match a defined secret.

        See: <https://libvirt.org/formatdomain.html#tpm-device>
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class DomainDevicesTpmBackendEmulatorProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "removeDisabled":
            suggest = "remove_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesTpmBackendEmulatorProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesTpmBackendEmulatorProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesTpmBackendEmulatorProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 remove_disabled: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Sets the name of the swtpm emulator profile to apply, selecting a specific preconfigured TPM profile; the value is user-provided (for example, "qemu").
               
               See: <https://libvirt.org/formatdomain.html#tpm-device>
        :param _builtins.str remove_disabled: Sets whether disabled PCR banks are removed from the TPM profile presented to the guest; accepts "yes" or "no".
               
               See: <https://libvirt.org/formatdomain.html#tpm-device>
        :param _builtins.str source: Sets an optional identifier of the profile source for the TPM emulator profile (for example, a configuration database or profile namespace); the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#tpm-device>
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if remove_disabled is not None:
            pulumi.set(__self__, "remove_disabled", remove_disabled)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the name of the swtpm emulator profile to apply, selecting a specific preconfigured TPM profile; the value is user-provided (for example, "qemu").

        See: <https://libvirt.org/formatdomain.html#tpm-device>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="removeDisabled")
    def remove_disabled(self) -> Optional[_builtins.str]:
        """
        Sets whether disabled PCR banks are removed from the TPM profile presented to the guest; accepts "yes" or "no".

        See: <https://libvirt.org/formatdomain.html#tpm-device>
        """
        return pulumi.get(self, "remove_disabled")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        Sets an optional identifier of the profile source for the TPM emulator profile (for example, a configuration database or profile namespace); the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#tpm-device>
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class DomainDevicesTpmBackendEmulatorSource(dict):
    def __init__(__self__, *,
                 dir: Optional['outputs.DomainDevicesTpmBackendEmulatorSourceDir'] = None,
                 file: Optional['outputs.DomainDevicesTpmBackendEmulatorSourceFile'] = None):
        """
        :param 'DomainDevicesTpmBackendEmulatorSourceDirArgs' dir: Selects a directory-based backend for TPM emulator state and metadata storage.
        :param 'DomainDevicesTpmBackendEmulatorSourceFileArgs' file: Selects a file-based backend for TPM emulator state, pointing directly at a state file.
        """
        if dir is not None:
            pulumi.set(__self__, "dir", dir)
        if file is not None:
            pulumi.set(__self__, "file", file)

    @_builtins.property
    @pulumi.getter
    def dir(self) -> Optional['outputs.DomainDevicesTpmBackendEmulatorSourceDir']:
        """
        Selects a directory-based backend for TPM emulator state and metadata storage.
        """
        return pulumi.get(self, "dir")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.DomainDevicesTpmBackendEmulatorSourceFile']:
        """
        Selects a file-based backend for TPM emulator state, pointing directly at a state file.
        """
        return pulumi.get(self, "file")


@pulumi.output_type
class DomainDevicesTpmBackendEmulatorSourceDir(dict):
    def __init__(__self__, *,
                 path: Optional[_builtins.str] = None):
        """
        :param _builtins.str path: Sets the host directory path used by the TPM emulator to store its state; the value is a host filesystem path (for example, "/var/lib/swtpm/localstate").
               
               See: <https://libvirt.org/formatdomain.html#tpm-device>
        """
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Sets the host directory path used by the TPM emulator to store its state; the value is a host filesystem path (for example, "/var/lib/swtpm/localstate").

        See: <https://libvirt.org/formatdomain.html#tpm-device>
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DomainDevicesTpmBackendEmulatorSourceFile(dict):
    def __init__(__self__, *,
                 path: Optional[_builtins.str] = None):
        """
        :param _builtins.str path: Sets the host file path used by the TPM emulator to persist its state; the value is a host filesystem path (for example, "/var/lib/swtpm/state.tpm").
               
               See: <https://libvirt.org/formatdomain.html#tpm-device>
        """
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Sets the host file path used by the TPM emulator to persist its state; the value is a host filesystem path (for example, "/var/lib/swtpm/state.tpm").

        See: <https://libvirt.org/formatdomain.html#tpm-device>
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DomainDevicesTpmBackendExternal(dict):
    def __init__(__self__, *,
                 source: Optional['outputs.DomainDevicesTpmBackendExternalSource'] = None):
        """
        :param 'DomainDevicesTpmBackendExternalSourceArgs' source: Configures how the external TPM backend is reached, via either a D-Bus service or a character device.
        """
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainDevicesTpmBackendExternalSource']:
        """
        Configures how the external TPM backend is reached, via either a D-Bus service or a character device.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class DomainDevicesTpmBackendExternalSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "qemuvdAgent":
            suggest = "qemuvd_agent"
        elif key == "spicePort":
            suggest = "spice_port"
        elif key == "spiceVmc":
            suggest = "spice_vmc"
        elif key == "stdIo":
            suggest = "std_io"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesTpmBackendExternalSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesTpmBackendExternalSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesTpmBackendExternalSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbus: Optional['outputs.DomainDevicesTpmBackendExternalSourceDbus'] = None,
                 dev: Optional['outputs.DomainDevicesTpmBackendExternalSourceDev'] = None,
                 file: Optional['outputs.DomainDevicesTpmBackendExternalSourceFile'] = None,
                 nmdm: Optional['outputs.DomainDevicesTpmBackendExternalSourceNmdm'] = None,
                 null: Optional[_builtins.bool] = None,
                 pipe: Optional['outputs.DomainDevicesTpmBackendExternalSourcePipe'] = None,
                 pty: Optional['outputs.DomainDevicesTpmBackendExternalSourcePty'] = None,
                 qemuvd_agent: Optional['outputs.DomainDevicesTpmBackendExternalSourceQemuvdAgent'] = None,
                 spice_port: Optional['outputs.DomainDevicesTpmBackendExternalSourceSpicePort'] = None,
                 spice_vmc: Optional[_builtins.bool] = None,
                 std_io: Optional[_builtins.bool] = None,
                 tcp: Optional['outputs.DomainDevicesTpmBackendExternalSourceTcp'] = None,
                 udp: Optional['outputs.DomainDevicesTpmBackendExternalSourceUdp'] = None,
                 unix: Optional['outputs.DomainDevicesTpmBackendExternalSourceUnix'] = None,
                 vc: Optional[_builtins.bool] = None):
        """
        :param 'DomainDevicesTpmBackendExternalSourceDbusArgs' dbus: Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        :param 'DomainDevicesTpmBackendExternalSourceDevArgs' dev: Configures an EGD RNG backend that reads entropy from a host character device node.
        :param 'DomainDevicesTpmBackendExternalSourceFileArgs' file: Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        :param 'DomainDevicesTpmBackendExternalSourceNmdmArgs' nmdm: Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        :param _builtins.bool null: Enables use of a null character device as the external TPM backend source; when set (true), the TPM device discards all output and never provides input.
               
               See: <https://libvirt.org/formatdomain.html#null-device>
        :param 'DomainDevicesTpmBackendExternalSourcePipeArgs' pipe: Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        :param 'DomainDevicesTpmBackendExternalSourcePtyArgs' pty: Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        :param 'DomainDevicesTpmBackendExternalSourceQemuvdAgentArgs' qemuvd_agent: Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        :param 'DomainDevicesTpmBackendExternalSourceSpicePortArgs' spice_port: Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        :param _builtins.bool spice_vmc: When true, enables a SPICE VMC (virtioserial SPICE management) channel as the backend connection for the external TPM; omitting or setting false leaves this source disabled.
               
               See: <https://libvirt.org/formatdomain.html#spice-channel>
        :param _builtins.bool std_io: When true, connects the external TPM emulator to the domain via the QEMU standard input/output streams instead of a separate device; omitting or setting false disables this source.
               
               See: <https://libvirt.org/formatdomain.html#tpm-device>
        :param 'DomainDevicesTpmBackendExternalSourceTcpArgs' tcp: Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        :param 'DomainDevicesTpmBackendExternalSourceUdpArgs' udp: Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        :param 'DomainDevicesTpmBackendExternalSourceUnixArgs' unix: Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        :param _builtins.bool vc: Enables use of a TPM backend source type "VC" for the external TPM device; setting this boolean to true emits the <VC/> element, while false or null omits it.
               
               See: <https://libvirt.org/formatdomain.html#tpm-device>
        """
        if dbus is not None:
            pulumi.set(__self__, "dbus", dbus)
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if nmdm is not None:
            pulumi.set(__self__, "nmdm", nmdm)
        if null is not None:
            pulumi.set(__self__, "null", null)
        if pipe is not None:
            pulumi.set(__self__, "pipe", pipe)
        if pty is not None:
            pulumi.set(__self__, "pty", pty)
        if qemuvd_agent is not None:
            pulumi.set(__self__, "qemuvd_agent", qemuvd_agent)
        if spice_port is not None:
            pulumi.set(__self__, "spice_port", spice_port)
        if spice_vmc is not None:
            pulumi.set(__self__, "spice_vmc", spice_vmc)
        if std_io is not None:
            pulumi.set(__self__, "std_io", std_io)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)
        if unix is not None:
            pulumi.set(__self__, "unix", unix)
        if vc is not None:
            pulumi.set(__self__, "vc", vc)

    @_builtins.property
    @pulumi.getter
    def dbus(self) -> Optional['outputs.DomainDevicesTpmBackendExternalSourceDbus']:
        """
        Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        """
        return pulumi.get(self, "dbus")

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional['outputs.DomainDevicesTpmBackendExternalSourceDev']:
        """
        Configures an EGD RNG backend that reads entropy from a host character device node.
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.DomainDevicesTpmBackendExternalSourceFile']:
        """
        Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def nmdm(self) -> Optional['outputs.DomainDevicesTpmBackendExternalSourceNmdm']:
        """
        Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        """
        return pulumi.get(self, "nmdm")

    @_builtins.property
    @pulumi.getter
    def null(self) -> Optional[_builtins.bool]:
        """
        Enables use of a null character device as the external TPM backend source; when set (true), the TPM device discards all output and never provides input.

        See: <https://libvirt.org/formatdomain.html#null-device>
        """
        return pulumi.get(self, "null")

    @_builtins.property
    @pulumi.getter
    def pipe(self) -> Optional['outputs.DomainDevicesTpmBackendExternalSourcePipe']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        """
        return pulumi.get(self, "pipe")

    @_builtins.property
    @pulumi.getter
    def pty(self) -> Optional['outputs.DomainDevicesTpmBackendExternalSourcePty']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        """
        return pulumi.get(self, "pty")

    @_builtins.property
    @pulumi.getter(name="qemuvdAgent")
    def qemuvd_agent(self) -> Optional['outputs.DomainDevicesTpmBackendExternalSourceQemuvdAgent']:
        """
        Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        """
        return pulumi.get(self, "qemuvd_agent")

    @_builtins.property
    @pulumi.getter(name="spicePort")
    def spice_port(self) -> Optional['outputs.DomainDevicesTpmBackendExternalSourceSpicePort']:
        """
        Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        """
        return pulumi.get(self, "spice_port")

    @_builtins.property
    @pulumi.getter(name="spiceVmc")
    def spice_vmc(self) -> Optional[_builtins.bool]:
        """
        When true, enables a SPICE VMC (virtioserial SPICE management) channel as the backend connection for the external TPM; omitting or setting false leaves this source disabled.

        See: <https://libvirt.org/formatdomain.html#spice-channel>
        """
        return pulumi.get(self, "spice_vmc")

    @_builtins.property
    @pulumi.getter(name="stdIo")
    def std_io(self) -> Optional[_builtins.bool]:
        """
        When true, connects the external TPM emulator to the domain via the QEMU standard input/output streams instead of a separate device; omitting or setting false disables this source.

        See: <https://libvirt.org/formatdomain.html#tpm-device>
        """
        return pulumi.get(self, "std_io")

    @_builtins.property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.DomainDevicesTpmBackendExternalSourceTcp']:
        """
        Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        """
        return pulumi.get(self, "tcp")

    @_builtins.property
    @pulumi.getter
    def udp(self) -> Optional['outputs.DomainDevicesTpmBackendExternalSourceUdp']:
        """
        Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        """
        return pulumi.get(self, "udp")

    @_builtins.property
    @pulumi.getter
    def unix(self) -> Optional['outputs.DomainDevicesTpmBackendExternalSourceUnix']:
        """
        Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        """
        return pulumi.get(self, "unix")

    @_builtins.property
    @pulumi.getter
    def vc(self) -> Optional[_builtins.bool]:
        """
        Enables use of a TPM backend source type "VC" for the external TPM device; setting this boolean to true emits the <VC/> element, while false or null omits it.

        See: <https://libvirt.org/formatdomain.html#tpm-device>
        """
        return pulumi.get(self, "vc")


@pulumi.output_type
class DomainDevicesTpmBackendExternalSourceDbus(dict):
    def __init__(__self__, *,
                 channel: Optional[_builtins.str] = None):
        """
        :param _builtins.str channel: Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.str]:
        """
        Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesTpmBackendExternalSourceDev(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesTpmBackendExternalSourceDev. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesTpmBackendExternalSourceDev.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesTpmBackendExternalSourceDev.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesTpmBackendExternalSourceDevSecLabel']] = None):
        """
        :param _builtins.str path: Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesTpmBackendExternalSourceDevSecLabelArgs'] sec_labels: Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesTpmBackendExternalSourceDevSecLabel']]:
        """
        Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesTpmBackendExternalSourceDevSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesTpmBackendExternalSourceDevSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesTpmBackendExternalSourceDevSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesTpmBackendExternalSourceDevSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesTpmBackendExternalSourceFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesTpmBackendExternalSourceFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesTpmBackendExternalSourceFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesTpmBackendExternalSourceFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 append: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesTpmBackendExternalSourceFileSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str append: Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
               
               See: <https://libvirt.org/formatdomain.html#device-logfile>
        :param Sequence['DomainDevicesTpmBackendExternalSourceFileSecLabelArgs'] sec_labels: Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def append(self) -> Optional[_builtins.str]:
        """
        Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.

        See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        return pulumi.get(self, "append")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesTpmBackendExternalSourceFileSecLabel']]:
        """
        Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesTpmBackendExternalSourceFileSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesTpmBackendExternalSourceFileSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesTpmBackendExternalSourceFileSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesTpmBackendExternalSourceFileSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesTpmBackendExternalSourceNmdm(dict):
    def __init__(__self__, *,
                 master: _builtins.str,
                 slave: _builtins.str):
        """
        :param _builtins.str master: Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        :param _builtins.str slave: Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        pulumi.set(__self__, "master", master)
        pulumi.set(__self__, "slave", slave)

    @_builtins.property
    @pulumi.getter
    def master(self) -> _builtins.str:
        """
        Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "master")

    @_builtins.property
    @pulumi.getter
    def slave(self) -> _builtins.str:
        """
        Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "slave")


@pulumi.output_type
class DomainDevicesTpmBackendExternalSourcePipe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesTpmBackendExternalSourcePipe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesTpmBackendExternalSourcePipe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesTpmBackendExternalSourcePipe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesTpmBackendExternalSourcePipeSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesTpmBackendExternalSourcePipeSecLabelArgs'] sec_labels: Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesTpmBackendExternalSourcePipeSecLabel']]:
        """
        Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesTpmBackendExternalSourcePipeSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesTpmBackendExternalSourcePipeSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesTpmBackendExternalSourcePipeSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesTpmBackendExternalSourcePipeSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesTpmBackendExternalSourcePty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesTpmBackendExternalSourcePty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesTpmBackendExternalSourcePty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesTpmBackendExternalSourcePty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesTpmBackendExternalSourcePtySecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainDevicesTpmBackendExternalSourcePtySecLabelArgs'] sec_labels: Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesTpmBackendExternalSourcePtySecLabel']]:
        """
        Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesTpmBackendExternalSourcePtySecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesTpmBackendExternalSourcePtySecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesTpmBackendExternalSourcePtySecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesTpmBackendExternalSourcePtySecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesTpmBackendExternalSourceQemuvdAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clipBoard":
            suggest = "clip_board"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesTpmBackendExternalSourceQemuvdAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesTpmBackendExternalSourceQemuvdAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesTpmBackendExternalSourceQemuvdAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clip_board: Optional['outputs.DomainDevicesTpmBackendExternalSourceQemuvdAgentClipBoard'] = None,
                 mouse: Optional['outputs.DomainDevicesTpmBackendExternalSourceQemuvdAgentMouse'] = None):
        """
        :param 'DomainDevicesTpmBackendExternalSourceQemuvdAgentClipBoardArgs' clip_board: Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        :param 'DomainDevicesTpmBackendExternalSourceQemuvdAgentMouseArgs' mouse: Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        if clip_board is not None:
            pulumi.set(__self__, "clip_board", clip_board)
        if mouse is not None:
            pulumi.set(__self__, "mouse", mouse)

    @_builtins.property
    @pulumi.getter(name="clipBoard")
    def clip_board(self) -> Optional['outputs.DomainDevicesTpmBackendExternalSourceQemuvdAgentClipBoard']:
        """
        Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        """
        return pulumi.get(self, "clip_board")

    @_builtins.property
    @pulumi.getter
    def mouse(self) -> Optional['outputs.DomainDevicesTpmBackendExternalSourceQemuvdAgentMouse']:
        """
        Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        return pulumi.get(self, "mouse")


@pulumi.output_type
class DomainDevicesTpmBackendExternalSourceQemuvdAgentClipBoard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyPaste":
            suggest = "copy_paste"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesTpmBackendExternalSourceQemuvdAgentClipBoard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesTpmBackendExternalSourceQemuvdAgentClipBoard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesTpmBackendExternalSourceQemuvdAgentClipBoard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_paste: _builtins.str):
        """
        :param _builtins.str copy_paste: Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "copy_paste", copy_paste)

    @_builtins.property
    @pulumi.getter(name="copyPaste")
    def copy_paste(self) -> _builtins.str:
        """
        Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "copy_paste")


@pulumi.output_type
class DomainDevicesTpmBackendExternalSourceQemuvdAgentMouse(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DomainDevicesTpmBackendExternalSourceSpicePort(dict):
    def __init__(__self__, *,
                 channel: _builtins.str):
        """
        :param _builtins.str channel: Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainDevicesTpmBackendExternalSourceTcp(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesTpmBackendExternalSourceTcpReconnect'] = None,
                 service: Optional[_builtins.str] = None,
                 tls: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str mode: Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesTpmBackendExternalSourceTcpReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param _builtins.str service: Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str tls: Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesTpmBackendExternalSourceTcpReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[_builtins.str]:
        """
        Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class DomainDevicesTpmBackendExternalSourceTcpReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesTpmBackendExternalSourceUdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindHost":
            suggest = "bind_host"
        elif key == "bindService":
            suggest = "bind_service"
        elif key == "connectHost":
            suggest = "connect_host"
        elif key == "connectService":
            suggest = "connect_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesTpmBackendExternalSourceUdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesTpmBackendExternalSourceUdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesTpmBackendExternalSourceUdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bind_host: _builtins.str,
                 bind_service: _builtins.str,
                 connect_host: _builtins.str,
                 connect_service: _builtins.str):
        """
        :param _builtins.str bind_host: Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str bind_service: Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_host: Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_service: Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "bind_host", bind_host)
        pulumi.set(__self__, "bind_service", bind_service)
        pulumi.set(__self__, "connect_host", connect_host)
        pulumi.set(__self__, "connect_service", connect_service)

    @_builtins.property
    @pulumi.getter(name="bindHost")
    def bind_host(self) -> _builtins.str:
        """
        Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_host")

    @_builtins.property
    @pulumi.getter(name="bindService")
    def bind_service(self) -> _builtins.str:
        """
        Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_service")

    @_builtins.property
    @pulumi.getter(name="connectHost")
    def connect_host(self) -> _builtins.str:
        """
        Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_host")

    @_builtins.property
    @pulumi.getter(name="connectService")
    def connect_service(self) -> _builtins.str:
        """
        Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_service")


@pulumi.output_type
class DomainDevicesTpmBackendExternalSourceUnix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesTpmBackendExternalSourceUnix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesTpmBackendExternalSourceUnix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesTpmBackendExternalSourceUnix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainDevicesTpmBackendExternalSourceUnixReconnect'] = None,
                 sec_labels: Optional[Sequence['outputs.DomainDevicesTpmBackendExternalSourceUnixSecLabel']] = None):
        """
        :param _builtins.str mode: Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str path: Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainDevicesTpmBackendExternalSourceUnixReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param Sequence['DomainDevicesTpmBackendExternalSourceUnixSecLabelArgs'] sec_labels: Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainDevicesTpmBackendExternalSourceUnixReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainDevicesTpmBackendExternalSourceUnixSecLabel']]:
        """
        Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainDevicesTpmBackendExternalSourceUnixReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainDevicesTpmBackendExternalSourceUnixSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesTpmBackendExternalSourceUnixSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesTpmBackendExternalSourceUnixSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesTpmBackendExternalSourceUnixSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainDevicesTpmBackendPassthrough(dict):
    def __init__(__self__, *,
                 device: Optional['outputs.DomainDevicesTpmBackendPassthroughDevice'] = None):
        """
        :param 'DomainDevicesTpmBackendPassthroughDeviceArgs' device: Sets the host character or TPM device used by the passthrough TPM backend; the device element groups attributes describing the host TPM node.
        """
        if device is not None:
            pulumi.set(__self__, "device", device)

    @_builtins.property
    @pulumi.getter
    def device(self) -> Optional['outputs.DomainDevicesTpmBackendPassthroughDevice']:
        """
        Sets the host character or TPM device used by the passthrough TPM backend; the device element groups attributes describing the host TPM node.
        """
        return pulumi.get(self, "device")


@pulumi.output_type
class DomainDevicesTpmBackendPassthroughDevice(dict):
    def __init__(__self__, *,
                 path: _builtins.str):
        """
        :param _builtins.str path: Sets the path of the host TPM device node for a passthrough TPM backend (for example `/dev/tpm0`); the value is userprovided and required when passthrough is used.
               
               See: <https://libvirt.org/formatdomain.html#tpm-device>
        """
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the path of the host TPM device node for a passthrough TPM backend (for example `/dev/tpm0`); the value is userprovided and required when passthrough is used.

        See: <https://libvirt.org/formatdomain.html#tpm-device>
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DomainDevicesVideo(dict):
    def __init__(__self__, *,
                 acpi: Optional['outputs.DomainDevicesVideoAcpi'] = None,
                 address: Optional['outputs.DomainDevicesVideoAddress'] = None,
                 alias: Optional['outputs.DomainDevicesVideoAlias'] = None,
                 driver: Optional['outputs.DomainDevicesVideoDriver'] = None,
                 model: Optional['outputs.DomainDevicesVideoModel'] = None):
        """
        :param 'DomainDevicesVideoAcpiArgs' acpi: Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        :param 'DomainDevicesVideoAddressArgs' address: Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        :param 'DomainDevicesVideoAliasArgs' alias: Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        :param 'DomainDevicesVideoDriverArgs' driver: Configures low-level driver options for the video device, such as virtio transport and VGA behavior; attributes are driver- and model-specific.
        :param 'DomainDevicesVideoModelArgs' model: Defines the emulated video adapter model (for example `vga`, `cirrus`, `qxl`, `virtio`, `bochs`), which determines capabilities such as resolutions and acceleration.
        """
        if acpi is not None:
            pulumi.set(__self__, "acpi", acpi)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if model is not None:
            pulumi.set(__self__, "model", model)

    @_builtins.property
    @pulumi.getter
    def acpi(self) -> Optional['outputs.DomainDevicesVideoAcpi']:
        """
        Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        """
        return pulumi.get(self, "acpi")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesVideoAddress']:
        """
        Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional['outputs.DomainDevicesVideoAlias']:
        """
        Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def driver(self) -> Optional['outputs.DomainDevicesVideoDriver']:
        """
        Configures low-level driver options for the video device, such as virtio transport and VGA behavior; attributes are driver- and model-specific.
        """
        return pulumi.get(self, "driver")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional['outputs.DomainDevicesVideoModel']:
        """
        Defines the emulated video adapter model (for example `vga`, `cirrus`, `qxl`, `virtio`, `bochs`), which determines capabilities such as resolutions and acceleration.
        """
        return pulumi.get(self, "model")


@pulumi.output_type
class DomainDevicesVideoAcpi(dict):
    def __init__(__self__, *,
                 index: Optional[_builtins.float] = None):
        """
        :param _builtins.float index: Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        """
        if index is not None:
            pulumi.set(__self__, "index", index)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "index")


@pulumi.output_type
class DomainDevicesVideoAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesVideoAlias(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
               
               See: <https://libvirt.org/formatdomain.html#devices>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesVideoDriver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pagePerVq":
            suggest = "page_per_vq"
        elif key == "vgaConf":
            suggest = "vga_conf"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesVideoDriver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesVideoDriver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesVideoDriver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ats: Optional[_builtins.str] = None,
                 iommu: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 packed: Optional[_builtins.str] = None,
                 page_per_vq: Optional[_builtins.str] = None,
                 vga_conf: Optional[_builtins.str] = None):
        """
        :param _builtins.str ats: Controls the virtio Address Translation Service (ATS) feature for the video device when using an emulated IOMMU; values are typically `on` or `off`.
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.str iommu: Enables or disables the use of an emulated IOMMU for the video device; values are typically `on` or `off` and require a matching IOMMU device configuration.
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.str name: Sets a driver name or variant for the video device; the value is userprovided and specific to the selected video model and hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#video-devices>
        :param _builtins.str packed: Controls whether the virtio device uses packed virtqueue format instead of split queues; values are typically `on` or `off`.
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.str page_per_vq: Controls whether each virtqueue of the device gets its own memory page (page-per-vq optimization); values are typically `on` or `off`.
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.str vga_conf: Sets the VGA configuration policy for the video device via the `vgaconf` option (for example `on`, `off`, or `io`), controlling legacy VGA behavior; the exact accepted values are hypervisor-specific.
               
               See: <https://libvirt.org/formatdomain.html#video-devices>
        """
        if ats is not None:
            pulumi.set(__self__, "ats", ats)
        if iommu is not None:
            pulumi.set(__self__, "iommu", iommu)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if packed is not None:
            pulumi.set(__self__, "packed", packed)
        if page_per_vq is not None:
            pulumi.set(__self__, "page_per_vq", page_per_vq)
        if vga_conf is not None:
            pulumi.set(__self__, "vga_conf", vga_conf)

    @_builtins.property
    @pulumi.getter
    def ats(self) -> Optional[_builtins.str]:
        """
        Controls the virtio Address Translation Service (ATS) feature for the video device when using an emulated IOMMU; values are typically `on` or `off`.

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "ats")

    @_builtins.property
    @pulumi.getter
    def iommu(self) -> Optional[_builtins.str]:
        """
        Enables or disables the use of an emulated IOMMU for the video device; values are typically `on` or `off` and require a matching IOMMU device configuration.

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "iommu")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets a driver name or variant for the video device; the value is userprovided and specific to the selected video model and hypervisor support.

        See: <https://libvirt.org/formatdomain.html#video-devices>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def packed(self) -> Optional[_builtins.str]:
        """
        Controls whether the virtio device uses packed virtqueue format instead of split queues; values are typically `on` or `off`.

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "packed")

    @_builtins.property
    @pulumi.getter(name="pagePerVq")
    def page_per_vq(self) -> Optional[_builtins.str]:
        """
        Controls whether each virtqueue of the device gets its own memory page (page-per-vq optimization); values are typically `on` or `off`.

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "page_per_vq")

    @_builtins.property
    @pulumi.getter(name="vgaConf")
    def vga_conf(self) -> Optional[_builtins.str]:
        """
        Sets the VGA configuration policy for the video device via the `vgaconf` option (for example `on`, `off`, or `io`), controlling legacy VGA behavior; the exact accepted values are hypervisor-specific.

        See: <https://libvirt.org/formatdomain.html#video-devices>
        """
        return pulumi.get(self, "vga_conf")


@pulumi.output_type
class DomainDevicesVideoModel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vgaMem":
            suggest = "vga_mem"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesVideoModel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesVideoModel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesVideoModel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accel: Optional['outputs.DomainDevicesVideoModelAccel'] = None,
                 blob: Optional[_builtins.str] = None,
                 edid: Optional[_builtins.str] = None,
                 heads: Optional[_builtins.float] = None,
                 primary: Optional[_builtins.str] = None,
                 ram: Optional[_builtins.float] = None,
                 resolution: Optional['outputs.DomainDevicesVideoModelResolution'] = None,
                 type: Optional[_builtins.str] = None,
                 vga_mem: Optional[_builtins.float] = None,
                 vram: Optional[_builtins.float] = None,
                 vram64: Optional[_builtins.float] = None):
        """
        :param 'DomainDevicesVideoModelAccelArgs' accel: Configures hardware acceleration options for the video model, enabling or disabling 2D/3D acceleration if supported by the chosen model.
        :param _builtins.str blob: Controls whether the video device exposes a framebuffer "blob" resource to the guest; accepts "on" or "off" where supported.
               
               See: <https://libvirt.org/formatdomain.html#video-devices>
        :param _builtins.str edid: Controls whether an EDID block is exposed to the guest display for this video device; accepts "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#video-devices>
        :param _builtins.float heads: Sets the number of display heads (monitors) exposed by this video device model; expects a positive integer.
               
               See: <https://libvirt.org/formatdomain.html#video-devices>
        :param _builtins.str primary: Marks this video device as the primary adapter when set to "yes" and as non-primary when set to "no".
               
               See: <https://libvirt.org/formatdomain.html#video-devices>
        :param _builtins.float ram: Sets the amount of RAM (in KiB) assigned to the video device, controlling the total memory available to the model; expects a non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#video-devices>
        :param 'DomainDevicesVideoModelResolutionArgs' resolution: Configures a fixed default resolution for the video device via its x and y dimensions; only effective when both coordinates are provided.
        :param _builtins.str type: Selects the emulated video card model (for example "vga", "qxl", "virtio"); the value is user-provided and passed through to the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#video-devices>
        :param _builtins.float vga_mem: Sets the amount of legacy VGA memory (in KiB) exposed by the adapter (vgamem); expects a non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#video-devices>
        :param _builtins.float vram: Sets the amount of video RAM (in KiB) exposed to the guest for this adapter; expects a non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#video-devices>
        :param _builtins.float vram64: Sets the additional 64-bit-accessible video RAM (in KiB) for this adapter where supported; expects a non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#video-devices>
        """
        if accel is not None:
            pulumi.set(__self__, "accel", accel)
        if blob is not None:
            pulumi.set(__self__, "blob", blob)
        if edid is not None:
            pulumi.set(__self__, "edid", edid)
        if heads is not None:
            pulumi.set(__self__, "heads", heads)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if ram is not None:
            pulumi.set(__self__, "ram", ram)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vga_mem is not None:
            pulumi.set(__self__, "vga_mem", vga_mem)
        if vram is not None:
            pulumi.set(__self__, "vram", vram)
        if vram64 is not None:
            pulumi.set(__self__, "vram64", vram64)

    @_builtins.property
    @pulumi.getter
    def accel(self) -> Optional['outputs.DomainDevicesVideoModelAccel']:
        """
        Configures hardware acceleration options for the video model, enabling or disabling 2D/3D acceleration if supported by the chosen model.
        """
        return pulumi.get(self, "accel")

    @_builtins.property
    @pulumi.getter
    def blob(self) -> Optional[_builtins.str]:
        """
        Controls whether the video device exposes a framebuffer "blob" resource to the guest; accepts "on" or "off" where supported.

        See: <https://libvirt.org/formatdomain.html#video-devices>
        """
        return pulumi.get(self, "blob")

    @_builtins.property
    @pulumi.getter
    def edid(self) -> Optional[_builtins.str]:
        """
        Controls whether an EDID block is exposed to the guest display for this video device; accepts "on" or "off".

        See: <https://libvirt.org/formatdomain.html#video-devices>
        """
        return pulumi.get(self, "edid")

    @_builtins.property
    @pulumi.getter
    def heads(self) -> Optional[_builtins.float]:
        """
        Sets the number of display heads (monitors) exposed by this video device model; expects a positive integer.

        See: <https://libvirt.org/formatdomain.html#video-devices>
        """
        return pulumi.get(self, "heads")

    @_builtins.property
    @pulumi.getter
    def primary(self) -> Optional[_builtins.str]:
        """
        Marks this video device as the primary adapter when set to "yes" and as non-primary when set to "no".

        See: <https://libvirt.org/formatdomain.html#video-devices>
        """
        return pulumi.get(self, "primary")

    @_builtins.property
    @pulumi.getter
    def ram(self) -> Optional[_builtins.float]:
        """
        Sets the amount of RAM (in KiB) assigned to the video device, controlling the total memory available to the model; expects a non-negative integer.

        See: <https://libvirt.org/formatdomain.html#video-devices>
        """
        return pulumi.get(self, "ram")

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> Optional['outputs.DomainDevicesVideoModelResolution']:
        """
        Configures a fixed default resolution for the video device via its x and y dimensions; only effective when both coordinates are provided.
        """
        return pulumi.get(self, "resolution")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Selects the emulated video card model (for example "vga", "qxl", "virtio"); the value is user-provided and passed through to the hypervisor.

        See: <https://libvirt.org/formatdomain.html#video-devices>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vgaMem")
    def vga_mem(self) -> Optional[_builtins.float]:
        """
        Sets the amount of legacy VGA memory (in KiB) exposed by the adapter (vgamem); expects a non-negative integer.

        See: <https://libvirt.org/formatdomain.html#video-devices>
        """
        return pulumi.get(self, "vga_mem")

    @_builtins.property
    @pulumi.getter
    def vram(self) -> Optional[_builtins.float]:
        """
        Sets the amount of video RAM (in KiB) exposed to the guest for this adapter; expects a non-negative integer.

        See: <https://libvirt.org/formatdomain.html#video-devices>
        """
        return pulumi.get(self, "vram")

    @_builtins.property
    @pulumi.getter
    def vram64(self) -> Optional[_builtins.float]:
        """
        Sets the additional 64-bit-accessible video RAM (in KiB) for this adapter where supported; expects a non-negative integer.

        See: <https://libvirt.org/formatdomain.html#video-devices>
        """
        return pulumi.get(self, "vram64")


@pulumi.output_type
class DomainDevicesVideoModelAccel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "renderNode":
            suggest = "render_node"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesVideoModelAccel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesVideoModelAccel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesVideoModelAccel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accel2d: Optional[_builtins.str] = None,
                 accel3d: Optional[_builtins.str] = None,
                 render_node: Optional[_builtins.str] = None):
        """
        :param _builtins.str accel2d: Enables or disables 2D acceleration for the video device model; values are typically `yes`/`no` or `on`/`off` depending on libvirt version.
               
               See: <https://libvirt.org/formatdomain.html#video-devices>
        :param _builtins.str accel3d: Configures whether 3D acceleration is enabled for the video device model; accepts the string values "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#video-devices>
        :param _builtins.str render_node: Sets the render node path used for hardware-accelerated rendering by the video device (for example "/dev/dri/renderD128"); the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#video-devices>
        """
        if accel2d is not None:
            pulumi.set(__self__, "accel2d", accel2d)
        if accel3d is not None:
            pulumi.set(__self__, "accel3d", accel3d)
        if render_node is not None:
            pulumi.set(__self__, "render_node", render_node)

    @_builtins.property
    @pulumi.getter
    def accel2d(self) -> Optional[_builtins.str]:
        """
        Enables or disables 2D acceleration for the video device model; values are typically `yes`/`no` or `on`/`off` depending on libvirt version.

        See: <https://libvirt.org/formatdomain.html#video-devices>
        """
        return pulumi.get(self, "accel2d")

    @_builtins.property
    @pulumi.getter
    def accel3d(self) -> Optional[_builtins.str]:
        """
        Configures whether 3D acceleration is enabled for the video device model; accepts the string values "on" or "off".

        See: <https://libvirt.org/formatdomain.html#video-devices>
        """
        return pulumi.get(self, "accel3d")

    @_builtins.property
    @pulumi.getter(name="renderNode")
    def render_node(self) -> Optional[_builtins.str]:
        """
        Sets the render node path used for hardware-accelerated rendering by the video device (for example "/dev/dri/renderD128"); the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#video-devices>
        """
        return pulumi.get(self, "render_node")


@pulumi.output_type
class DomainDevicesVideoModelResolution(dict):
    def __init__(__self__, *,
                 x: _builtins.float,
                 y: _builtins.float):
        """
        :param _builtins.float x: Sets the horizontal resolution in pixels for the video device; expects a positive integer (for example 1920).
               
               See: <https://libvirt.org/formatdomain.html#video-devices>
        :param _builtins.float y: Sets the vertical resolution in pixels for the video device; expects a positive integer (for example 1080).
               
               See: <https://libvirt.org/formatdomain.html#video-devices>
        """
        pulumi.set(__self__, "x", x)
        pulumi.set(__self__, "y", y)

    @_builtins.property
    @pulumi.getter
    def x(self) -> _builtins.float:
        """
        Sets the horizontal resolution in pixels for the video device; expects a positive integer (for example 1920).

        See: <https://libvirt.org/formatdomain.html#video-devices>
        """
        return pulumi.get(self, "x")

    @_builtins.property
    @pulumi.getter
    def y(self) -> _builtins.float:
        """
        Sets the vertical resolution in pixels for the video device; expects a positive integer (for example 1080).

        See: <https://libvirt.org/formatdomain.html#video-devices>
        """
        return pulumi.get(self, "y")


@pulumi.output_type
class DomainDevicesVsock(dict):
    def __init__(__self__, *,
                 acpi: Optional['outputs.DomainDevicesVsockAcpi'] = None,
                 address: Optional['outputs.DomainDevicesVsockAddress'] = None,
                 alias: Optional['outputs.DomainDevicesVsockAlias'] = None,
                 cid: Optional['outputs.DomainDevicesVsockCid'] = None,
                 driver: Optional['outputs.DomainDevicesVsockDriver'] = None,
                 model: Optional[_builtins.str] = None):
        """
        :param 'DomainDevicesVsockAcpiArgs' acpi: Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        :param 'DomainDevicesVsockAddressArgs' address: Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        :param 'DomainDevicesVsockAliasArgs' alias: Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        :param 'DomainDevicesVsockCidArgs' cid: Configures the vsock context ID (CID) container, which holds either a fixed CID or indicates automatic assignment for the vsock device.
        :param 'DomainDevicesVsockDriverArgs' driver: Configures virtio transportspecific options for the vsock device driver, such as IOMMU and ATS usage.
        :param _builtins.str model: Sets the vsock device model, typically one of "virtio", "virtio-transitional", or "virtio-non-transitional"; if omitted, libvirt uses its default vsock model.
               
               See: <https://libvirt.org/formatdomain.html#vsock>
        """
        if acpi is not None:
            pulumi.set(__self__, "acpi", acpi)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cid is not None:
            pulumi.set(__self__, "cid", cid)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if model is not None:
            pulumi.set(__self__, "model", model)

    @_builtins.property
    @pulumi.getter
    def acpi(self) -> Optional['outputs.DomainDevicesVsockAcpi']:
        """
        Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        """
        return pulumi.get(self, "acpi")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesVsockAddress']:
        """
        Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional['outputs.DomainDevicesVsockAlias']:
        """
        Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def cid(self) -> Optional['outputs.DomainDevicesVsockCid']:
        """
        Configures the vsock context ID (CID) container, which holds either a fixed CID or indicates automatic assignment for the vsock device.
        """
        return pulumi.get(self, "cid")

    @_builtins.property
    @pulumi.getter
    def driver(self) -> Optional['outputs.DomainDevicesVsockDriver']:
        """
        Configures virtio transportspecific options for the vsock device driver, such as IOMMU and ATS usage.
        """
        return pulumi.get(self, "driver")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Sets the vsock device model, typically one of "virtio", "virtio-transitional", or "virtio-non-transitional"; if omitted, libvirt uses its default vsock model.

        See: <https://libvirt.org/formatdomain.html#vsock>
        """
        return pulumi.get(self, "model")


@pulumi.output_type
class DomainDevicesVsockAcpi(dict):
    def __init__(__self__, *,
                 index: Optional[_builtins.float] = None):
        """
        :param _builtins.float index: Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        """
        if index is not None:
            pulumi.set(__self__, "index", index)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "index")


@pulumi.output_type
class DomainDevicesVsockAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesVsockAlias(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
               
               See: <https://libvirt.org/formatdomain.html#devices>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainDevicesVsockCid(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 auto: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: Sets a fixed 32bit vsock context ID (CID) value to be used by the guest; the value is userprovided and must be valid for the chosen vsock backend (for example, a positive integer like 3).
               
               See: <https://libvirt.org/formatdomain.html#vsock>
        :param _builtins.str auto: Controls whether the vsock CID is assigned automatically; when set (typically "yes"/"no"), libvirt or the hypervisor chooses an appropriate CID if automatic assignment is enabled.
               
               See: <https://libvirt.org/formatdomain.html#vsock>
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if auto is not None:
            pulumi.set(__self__, "auto", auto)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Sets a fixed 32bit vsock context ID (CID) value to be used by the guest; the value is userprovided and must be valid for the chosen vsock backend (for example, a positive integer like 3).

        See: <https://libvirt.org/formatdomain.html#vsock>
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def auto(self) -> Optional[_builtins.str]:
        """
        Controls whether the vsock CID is assigned automatically; when set (typically "yes"/"no"), libvirt or the hypervisor chooses an appropriate CID if automatic assignment is enabled.

        See: <https://libvirt.org/formatdomain.html#vsock>
        """
        return pulumi.get(self, "auto")


@pulumi.output_type
class DomainDevicesVsockDriver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pagePerVq":
            suggest = "page_per_vq"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDevicesVsockDriver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDevicesVsockDriver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDevicesVsockDriver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ats: Optional[_builtins.str] = None,
                 iommu: Optional[_builtins.str] = None,
                 packed: Optional[_builtins.str] = None,
                 page_per_vq: Optional[_builtins.str] = None):
        """
        :param _builtins.str ats: Controls Address Translation Service (ATS) support for the virtio vsock device; valid values are "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.str iommu: Enables or disables use of an emulated IOMMU for the virtio vsock device; valid values are "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.str packed: Toggles the virtio "packed" ring layout for the vsock device; valid values are "on" or "off" and support depends on the guest and hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        :param _builtins.str page_per_vq: Controls whether each virtqueue of the vsock device uses a separate page (page_per_vq); valid values are "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        if ats is not None:
            pulumi.set(__self__, "ats", ats)
        if iommu is not None:
            pulumi.set(__self__, "iommu", iommu)
        if packed is not None:
            pulumi.set(__self__, "packed", packed)
        if page_per_vq is not None:
            pulumi.set(__self__, "page_per_vq", page_per_vq)

    @_builtins.property
    @pulumi.getter
    def ats(self) -> Optional[_builtins.str]:
        """
        Controls Address Translation Service (ATS) support for the virtio vsock device; valid values are "on" or "off".

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "ats")

    @_builtins.property
    @pulumi.getter
    def iommu(self) -> Optional[_builtins.str]:
        """
        Enables or disables use of an emulated IOMMU for the virtio vsock device; valid values are "on" or "off".

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "iommu")

    @_builtins.property
    @pulumi.getter
    def packed(self) -> Optional[_builtins.str]:
        """
        Toggles the virtio "packed" ring layout for the vsock device; valid values are "on" or "off" and support depends on the guest and hypervisor.

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "packed")

    @_builtins.property
    @pulumi.getter(name="pagePerVq")
    def page_per_vq(self) -> Optional[_builtins.str]:
        """
        Controls whether each virtqueue of the vsock device uses a separate page (page_per_vq); valid values are "on" or "off".

        See: <https://libvirt.org/formatdomain.html#virtio-related-options>
        """
        return pulumi.get(self, "page_per_vq")


@pulumi.output_type
class DomainDevicesWatchdog(dict):
    def __init__(__self__, *,
                 model: _builtins.str,
                 acpi: Optional['outputs.DomainDevicesWatchdogAcpi'] = None,
                 action: Optional[_builtins.str] = None,
                 address: Optional['outputs.DomainDevicesWatchdogAddress'] = None,
                 alias: Optional['outputs.DomainDevicesWatchdogAlias'] = None):
        """
        :param _builtins.str model: Specifies the watchdog hardware model to emulate (for example, "i6300esb"), and is required when defining a watchdog device.
               
               See: <https://libvirt.org/formatdomain.html#watchdog-devices>
        :param 'DomainDevicesWatchdogAcpiArgs' acpi: Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        :param _builtins.str action: Selects the action to take when the watchdog fires, such as "reset", "poweroff", "dump", or "none", depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#watchdog-devices>
        :param 'DomainDevicesWatchdogAddressArgs' address: Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        :param 'DomainDevicesWatchdogAliasArgs' alias: Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        pulumi.set(__self__, "model", model)
        if acpi is not None:
            pulumi.set(__self__, "acpi", acpi)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)

    @_builtins.property
    @pulumi.getter
    def model(self) -> _builtins.str:
        """
        Specifies the watchdog hardware model to emulate (for example, "i6300esb"), and is required when defining a watchdog device.

        See: <https://libvirt.org/formatdomain.html#watchdog-devices>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def acpi(self) -> Optional['outputs.DomainDevicesWatchdogAcpi']:
        """
        Configures ACPI Error Record Serialization Table (ERST) parameters associated with the pstore device for recording crash logs.
        """
        return pulumi.get(self, "acpi")

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        """
        Selects the action to take when the watchdog fires, such as "reset", "poweroff", "dump", or "none", depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#watchdog-devices>
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.DomainDevicesWatchdogAddress']:
        """
        Specifies the guest bus address at which the pstore device is attached (bus/slot/function details), if the hypervisor allows explicit placement.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional['outputs.DomainDevicesWatchdogAlias']:
        """
        Assigns an internal alias object to the pstore device, which can be used by management tooling to reference the device.
        """
        return pulumi.get(self, "alias")


@pulumi.output_type
class DomainDevicesWatchdogAcpi(dict):
    def __init__(__self__, *,
                 index: Optional[_builtins.float] = None):
        """
        :param _builtins.float index: Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#pstore>
        """
        if index is not None:
            pulumi.set(__self__, "index", index)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the ACPI ERST record index used by this pstore device; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#pstore>
        """
        return pulumi.get(self, "index")


@pulumi.output_type
class DomainDevicesWatchdogAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainDevicesWatchdogAlias(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.
               
               See: <https://libvirt.org/formatdomain.html#devices>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the alias name used internally by libvirt/qemu to identify this pstore device; the value is user-provided and must be unique among device aliases in the domain.

        See: <https://libvirt.org/formatdomain.html#devices>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainFeatures(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "asyncTeardown":
            suggest = "async_teardown"
        elif key == "ccfAssist":
            suggest = "ccf_assist"
        elif key == "hyperV":
            suggest = "hyper_v"
        elif key == "nestedHv":
            suggest = "nested_hv"
        elif key == "privNet":
            suggest = "priv_net"
        elif key == "pvSpinlock":
            suggest = "pv_spinlock"
        elif key == "vmCoreInfo":
            suggest = "vm_core_info"
        elif key == "vmPort":
            suggest = "vm_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainFeatures. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainFeatures.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainFeatures.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acpi: Optional[_builtins.bool] = None,
                 aia: Optional['outputs.DomainFeaturesAia'] = None,
                 apic: Optional['outputs.DomainFeaturesApic'] = None,
                 async_teardown: Optional['outputs.DomainFeaturesAsyncTeardown'] = None,
                 capabilities: Optional['outputs.DomainFeaturesCapabilities'] = None,
                 ccf_assist: Optional['outputs.DomainFeaturesCcfAssist'] = None,
                 cfpc: Optional['outputs.DomainFeaturesCfpc'] = None,
                 gic: Optional['outputs.DomainFeaturesGic'] = None,
                 hap: Optional['outputs.DomainFeaturesHap'] = None,
                 hpt: Optional['outputs.DomainFeaturesHpt'] = None,
                 htm: Optional['outputs.DomainFeaturesHtm'] = None,
                 hyper_v: Optional['outputs.DomainFeaturesHyperV'] = None,
                 ibs: Optional['outputs.DomainFeaturesIbs'] = None,
                 ioapic: Optional['outputs.DomainFeaturesIoapic'] = None,
                 kvm: Optional['outputs.DomainFeaturesKvm'] = None,
                 msrs: Optional['outputs.DomainFeaturesMsrs'] = None,
                 nested_hv: Optional['outputs.DomainFeaturesNestedHv'] = None,
                 pae: Optional[_builtins.bool] = None,
                 pmu: Optional['outputs.DomainFeaturesPmu'] = None,
                 priv_net: Optional[_builtins.bool] = None,
                 ps2: Optional['outputs.DomainFeaturesPs2'] = None,
                 pv_spinlock: Optional['outputs.DomainFeaturesPvSpinlock'] = None,
                 ras: Optional['outputs.DomainFeaturesRas'] = None,
                 sbbc: Optional['outputs.DomainFeaturesSbbc'] = None,
                 smm: Optional['outputs.DomainFeaturesSmm'] = None,
                 tcg: Optional['outputs.DomainFeaturesTcg'] = None,
                 viridian: Optional[_builtins.bool] = None,
                 vm_core_info: Optional['outputs.DomainFeaturesVmCoreInfo'] = None,
                 vm_port: Optional['outputs.DomainFeaturesVmPort'] = None,
                 xen: Optional['outputs.DomainFeaturesXen'] = None):
        """
        :param _builtins.bool acpi: Controls exposure of ACPI support to the guest; presence of this element enables ACPI, while its omission leaves it at libvirts default behavior.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        :param 'DomainFeaturesAiaArgs' aia: Configures the Advanced Interrupt Architecture (AIA) feature for the guest CPU/machine, with the specific mode or value being userprovided according to hypervisor support.
        :param 'DomainFeaturesApicArgs' apic: Enables inclusion of the APIC (Advanced Programmable Interrupt Controller) feature block for the guest; presence of this block allows configuring APIC-related behavior such as end-of-interrupt handling.
        :param 'DomainFeaturesAsyncTeardownArgs' async_teardown: Enables configuration of asynchronous teardown support for the guest; when present, it allows controlling whether the hypervisor uses async teardown semantics.
        :param 'DomainFeaturesCapabilitiesArgs' capabilities: Configures per-domain Linux capability controls, allowing fine-grained enabling or disabling of specific capabilities inside the guest.
        :param 'DomainFeaturesCcfAssistArgs' ccf_assist: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        :param 'DomainFeaturesCfpcArgs' cfpc: Configures the "cfpc" CPU feature (a speculative-execution/flush-control mitigation) policy for the guest.
        :param 'DomainFeaturesGicArgs' gic: Configures the ARM Generic Interrupt Controller (GIC) feature for the guest, allowing selection or control of the emulated GIC model.
        :param 'DomainFeaturesHapArgs' hap: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        :param 'DomainFeaturesHptArgs' hpt: Configures the hashed page table (HPT) feature used by some PowerPC guests, including its size and resizing behavior.
        :param 'DomainFeaturesHtmArgs' htm: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        :param 'DomainFeaturesHyperVArgs' hyper_v: Enables configuration of Hyper-V enlightenment features for the guest when running on a Hyper-V-capable hypervisor.
        :param 'DomainFeaturesIbsArgs' ibs: Enables configuration of the Instruction Based Sampling (IBS) CPU feature on supported AMD guests.
        :param 'DomainFeaturesIoapicArgs' ioapic: Configures the emulation mode for the virtual IOAPIC used for interrupt routing in the guest.
        :param 'DomainFeaturesKvmArgs' kvm: Enables configuration of KVM-specific CPU or machine features via its child elements (for example, toggling individual KVM feature flags).
        :param 'DomainFeaturesMsrsArgs' msrs: Configures handling of unknown/unsupported model-specific registers (MSRs) encountered in the guest, controlling whether guest MSR accesses can be ignored or cause failures.
        :param 'DomainFeaturesNestedHvArgs' nested_hv: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        :param _builtins.bool pae: Enables or disables Physical Address Extension (PAE) support for the guest; when set true the PAE feature element is emitted, when false or unset it is omitted.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        :param 'DomainFeaturesPmuArgs' pmu: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        :param _builtins.bool priv_net: Enables or disables the hypervisors private networking feature for the guest; when set true the privnet feature element is emitted, when false or unset it is omitted.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        :param 'DomainFeaturesPs2Args' ps2: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        :param 'DomainFeaturesPvSpinlockArgs' pv_spinlock: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        :param 'DomainFeaturesRasArgs' ras: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        :param 'DomainFeaturesSbbcArgs' sbbc: Configures the Spectre-Boundary-Branch-Control (SBBC) mitigation feature for the guest CPU.
        :param 'DomainFeaturesSmmArgs' smm: Configures System Management Mode (SMM) support for the guest, which is required for features like UEFI Secure Boot on some machine types.
        :param 'DomainFeaturesTcgArgs' tcg: Configures QEMUs TCG (software CPU emulation) feature block for fine-grained tuning of emulation behavior when TCG is in use.
        :param _builtins.bool viridian: Enables or disables the Viridian (Hyper-V enlightenment) feature block for the guest; when this presence-boolean is true the viridian feature element is emitted, otherwise it is omitted.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        :param 'DomainFeaturesVmCoreInfoArgs' vm_core_info: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        :param 'DomainFeaturesVmPortArgs' vm_port: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        :param 'DomainFeaturesXenArgs' xen: Configures Xen-specific paravirtualization compatibility features for the guest when running under QEMU/KVM with Xen emulation options.
        """
        if acpi is not None:
            pulumi.set(__self__, "acpi", acpi)
        if aia is not None:
            pulumi.set(__self__, "aia", aia)
        if apic is not None:
            pulumi.set(__self__, "apic", apic)
        if async_teardown is not None:
            pulumi.set(__self__, "async_teardown", async_teardown)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if ccf_assist is not None:
            pulumi.set(__self__, "ccf_assist", ccf_assist)
        if cfpc is not None:
            pulumi.set(__self__, "cfpc", cfpc)
        if gic is not None:
            pulumi.set(__self__, "gic", gic)
        if hap is not None:
            pulumi.set(__self__, "hap", hap)
        if hpt is not None:
            pulumi.set(__self__, "hpt", hpt)
        if htm is not None:
            pulumi.set(__self__, "htm", htm)
        if hyper_v is not None:
            pulumi.set(__self__, "hyper_v", hyper_v)
        if ibs is not None:
            pulumi.set(__self__, "ibs", ibs)
        if ioapic is not None:
            pulumi.set(__self__, "ioapic", ioapic)
        if kvm is not None:
            pulumi.set(__self__, "kvm", kvm)
        if msrs is not None:
            pulumi.set(__self__, "msrs", msrs)
        if nested_hv is not None:
            pulumi.set(__self__, "nested_hv", nested_hv)
        if pae is not None:
            pulumi.set(__self__, "pae", pae)
        if pmu is not None:
            pulumi.set(__self__, "pmu", pmu)
        if priv_net is not None:
            pulumi.set(__self__, "priv_net", priv_net)
        if ps2 is not None:
            pulumi.set(__self__, "ps2", ps2)
        if pv_spinlock is not None:
            pulumi.set(__self__, "pv_spinlock", pv_spinlock)
        if ras is not None:
            pulumi.set(__self__, "ras", ras)
        if sbbc is not None:
            pulumi.set(__self__, "sbbc", sbbc)
        if smm is not None:
            pulumi.set(__self__, "smm", smm)
        if tcg is not None:
            pulumi.set(__self__, "tcg", tcg)
        if viridian is not None:
            pulumi.set(__self__, "viridian", viridian)
        if vm_core_info is not None:
            pulumi.set(__self__, "vm_core_info", vm_core_info)
        if vm_port is not None:
            pulumi.set(__self__, "vm_port", vm_port)
        if xen is not None:
            pulumi.set(__self__, "xen", xen)

    @_builtins.property
    @pulumi.getter
    def acpi(self) -> Optional[_builtins.bool]:
        """
        Controls exposure of ACPI support to the guest; presence of this element enables ACPI, while its omission leaves it at libvirts default behavior.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "acpi")

    @_builtins.property
    @pulumi.getter
    def aia(self) -> Optional['outputs.DomainFeaturesAia']:
        """
        Configures the Advanced Interrupt Architecture (AIA) feature for the guest CPU/machine, with the specific mode or value being userprovided according to hypervisor support.
        """
        return pulumi.get(self, "aia")

    @_builtins.property
    @pulumi.getter
    def apic(self) -> Optional['outputs.DomainFeaturesApic']:
        """
        Enables inclusion of the APIC (Advanced Programmable Interrupt Controller) feature block for the guest; presence of this block allows configuring APIC-related behavior such as end-of-interrupt handling.
        """
        return pulumi.get(self, "apic")

    @_builtins.property
    @pulumi.getter(name="asyncTeardown")
    def async_teardown(self) -> Optional['outputs.DomainFeaturesAsyncTeardown']:
        """
        Enables configuration of asynchronous teardown support for the guest; when present, it allows controlling whether the hypervisor uses async teardown semantics.
        """
        return pulumi.get(self, "async_teardown")

    @_builtins.property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.DomainFeaturesCapabilities']:
        """
        Configures per-domain Linux capability controls, allowing fine-grained enabling or disabling of specific capabilities inside the guest.
        """
        return pulumi.get(self, "capabilities")

    @_builtins.property
    @pulumi.getter(name="ccfAssist")
    def ccf_assist(self) -> Optional['outputs.DomainFeaturesCcfAssist']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "ccf_assist")

    @_builtins.property
    @pulumi.getter
    def cfpc(self) -> Optional['outputs.DomainFeaturesCfpc']:
        """
        Configures the "cfpc" CPU feature (a speculative-execution/flush-control mitigation) policy for the guest.
        """
        return pulumi.get(self, "cfpc")

    @_builtins.property
    @pulumi.getter
    def gic(self) -> Optional['outputs.DomainFeaturesGic']:
        """
        Configures the ARM Generic Interrupt Controller (GIC) feature for the guest, allowing selection or control of the emulated GIC model.
        """
        return pulumi.get(self, "gic")

    @_builtins.property
    @pulumi.getter
    def hap(self) -> Optional['outputs.DomainFeaturesHap']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "hap")

    @_builtins.property
    @pulumi.getter
    def hpt(self) -> Optional['outputs.DomainFeaturesHpt']:
        """
        Configures the hashed page table (HPT) feature used by some PowerPC guests, including its size and resizing behavior.
        """
        return pulumi.get(self, "hpt")

    @_builtins.property
    @pulumi.getter
    def htm(self) -> Optional['outputs.DomainFeaturesHtm']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "htm")

    @_builtins.property
    @pulumi.getter(name="hyperV")
    def hyper_v(self) -> Optional['outputs.DomainFeaturesHyperV']:
        """
        Enables configuration of Hyper-V enlightenment features for the guest when running on a Hyper-V-capable hypervisor.
        """
        return pulumi.get(self, "hyper_v")

    @_builtins.property
    @pulumi.getter
    def ibs(self) -> Optional['outputs.DomainFeaturesIbs']:
        """
        Enables configuration of the Instruction Based Sampling (IBS) CPU feature on supported AMD guests.
        """
        return pulumi.get(self, "ibs")

    @_builtins.property
    @pulumi.getter
    def ioapic(self) -> Optional['outputs.DomainFeaturesIoapic']:
        """
        Configures the emulation mode for the virtual IOAPIC used for interrupt routing in the guest.
        """
        return pulumi.get(self, "ioapic")

    @_builtins.property
    @pulumi.getter
    def kvm(self) -> Optional['outputs.DomainFeaturesKvm']:
        """
        Enables configuration of KVM-specific CPU or machine features via its child elements (for example, toggling individual KVM feature flags).
        """
        return pulumi.get(self, "kvm")

    @_builtins.property
    @pulumi.getter
    def msrs(self) -> Optional['outputs.DomainFeaturesMsrs']:
        """
        Configures handling of unknown/unsupported model-specific registers (MSRs) encountered in the guest, controlling whether guest MSR accesses can be ignored or cause failures.
        """
        return pulumi.get(self, "msrs")

    @_builtins.property
    @pulumi.getter(name="nestedHv")
    def nested_hv(self) -> Optional['outputs.DomainFeaturesNestedHv']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "nested_hv")

    @_builtins.property
    @pulumi.getter
    def pae(self) -> Optional[_builtins.bool]:
        """
        Enables or disables Physical Address Extension (PAE) support for the guest; when set true the PAE feature element is emitted, when false or unset it is omitted.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "pae")

    @_builtins.property
    @pulumi.getter
    def pmu(self) -> Optional['outputs.DomainFeaturesPmu']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "pmu")

    @_builtins.property
    @pulumi.getter(name="privNet")
    def priv_net(self) -> Optional[_builtins.bool]:
        """
        Enables or disables the hypervisors private networking feature for the guest; when set true the privnet feature element is emitted, when false or unset it is omitted.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "priv_net")

    @_builtins.property
    @pulumi.getter
    def ps2(self) -> Optional['outputs.DomainFeaturesPs2']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "ps2")

    @_builtins.property
    @pulumi.getter(name="pvSpinlock")
    def pv_spinlock(self) -> Optional['outputs.DomainFeaturesPvSpinlock']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "pv_spinlock")

    @_builtins.property
    @pulumi.getter
    def ras(self) -> Optional['outputs.DomainFeaturesRas']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "ras")

    @_builtins.property
    @pulumi.getter
    def sbbc(self) -> Optional['outputs.DomainFeaturesSbbc']:
        """
        Configures the Spectre-Boundary-Branch-Control (SBBC) mitigation feature for the guest CPU.
        """
        return pulumi.get(self, "sbbc")

    @_builtins.property
    @pulumi.getter
    def smm(self) -> Optional['outputs.DomainFeaturesSmm']:
        """
        Configures System Management Mode (SMM) support for the guest, which is required for features like UEFI Secure Boot on some machine types.
        """
        return pulumi.get(self, "smm")

    @_builtins.property
    @pulumi.getter
    def tcg(self) -> Optional['outputs.DomainFeaturesTcg']:
        """
        Configures QEMUs TCG (software CPU emulation) feature block for fine-grained tuning of emulation behavior when TCG is in use.
        """
        return pulumi.get(self, "tcg")

    @_builtins.property
    @pulumi.getter
    def viridian(self) -> Optional[_builtins.bool]:
        """
        Enables or disables the Viridian (Hyper-V enlightenment) feature block for the guest; when this presence-boolean is true the viridian feature element is emitted, otherwise it is omitted.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "viridian")

    @_builtins.property
    @pulumi.getter(name="vmCoreInfo")
    def vm_core_info(self) -> Optional['outputs.DomainFeaturesVmCoreInfo']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "vm_core_info")

    @_builtins.property
    @pulumi.getter(name="vmPort")
    def vm_port(self) -> Optional['outputs.DomainFeaturesVmPort']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "vm_port")

    @_builtins.property
    @pulumi.getter
    def xen(self) -> Optional['outputs.DomainFeaturesXen']:
        """
        Configures Xen-specific paravirtualization compatibility features for the guest when running under QEMU/KVM with Xen emulation options.
        """
        return pulumi.get(self, "xen")


@pulumi.output_type
class DomainFeaturesAia(dict):
    def __init__(__self__, *,
                 value: _builtins.str):
        """
        :param _builtins.str value: Configures the Advanced Interrupt Architecture (AIA) feature state for the domain; valid values are user-provided strings such as "on", "off", or mode-specific values as supported by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Configures the Advanced Interrupt Architecture (AIA) feature state for the domain; valid values are user-provided strings such as "on", "off", or mode-specific values as supported by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainFeaturesApic(dict):
    def __init__(__self__, *,
                 eoi: Optional[_builtins.str] = None):
        """
        :param _builtins.str eoi: Sets whether APIC end-of-interrupt (EOI) optimization is enabled for the guest; valid values are user-provided strings typically interpreted as "on" or "off" by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if eoi is not None:
            pulumi.set(__self__, "eoi", eoi)

    @_builtins.property
    @pulumi.getter
    def eoi(self) -> Optional[_builtins.str]:
        """
        Sets whether APIC end-of-interrupt (EOI) optimization is enabled for the guest; valid values are user-provided strings typically interpreted as "on" or "off" by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "eoi")


@pulumi.output_type
class DomainFeaturesAsyncTeardown(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.str] = None):
        """
        :param _builtins.str enabled: Sets whether asynchronous teardown is enabled for the domain; valid values are user-provided strings typically treated as "on"/"off" or "yes"/"no" by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.str]:
        """
        Sets whether asynchronous teardown is enabled for the domain; valid values are user-provided strings typically treated as "on"/"off" or "yes"/"no" by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DomainFeaturesCapabilities(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "auditControl":
            suggest = "audit_control"
        elif key == "auditWrite":
            suggest = "audit_write"
        elif key == "blockSuspend":
            suggest = "block_suspend"
        elif key == "dacOverride":
            suggest = "dac_override"
        elif key == "dacReadSearch":
            suggest = "dac_read_search"
        elif key == "fsetId":
            suggest = "fset_id"
        elif key == "ipcLock":
            suggest = "ipc_lock"
        elif key == "ipcOwner":
            suggest = "ipc_owner"
        elif key == "linuxImmutable":
            suggest = "linux_immutable"
        elif key == "macAdmin":
            suggest = "mac_admin"
        elif key == "macOverride":
            suggest = "mac_override"
        elif key == "mkNod":
            suggest = "mk_nod"
        elif key == "netAdmin":
            suggest = "net_admin"
        elif key == "netBindService":
            suggest = "net_bind_service"
        elif key == "netBroadcast":
            suggest = "net_broadcast"
        elif key == "netRaw":
            suggest = "net_raw"
        elif key == "setFCap":
            suggest = "set_f_cap"
        elif key == "setGid":
            suggest = "set_gid"
        elif key == "setPCap":
            suggest = "set_p_cap"
        elif key == "setUid":
            suggest = "set_uid"
        elif key == "sysAdmin":
            suggest = "sys_admin"
        elif key == "sysBoot":
            suggest = "sys_boot"
        elif key == "sysChRoot":
            suggest = "sys_ch_root"
        elif key == "sysLog":
            suggest = "sys_log"
        elif key == "sysModule":
            suggest = "sys_module"
        elif key == "sysNice":
            suggest = "sys_nice"
        elif key == "sysPAcct":
            suggest = "sys_p_acct"
        elif key == "sysPTrace":
            suggest = "sys_p_trace"
        elif key == "sysRawIo":
            suggest = "sys_raw_io"
        elif key == "sysResource":
            suggest = "sys_resource"
        elif key == "sysTime":
            suggest = "sys_time"
        elif key == "sysTtyCnofig":
            suggest = "sys_tty_cnofig"
        elif key == "wakeAlarm":
            suggest = "wake_alarm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainFeaturesCapabilities. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainFeaturesCapabilities.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainFeaturesCapabilities.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audit_control: Optional['outputs.DomainFeaturesCapabilitiesAuditControl'] = None,
                 audit_write: Optional['outputs.DomainFeaturesCapabilitiesAuditWrite'] = None,
                 block_suspend: Optional['outputs.DomainFeaturesCapabilitiesBlockSuspend'] = None,
                 chown: Optional['outputs.DomainFeaturesCapabilitiesChown'] = None,
                 dac_override: Optional['outputs.DomainFeaturesCapabilitiesDacOverride'] = None,
                 dac_read_search: Optional['outputs.DomainFeaturesCapabilitiesDacReadSearch'] = None,
                 fowner: Optional['outputs.DomainFeaturesCapabilitiesFowner'] = None,
                 fset_id: Optional['outputs.DomainFeaturesCapabilitiesFsetId'] = None,
                 ipc_lock: Optional['outputs.DomainFeaturesCapabilitiesIpcLock'] = None,
                 ipc_owner: Optional['outputs.DomainFeaturesCapabilitiesIpcOwner'] = None,
                 kill: Optional['outputs.DomainFeaturesCapabilitiesKill'] = None,
                 lease: Optional['outputs.DomainFeaturesCapabilitiesLease'] = None,
                 linux_immutable: Optional['outputs.DomainFeaturesCapabilitiesLinuxImmutable'] = None,
                 mac_admin: Optional['outputs.DomainFeaturesCapabilitiesMacAdmin'] = None,
                 mac_override: Optional['outputs.DomainFeaturesCapabilitiesMacOverride'] = None,
                 mk_nod: Optional['outputs.DomainFeaturesCapabilitiesMkNod'] = None,
                 net_admin: Optional['outputs.DomainFeaturesCapabilitiesNetAdmin'] = None,
                 net_bind_service: Optional['outputs.DomainFeaturesCapabilitiesNetBindService'] = None,
                 net_broadcast: Optional['outputs.DomainFeaturesCapabilitiesNetBroadcast'] = None,
                 net_raw: Optional['outputs.DomainFeaturesCapabilitiesNetRaw'] = None,
                 policy: Optional[_builtins.str] = None,
                 set_f_cap: Optional['outputs.DomainFeaturesCapabilitiesSetFCap'] = None,
                 set_gid: Optional['outputs.DomainFeaturesCapabilitiesSetGid'] = None,
                 set_p_cap: Optional['outputs.DomainFeaturesCapabilitiesSetPCap'] = None,
                 set_uid: Optional['outputs.DomainFeaturesCapabilitiesSetUid'] = None,
                 sys_admin: Optional['outputs.DomainFeaturesCapabilitiesSysAdmin'] = None,
                 sys_boot: Optional['outputs.DomainFeaturesCapabilitiesSysBoot'] = None,
                 sys_ch_root: Optional['outputs.DomainFeaturesCapabilitiesSysChRoot'] = None,
                 sys_log: Optional['outputs.DomainFeaturesCapabilitiesSysLog'] = None,
                 sys_module: Optional['outputs.DomainFeaturesCapabilitiesSysModule'] = None,
                 sys_nice: Optional['outputs.DomainFeaturesCapabilitiesSysNice'] = None,
                 sys_p_acct: Optional['outputs.DomainFeaturesCapabilitiesSysPAcct'] = None,
                 sys_p_trace: Optional['outputs.DomainFeaturesCapabilitiesSysPTrace'] = None,
                 sys_raw_io: Optional['outputs.DomainFeaturesCapabilitiesSysRawIo'] = None,
                 sys_resource: Optional['outputs.DomainFeaturesCapabilitiesSysResource'] = None,
                 sys_time: Optional['outputs.DomainFeaturesCapabilitiesSysTime'] = None,
                 sys_tty_cnofig: Optional['outputs.DomainFeaturesCapabilitiesSysTtyCnofig'] = None,
                 wake_alarm: Optional['outputs.DomainFeaturesCapabilitiesWakeAlarm'] = None):
        """
        :param 'DomainFeaturesCapabilitiesAuditControlArgs' audit_control: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesAuditWriteArgs' audit_write: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesBlockSuspendArgs' block_suspend: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesChownArgs' chown: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesDacOverrideArgs' dac_override: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesDacReadSearchArgs' dac_read_search: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesFownerArgs' fowner: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesFsetIdArgs' fset_id: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesIpcLockArgs' ipc_lock: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesIpcOwnerArgs' ipc_owner: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesKillArgs' kill: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesLeaseArgs' lease: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesLinuxImmutableArgs' linux_immutable: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesMacAdminArgs' mac_admin: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesMacOverrideArgs' mac_override: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesMkNodArgs' mk_nod: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesNetAdminArgs' net_admin: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesNetBindServiceArgs' net_bind_service: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesNetBroadcastArgs' net_broadcast: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesNetRawArgs' net_raw: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param _builtins.str policy: Sets the overall policy for how listed capabilities are applied to the guest; the value is user-provided and may follow libvirts capability policy keywords (for example, to treat unlisted capabilities as denied or allowed).
        :param 'DomainFeaturesCapabilitiesSetFCapArgs' set_f_cap: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesSetGidArgs' set_gid: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesSetPCapArgs' set_p_cap: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesSetUidArgs' set_uid: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesSysAdminArgs' sys_admin: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesSysBootArgs' sys_boot: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesSysChRootArgs' sys_ch_root: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesSysLogArgs' sys_log: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesSysModuleArgs' sys_module: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesSysNiceArgs' sys_nice: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesSysPAcctArgs' sys_p_acct: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesSysPTraceArgs' sys_p_trace: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesSysRawIoArgs' sys_raw_io: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesSysResourceArgs' sys_resource: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesSysTimeArgs' sys_time: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesSysTtyCnofigArgs' sys_tty_cnofig: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        :param 'DomainFeaturesCapabilitiesWakeAlarmArgs' wake_alarm: Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        if audit_control is not None:
            pulumi.set(__self__, "audit_control", audit_control)
        if audit_write is not None:
            pulumi.set(__self__, "audit_write", audit_write)
        if block_suspend is not None:
            pulumi.set(__self__, "block_suspend", block_suspend)
        if chown is not None:
            pulumi.set(__self__, "chown", chown)
        if dac_override is not None:
            pulumi.set(__self__, "dac_override", dac_override)
        if dac_read_search is not None:
            pulumi.set(__self__, "dac_read_search", dac_read_search)
        if fowner is not None:
            pulumi.set(__self__, "fowner", fowner)
        if fset_id is not None:
            pulumi.set(__self__, "fset_id", fset_id)
        if ipc_lock is not None:
            pulumi.set(__self__, "ipc_lock", ipc_lock)
        if ipc_owner is not None:
            pulumi.set(__self__, "ipc_owner", ipc_owner)
        if kill is not None:
            pulumi.set(__self__, "kill", kill)
        if lease is not None:
            pulumi.set(__self__, "lease", lease)
        if linux_immutable is not None:
            pulumi.set(__self__, "linux_immutable", linux_immutable)
        if mac_admin is not None:
            pulumi.set(__self__, "mac_admin", mac_admin)
        if mac_override is not None:
            pulumi.set(__self__, "mac_override", mac_override)
        if mk_nod is not None:
            pulumi.set(__self__, "mk_nod", mk_nod)
        if net_admin is not None:
            pulumi.set(__self__, "net_admin", net_admin)
        if net_bind_service is not None:
            pulumi.set(__self__, "net_bind_service", net_bind_service)
        if net_broadcast is not None:
            pulumi.set(__self__, "net_broadcast", net_broadcast)
        if net_raw is not None:
            pulumi.set(__self__, "net_raw", net_raw)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if set_f_cap is not None:
            pulumi.set(__self__, "set_f_cap", set_f_cap)
        if set_gid is not None:
            pulumi.set(__self__, "set_gid", set_gid)
        if set_p_cap is not None:
            pulumi.set(__self__, "set_p_cap", set_p_cap)
        if set_uid is not None:
            pulumi.set(__self__, "set_uid", set_uid)
        if sys_admin is not None:
            pulumi.set(__self__, "sys_admin", sys_admin)
        if sys_boot is not None:
            pulumi.set(__self__, "sys_boot", sys_boot)
        if sys_ch_root is not None:
            pulumi.set(__self__, "sys_ch_root", sys_ch_root)
        if sys_log is not None:
            pulumi.set(__self__, "sys_log", sys_log)
        if sys_module is not None:
            pulumi.set(__self__, "sys_module", sys_module)
        if sys_nice is not None:
            pulumi.set(__self__, "sys_nice", sys_nice)
        if sys_p_acct is not None:
            pulumi.set(__self__, "sys_p_acct", sys_p_acct)
        if sys_p_trace is not None:
            pulumi.set(__self__, "sys_p_trace", sys_p_trace)
        if sys_raw_io is not None:
            pulumi.set(__self__, "sys_raw_io", sys_raw_io)
        if sys_resource is not None:
            pulumi.set(__self__, "sys_resource", sys_resource)
        if sys_time is not None:
            pulumi.set(__self__, "sys_time", sys_time)
        if sys_tty_cnofig is not None:
            pulumi.set(__self__, "sys_tty_cnofig", sys_tty_cnofig)
        if wake_alarm is not None:
            pulumi.set(__self__, "wake_alarm", wake_alarm)

    @_builtins.property
    @pulumi.getter(name="auditControl")
    def audit_control(self) -> Optional['outputs.DomainFeaturesCapabilitiesAuditControl']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "audit_control")

    @_builtins.property
    @pulumi.getter(name="auditWrite")
    def audit_write(self) -> Optional['outputs.DomainFeaturesCapabilitiesAuditWrite']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "audit_write")

    @_builtins.property
    @pulumi.getter(name="blockSuspend")
    def block_suspend(self) -> Optional['outputs.DomainFeaturesCapabilitiesBlockSuspend']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "block_suspend")

    @_builtins.property
    @pulumi.getter
    def chown(self) -> Optional['outputs.DomainFeaturesCapabilitiesChown']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "chown")

    @_builtins.property
    @pulumi.getter(name="dacOverride")
    def dac_override(self) -> Optional['outputs.DomainFeaturesCapabilitiesDacOverride']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "dac_override")

    @_builtins.property
    @pulumi.getter(name="dacReadSearch")
    def dac_read_search(self) -> Optional['outputs.DomainFeaturesCapabilitiesDacReadSearch']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "dac_read_search")

    @_builtins.property
    @pulumi.getter
    def fowner(self) -> Optional['outputs.DomainFeaturesCapabilitiesFowner']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "fowner")

    @_builtins.property
    @pulumi.getter(name="fsetId")
    def fset_id(self) -> Optional['outputs.DomainFeaturesCapabilitiesFsetId']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "fset_id")

    @_builtins.property
    @pulumi.getter(name="ipcLock")
    def ipc_lock(self) -> Optional['outputs.DomainFeaturesCapabilitiesIpcLock']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "ipc_lock")

    @_builtins.property
    @pulumi.getter(name="ipcOwner")
    def ipc_owner(self) -> Optional['outputs.DomainFeaturesCapabilitiesIpcOwner']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "ipc_owner")

    @_builtins.property
    @pulumi.getter
    def kill(self) -> Optional['outputs.DomainFeaturesCapabilitiesKill']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "kill")

    @_builtins.property
    @pulumi.getter
    def lease(self) -> Optional['outputs.DomainFeaturesCapabilitiesLease']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "lease")

    @_builtins.property
    @pulumi.getter(name="linuxImmutable")
    def linux_immutable(self) -> Optional['outputs.DomainFeaturesCapabilitiesLinuxImmutable']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "linux_immutable")

    @_builtins.property
    @pulumi.getter(name="macAdmin")
    def mac_admin(self) -> Optional['outputs.DomainFeaturesCapabilitiesMacAdmin']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "mac_admin")

    @_builtins.property
    @pulumi.getter(name="macOverride")
    def mac_override(self) -> Optional['outputs.DomainFeaturesCapabilitiesMacOverride']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "mac_override")

    @_builtins.property
    @pulumi.getter(name="mkNod")
    def mk_nod(self) -> Optional['outputs.DomainFeaturesCapabilitiesMkNod']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "mk_nod")

    @_builtins.property
    @pulumi.getter(name="netAdmin")
    def net_admin(self) -> Optional['outputs.DomainFeaturesCapabilitiesNetAdmin']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "net_admin")

    @_builtins.property
    @pulumi.getter(name="netBindService")
    def net_bind_service(self) -> Optional['outputs.DomainFeaturesCapabilitiesNetBindService']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "net_bind_service")

    @_builtins.property
    @pulumi.getter(name="netBroadcast")
    def net_broadcast(self) -> Optional['outputs.DomainFeaturesCapabilitiesNetBroadcast']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "net_broadcast")

    @_builtins.property
    @pulumi.getter(name="netRaw")
    def net_raw(self) -> Optional['outputs.DomainFeaturesCapabilitiesNetRaw']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "net_raw")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[_builtins.str]:
        """
        Sets the overall policy for how listed capabilities are applied to the guest; the value is user-provided and may follow libvirts capability policy keywords (for example, to treat unlisted capabilities as denied or allowed).
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter(name="setFCap")
    def set_f_cap(self) -> Optional['outputs.DomainFeaturesCapabilitiesSetFCap']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "set_f_cap")

    @_builtins.property
    @pulumi.getter(name="setGid")
    def set_gid(self) -> Optional['outputs.DomainFeaturesCapabilitiesSetGid']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "set_gid")

    @_builtins.property
    @pulumi.getter(name="setPCap")
    def set_p_cap(self) -> Optional['outputs.DomainFeaturesCapabilitiesSetPCap']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "set_p_cap")

    @_builtins.property
    @pulumi.getter(name="setUid")
    def set_uid(self) -> Optional['outputs.DomainFeaturesCapabilitiesSetUid']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "set_uid")

    @_builtins.property
    @pulumi.getter(name="sysAdmin")
    def sys_admin(self) -> Optional['outputs.DomainFeaturesCapabilitiesSysAdmin']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "sys_admin")

    @_builtins.property
    @pulumi.getter(name="sysBoot")
    def sys_boot(self) -> Optional['outputs.DomainFeaturesCapabilitiesSysBoot']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "sys_boot")

    @_builtins.property
    @pulumi.getter(name="sysChRoot")
    def sys_ch_root(self) -> Optional['outputs.DomainFeaturesCapabilitiesSysChRoot']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "sys_ch_root")

    @_builtins.property
    @pulumi.getter(name="sysLog")
    def sys_log(self) -> Optional['outputs.DomainFeaturesCapabilitiesSysLog']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "sys_log")

    @_builtins.property
    @pulumi.getter(name="sysModule")
    def sys_module(self) -> Optional['outputs.DomainFeaturesCapabilitiesSysModule']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "sys_module")

    @_builtins.property
    @pulumi.getter(name="sysNice")
    def sys_nice(self) -> Optional['outputs.DomainFeaturesCapabilitiesSysNice']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "sys_nice")

    @_builtins.property
    @pulumi.getter(name="sysPAcct")
    def sys_p_acct(self) -> Optional['outputs.DomainFeaturesCapabilitiesSysPAcct']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "sys_p_acct")

    @_builtins.property
    @pulumi.getter(name="sysPTrace")
    def sys_p_trace(self) -> Optional['outputs.DomainFeaturesCapabilitiesSysPTrace']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "sys_p_trace")

    @_builtins.property
    @pulumi.getter(name="sysRawIo")
    def sys_raw_io(self) -> Optional['outputs.DomainFeaturesCapabilitiesSysRawIo']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "sys_raw_io")

    @_builtins.property
    @pulumi.getter(name="sysResource")
    def sys_resource(self) -> Optional['outputs.DomainFeaturesCapabilitiesSysResource']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "sys_resource")

    @_builtins.property
    @pulumi.getter(name="sysTime")
    def sys_time(self) -> Optional['outputs.DomainFeaturesCapabilitiesSysTime']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "sys_time")

    @_builtins.property
    @pulumi.getter(name="sysTtyCnofig")
    def sys_tty_cnofig(self) -> Optional['outputs.DomainFeaturesCapabilitiesSysTtyCnofig']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "sys_tty_cnofig")

    @_builtins.property
    @pulumi.getter(name="wakeAlarm")
    def wake_alarm(self) -> Optional['outputs.DomainFeaturesCapabilitiesWakeAlarm']:
        """
        Configures inclusion of the `wake_alarm` capability entry, indicating whether the guest can schedule wake-up alarms that may power on or resume the virtual machine.
        """
        return pulumi.get(self, "wake_alarm")


@pulumi.output_type
class DomainFeaturesCapabilitiesAuditControl(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesAuditWrite(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesBlockSuspend(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesChown(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesDacOverride(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesDacReadSearch(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesFowner(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesFsetId(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesIpcLock(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesIpcOwner(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesKill(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesLease(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesLinuxImmutable(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesMacAdmin(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesMacOverride(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesMkNod(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesNetAdmin(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesNetBindService(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesNetBroadcast(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesNetRaw(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesSetFCap(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesSetGid(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesSetPCap(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesSetUid(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesSysAdmin(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesSysBoot(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesSysChRoot(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesSysLog(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesSysModule(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesSysNice(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesSysPAcct(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesSysPTrace(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesSysRawIo(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesSysResource(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesSysTime(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesSysTtyCnofig(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCapabilitiesWakeAlarm(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether the guest is allowed to use the host wake alarm capability; accepts the usual feature state values such as "on", "off", or "default" depending on hypervisor support.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCcfAssist(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesCfpc(dict):
    def __init__(__self__, *,
                 value: _builtins.str):
        """
        :param _builtins.str value: Sets the cfpc policy value; libvirt accepts specific strings such as "on", "off", "workaround", "broken", or "default" depending on the mitigation mode supported by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Sets the cfpc policy value; libvirt accepts specific strings such as "on", "off", "workaround", "broken", or "default" depending on the mitigation mode supported by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainFeaturesGic(dict):
    def __init__(__self__, *,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str version: Sets the desired GIC hardware version presented to the guest, such as "2" or "3", with the exact allowed values depending on the guest architecture and machine type.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Sets the desired GIC hardware version presented to the guest, such as "2" or "3", with the exact allowed values depending on the guest architecture and machine type.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DomainFeaturesHap(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesHpt(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxPageSize":
            suggest = "max_page_size"
        elif key == "maxPageSizeUnit":
            suggest = "max_page_size_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainFeaturesHpt. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainFeaturesHpt.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainFeaturesHpt.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_page_size: Optional[_builtins.str] = None,
                 max_page_size_unit: Optional[_builtins.str] = None,
                 resizing: Optional[_builtins.str] = None):
        """
        :param _builtins.str max_page_size: Sets the maximum page size used by the guest hashed page table; value is a number interpreted together with max_page_size_unit (for example, 16 with unit "MiB").
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        :param _builtins.str max_page_size_unit: Specifies the unit for hpt.max_page_size (for example "KiB", "MiB", or "GiB"); this is a string unit indicator used in combination with the numeric value.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        :param _builtins.str resizing: Controls whether hashed page table resizing is allowed at runtime; valid values are user-provided strings such as "on", "off", or similar policy keywords as supported by libvirt.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if max_page_size is not None:
            pulumi.set(__self__, "max_page_size", max_page_size)
        if max_page_size_unit is not None:
            pulumi.set(__self__, "max_page_size_unit", max_page_size_unit)
        if resizing is not None:
            pulumi.set(__self__, "resizing", resizing)

    @_builtins.property
    @pulumi.getter(name="maxPageSize")
    def max_page_size(self) -> Optional[_builtins.str]:
        """
        Sets the maximum page size used by the guest hashed page table; value is a number interpreted together with max_page_size_unit (for example, 16 with unit "MiB").

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "max_page_size")

    @_builtins.property
    @pulumi.getter(name="maxPageSizeUnit")
    def max_page_size_unit(self) -> Optional[_builtins.str]:
        """
        Specifies the unit for hpt.max_page_size (for example "KiB", "MiB", or "GiB"); this is a string unit indicator used in combination with the numeric value.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "max_page_size_unit")

    @_builtins.property
    @pulumi.getter
    def resizing(self) -> Optional[_builtins.str]:
        """
        Controls whether hashed page table resizing is allowed at runtime; valid values are user-provided strings such as "on", "off", or similar policy keywords as supported by libvirt.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "resizing")


@pulumi.output_type
class DomainFeaturesHtm(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesHyperV(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emsrBitmap":
            suggest = "emsr_bitmap"
        elif key == "reEnlightenment":
            suggest = "re_enlightenment"
        elif key == "tlbFlush":
            suggest = "tlb_flush"
        elif key == "vendorId":
            suggest = "vendor_id"
        elif key == "vpIndex":
            suggest = "vp_index"
        elif key == "xmmInput":
            suggest = "xmm_input"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainFeaturesHyperV. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainFeaturesHyperV.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainFeaturesHyperV.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 avic: Optional['outputs.DomainFeaturesHyperVAvic'] = None,
                 emsr_bitmap: Optional['outputs.DomainFeaturesHyperVEmsrBitmap'] = None,
                 evmcs: Optional['outputs.DomainFeaturesHyperVEvmcs'] = None,
                 frequencies: Optional['outputs.DomainFeaturesHyperVFrequencies'] = None,
                 ipi: Optional['outputs.DomainFeaturesHyperVIpi'] = None,
                 mode: Optional[_builtins.str] = None,
                 re_enlightenment: Optional['outputs.DomainFeaturesHyperVReEnlightenment'] = None,
                 relaxed: Optional['outputs.DomainFeaturesHyperVRelaxed'] = None,
                 reset: Optional['outputs.DomainFeaturesHyperVReset'] = None,
                 runtime: Optional['outputs.DomainFeaturesHyperVRuntime'] = None,
                 spinlocks: Optional['outputs.DomainFeaturesHyperVSpinlocks'] = None,
                 stimer: Optional['outputs.DomainFeaturesHyperVStimer'] = None,
                 synic: Optional['outputs.DomainFeaturesHyperVSynic'] = None,
                 tlb_flush: Optional['outputs.DomainFeaturesHyperVTlbFlush'] = None,
                 vapic: Optional['outputs.DomainFeaturesHyperVVapic'] = None,
                 vendor_id: Optional['outputs.DomainFeaturesHyperVVendorId'] = None,
                 vp_index: Optional['outputs.DomainFeaturesHyperVVpIndex'] = None,
                 xmm_input: Optional['outputs.DomainFeaturesHyperVXmmInput'] = None):
        """
        :param 'DomainFeaturesHyperVAvicArgs' avic: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        :param 'DomainFeaturesHyperVEmsrBitmapArgs' emsr_bitmap: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        :param 'DomainFeaturesHyperVEvmcsArgs' evmcs: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        :param 'DomainFeaturesHyperVFrequenciesArgs' frequencies: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        :param 'DomainFeaturesHyperVIpiArgs' ipi: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        :param _builtins.str mode: Sets the Hyper-V enlightenment mode for the domain (for example, "custom" vs. driver-specific modes); the exact allowed values are user-provided and depend on the libvirt/QEMU version.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        :param 'DomainFeaturesHyperVReEnlightenmentArgs' re_enlightenment: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        :param 'DomainFeaturesHyperVRelaxedArgs' relaxed: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        :param 'DomainFeaturesHyperVResetArgs' reset: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        :param 'DomainFeaturesHyperVRuntimeArgs' runtime: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        :param 'DomainFeaturesHyperVSpinlocksArgs' spinlocks: Configures the Hyper-V spinlock enlightenment, which can reduce CPU waste on spinlocks by triggering a fallback after a configurable number of retries.
        :param 'DomainFeaturesHyperVStimerArgs' stimer: Configures the Hyper-V synthetic timer (stimer) feature, which provides paravirtualized timer support to the guest.
        :param 'DomainFeaturesHyperVSynicArgs' synic: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        :param 'DomainFeaturesHyperVTlbFlushArgs' tlb_flush: Enables configuration of Hyper-V TLB flush enlightenment features for the guest; presence of this block allows selecting specific flush modes via its children.
        :param 'DomainFeaturesHyperVVapicArgs' vapic: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        :param 'DomainFeaturesHyperVVendorIdArgs' vendor_id: Enables configuration of a custom Hyper-V CPUID vendor ID string presented to the guest.
        :param 'DomainFeaturesHyperVVpIndexArgs' vp_index: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        :param 'DomainFeaturesHyperVXmmInputArgs' xmm_input: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        if avic is not None:
            pulumi.set(__self__, "avic", avic)
        if emsr_bitmap is not None:
            pulumi.set(__self__, "emsr_bitmap", emsr_bitmap)
        if evmcs is not None:
            pulumi.set(__self__, "evmcs", evmcs)
        if frequencies is not None:
            pulumi.set(__self__, "frequencies", frequencies)
        if ipi is not None:
            pulumi.set(__self__, "ipi", ipi)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if re_enlightenment is not None:
            pulumi.set(__self__, "re_enlightenment", re_enlightenment)
        if relaxed is not None:
            pulumi.set(__self__, "relaxed", relaxed)
        if reset is not None:
            pulumi.set(__self__, "reset", reset)
        if runtime is not None:
            pulumi.set(__self__, "runtime", runtime)
        if spinlocks is not None:
            pulumi.set(__self__, "spinlocks", spinlocks)
        if stimer is not None:
            pulumi.set(__self__, "stimer", stimer)
        if synic is not None:
            pulumi.set(__self__, "synic", synic)
        if tlb_flush is not None:
            pulumi.set(__self__, "tlb_flush", tlb_flush)
        if vapic is not None:
            pulumi.set(__self__, "vapic", vapic)
        if vendor_id is not None:
            pulumi.set(__self__, "vendor_id", vendor_id)
        if vp_index is not None:
            pulumi.set(__self__, "vp_index", vp_index)
        if xmm_input is not None:
            pulumi.set(__self__, "xmm_input", xmm_input)

    @_builtins.property
    @pulumi.getter
    def avic(self) -> Optional['outputs.DomainFeaturesHyperVAvic']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "avic")

    @_builtins.property
    @pulumi.getter(name="emsrBitmap")
    def emsr_bitmap(self) -> Optional['outputs.DomainFeaturesHyperVEmsrBitmap']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "emsr_bitmap")

    @_builtins.property
    @pulumi.getter
    def evmcs(self) -> Optional['outputs.DomainFeaturesHyperVEvmcs']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "evmcs")

    @_builtins.property
    @pulumi.getter
    def frequencies(self) -> Optional['outputs.DomainFeaturesHyperVFrequencies']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "frequencies")

    @_builtins.property
    @pulumi.getter
    def ipi(self) -> Optional['outputs.DomainFeaturesHyperVIpi']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "ipi")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the Hyper-V enlightenment mode for the domain (for example, "custom" vs. driver-specific modes); the exact allowed values are user-provided and depend on the libvirt/QEMU version.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="reEnlightenment")
    def re_enlightenment(self) -> Optional['outputs.DomainFeaturesHyperVReEnlightenment']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "re_enlightenment")

    @_builtins.property
    @pulumi.getter
    def relaxed(self) -> Optional['outputs.DomainFeaturesHyperVRelaxed']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "relaxed")

    @_builtins.property
    @pulumi.getter
    def reset(self) -> Optional['outputs.DomainFeaturesHyperVReset']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "reset")

    @_builtins.property
    @pulumi.getter
    def runtime(self) -> Optional['outputs.DomainFeaturesHyperVRuntime']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "runtime")

    @_builtins.property
    @pulumi.getter
    def spinlocks(self) -> Optional['outputs.DomainFeaturesHyperVSpinlocks']:
        """
        Configures the Hyper-V spinlock enlightenment, which can reduce CPU waste on spinlocks by triggering a fallback after a configurable number of retries.
        """
        return pulumi.get(self, "spinlocks")

    @_builtins.property
    @pulumi.getter
    def stimer(self) -> Optional['outputs.DomainFeaturesHyperVStimer']:
        """
        Configures the Hyper-V synthetic timer (stimer) feature, which provides paravirtualized timer support to the guest.
        """
        return pulumi.get(self, "stimer")

    @_builtins.property
    @pulumi.getter
    def synic(self) -> Optional['outputs.DomainFeaturesHyperVSynic']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "synic")

    @_builtins.property
    @pulumi.getter(name="tlbFlush")
    def tlb_flush(self) -> Optional['outputs.DomainFeaturesHyperVTlbFlush']:
        """
        Enables configuration of Hyper-V TLB flush enlightenment features for the guest; presence of this block allows selecting specific flush modes via its children.
        """
        return pulumi.get(self, "tlb_flush")

    @_builtins.property
    @pulumi.getter
    def vapic(self) -> Optional['outputs.DomainFeaturesHyperVVapic']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "vapic")

    @_builtins.property
    @pulumi.getter(name="vendorId")
    def vendor_id(self) -> Optional['outputs.DomainFeaturesHyperVVendorId']:
        """
        Enables configuration of a custom Hyper-V CPUID vendor ID string presented to the guest.
        """
        return pulumi.get(self, "vendor_id")

    @_builtins.property
    @pulumi.getter(name="vpIndex")
    def vp_index(self) -> Optional['outputs.DomainFeaturesHyperVVpIndex']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "vp_index")

    @_builtins.property
    @pulumi.getter(name="xmmInput")
    def xmm_input(self) -> Optional['outputs.DomainFeaturesHyperVXmmInput']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "xmm_input")


@pulumi.output_type
class DomainFeaturesHyperVAvic(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesHyperVEmsrBitmap(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesHyperVEvmcs(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesHyperVFrequencies(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesHyperVIpi(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesHyperVReEnlightenment(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesHyperVRelaxed(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesHyperVReset(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesHyperVRuntime(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesHyperVSpinlocks(dict):
    def __init__(__self__, *,
                 retries: Optional[_builtins.float] = None):
        """
        :param _builtins.float retries: Sets the maximum number of spinlock retries before triggering the Hyper-V enlightenment fallback; the value is a user-provided non-negative integer (e.g., 4095).
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if retries is not None:
            pulumi.set(__self__, "retries", retries)

    @_builtins.property
    @pulumi.getter
    def retries(self) -> Optional[_builtins.float]:
        """
        Sets the maximum number of spinlock retries before triggering the Hyper-V enlightenment fallback; the value is a user-provided non-negative integer (e.g., 4095).

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "retries")


@pulumi.output_type
class DomainFeaturesHyperVStimer(dict):
    def __init__(__self__, *,
                 direct: Optional['outputs.DomainFeaturesHyperVStimerDirect'] = None):
        """
        :param 'DomainFeaturesHyperVStimerDirectArgs' direct: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        if direct is not None:
            pulumi.set(__self__, "direct", direct)

    @_builtins.property
    @pulumi.getter
    def direct(self) -> Optional['outputs.DomainFeaturesHyperVStimerDirect']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "direct")


@pulumi.output_type
class DomainFeaturesHyperVStimerDirect(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesHyperVSynic(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesHyperVTlbFlush(dict):
    def __init__(__self__, *,
                 direct: Optional['outputs.DomainFeaturesHyperVTlbFlushDirect'] = None,
                 extended: Optional['outputs.DomainFeaturesHyperVTlbFlushExtended'] = None):
        """
        :param 'DomainFeaturesHyperVTlbFlushDirectArgs' direct: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        :param 'DomainFeaturesHyperVTlbFlushExtendedArgs' extended: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        if direct is not None:
            pulumi.set(__self__, "direct", direct)
        if extended is not None:
            pulumi.set(__self__, "extended", extended)

    @_builtins.property
    @pulumi.getter
    def direct(self) -> Optional['outputs.DomainFeaturesHyperVTlbFlushDirect']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "direct")

    @_builtins.property
    @pulumi.getter
    def extended(self) -> Optional['outputs.DomainFeaturesHyperVTlbFlushExtended']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "extended")


@pulumi.output_type
class DomainFeaturesHyperVTlbFlushDirect(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesHyperVTlbFlushExtended(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesHyperVVapic(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesHyperVVendorId(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str value: Sets the custom Hyper-V vendor ID string exposed to the guest; the value is user-provided and typically limited to 12 ASCII characters (for example, "KVM HvVendor").
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Sets the custom Hyper-V vendor ID string exposed to the guest; the value is user-provided and typically limited to 12 ASCII characters (for example, "KVM HvVendor").

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainFeaturesHyperVVpIndex(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesHyperVXmmInput(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesIbs(dict):
    def __init__(__self__, *,
                 value: _builtins.str):
        """
        :param _builtins.str value: Sets the state of the IBS feature, usually "on" or "off"; this attribute is required when ibs is present and must be explicitly specified.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Sets the state of the IBS feature, usually "on" or "off"; this attribute is required when ibs is present and must be explicitly specified.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainFeaturesIoapic(dict):
    def __init__(__self__, *,
                 driver: Optional[_builtins.str] = None):
        """
        :param _builtins.str driver: Selects the IOAPIC emulation driver, typically using values like "qemu" or "kvm"; the exact string is user-provided but must be supported by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if driver is not None:
            pulumi.set(__self__, "driver", driver)

    @_builtins.property
    @pulumi.getter
    def driver(self) -> Optional[_builtins.str]:
        """
        Selects the IOAPIC emulation driver, typically using values like "qemu" or "kvm"; the exact string is user-provided but must be supported by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "driver")


@pulumi.output_type
class DomainFeaturesKvm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dirtyRing":
            suggest = "dirty_ring"
        elif key == "hintDedicated":
            suggest = "hint_dedicated"
        elif key == "pollControl":
            suggest = "poll_control"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainFeaturesKvm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainFeaturesKvm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainFeaturesKvm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dirty_ring: Optional['outputs.DomainFeaturesKvmDirtyRing'] = None,
                 hidden: Optional['outputs.DomainFeaturesKvmHidden'] = None,
                 hint_dedicated: Optional['outputs.DomainFeaturesKvmHintDedicated'] = None,
                 poll_control: Optional['outputs.DomainFeaturesKvmPollControl'] = None,
                 pvipi: Optional['outputs.DomainFeaturesKvmPvipi'] = None):
        """
        :param 'DomainFeaturesKvmDirtyRingArgs' dirty_ring: Configures the KVM dirty-ring feature for tracking guest memory changes via a ring buffer instead of legacy dirty logging, enabling more efficient live migration and dirty-page tracking when supported by the host.
        :param 'DomainFeaturesKvmHiddenArgs' hidden: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        :param 'DomainFeaturesKvmHintDedicatedArgs' hint_dedicated: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        :param 'DomainFeaturesKvmPollControlArgs' poll_control: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        :param 'DomainFeaturesKvmPvipiArgs' pvipi: Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        if dirty_ring is not None:
            pulumi.set(__self__, "dirty_ring", dirty_ring)
        if hidden is not None:
            pulumi.set(__self__, "hidden", hidden)
        if hint_dedicated is not None:
            pulumi.set(__self__, "hint_dedicated", hint_dedicated)
        if poll_control is not None:
            pulumi.set(__self__, "poll_control", poll_control)
        if pvipi is not None:
            pulumi.set(__self__, "pvipi", pvipi)

    @_builtins.property
    @pulumi.getter(name="dirtyRing")
    def dirty_ring(self) -> Optional['outputs.DomainFeaturesKvmDirtyRing']:
        """
        Configures the KVM dirty-ring feature for tracking guest memory changes via a ring buffer instead of legacy dirty logging, enabling more efficient live migration and dirty-page tracking when supported by the host.
        """
        return pulumi.get(self, "dirty_ring")

    @_builtins.property
    @pulumi.getter
    def hidden(self) -> Optional['outputs.DomainFeaturesKvmHidden']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "hidden")

    @_builtins.property
    @pulumi.getter(name="hintDedicated")
    def hint_dedicated(self) -> Optional['outputs.DomainFeaturesKvmHintDedicated']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "hint_dedicated")

    @_builtins.property
    @pulumi.getter(name="pollControl")
    def poll_control(self) -> Optional['outputs.DomainFeaturesKvmPollControl']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "poll_control")

    @_builtins.property
    @pulumi.getter
    def pvipi(self) -> Optional['outputs.DomainFeaturesKvmPvipi']:
        """
        Controls whether the hypervisor exposes legacy PS/2 controller semantics as a CPU/machine feature toggle for the guest.
        """
        return pulumi.get(self, "pvipi")


@pulumi.output_type
class DomainFeaturesKvmDirtyRing(dict):
    def __init__(__self__, *,
                 size: Optional[_builtins.float] = None):
        """
        :param _builtins.float size: Sets the size of the KVM dirty-ring buffer used for memory dirty tracking; the value is user-provided and must be a positive integer representing the number of slots in the ring (exact limits depend on the host kernel/QEMU).
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.float]:
        """
        Sets the size of the KVM dirty-ring buffer used for memory dirty tracking; the value is user-provided and must be a positive integer representing the number of slots in the ring (exact limits depend on the host kernel/QEMU).

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class DomainFeaturesKvmHidden(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesKvmHintDedicated(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesKvmPollControl(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesKvmPvipi(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesMsrs(dict):
    def __init__(__self__, *,
                 unknown: _builtins.str):
        """
        :param _builtins.str unknown: Sets the policy for unknown MSR accesses by the guest; valid values are driver-specific (commonly "ignore", "warn", or "fault") and must be provided explicitly.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        pulumi.set(__self__, "unknown", unknown)

    @_builtins.property
    @pulumi.getter
    def unknown(self) -> _builtins.str:
        """
        Sets the policy for unknown MSR accesses by the guest; valid values are driver-specific (commonly "ignore", "warn", or "fault") and must be provided explicitly.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "unknown")


@pulumi.output_type
class DomainFeaturesNestedHv(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesPmu(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesPs2(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesPvSpinlock(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesRas(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesSbbc(dict):
    def __init__(__self__, *,
                 value: _builtins.str):
        """
        :param _builtins.str value: Sets the SBBC mitigation mode as a user-provided value (for example "on", "off", or a model-specific keyword, depending on hypervisor support); this attribute is required when sbbc is present.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Sets the SBBC mitigation mode as a user-provided value (for example "on", "off", or a model-specific keyword, depending on hypervisor support); this attribute is required when sbbc is present.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainFeaturesSmm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tsegUnit":
            suggest = "tseg_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainFeaturesSmm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainFeaturesSmm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainFeaturesSmm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None,
                 tseg: Optional[_builtins.float] = None,
                 tseg_unit: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Controls whether SMM is enabled via a state flag (typically "on" or "off"; the exact accepted values are hypervisor-dependent).
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        :param _builtins.float tseg: Sets the size of the TSEG (SMRAM) memory area used by SMM, with the numeric quantity paired with tseg_unit (for example 64 with unit "MiB").
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        :param _builtins.str tseg_unit: Specifies the unit used for the SMM TSEG size, paired with smm.tseg (for example "KiB", "MiB", or "GiB"); the concrete unit string is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)
        if tseg is not None:
            pulumi.set(__self__, "tseg", tseg)
        if tseg_unit is not None:
            pulumi.set(__self__, "tseg_unit", tseg_unit)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Controls whether SMM is enabled via a state flag (typically "on" or "off"; the exact accepted values are hypervisor-dependent).

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def tseg(self) -> Optional[_builtins.float]:
        """
        Sets the size of the TSEG (SMRAM) memory area used by SMM, with the numeric quantity paired with tseg_unit (for example 64 with unit "MiB").

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "tseg")

    @_builtins.property
    @pulumi.getter(name="tsegUnit")
    def tseg_unit(self) -> Optional[_builtins.str]:
        """
        Specifies the unit used for the SMM TSEG size, paired with smm.tseg (for example "KiB", "MiB", or "GiB"); the concrete unit string is user-provided.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "tseg_unit")


@pulumi.output_type
class DomainFeaturesTcg(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tbCache":
            suggest = "tb_cache"
        elif key == "tbCacheUnit":
            suggest = "tb_cache_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainFeaturesTcg. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainFeaturesTcg.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainFeaturesTcg.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tb_cache: Optional[_builtins.float] = None,
                 tb_cache_unit: Optional[_builtins.str] = None):
        """
        :param _builtins.float tb_cache: Sets the size of the TCG translation block cache, with the numeric value paired with tb_cache_unit (for example 128 with unit "MiB").
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        :param _builtins.str tb_cache_unit: Specifies the unit used for the TCG translation block cache size, paired with tcg.tb_cache (for example "KiB", "MiB", or "GiB"); the exact unit string is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if tb_cache is not None:
            pulumi.set(__self__, "tb_cache", tb_cache)
        if tb_cache_unit is not None:
            pulumi.set(__self__, "tb_cache_unit", tb_cache_unit)

    @_builtins.property
    @pulumi.getter(name="tbCache")
    def tb_cache(self) -> Optional[_builtins.float]:
        """
        Sets the size of the TCG translation block cache, with the numeric value paired with tb_cache_unit (for example 128 with unit "MiB").

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "tb_cache")

    @_builtins.property
    @pulumi.getter(name="tbCacheUnit")
    def tb_cache_unit(self) -> Optional[_builtins.str]:
        """
        Specifies the unit used for the TCG translation block cache size, paired with tcg.tb_cache (for example "KiB", "MiB", or "GiB"); the exact unit string is user-provided.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "tb_cache_unit")


@pulumi.output_type
class DomainFeaturesVmCoreInfo(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesVmPort(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets the PS2 feature state; valid values are usually "on" or "off" to enable or disable the PS/2-related feature for the domain.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesXen(dict):
    def __init__(__self__, *,
                 e820host: Optional['outputs.DomainFeaturesXenE820host'] = None,
                 passthrough: Optional['outputs.DomainFeaturesXenPassthrough'] = None):
        """
        :param 'DomainFeaturesXenE820hostArgs' e820host: Enables or disables use of the hosts E820 memory map when exposing Xen emulation to the guest, typically as a yes/no style toggle (value is user-provided such as "on"/"off").
        :param 'DomainFeaturesXenPassthroughArgs' passthrough: Enables configuration of Xen passthrough-related features for the domain; presence of this block determines whether passthrough suboptions can be set.
        """
        if e820host is not None:
            pulumi.set(__self__, "e820host", e820host)
        if passthrough is not None:
            pulumi.set(__self__, "passthrough", passthrough)

    @_builtins.property
    @pulumi.getter
    def e820host(self) -> Optional['outputs.DomainFeaturesXenE820host']:
        """
        Enables or disables use of the hosts E820 memory map when exposing Xen emulation to the guest, typically as a yes/no style toggle (value is user-provided such as "on"/"off").
        """
        return pulumi.get(self, "e820host")

    @_builtins.property
    @pulumi.getter
    def passthrough(self) -> Optional['outputs.DomainFeaturesXenPassthrough']:
        """
        Enables configuration of Xen passthrough-related features for the domain; presence of this block determines whether passthrough suboptions can be set.
        """
        return pulumi.get(self, "passthrough")


@pulumi.output_type
class DomainFeaturesXenE820host(dict):
    def __init__(__self__, *,
                 state: _builtins.str):
        """
        :param _builtins.str state: Sets whether the Xen e820_host feature is enabled for the guest; accepts the string values "on" or "off" and is required when the xen.e820host feature is present.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        Sets whether the Xen e820_host feature is enabled for the guest; accepts the string values "on" or "off" and is required when the xen.e820host feature is present.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainFeaturesXenPassthrough(dict):
    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str mode: Sets the Xen passthrough mode for the domain; the value is user-provided and must be a valid mode string recognized by the underlying Xen/libvirt version (for example, a specific IOMMU or passthrough mode).
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        :param _builtins.str state: Sets whether Xen passthrough is enabled; accepts the string values "on" or "off" when the passthrough block is defined.
               
               See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the Xen passthrough mode for the domain; the value is user-provided and must be a valid mode string recognized by the underlying Xen/libvirt version (for example, a specific IOMMU or passthrough mode).

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Sets whether Xen passthrough is enabled; accepts the string values "on" or "off" when the passthrough block is defined.

        See: <https://libvirt.org/formatdomain.html#hypervisor-features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainIdMap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "giDs":
            suggest = "gi_ds"
        elif key == "uiDs":
            suggest = "ui_ds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainIdMap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainIdMap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainIdMap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gi_ds: Optional[Sequence['outputs.DomainIdMapGiD']] = None,
                 ui_ds: Optional[Sequence['outputs.DomainIdMapUiD']] = None):
        """
        :param Sequence['DomainIdMapGiDArgs'] gi_ds: Defines one or more guest-to-host GID mapping ranges used for ID translation; each entry specifies a contiguous gid range.
               
               See: <https://libvirt.org/formatdomain.html#container-boot>
        :param Sequence['DomainIdMapUiDArgs'] ui_ds: Defines one or more guest-to-host UID mapping ranges used for ID translation; each entry specifies a contiguous uid range.
               
               See: <https://libvirt.org/formatdomain.html#container-boot>
        """
        if gi_ds is not None:
            pulumi.set(__self__, "gi_ds", gi_ds)
        if ui_ds is not None:
            pulumi.set(__self__, "ui_ds", ui_ds)

    @_builtins.property
    @pulumi.getter(name="giDs")
    def gi_ds(self) -> Optional[Sequence['outputs.DomainIdMapGiD']]:
        """
        Defines one or more guest-to-host GID mapping ranges used for ID translation; each entry specifies a contiguous gid range.

        See: <https://libvirt.org/formatdomain.html#container-boot>
        """
        return pulumi.get(self, "gi_ds")

    @_builtins.property
    @pulumi.getter(name="uiDs")
    def ui_ds(self) -> Optional[Sequence['outputs.DomainIdMapUiD']]:
        """
        Defines one or more guest-to-host UID mapping ranges used for ID translation; each entry specifies a contiguous uid range.

        See: <https://libvirt.org/formatdomain.html#container-boot>
        """
        return pulumi.get(self, "ui_ds")


@pulumi.output_type
class DomainIdMapGiD(dict):
    def __init__(__self__, *,
                 count: _builtins.float,
                 start: _builtins.float,
                 target: _builtins.float):
        """
        :param _builtins.float count: Sets the number of consecutive GIDs in this mapping range; must be a positive integer.
               
               See: <https://libvirt.org/formatdomain.html#container-boot>
        :param _builtins.float start: Sets the starting guest GID for this mapping range; must be a non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#container-boot>
        :param _builtins.float target: Sets the starting host GID that the guest GIDs in this range are mapped to; must be a non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#container-boot>
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "start", start)
        pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.float:
        """
        Sets the number of consecutive GIDs in this mapping range; must be a positive integer.

        See: <https://libvirt.org/formatdomain.html#container-boot>
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def start(self) -> _builtins.float:
        """
        Sets the starting guest GID for this mapping range; must be a non-negative integer.

        See: <https://libvirt.org/formatdomain.html#container-boot>
        """
        return pulumi.get(self, "start")

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.float:
        """
        Sets the starting host GID that the guest GIDs in this range are mapped to; must be a non-negative integer.

        See: <https://libvirt.org/formatdomain.html#container-boot>
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class DomainIdMapUiD(dict):
    def __init__(__self__, *,
                 count: _builtins.float,
                 start: _builtins.float,
                 target: _builtins.float):
        """
        :param _builtins.float count: Sets the number of consecutive GIDs in this mapping range; must be a positive integer.
               
               See: <https://libvirt.org/formatdomain.html#container-boot>
        :param _builtins.float start: Sets the starting guest GID for this mapping range; must be a non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#container-boot>
        :param _builtins.float target: Sets the starting host GID that the guest GIDs in this range are mapped to; must be a non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#container-boot>
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "start", start)
        pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.float:
        """
        Sets the number of consecutive GIDs in this mapping range; must be a positive integer.

        See: <https://libvirt.org/formatdomain.html#container-boot>
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def start(self) -> _builtins.float:
        """
        Sets the starting guest GID for this mapping range; must be a non-negative integer.

        See: <https://libvirt.org/formatdomain.html#container-boot>
        """
        return pulumi.get(self, "start")

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.float:
        """
        Sets the starting host GID that the guest GIDs in this range are mapped to; must be a non-negative integer.

        See: <https://libvirt.org/formatdomain.html#container-boot>
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class DomainIoThreadIDs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ioThreads":
            suggest = "io_threads"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainIoThreadIDs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainIoThreadIDs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainIoThreadIDs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 io_threads: Optional[Sequence['outputs.DomainIoThreadIDsIoThread']] = None):
        """
        :param Sequence['DomainIoThreadIDsIoThreadArgs'] io_threads: Defines an individual IOThread entry within the IOThread ID set, optionally with per-thread tuning such as polling.
               
               See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
        """
        if io_threads is not None:
            pulumi.set(__self__, "io_threads", io_threads)

    @_builtins.property
    @pulumi.getter(name="ioThreads")
    def io_threads(self) -> Optional[Sequence['outputs.DomainIoThreadIDsIoThread']]:
        """
        Defines an individual IOThread entry within the IOThread ID set, optionally with per-thread tuning such as polling.

        See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
        """
        return pulumi.get(self, "io_threads")


@pulumi.output_type
class DomainIoThreadIDsIoThread(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolMax":
            suggest = "pool_max"
        elif key == "poolMin":
            suggest = "pool_min"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainIoThreadIDsIoThread. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainIoThreadIDsIoThread.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainIoThreadIDsIoThread.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[_builtins.float] = None,
                 poll: Optional['outputs.DomainIoThreadIDsIoThreadPoll'] = None,
                 pool_max: Optional[_builtins.float] = None,
                 pool_min: Optional[_builtins.float] = None):
        """
        :param _builtins.float id: Exposes or sets the numeric ID for this IOThread; when omitted it is assigned/computed by libvirt and is treated as read-only in the plan.
               
               See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
        :param 'DomainIoThreadIDsIoThreadPollArgs' poll: Sets the polling configuration for this IOThread (for example enabling or tuning busy-poll behavior); value is user-provided and must be a valid polling specification supported by libvirt/QEMU.
        :param _builtins.float pool_max: Sets the maximum size of the IOThreads internal poll thread pool via thread_pool_max; the value is userprovided (typically a positive integer).
               
               See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
        :param _builtins.float pool_min: Sets the minimum size of the IOThreads internal poll thread pool via thread_pool_min; the value is userprovided (typically a nonnegative integer).
               
               See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if poll is not None:
            pulumi.set(__self__, "poll", poll)
        if pool_max is not None:
            pulumi.set(__self__, "pool_max", pool_max)
        if pool_min is not None:
            pulumi.set(__self__, "pool_min", pool_min)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.float]:
        """
        Exposes or sets the numeric ID for this IOThread; when omitted it is assigned/computed by libvirt and is treated as read-only in the plan.

        See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def poll(self) -> Optional['outputs.DomainIoThreadIDsIoThreadPoll']:
        """
        Sets the polling configuration for this IOThread (for example enabling or tuning busy-poll behavior); value is user-provided and must be a valid polling specification supported by libvirt/QEMU.
        """
        return pulumi.get(self, "poll")

    @_builtins.property
    @pulumi.getter(name="poolMax")
    def pool_max(self) -> Optional[_builtins.float]:
        """
        Sets the maximum size of the IOThreads internal poll thread pool via thread_pool_max; the value is userprovided (typically a positive integer).

        See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
        """
        return pulumi.get(self, "pool_max")

    @_builtins.property
    @pulumi.getter(name="poolMin")
    def pool_min(self) -> Optional[_builtins.float]:
        """
        Sets the minimum size of the IOThreads internal poll thread pool via thread_pool_min; the value is userprovided (typically a nonnegative integer).

        See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
        """
        return pulumi.get(self, "pool_min")


@pulumi.output_type
class DomainIoThreadIDsIoThreadPoll(dict):
    def __init__(__self__, *,
                 grow: Optional[_builtins.float] = None,
                 max: Optional[_builtins.float] = None,
                 shrink: Optional[_builtins.float] = None):
        """
        :param _builtins.float grow: Sets the per-IOThread poll configurations grow threshold, controlling how aggressively the IOThread poll mode ramps up; the value is user-provided (typically a nonnegative integer).
               
               See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
        :param _builtins.float max: Sets the maximum polling threshold for the IOThread, limiting how far the poll mode can scale; the value is user-provided (typically a nonnegative integer).
               
               See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
        :param _builtins.float shrink: Sets the per-IOThread poll configurations shrink threshold, controlling how quickly the IOThread backs off from poll mode; the value is user-provided (typically a nonnegative integer).
               
               See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
        """
        if grow is not None:
            pulumi.set(__self__, "grow", grow)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if shrink is not None:
            pulumi.set(__self__, "shrink", shrink)

    @_builtins.property
    @pulumi.getter
    def grow(self) -> Optional[_builtins.float]:
        """
        Sets the per-IOThread poll configurations grow threshold, controlling how aggressively the IOThread poll mode ramps up; the value is user-provided (typically a nonnegative integer).

        See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
        """
        return pulumi.get(self, "grow")

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        """
        Sets the maximum polling threshold for the IOThread, limiting how far the poll mode can scale; the value is user-provided (typically a nonnegative integer).

        See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def shrink(self) -> Optional[_builtins.float]:
        """
        Sets the per-IOThread poll configurations shrink threshold, controlling how quickly the IOThread backs off from poll mode; the value is user-provided (typically a nonnegative integer).

        See: <https://libvirt.org/formatdomain.html#iothreads-allocation>
        """
        return pulumi.get(self, "shrink")


@pulumi.output_type
class DomainKeyWrap(dict):
    def __init__(__self__, *,
                 ciphers: Optional[Sequence['outputs.DomainKeyWrapCipher']] = None):
        """
        :param Sequence['DomainKeyWrapCipherArgs'] ciphers: Defines one or more ciphers that can be used for s390 key-wrapping operations, each with its own name and enable/disable state.
               
               See: <https://libvirt.org/formatdomain.html#key-wrap>
        """
        if ciphers is not None:
            pulumi.set(__self__, "ciphers", ciphers)

    @_builtins.property
    @pulumi.getter
    def ciphers(self) -> Optional[Sequence['outputs.DomainKeyWrapCipher']]:
        """
        Defines one or more ciphers that can be used for s390 key-wrapping operations, each with its own name and enable/disable state.

        See: <https://libvirt.org/formatdomain.html#key-wrap>
        """
        return pulumi.get(self, "ciphers")


@pulumi.output_type
class DomainKeyWrapCipher(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 state: _builtins.str):
        """
        :param _builtins.str name: Sets the cipher name used for s390 key-wrapping, typically aes or dea; the value is required and must match a cipher supported by the host/firmware.
               
               See: <https://libvirt.org/formatdomain.html#key-wrap>
        :param _builtins.str state: Sets whether the given key-wrap cipher is enabled or disabled, using the required values "on" or "off".
               
               See: <https://libvirt.org/formatdomain.html#key-wrap>
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the cipher name used for s390 key-wrapping, typically aes or dea; the value is required and must match a cipher supported by the host/firmware.

        See: <https://libvirt.org/formatdomain.html#key-wrap>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        Sets whether the given key-wrap cipher is enabled or disabled, using the required values "on" or "off".

        See: <https://libvirt.org/formatdomain.html#key-wrap>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DomainLaunchSecurity(dict):
    def __init__(__self__, *,
                 s390pv: Optional[_builtins.bool] = None,
                 sev: Optional['outputs.DomainLaunchSecuritySev'] = None,
                 sevsnp: Optional['outputs.DomainLaunchSecuritySevsnp'] = None,
                 tdx: Optional['outputs.DomainLaunchSecurityTdx'] = None):
        """
        :param _builtins.bool s390pv: Enables s390 protected virtualization (IBM Secure Execution) for the domain when set to true; if absent/false, s390pv launch security is not configured.
               
               See: <https://libvirt.org/formatdomain.html#launch-security>
        :param 'DomainLaunchSecuritySevArgs' sev: Configures AMD SEV launch security parameters for the domain, such as policy, certificates, and reduced physical address bits.
        :param 'DomainLaunchSecuritySevsnpArgs' sevsnp: Configures AMD SEV-SNP launch security parameters for the domain, extending SEV with additional integrity and security features; the subfields (if any) are userprovided.
        :param 'DomainLaunchSecurityTdxArgs' tdx: Enables Intel TDX launch security configuration for the domain and groups all TDX-specific measurement and policy options; presence configures the domain to run as a TDX guest.
        """
        if s390pv is not None:
            pulumi.set(__self__, "s390pv", s390pv)
        if sev is not None:
            pulumi.set(__self__, "sev", sev)
        if sevsnp is not None:
            pulumi.set(__self__, "sevsnp", sevsnp)
        if tdx is not None:
            pulumi.set(__self__, "tdx", tdx)

    @_builtins.property
    @pulumi.getter
    def s390pv(self) -> Optional[_builtins.bool]:
        """
        Enables s390 protected virtualization (IBM Secure Execution) for the domain when set to true; if absent/false, s390pv launch security is not configured.

        See: <https://libvirt.org/formatdomain.html#launch-security>
        """
        return pulumi.get(self, "s390pv")

    @_builtins.property
    @pulumi.getter
    def sev(self) -> Optional['outputs.DomainLaunchSecuritySev']:
        """
        Configures AMD SEV launch security parameters for the domain, such as policy, certificates, and reduced physical address bits.
        """
        return pulumi.get(self, "sev")

    @_builtins.property
    @pulumi.getter
    def sevsnp(self) -> Optional['outputs.DomainLaunchSecuritySevsnp']:
        """
        Configures AMD SEV-SNP launch security parameters for the domain, extending SEV with additional integrity and security features; the subfields (if any) are userprovided.
        """
        return pulumi.get(self, "sevsnp")

    @_builtins.property
    @pulumi.getter
    def tdx(self) -> Optional['outputs.DomainLaunchSecurityTdx']:
        """
        Enables Intel TDX launch security configuration for the domain and groups all TDX-specific measurement and policy options; presence configures the domain to run as a TDX guest.
        """
        return pulumi.get(self, "tdx")


@pulumi.output_type
class DomainLaunchSecuritySev(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dhCert":
            suggest = "dh_cert"
        elif key == "cbitPos":
            suggest = "cbit_pos"
        elif key == "kernelHashes":
            suggest = "kernel_hashes"
        elif key == "reducedPhysBits":
            suggest = "reduced_phys_bits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainLaunchSecuritySev. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainLaunchSecuritySev.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainLaunchSecuritySev.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dh_cert: _builtins.str,
                 session: _builtins.str,
                 cbit_pos: Optional[_builtins.float] = None,
                 kernel_hashes: Optional[_builtins.str] = None,
                 policy: Optional[_builtins.float] = None,
                 reduced_phys_bits: Optional[_builtins.float] = None):
        """
        :param _builtins.str dh_cert: Provides the required DiffieHellman certificate blob for establishing an SEV launch session; the value is userprovided (e.g., base64 or binary content as required by the SEV tooling).
               
               See: <https://libvirt.org/formatdomain.html#launch-security>
        :param _builtins.str session: Provides the required SEV session blob (e.g., launch session parameters or ticket) used to establish a protected guest; the value is userprovided according to SEV tooling.
               
               See: <https://libvirt.org/formatdomain.html#launch-security>
        :param _builtins.float cbit_pos: Sets the Cbit position for AMD SEV, indicating which guest-physical address bit marks encrypted memory; the value is userprovided (typically an integer matching host configuration).
               
               See: <https://libvirt.org/formatdomain.html#launch-security>
        :param _builtins.str kernel_hashes: Enables or disables validation of kernel hashes for SEV by specifying a kernelHashes attribute value; the value is userprovided (commonly "yes"/"no" or an implementation-defined flag).
               
               See: <https://libvirt.org/formatdomain.html#launch-security>
        :param _builtins.float policy: Sets the SEV policy value controlling allowed guest behaviors (e.g., debugging, migration); the value is userprovided, often as a bitmask or integer from SEV documentation.
               
               See: <https://libvirt.org/formatdomain.html#launch-security>
        :param _builtins.float reduced_phys_bits: Sets the number of reduced physical address bits for SEV, aligning guest addressing with host SEV constraints; the value is userprovided (typically an integer).
               
               See: <https://libvirt.org/formatdomain.html#launch-security>
        """
        pulumi.set(__self__, "dh_cert", dh_cert)
        pulumi.set(__self__, "session", session)
        if cbit_pos is not None:
            pulumi.set(__self__, "cbit_pos", cbit_pos)
        if kernel_hashes is not None:
            pulumi.set(__self__, "kernel_hashes", kernel_hashes)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if reduced_phys_bits is not None:
            pulumi.set(__self__, "reduced_phys_bits", reduced_phys_bits)

    @_builtins.property
    @pulumi.getter(name="dhCert")
    def dh_cert(self) -> _builtins.str:
        """
        Provides the required DiffieHellman certificate blob for establishing an SEV launch session; the value is userprovided (e.g., base64 or binary content as required by the SEV tooling).

        See: <https://libvirt.org/formatdomain.html#launch-security>
        """
        return pulumi.get(self, "dh_cert")

    @_builtins.property
    @pulumi.getter
    def session(self) -> _builtins.str:
        """
        Provides the required SEV session blob (e.g., launch session parameters or ticket) used to establish a protected guest; the value is userprovided according to SEV tooling.

        See: <https://libvirt.org/formatdomain.html#launch-security>
        """
        return pulumi.get(self, "session")

    @_builtins.property
    @pulumi.getter(name="cbitPos")
    def cbit_pos(self) -> Optional[_builtins.float]:
        """
        Sets the Cbit position for AMD SEV, indicating which guest-physical address bit marks encrypted memory; the value is userprovided (typically an integer matching host configuration).

        See: <https://libvirt.org/formatdomain.html#launch-security>
        """
        return pulumi.get(self, "cbit_pos")

    @_builtins.property
    @pulumi.getter(name="kernelHashes")
    def kernel_hashes(self) -> Optional[_builtins.str]:
        """
        Enables or disables validation of kernel hashes for SEV by specifying a kernelHashes attribute value; the value is userprovided (commonly "yes"/"no" or an implementation-defined flag).

        See: <https://libvirt.org/formatdomain.html#launch-security>
        """
        return pulumi.get(self, "kernel_hashes")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[_builtins.float]:
        """
        Sets the SEV policy value controlling allowed guest behaviors (e.g., debugging, migration); the value is userprovided, often as a bitmask or integer from SEV documentation.

        See: <https://libvirt.org/formatdomain.html#launch-security>
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter(name="reducedPhysBits")
    def reduced_phys_bits(self) -> Optional[_builtins.float]:
        """
        Sets the number of reduced physical address bits for SEV, aligning guest addressing with host SEV constraints; the value is userprovided (typically an integer).

        See: <https://libvirt.org/formatdomain.html#launch-security>
        """
        return pulumi.get(self, "reduced_phys_bits")


@pulumi.output_type
class DomainLaunchSecuritySevsnp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorKey":
            suggest = "author_key"
        elif key == "cbitPos":
            suggest = "cbit_pos"
        elif key == "guestVisibleWorkarounds":
            suggest = "guest_visible_workarounds"
        elif key == "hostData":
            suggest = "host_data"
        elif key == "idAuth":
            suggest = "id_auth"
        elif key == "idBlock":
            suggest = "id_block"
        elif key == "kernelHashes":
            suggest = "kernel_hashes"
        elif key == "reducedPhysBits":
            suggest = "reduced_phys_bits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainLaunchSecuritySevsnp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainLaunchSecuritySevsnp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainLaunchSecuritySevsnp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 author_key: Optional[_builtins.str] = None,
                 cbit_pos: Optional[_builtins.float] = None,
                 guest_visible_workarounds: Optional[_builtins.str] = None,
                 host_data: Optional[_builtins.str] = None,
                 id_auth: Optional[_builtins.str] = None,
                 id_block: Optional[_builtins.str] = None,
                 kernel_hashes: Optional[_builtins.str] = None,
                 policy: Optional[_builtins.float] = None,
                 reduced_phys_bits: Optional[_builtins.float] = None,
                 vcek: Optional[_builtins.str] = None):
        """
        :param _builtins.str author_key: Sets the SEV-SNP author key blob used to validate the guests identity when SEV-SNP launch security is enabled; the value is user-provided binary data (typically base64-encoded).
               
               See: <https://libvirt.org/formatdomain.html#launch-security>
        :param _builtins.float cbit_pos: Sets the SEV-SNP C-bit position (cbitpos) indicating which guest-physical address bit marks encrypted memory; value is user-provided and must match the host SEV-SNP configuration.
               
               See: <https://libvirt.org/formatdomain.html#launch-security>
        :param _builtins.str guest_visible_workarounds: Sets the SEV-SNP guestVisibleWorkarounds flag or bitmap controlling which SEV-SNP hardware or microcode workarounds are exposed to the guest; value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#launch-security>
        :param _builtins.str host_data: Provides an optional SEV-SNP hostData blob passed into the SEV-SNP launch flow for attestation purposes; the value is user-provided binary data (commonly base64-encoded).
               
               See: <https://libvirt.org/formatdomain.html#launch-security>
        :param _builtins.str id_auth: Supplies the SEV-SNP idAuth structure used to authenticate the guests identity as part of the SEV-SNP launch; value is user-provided binary data from the SEV tooling.
               
               See: <https://libvirt.org/formatdomain.html#launch-security>
        :param _builtins.str id_block: Supplies the SEV-SNP idBlock structure defining the guest identity and policy for SEV-SNP launch; value is user-provided binary data from the SEV tooling.
               
               See: <https://libvirt.org/formatdomain.html#launch-security>
        :param _builtins.str kernel_hashes: Points to a file containing kernel hash metadata for SEV-SNP attestation when SEV-SNP launch security is enabled; value is a user-provided path string.
               
               See: <https://libvirt.org/formatdomain.html#launch-security>
        :param _builtins.float policy: Sets the SEV-SNP guest policy value (bitfield) governing allowed debug, migration, and other behaviors; value is user-provided, commonly expressed as an integer or hex string.
               
               See: <https://libvirt.org/formatdomain.html#launch-security>
        :param _builtins.float reduced_phys_bits: Sets the number of reduced physical address bits (reducedPhysBits) for SEV-SNP, matching the host configuration; value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#launch-security>
        :param _builtins.str vcek: Points to a file with the SEV-SNP VCEK (Versioned Chip Endorsement Key) certificate used for attestation; value is a user-provided path string.
               
               See: <https://libvirt.org/formatdomain.html#launch-security>
        """
        if author_key is not None:
            pulumi.set(__self__, "author_key", author_key)
        if cbit_pos is not None:
            pulumi.set(__self__, "cbit_pos", cbit_pos)
        if guest_visible_workarounds is not None:
            pulumi.set(__self__, "guest_visible_workarounds", guest_visible_workarounds)
        if host_data is not None:
            pulumi.set(__self__, "host_data", host_data)
        if id_auth is not None:
            pulumi.set(__self__, "id_auth", id_auth)
        if id_block is not None:
            pulumi.set(__self__, "id_block", id_block)
        if kernel_hashes is not None:
            pulumi.set(__self__, "kernel_hashes", kernel_hashes)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if reduced_phys_bits is not None:
            pulumi.set(__self__, "reduced_phys_bits", reduced_phys_bits)
        if vcek is not None:
            pulumi.set(__self__, "vcek", vcek)

    @_builtins.property
    @pulumi.getter(name="authorKey")
    def author_key(self) -> Optional[_builtins.str]:
        """
        Sets the SEV-SNP author key blob used to validate the guests identity when SEV-SNP launch security is enabled; the value is user-provided binary data (typically base64-encoded).

        See: <https://libvirt.org/formatdomain.html#launch-security>
        """
        return pulumi.get(self, "author_key")

    @_builtins.property
    @pulumi.getter(name="cbitPos")
    def cbit_pos(self) -> Optional[_builtins.float]:
        """
        Sets the SEV-SNP C-bit position (cbitpos) indicating which guest-physical address bit marks encrypted memory; value is user-provided and must match the host SEV-SNP configuration.

        See: <https://libvirt.org/formatdomain.html#launch-security>
        """
        return pulumi.get(self, "cbit_pos")

    @_builtins.property
    @pulumi.getter(name="guestVisibleWorkarounds")
    def guest_visible_workarounds(self) -> Optional[_builtins.str]:
        """
        Sets the SEV-SNP guestVisibleWorkarounds flag or bitmap controlling which SEV-SNP hardware or microcode workarounds are exposed to the guest; value is user-provided.

        See: <https://libvirt.org/formatdomain.html#launch-security>
        """
        return pulumi.get(self, "guest_visible_workarounds")

    @_builtins.property
    @pulumi.getter(name="hostData")
    def host_data(self) -> Optional[_builtins.str]:
        """
        Provides an optional SEV-SNP hostData blob passed into the SEV-SNP launch flow for attestation purposes; the value is user-provided binary data (commonly base64-encoded).

        See: <https://libvirt.org/formatdomain.html#launch-security>
        """
        return pulumi.get(self, "host_data")

    @_builtins.property
    @pulumi.getter(name="idAuth")
    def id_auth(self) -> Optional[_builtins.str]:
        """
        Supplies the SEV-SNP idAuth structure used to authenticate the guests identity as part of the SEV-SNP launch; value is user-provided binary data from the SEV tooling.

        See: <https://libvirt.org/formatdomain.html#launch-security>
        """
        return pulumi.get(self, "id_auth")

    @_builtins.property
    @pulumi.getter(name="idBlock")
    def id_block(self) -> Optional[_builtins.str]:
        """
        Supplies the SEV-SNP idBlock structure defining the guest identity and policy for SEV-SNP launch; value is user-provided binary data from the SEV tooling.

        See: <https://libvirt.org/formatdomain.html#launch-security>
        """
        return pulumi.get(self, "id_block")

    @_builtins.property
    @pulumi.getter(name="kernelHashes")
    def kernel_hashes(self) -> Optional[_builtins.str]:
        """
        Points to a file containing kernel hash metadata for SEV-SNP attestation when SEV-SNP launch security is enabled; value is a user-provided path string.

        See: <https://libvirt.org/formatdomain.html#launch-security>
        """
        return pulumi.get(self, "kernel_hashes")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[_builtins.float]:
        """
        Sets the SEV-SNP guest policy value (bitfield) governing allowed debug, migration, and other behaviors; value is user-provided, commonly expressed as an integer or hex string.

        See: <https://libvirt.org/formatdomain.html#launch-security>
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter(name="reducedPhysBits")
    def reduced_phys_bits(self) -> Optional[_builtins.float]:
        """
        Sets the number of reduced physical address bits (reducedPhysBits) for SEV-SNP, matching the host configuration; value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#launch-security>
        """
        return pulumi.get(self, "reduced_phys_bits")

    @_builtins.property
    @pulumi.getter
    def vcek(self) -> Optional[_builtins.str]:
        """
        Points to a file with the SEV-SNP VCEK (Versioned Chip Endorsement Key) certificate used for attestation; value is a user-provided path string.

        See: <https://libvirt.org/formatdomain.html#launch-security>
        """
        return pulumi.get(self, "vcek")


@pulumi.output_type
class DomainLaunchSecurityTdx(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mrConfigId":
            suggest = "mr_config_id"
        elif key == "mrOwner":
            suggest = "mr_owner"
        elif key == "mrOwnerConfig":
            suggest = "mr_owner_config"
        elif key == "quoteGenerationService":
            suggest = "quote_generation_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainLaunchSecurityTdx. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainLaunchSecurityTdx.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainLaunchSecurityTdx.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mr_config_id: Optional[_builtins.str] = None,
                 mr_owner: Optional[_builtins.str] = None,
                 mr_owner_config: Optional[_builtins.str] = None,
                 policy: Optional[_builtins.float] = None,
                 quote_generation_service: Optional['outputs.DomainLaunchSecurityTdxQuoteGenerationService'] = None):
        """
        :param _builtins.str mr_config_id: Sets the TDX mrConfigId measurement value representing the guest configuration identity; value is user-provided binary/hex data from the TDX tooling.
               
               See: <https://libvirt.org/formatdomain.html#launch-security>
        :param _builtins.str mr_owner: Sets the TDX mrOwner measurement value representing the owner of the guest; value is user-provided binary/hex data from the TDX tooling.
               
               See: <https://libvirt.org/formatdomain.html#launch-security>
        :param _builtins.str mr_owner_config: Sets the TDX mrOwnerConfig measurement value describing the owner-specific configuration; value is user-provided binary/hex data from the TDX tooling.
               
               See: <https://libvirt.org/formatdomain.html#launch-security>
        :param _builtins.float policy: Sets the TDX guest policy bitfield controlling allowed operations (such as debug or migration); value is user-provided, typically as an integer or hex string.
               
               See: <https://libvirt.org/formatdomain.html#launch-security>
        :param 'DomainLaunchSecurityTdxQuoteGenerationServiceArgs' quote_generation_service: Configures an optional TDX quoteGenerationService, which specifies how attestation quotes are generated for the guest; child attributes further describe the service endpoint.
        """
        if mr_config_id is not None:
            pulumi.set(__self__, "mr_config_id", mr_config_id)
        if mr_owner is not None:
            pulumi.set(__self__, "mr_owner", mr_owner)
        if mr_owner_config is not None:
            pulumi.set(__self__, "mr_owner_config", mr_owner_config)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if quote_generation_service is not None:
            pulumi.set(__self__, "quote_generation_service", quote_generation_service)

    @_builtins.property
    @pulumi.getter(name="mrConfigId")
    def mr_config_id(self) -> Optional[_builtins.str]:
        """
        Sets the TDX mrConfigId measurement value representing the guest configuration identity; value is user-provided binary/hex data from the TDX tooling.

        See: <https://libvirt.org/formatdomain.html#launch-security>
        """
        return pulumi.get(self, "mr_config_id")

    @_builtins.property
    @pulumi.getter(name="mrOwner")
    def mr_owner(self) -> Optional[_builtins.str]:
        """
        Sets the TDX mrOwner measurement value representing the owner of the guest; value is user-provided binary/hex data from the TDX tooling.

        See: <https://libvirt.org/formatdomain.html#launch-security>
        """
        return pulumi.get(self, "mr_owner")

    @_builtins.property
    @pulumi.getter(name="mrOwnerConfig")
    def mr_owner_config(self) -> Optional[_builtins.str]:
        """
        Sets the TDX mrOwnerConfig measurement value describing the owner-specific configuration; value is user-provided binary/hex data from the TDX tooling.

        See: <https://libvirt.org/formatdomain.html#launch-security>
        """
        return pulumi.get(self, "mr_owner_config")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[_builtins.float]:
        """
        Sets the TDX guest policy bitfield controlling allowed operations (such as debug or migration); value is user-provided, typically as an integer or hex string.

        See: <https://libvirt.org/formatdomain.html#launch-security>
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter(name="quoteGenerationService")
    def quote_generation_service(self) -> Optional['outputs.DomainLaunchSecurityTdxQuoteGenerationService']:
        """
        Configures an optional TDX quoteGenerationService, which specifies how attestation quotes are generated for the guest; child attributes further describe the service endpoint.
        """
        return pulumi.get(self, "quote_generation_service")


@pulumi.output_type
class DomainLaunchSecurityTdxQuoteGenerationService(dict):
    def __init__(__self__, *,
                 path: Optional[_builtins.str] = None):
        """
        :param _builtins.str path: Sets the path used by the TDX quote generation service (for example, a socket or device path) for obtaining attestation quotes; value is a user-provided string.
               
               See: <https://libvirt.org/formatdomain.html#launch-security>
        """
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Sets the path used by the TDX quote generation service (for example, a socket or device path) for obtaining attestation quotes; value is a user-provided string.

        See: <https://libvirt.org/formatdomain.html#launch-security>
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DomainMemoryBacking(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memoryAccess":
            suggest = "memory_access"
        elif key == "memoryAllocation":
            suggest = "memory_allocation"
        elif key == "memoryDiscard":
            suggest = "memory_discard"
        elif key == "memoryHugePages":
            suggest = "memory_huge_pages"
        elif key == "memoryLocked":
            suggest = "memory_locked"
        elif key == "memoryNosharepages":
            suggest = "memory_nosharepages"
        elif key == "memorySource":
            suggest = "memory_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainMemoryBacking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainMemoryBacking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainMemoryBacking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 memory_access: Optional['outputs.DomainMemoryBackingMemoryAccess'] = None,
                 memory_allocation: Optional['outputs.DomainMemoryBackingMemoryAllocation'] = None,
                 memory_discard: Optional[_builtins.bool] = None,
                 memory_huge_pages: Optional['outputs.DomainMemoryBackingMemoryHugePages'] = None,
                 memory_locked: Optional[_builtins.bool] = None,
                 memory_nosharepages: Optional[_builtins.bool] = None,
                 memory_source: Optional['outputs.DomainMemoryBackingMemorySource'] = None):
        """
        :param 'DomainMemoryBackingMemoryAccessArgs' memory_access: Controls the memory access policy for the guests backed memory (for example, NUMA-related access behavior) via a mode attribute.
        :param 'DomainMemoryBackingMemoryAllocationArgs' memory_allocation: Controls the allocation behavior of the backing memory, such as whether memory is preallocated and on how many threads.
        :param _builtins.bool memory_discard: Enables backing memory discard behavior when present; as a presence-only flag, setting this to true emits the element, while false or null omits it.
               
               See: <https://libvirt.org/formatdomain.html#memory-backing>
        :param 'DomainMemoryBackingMemoryHugePagesArgs' memory_huge_pages: Enables and configures the use of huge pages for guest memory, allowing one or more huge page size definitions.
        :param _builtins.bool memory_locked: Requests that the guests memory be locked in host RAM (mlock) when present; as a presence-only flag, true emits the element and false/null omits it.
               
               See: <https://libvirt.org/formatdomain.html#memory-backing>
        :param _builtins.bool memory_nosharepages: Disables page sharing for the guests memory when present, preventing features like KSM from deduplicating pages; as a presence-only flag, true emits the element and false/null omits it.
               
               See: <https://libvirt.org/formatdomain.html#memory-backing>
        :param 'DomainMemoryBackingMemorySourceArgs' memory_source: Selects the backing source type for guest memory (for example, anonymous, file-backed, or other hypervisor-supported sources).
        """
        if memory_access is not None:
            pulumi.set(__self__, "memory_access", memory_access)
        if memory_allocation is not None:
            pulumi.set(__self__, "memory_allocation", memory_allocation)
        if memory_discard is not None:
            pulumi.set(__self__, "memory_discard", memory_discard)
        if memory_huge_pages is not None:
            pulumi.set(__self__, "memory_huge_pages", memory_huge_pages)
        if memory_locked is not None:
            pulumi.set(__self__, "memory_locked", memory_locked)
        if memory_nosharepages is not None:
            pulumi.set(__self__, "memory_nosharepages", memory_nosharepages)
        if memory_source is not None:
            pulumi.set(__self__, "memory_source", memory_source)

    @_builtins.property
    @pulumi.getter(name="memoryAccess")
    def memory_access(self) -> Optional['outputs.DomainMemoryBackingMemoryAccess']:
        """
        Controls the memory access policy for the guests backed memory (for example, NUMA-related access behavior) via a mode attribute.
        """
        return pulumi.get(self, "memory_access")

    @_builtins.property
    @pulumi.getter(name="memoryAllocation")
    def memory_allocation(self) -> Optional['outputs.DomainMemoryBackingMemoryAllocation']:
        """
        Controls the allocation behavior of the backing memory, such as whether memory is preallocated and on how many threads.
        """
        return pulumi.get(self, "memory_allocation")

    @_builtins.property
    @pulumi.getter(name="memoryDiscard")
    def memory_discard(self) -> Optional[_builtins.bool]:
        """
        Enables backing memory discard behavior when present; as a presence-only flag, setting this to true emits the element, while false or null omits it.

        See: <https://libvirt.org/formatdomain.html#memory-backing>
        """
        return pulumi.get(self, "memory_discard")

    @_builtins.property
    @pulumi.getter(name="memoryHugePages")
    def memory_huge_pages(self) -> Optional['outputs.DomainMemoryBackingMemoryHugePages']:
        """
        Enables and configures the use of huge pages for guest memory, allowing one or more huge page size definitions.
        """
        return pulumi.get(self, "memory_huge_pages")

    @_builtins.property
    @pulumi.getter(name="memoryLocked")
    def memory_locked(self) -> Optional[_builtins.bool]:
        """
        Requests that the guests memory be locked in host RAM (mlock) when present; as a presence-only flag, true emits the element and false/null omits it.

        See: <https://libvirt.org/formatdomain.html#memory-backing>
        """
        return pulumi.get(self, "memory_locked")

    @_builtins.property
    @pulumi.getter(name="memoryNosharepages")
    def memory_nosharepages(self) -> Optional[_builtins.bool]:
        """
        Disables page sharing for the guests memory when present, preventing features like KSM from deduplicating pages; as a presence-only flag, true emits the element and false/null omits it.

        See: <https://libvirt.org/formatdomain.html#memory-backing>
        """
        return pulumi.get(self, "memory_nosharepages")

    @_builtins.property
    @pulumi.getter(name="memorySource")
    def memory_source(self) -> Optional['outputs.DomainMemoryBackingMemorySource']:
        """
        Selects the backing source type for guest memory (for example, anonymous, file-backed, or other hypervisor-supported sources).
        """
        return pulumi.get(self, "memory_source")


@pulumi.output_type
class DomainMemoryBackingMemoryAccess(dict):
    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str mode: Sets the memory access mode; the value is user-provided and must be one of the modes supported by libvirt for memoryBacking access (for example, platformspecific NUMA access modes).
               
               See: <https://libvirt.org/formatdomain.html#memory-backing>
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the memory access mode; the value is user-provided and must be one of the modes supported by libvirt for memoryBacking access (for example, platformspecific NUMA access modes).

        See: <https://libvirt.org/formatdomain.html#memory-backing>
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DomainMemoryBackingMemoryAllocation(dict):
    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 threads: Optional[_builtins.float] = None):
        """
        :param _builtins.str mode: Sets the allocation mode for backing memory; the value is user-provided and must be one of the modes supported by libvirt (for example, immediate vs. ondemand allocation depending on hypervisor support).
               
               See: <https://libvirt.org/formatdomain.html#memory-backing>
        :param _builtins.float threads: Specifies the number of threads to use when performing the chosen memory allocation mode; the value is a user-provided positive integer.
               
               See: <https://libvirt.org/formatdomain.html#memory-backing>
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if threads is not None:
            pulumi.set(__self__, "threads", threads)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the allocation mode for backing memory; the value is user-provided and must be one of the modes supported by libvirt (for example, immediate vs. ondemand allocation depending on hypervisor support).

        See: <https://libvirt.org/formatdomain.html#memory-backing>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def threads(self) -> Optional[_builtins.float]:
        """
        Specifies the number of threads to use when performing the chosen memory allocation mode; the value is a user-provided positive integer.

        See: <https://libvirt.org/formatdomain.html#memory-backing>
        """
        return pulumi.get(self, "threads")


@pulumi.output_type
class DomainMemoryBackingMemoryHugePages(dict):
    def __init__(__self__, *,
                 hugepages: Optional[Sequence['outputs.DomainMemoryBackingMemoryHugePagesHugepage']] = None):
        """
        :param Sequence['DomainMemoryBackingMemoryHugePagesHugepageArgs'] hugepages: Defines a single huge page configuration, including page size, optional unit, and optional NUMA node set.
               
               See: <https://libvirt.org/formatdomain.html#memory-backing>
        """
        if hugepages is not None:
            pulumi.set(__self__, "hugepages", hugepages)

    @_builtins.property
    @pulumi.getter
    def hugepages(self) -> Optional[Sequence['outputs.DomainMemoryBackingMemoryHugePagesHugepage']]:
        """
        Defines a single huge page configuration, including page size, optional unit, and optional NUMA node set.

        See: <https://libvirt.org/formatdomain.html#memory-backing>
        """
        return pulumi.get(self, "hugepages")


@pulumi.output_type
class DomainMemoryBackingMemoryHugePagesHugepage(dict):
    def __init__(__self__, *,
                 size: _builtins.float,
                 nodeset: Optional[_builtins.str] = None,
                 unit: Optional[_builtins.str] = None):
        """
        :param _builtins.float size: Sets the huge page size for this entry as a required positive integer, interpreted together with the unit field (for example, 2048 with unit "KiB" for 2 MiB pages).
               
               See: <https://libvirt.org/formatdomain.html#memory-backing>
        :param _builtins.str nodeset: Restricts use of this huge page size to a specific NUMA node set; the value is user-provided and follows libvirt nodeset syntax (e.g. "0-1,3").
               
               See: <https://libvirt.org/formatdomain.html#memory-backing>
        :param _builtins.str unit: Sets the unit for the huge page size; the value is user-provided and must be one of the libvirt-supported size units (such as "B", "KiB", "MiB", "GiB").
               
               See: <https://libvirt.org/formatdomain.html#memory-backing>
        """
        pulumi.set(__self__, "size", size)
        if nodeset is not None:
            pulumi.set(__self__, "nodeset", nodeset)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.float:
        """
        Sets the huge page size for this entry as a required positive integer, interpreted together with the unit field (for example, 2048 with unit "KiB" for 2 MiB pages).

        See: <https://libvirt.org/formatdomain.html#memory-backing>
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def nodeset(self) -> Optional[_builtins.str]:
        """
        Restricts use of this huge page size to a specific NUMA node set; the value is user-provided and follows libvirt nodeset syntax (e.g. "0-1,3").

        See: <https://libvirt.org/formatdomain.html#memory-backing>
        """
        return pulumi.get(self, "nodeset")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        """
        Sets the unit for the huge page size; the value is user-provided and must be one of the libvirt-supported size units (such as "B", "KiB", "MiB", "GiB").

        See: <https://libvirt.org/formatdomain.html#memory-backing>
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class DomainMemoryBackingMemorySource(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Specifies the memory source type; the value is user-provided and must be one of the libvirt-supported types for memoryBacking source (e.g. platform-specific values like "anonymous" or "file").
               
               See: <https://libvirt.org/formatdomain.html#memory-backing>
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Specifies the memory source type; the value is user-provided and must be one of the libvirt-supported types for memoryBacking source (e.g. platform-specific values like "anonymous" or "file").

        See: <https://libvirt.org/formatdomain.html#memory-backing>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainMemoryTune(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hardLimit":
            suggest = "hard_limit"
        elif key == "hardLimitUnit":
            suggest = "hard_limit_unit"
        elif key == "minGuarantee":
            suggest = "min_guarantee"
        elif key == "minGuaranteeUnit":
            suggest = "min_guarantee_unit"
        elif key == "softLimit":
            suggest = "soft_limit"
        elif key == "softLimitUnit":
            suggest = "soft_limit_unit"
        elif key == "swapHardLimit":
            suggest = "swap_hard_limit"
        elif key == "swapHardLimitUnit":
            suggest = "swap_hard_limit_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainMemoryTune. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainMemoryTune.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainMemoryTune.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hard_limit: Optional[_builtins.float] = None,
                 hard_limit_unit: Optional[_builtins.str] = None,
                 min_guarantee: Optional[_builtins.float] = None,
                 min_guarantee_unit: Optional[_builtins.str] = None,
                 soft_limit: Optional[_builtins.float] = None,
                 soft_limit_unit: Optional[_builtins.str] = None,
                 swap_hard_limit: Optional[_builtins.float] = None,
                 swap_hard_limit_unit: Optional[_builtins.str] = None):
        """
        :param _builtins.float hard_limit: Sets an upper hard limit on the domains memory usage; the value is a user-provided positive integer in libvirt memory units (typically KiB) and must not be lower than other required limits.
               
               See: <https://libvirt.org/formatdomain.html#memory-tuning>
        :param _builtins.str hard_limit_unit: Sets the unit for the memory_tune hard_limit value, typically as a memory size unit such as KiB, MiB, or GiB; the string is user-provided and must match libvirts accepted memory units.
               
               See: <https://libvirt.org/formatdomain.html#memory-tuning>
        :param _builtins.float min_guarantee: Sets the minimum amount of memory that the hypervisor guarantees to keep available for the guest, expressed in the unit given by min_guarantee_unit.
               
               See: <https://libvirt.org/formatdomain.html#memory-tuning>
        :param _builtins.str min_guarantee_unit: Sets the unit for the memory_tune min_guarantee value, typically as a memory size unit such as KiB, MiB, or GiB; the string is user-provided and must match libvirts accepted memory units.
               
               See: <https://libvirt.org/formatdomain.html#memory-tuning>
        :param _builtins.float soft_limit: Sets a soft memory usage limit for the guest, above which its memory may be preferentially reclaimed, expressed in the unit given by soft_limit_unit.
               
               See: <https://libvirt.org/formatdomain.html#memory-tuning>
        :param _builtins.str soft_limit_unit: Sets the unit for the memory_tune soft_limit value, typically as a memory size unit such as KiB, MiB, or GiB; the string is user-provided and must match libvirts accepted memory units.
               
               See: <https://libvirt.org/formatdomain.html#memory-tuning>
        :param _builtins.float swap_hard_limit: Sets an upper limit on the guests combined RAM+swap usage, expressed in the unit given by swap_hard_limit_unit, beyond which further allocation is refused.
               
               See: <https://libvirt.org/formatdomain.html#memory-tuning>
        :param _builtins.str swap_hard_limit_unit: Sets the unit for the memory_tune swap_hard_limit value, typically as a memory size unit such as KiB, MiB, or GiB; the string is user-provided and must match libvirts accepted memory units.
               
               See: <https://libvirt.org/formatdomain.html#memory-tuning>
        """
        if hard_limit is not None:
            pulumi.set(__self__, "hard_limit", hard_limit)
        if hard_limit_unit is not None:
            pulumi.set(__self__, "hard_limit_unit", hard_limit_unit)
        if min_guarantee is not None:
            pulumi.set(__self__, "min_guarantee", min_guarantee)
        if min_guarantee_unit is not None:
            pulumi.set(__self__, "min_guarantee_unit", min_guarantee_unit)
        if soft_limit is not None:
            pulumi.set(__self__, "soft_limit", soft_limit)
        if soft_limit_unit is not None:
            pulumi.set(__self__, "soft_limit_unit", soft_limit_unit)
        if swap_hard_limit is not None:
            pulumi.set(__self__, "swap_hard_limit", swap_hard_limit)
        if swap_hard_limit_unit is not None:
            pulumi.set(__self__, "swap_hard_limit_unit", swap_hard_limit_unit)

    @_builtins.property
    @pulumi.getter(name="hardLimit")
    def hard_limit(self) -> Optional[_builtins.float]:
        """
        Sets an upper hard limit on the domains memory usage; the value is a user-provided positive integer in libvirt memory units (typically KiB) and must not be lower than other required limits.

        See: <https://libvirt.org/formatdomain.html#memory-tuning>
        """
        return pulumi.get(self, "hard_limit")

    @_builtins.property
    @pulumi.getter(name="hardLimitUnit")
    def hard_limit_unit(self) -> Optional[_builtins.str]:
        """
        Sets the unit for the memory_tune hard_limit value, typically as a memory size unit such as KiB, MiB, or GiB; the string is user-provided and must match libvirts accepted memory units.

        See: <https://libvirt.org/formatdomain.html#memory-tuning>
        """
        return pulumi.get(self, "hard_limit_unit")

    @_builtins.property
    @pulumi.getter(name="minGuarantee")
    def min_guarantee(self) -> Optional[_builtins.float]:
        """
        Sets the minimum amount of memory that the hypervisor guarantees to keep available for the guest, expressed in the unit given by min_guarantee_unit.

        See: <https://libvirt.org/formatdomain.html#memory-tuning>
        """
        return pulumi.get(self, "min_guarantee")

    @_builtins.property
    @pulumi.getter(name="minGuaranteeUnit")
    def min_guarantee_unit(self) -> Optional[_builtins.str]:
        """
        Sets the unit for the memory_tune min_guarantee value, typically as a memory size unit such as KiB, MiB, or GiB; the string is user-provided and must match libvirts accepted memory units.

        See: <https://libvirt.org/formatdomain.html#memory-tuning>
        """
        return pulumi.get(self, "min_guarantee_unit")

    @_builtins.property
    @pulumi.getter(name="softLimit")
    def soft_limit(self) -> Optional[_builtins.float]:
        """
        Sets a soft memory usage limit for the guest, above which its memory may be preferentially reclaimed, expressed in the unit given by soft_limit_unit.

        See: <https://libvirt.org/formatdomain.html#memory-tuning>
        """
        return pulumi.get(self, "soft_limit")

    @_builtins.property
    @pulumi.getter(name="softLimitUnit")
    def soft_limit_unit(self) -> Optional[_builtins.str]:
        """
        Sets the unit for the memory_tune soft_limit value, typically as a memory size unit such as KiB, MiB, or GiB; the string is user-provided and must match libvirts accepted memory units.

        See: <https://libvirt.org/formatdomain.html#memory-tuning>
        """
        return pulumi.get(self, "soft_limit_unit")

    @_builtins.property
    @pulumi.getter(name="swapHardLimit")
    def swap_hard_limit(self) -> Optional[_builtins.float]:
        """
        Sets an upper limit on the guests combined RAM+swap usage, expressed in the unit given by swap_hard_limit_unit, beyond which further allocation is refused.

        See: <https://libvirt.org/formatdomain.html#memory-tuning>
        """
        return pulumi.get(self, "swap_hard_limit")

    @_builtins.property
    @pulumi.getter(name="swapHardLimitUnit")
    def swap_hard_limit_unit(self) -> Optional[_builtins.str]:
        """
        Sets the unit for the memory_tune swap_hard_limit value, typically as a memory size unit such as KiB, MiB, or GiB; the string is user-provided and must match libvirts accepted memory units.

        See: <https://libvirt.org/formatdomain.html#memory-tuning>
        """
        return pulumi.get(self, "swap_hard_limit_unit")


@pulumi.output_type
class DomainMetadata(dict):
    def __init__(__self__, *,
                 xml: _builtins.str):
        """
        :param _builtins.str xml: Provides the raw XML content to store inside the domains metadata element; this must be well-formed XML and is fully user-defined.
               
               See: <https://libvirt.org/formatdomain.html#general-metadata>
        """
        pulumi.set(__self__, "xml", xml)

    @_builtins.property
    @pulumi.getter
    def xml(self) -> _builtins.str:
        """
        Provides the raw XML content to store inside the domains metadata element; this must be well-formed XML and is fully user-defined.

        See: <https://libvirt.org/formatdomain.html#general-metadata>
        """
        return pulumi.get(self, "xml")


@pulumi.output_type
class DomainNumaTune(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memNodes":
            suggest = "mem_nodes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainNumaTune. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainNumaTune.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainNumaTune.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mem_nodes: Optional[Sequence['outputs.DomainNumaTuneMemNode']] = None,
                 memory: Optional['outputs.DomainNumaTuneMemory'] = None):
        """
        :param Sequence['DomainNumaTuneMemNodeArgs'] mem_nodes: Defines per-guest-NUMA-node memory policies, each entry specifying how a given guest cell maps to host NUMA nodes.
               
               See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
        :param 'DomainNumaTuneMemoryArgs' memory: Configures a global NUMA memory policy for the domain process, independent of per-cell mem_nodes settings.
        """
        if mem_nodes is not None:
            pulumi.set(__self__, "mem_nodes", mem_nodes)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @_builtins.property
    @pulumi.getter(name="memNodes")
    def mem_nodes(self) -> Optional[Sequence['outputs.DomainNumaTuneMemNode']]:
        """
        Defines per-guest-NUMA-node memory policies, each entry specifying how a given guest cell maps to host NUMA nodes.

        See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
        """
        return pulumi.get(self, "mem_nodes")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> Optional['outputs.DomainNumaTuneMemory']:
        """
        Configures a global NUMA memory policy for the domain process, independent of per-cell mem_nodes settings.
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class DomainNumaTuneMemNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cellId":
            suggest = "cell_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainNumaTuneMemNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainNumaTuneMemNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainNumaTuneMemNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cell_id: _builtins.float,
                 mode: _builtins.str,
                 nodeset: _builtins.str):
        """
        :param _builtins.float cell_id: Sets the guest NUMA cell (node) index for this mem_nodes entry; the value is a non-negative integer matching a defined guest NUMA cell.
               
               See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
        :param _builtins.str mode: Sets the NUMA memory allocation policy for the specified guest cell, with valid values including preferred, interleave, bind, strict, or other modes accepted by libvirt.
               
               See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
        :param _builtins.str nodeset: Specifies the host NUMA node or nodes to which the guest cells memory policy applies, using libvirts nodeset syntax (e.g. "0-2,4").
               
               See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
        """
        pulumi.set(__self__, "cell_id", cell_id)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "nodeset", nodeset)

    @_builtins.property
    @pulumi.getter(name="cellId")
    def cell_id(self) -> _builtins.float:
        """
        Sets the guest NUMA cell (node) index for this mem_nodes entry; the value is a non-negative integer matching a defined guest NUMA cell.

        See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
        """
        return pulumi.get(self, "cell_id")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets the NUMA memory allocation policy for the specified guest cell, with valid values including preferred, interleave, bind, strict, or other modes accepted by libvirt.

        See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def nodeset(self) -> _builtins.str:
        """
        Specifies the host NUMA node or nodes to which the guest cells memory policy applies, using libvirts nodeset syntax (e.g. "0-2,4").

        See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
        """
        return pulumi.get(self, "nodeset")


@pulumi.output_type
class DomainNumaTuneMemory(dict):
    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 nodeset: Optional[_builtins.str] = None,
                 placement: Optional[_builtins.str] = None):
        """
        :param _builtins.str mode: Sets the overall NUMA memory allocation policy for the domain, with valid values including preferred, interleave, bind, strict, or other modes accepted by libvirt.
               
               See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
        :param _builtins.str nodeset: Specifies the host NUMA node or nodes used by the global memory policy, using libvirts nodeset syntax (e.g. "0-1" or "0,2,4").
               
               See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
        :param _builtins.str placement: Controls whether libvirt automatically selects NUMA nodes for the domains memory (auto) or uses an explicit nodeset (static), with valid values being auto or static.
               
               See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if nodeset is not None:
            pulumi.set(__self__, "nodeset", nodeset)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the overall NUMA memory allocation policy for the domain, with valid values including preferred, interleave, bind, strict, or other modes accepted by libvirt.

        See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def nodeset(self) -> Optional[_builtins.str]:
        """
        Specifies the host NUMA node or nodes used by the global memory policy, using libvirts nodeset syntax (e.g. "0-1" or "0,2,4").

        See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
        """
        return pulumi.get(self, "nodeset")

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[_builtins.str]:
        """
        Controls whether libvirt automatically selects NUMA nodes for the domains memory (auto) or uses an explicit nodeset (static), with valid values being auto or static.

        See: <https://libvirt.org/formatdomain.html#numa-node-tuning>
        """
        return pulumi.get(self, "placement")


@pulumi.output_type
class DomainOs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootDevices":
            suggest = "boot_devices"
        elif key == "bootMenu":
            suggest = "boot_menu"
        elif key == "firmwareInfo":
            suggest = "firmware_info"
        elif key == "initArgs":
            suggest = "init_args"
        elif key == "initDir":
            suggest = "init_dir"
        elif key == "initEnvs":
            suggest = "init_envs"
        elif key == "initGroup":
            suggest = "init_group"
        elif key == "initUser":
            suggest = "init_user"
        elif key == "loaderFormat":
            suggest = "loader_format"
        elif key == "loaderReadonly":
            suggest = "loader_readonly"
        elif key == "loaderSecure":
            suggest = "loader_secure"
        elif key == "loaderStateless":
            suggest = "loader_stateless"
        elif key == "loaderType":
            suggest = "loader_type"
        elif key == "nvRam":
            suggest = "nv_ram"
        elif key == "smBios":
            suggest = "sm_bios"
        elif key == "typeArch":
            suggest = "type_arch"
        elif key == "typeMachine":
            suggest = "type_machine"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acpi: Optional['outputs.DomainOsAcpi'] = None,
                 bios: Optional['outputs.DomainOsBios'] = None,
                 boot_devices: Optional[Sequence['outputs.DomainOsBootDevice']] = None,
                 boot_menu: Optional['outputs.DomainOsBootMenu'] = None,
                 cmdline: Optional[_builtins.str] = None,
                 dtb: Optional[_builtins.str] = None,
                 firmware: Optional[_builtins.str] = None,
                 firmware_info: Optional['outputs.DomainOsFirmwareInfo'] = None,
                 init: Optional[_builtins.str] = None,
                 init_args: Optional[Sequence[_builtins.str]] = None,
                 init_dir: Optional[_builtins.str] = None,
                 init_envs: Optional[Sequence['outputs.DomainOsInitEnv']] = None,
                 init_group: Optional[_builtins.str] = None,
                 init_user: Optional[_builtins.str] = None,
                 initrd: Optional[_builtins.str] = None,
                 kernel: Optional[_builtins.str] = None,
                 loader: Optional[_builtins.str] = None,
                 loader_format: Optional[_builtins.str] = None,
                 loader_readonly: Optional[_builtins.str] = None,
                 loader_secure: Optional[_builtins.str] = None,
                 loader_stateless: Optional[_builtins.str] = None,
                 loader_type: Optional[_builtins.str] = None,
                 nv_ram: Optional['outputs.DomainOsNvRam'] = None,
                 shim: Optional[_builtins.str] = None,
                 sm_bios: Optional['outputs.DomainOsSmBios'] = None,
                 type: Optional[_builtins.str] = None,
                 type_arch: Optional[_builtins.str] = None,
                 type_machine: Optional[_builtins.str] = None):
        """
        :param 'DomainOsAcpiArgs' acpi: Enables configuration of additional ACPI tables presented to the guest firmware/OS via nested table definitions. The element itself has no attributes; behavior is controlled by its child tables.
        :param 'DomainOsBiosArgs' bios: Configures BIOS-related boot behavior for fully virtualized guests, such as reboot timeout and use of serial console for BIOS messages. All child attributes are optional.
        :param Sequence['DomainOsBootDeviceArgs'] boot_devices: Specifies an ordered list of devices the firmware should try when booting the guest OS. Multiple entries are allowed to define a boot priority list.
               
               See: <https://libvirt.org/formatdomain.html#bios-bootloader>
        :param 'DomainOsBootMenuArgs' boot_menu: Enables or configures the firmware boot menu shown before booting the OS, including optional timeout. Presence alone does not enable it; see enable/timeout attributes.
        :param _builtins.str cmdline: Provides the kernel command line arguments passed to the guest when using direct kernel boot; the value is a free-form string. Example: "console=ttyS0 root=/dev/vda1".
               
               See: <https://libvirt.org/formatdomain.html#direct-kernel-boot>
        :param _builtins.str dtb: Sets the host path to a Device Tree Blob passed to the guest kernel during direct kernel boot on architectures that use DTBs; the value is user-provided. Example: "/var/lib/libvirt/images/guest.dtb".
               
               See: <https://libvirt.org/formatdomain.html#direct-kernel-boot>
        :param _builtins.str firmware: Selects the guest firmware type or boot mode via a string value (for example "efi", "bios", or other driver-dependent identifiers); the value is user-provided and must be supported by the hypervisor/host. If unset, the default firmware is used.
               
               See: <https://libvirt.org/formatdomain.html#operating-system-booting>
        :param 'DomainOsFirmwareInfoArgs' firmware_info: Provides structured configuration for the firmware image when using pflash/NVRAM or other non-default firmware setups, such as specifying a particular firmware file and NVRAM store; contents and attributes are user-provided and driver-specific. Use this when finer-grained firmware selection is needed beyond the simple firmware attribute.
        :param _builtins.str init: Sets the path to the init binary inside a container-based guest, used instead of a kernel or boot image when booting container domains.
               
               See: <https://libvirt.org/formatdomain.html#container-boot>
        :param Sequence[_builtins.str] init_args: Provides additional command-line arguments to pass to the init binary configured by domain.os.init; multiple values map to multiple arguments in order (for example ["--foreground","--config=/cfg"]).
               
               See: <https://libvirt.org/formatdomain.html#container-boot>
        :param _builtins.str init_dir: Sets the working directory from which the container init binary is started.
               
               See: <https://libvirt.org/formatdomain.html#container-boot>
        :param Sequence['DomainOsInitEnvArgs'] init_envs: Defines one environment variable to export for the container init process; multiple blocks can be used to define multiple variables.
               
               See: <https://libvirt.org/formatdomain.html#container-boot>
        :param _builtins.str init_group: Sets the numeric group ID or group name that the container init process runs as.
               
               See: <https://libvirt.org/formatdomain.html#container-boot>
        :param _builtins.str init_user: Sets the numeric user ID or user name that the container init process runs as.
               
               See: <https://libvirt.org/formatdomain.html#container-boot>
        :param _builtins.str initrd: Specifies the path on the host to an initrd image used when directly booting a kernel for the guest.
               
               See: <https://libvirt.org/formatdomain.html#direct-kernel-boot>
        :param _builtins.str kernel: Specifies the path on the host to a kernel image used for direct kernel boot of the guest.
               
               See: <https://libvirt.org/formatdomain.html#direct-kernel-boot>
        :param _builtins.str loader: Sets the path or identifier of the firmware/BIOS/EFI loader image used to boot the guest (for example an OVMF or BIOS binary).
               
               See: <https://libvirt.org/formatdomain.html#bios-bootloader>
        :param _builtins.str loader_format: Sets the loader image format (for example "raw" or "qcow2") corresponding to the loader; value is user-provided but must be supported by the hypervisor/firmware.
               
               See: <https://libvirt.org/formatdomain.html#bios-bootloader>
        :param _builtins.str loader_readonly: Controls whether the firmware loader image is opened read-only, typically using a "yes"/"no" style flag as expected by libvirt/QEMU.
               
               See: <https://libvirt.org/formatdomain.html#bios-bootloader>
        :param _builtins.str loader_secure: Enables or disables secure boot support for the configured firmware loader, usually via a "yes"/"no" style flag.
               
               See: <https://libvirt.org/formatdomain.html#bios-bootloader>
        :param _builtins.str loader_stateless: Controls whether the firmware loader operates in stateless mode (firmware state not persisted), typically configured as a "yes"/"no" style flag.
               
               See: <https://libvirt.org/formatdomain.html#bios-bootloader>
        :param _builtins.str loader_type: Specifies the loader type, such as "pflash" for UEFI flash-based firmware or "rom" for traditional BIOS, with supported values depending on the hypervisor/architecture.
               
               See: <https://libvirt.org/formatdomain.html#bios-bootloader>
        :param 'DomainOsNvRamArgs' nv_ram: Sets the path for the guest NVRAM/UEFI variable store file associated with the firmware loader, allowing persistence of firmware settings across reboots.
        :param _builtins.str shim: Provides the path to a UEFI shim binary used in secure-boot chains, typically sitting between firmware and the OS loader; the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#direct-kernel-boot>
        :param 'DomainOsSmBiosArgs' sm_bios: Enables configuration of SMBIOS-related behavior for the guest firmware, such as whether to use host, guest-defined, or sysinfo-based SMBIOS data.
        :param _builtins.str type: Sets the guest OS type string (for example, hvm or exe), indicating the virtualization style or booting method expected by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#operating-system-booting>
        :param _builtins.str type_arch: Sets the architecture for the guest OS type (for example, x86_64 or i686) via the arch attribute, influencing the machine type, CPU model, and firmware choice.
               
               See: <https://libvirt.org/formatdomain.html#operating-system-booting>
        :param _builtins.str type_machine: Sets the machine type for the guest OS type (for example, pc-q35-2.10 or pc-i440fx-7.2), selecting the chipset and board model used by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#operating-system-booting>
        """
        if acpi is not None:
            pulumi.set(__self__, "acpi", acpi)
        if bios is not None:
            pulumi.set(__self__, "bios", bios)
        if boot_devices is not None:
            pulumi.set(__self__, "boot_devices", boot_devices)
        if boot_menu is not None:
            pulumi.set(__self__, "boot_menu", boot_menu)
        if cmdline is not None:
            pulumi.set(__self__, "cmdline", cmdline)
        if dtb is not None:
            pulumi.set(__self__, "dtb", dtb)
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if firmware_info is not None:
            pulumi.set(__self__, "firmware_info", firmware_info)
        if init is not None:
            pulumi.set(__self__, "init", init)
        if init_args is not None:
            pulumi.set(__self__, "init_args", init_args)
        if init_dir is not None:
            pulumi.set(__self__, "init_dir", init_dir)
        if init_envs is not None:
            pulumi.set(__self__, "init_envs", init_envs)
        if init_group is not None:
            pulumi.set(__self__, "init_group", init_group)
        if init_user is not None:
            pulumi.set(__self__, "init_user", init_user)
        if initrd is not None:
            pulumi.set(__self__, "initrd", initrd)
        if kernel is not None:
            pulumi.set(__self__, "kernel", kernel)
        if loader is not None:
            pulumi.set(__self__, "loader", loader)
        if loader_format is not None:
            pulumi.set(__self__, "loader_format", loader_format)
        if loader_readonly is not None:
            pulumi.set(__self__, "loader_readonly", loader_readonly)
        if loader_secure is not None:
            pulumi.set(__self__, "loader_secure", loader_secure)
        if loader_stateless is not None:
            pulumi.set(__self__, "loader_stateless", loader_stateless)
        if loader_type is not None:
            pulumi.set(__self__, "loader_type", loader_type)
        if nv_ram is not None:
            pulumi.set(__self__, "nv_ram", nv_ram)
        if shim is not None:
            pulumi.set(__self__, "shim", shim)
        if sm_bios is not None:
            pulumi.set(__self__, "sm_bios", sm_bios)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type_arch is not None:
            pulumi.set(__self__, "type_arch", type_arch)
        if type_machine is not None:
            pulumi.set(__self__, "type_machine", type_machine)

    @_builtins.property
    @pulumi.getter
    def acpi(self) -> Optional['outputs.DomainOsAcpi']:
        """
        Enables configuration of additional ACPI tables presented to the guest firmware/OS via nested table definitions. The element itself has no attributes; behavior is controlled by its child tables.
        """
        return pulumi.get(self, "acpi")

    @_builtins.property
    @pulumi.getter
    def bios(self) -> Optional['outputs.DomainOsBios']:
        """
        Configures BIOS-related boot behavior for fully virtualized guests, such as reboot timeout and use of serial console for BIOS messages. All child attributes are optional.
        """
        return pulumi.get(self, "bios")

    @_builtins.property
    @pulumi.getter(name="bootDevices")
    def boot_devices(self) -> Optional[Sequence['outputs.DomainOsBootDevice']]:
        """
        Specifies an ordered list of devices the firmware should try when booting the guest OS. Multiple entries are allowed to define a boot priority list.

        See: <https://libvirt.org/formatdomain.html#bios-bootloader>
        """
        return pulumi.get(self, "boot_devices")

    @_builtins.property
    @pulumi.getter(name="bootMenu")
    def boot_menu(self) -> Optional['outputs.DomainOsBootMenu']:
        """
        Enables or configures the firmware boot menu shown before booting the OS, including optional timeout. Presence alone does not enable it; see enable/timeout attributes.
        """
        return pulumi.get(self, "boot_menu")

    @_builtins.property
    @pulumi.getter
    def cmdline(self) -> Optional[_builtins.str]:
        """
        Provides the kernel command line arguments passed to the guest when using direct kernel boot; the value is a free-form string. Example: "console=ttyS0 root=/dev/vda1".

        See: <https://libvirt.org/formatdomain.html#direct-kernel-boot>
        """
        return pulumi.get(self, "cmdline")

    @_builtins.property
    @pulumi.getter
    def dtb(self) -> Optional[_builtins.str]:
        """
        Sets the host path to a Device Tree Blob passed to the guest kernel during direct kernel boot on architectures that use DTBs; the value is user-provided. Example: "/var/lib/libvirt/images/guest.dtb".

        See: <https://libvirt.org/formatdomain.html#direct-kernel-boot>
        """
        return pulumi.get(self, "dtb")

    @_builtins.property
    @pulumi.getter
    def firmware(self) -> Optional[_builtins.str]:
        """
        Selects the guest firmware type or boot mode via a string value (for example "efi", "bios", or other driver-dependent identifiers); the value is user-provided and must be supported by the hypervisor/host. If unset, the default firmware is used.

        See: <https://libvirt.org/formatdomain.html#operating-system-booting>
        """
        return pulumi.get(self, "firmware")

    @_builtins.property
    @pulumi.getter(name="firmwareInfo")
    def firmware_info(self) -> Optional['outputs.DomainOsFirmwareInfo']:
        """
        Provides structured configuration for the firmware image when using pflash/NVRAM or other non-default firmware setups, such as specifying a particular firmware file and NVRAM store; contents and attributes are user-provided and driver-specific. Use this when finer-grained firmware selection is needed beyond the simple firmware attribute.
        """
        return pulumi.get(self, "firmware_info")

    @_builtins.property
    @pulumi.getter
    def init(self) -> Optional[_builtins.str]:
        """
        Sets the path to the init binary inside a container-based guest, used instead of a kernel or boot image when booting container domains.

        See: <https://libvirt.org/formatdomain.html#container-boot>
        """
        return pulumi.get(self, "init")

    @_builtins.property
    @pulumi.getter(name="initArgs")
    def init_args(self) -> Optional[Sequence[_builtins.str]]:
        """
        Provides additional command-line arguments to pass to the init binary configured by domain.os.init; multiple values map to multiple arguments in order (for example ["--foreground","--config=/cfg"]).

        See: <https://libvirt.org/formatdomain.html#container-boot>
        """
        return pulumi.get(self, "init_args")

    @_builtins.property
    @pulumi.getter(name="initDir")
    def init_dir(self) -> Optional[_builtins.str]:
        """
        Sets the working directory from which the container init binary is started.

        See: <https://libvirt.org/formatdomain.html#container-boot>
        """
        return pulumi.get(self, "init_dir")

    @_builtins.property
    @pulumi.getter(name="initEnvs")
    def init_envs(self) -> Optional[Sequence['outputs.DomainOsInitEnv']]:
        """
        Defines one environment variable to export for the container init process; multiple blocks can be used to define multiple variables.

        See: <https://libvirt.org/formatdomain.html#container-boot>
        """
        return pulumi.get(self, "init_envs")

    @_builtins.property
    @pulumi.getter(name="initGroup")
    def init_group(self) -> Optional[_builtins.str]:
        """
        Sets the numeric group ID or group name that the container init process runs as.

        See: <https://libvirt.org/formatdomain.html#container-boot>
        """
        return pulumi.get(self, "init_group")

    @_builtins.property
    @pulumi.getter(name="initUser")
    def init_user(self) -> Optional[_builtins.str]:
        """
        Sets the numeric user ID or user name that the container init process runs as.

        See: <https://libvirt.org/formatdomain.html#container-boot>
        """
        return pulumi.get(self, "init_user")

    @_builtins.property
    @pulumi.getter
    def initrd(self) -> Optional[_builtins.str]:
        """
        Specifies the path on the host to an initrd image used when directly booting a kernel for the guest.

        See: <https://libvirt.org/formatdomain.html#direct-kernel-boot>
        """
        return pulumi.get(self, "initrd")

    @_builtins.property
    @pulumi.getter
    def kernel(self) -> Optional[_builtins.str]:
        """
        Specifies the path on the host to a kernel image used for direct kernel boot of the guest.

        See: <https://libvirt.org/formatdomain.html#direct-kernel-boot>
        """
        return pulumi.get(self, "kernel")

    @_builtins.property
    @pulumi.getter
    def loader(self) -> Optional[_builtins.str]:
        """
        Sets the path or identifier of the firmware/BIOS/EFI loader image used to boot the guest (for example an OVMF or BIOS binary).

        See: <https://libvirt.org/formatdomain.html#bios-bootloader>
        """
        return pulumi.get(self, "loader")

    @_builtins.property
    @pulumi.getter(name="loaderFormat")
    def loader_format(self) -> Optional[_builtins.str]:
        """
        Sets the loader image format (for example "raw" or "qcow2") corresponding to the loader; value is user-provided but must be supported by the hypervisor/firmware.

        See: <https://libvirt.org/formatdomain.html#bios-bootloader>
        """
        return pulumi.get(self, "loader_format")

    @_builtins.property
    @pulumi.getter(name="loaderReadonly")
    def loader_readonly(self) -> Optional[_builtins.str]:
        """
        Controls whether the firmware loader image is opened read-only, typically using a "yes"/"no" style flag as expected by libvirt/QEMU.

        See: <https://libvirt.org/formatdomain.html#bios-bootloader>
        """
        return pulumi.get(self, "loader_readonly")

    @_builtins.property
    @pulumi.getter(name="loaderSecure")
    def loader_secure(self) -> Optional[_builtins.str]:
        """
        Enables or disables secure boot support for the configured firmware loader, usually via a "yes"/"no" style flag.

        See: <https://libvirt.org/formatdomain.html#bios-bootloader>
        """
        return pulumi.get(self, "loader_secure")

    @_builtins.property
    @pulumi.getter(name="loaderStateless")
    def loader_stateless(self) -> Optional[_builtins.str]:
        """
        Controls whether the firmware loader operates in stateless mode (firmware state not persisted), typically configured as a "yes"/"no" style flag.

        See: <https://libvirt.org/formatdomain.html#bios-bootloader>
        """
        return pulumi.get(self, "loader_stateless")

    @_builtins.property
    @pulumi.getter(name="loaderType")
    def loader_type(self) -> Optional[_builtins.str]:
        """
        Specifies the loader type, such as "pflash" for UEFI flash-based firmware or "rom" for traditional BIOS, with supported values depending on the hypervisor/architecture.

        See: <https://libvirt.org/formatdomain.html#bios-bootloader>
        """
        return pulumi.get(self, "loader_type")

    @_builtins.property
    @pulumi.getter(name="nvRam")
    def nv_ram(self) -> Optional['outputs.DomainOsNvRam']:
        """
        Sets the path for the guest NVRAM/UEFI variable store file associated with the firmware loader, allowing persistence of firmware settings across reboots.
        """
        return pulumi.get(self, "nv_ram")

    @_builtins.property
    @pulumi.getter
    def shim(self) -> Optional[_builtins.str]:
        """
        Provides the path to a UEFI shim binary used in secure-boot chains, typically sitting between firmware and the OS loader; the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#direct-kernel-boot>
        """
        return pulumi.get(self, "shim")

    @_builtins.property
    @pulumi.getter(name="smBios")
    def sm_bios(self) -> Optional['outputs.DomainOsSmBios']:
        """
        Enables configuration of SMBIOS-related behavior for the guest firmware, such as whether to use host, guest-defined, or sysinfo-based SMBIOS data.
        """
        return pulumi.get(self, "sm_bios")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Sets the guest OS type string (for example, hvm or exe), indicating the virtualization style or booting method expected by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#operating-system-booting>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="typeArch")
    def type_arch(self) -> Optional[_builtins.str]:
        """
        Sets the architecture for the guest OS type (for example, x86_64 or i686) via the arch attribute, influencing the machine type, CPU model, and firmware choice.

        See: <https://libvirt.org/formatdomain.html#operating-system-booting>
        """
        return pulumi.get(self, "type_arch")

    @_builtins.property
    @pulumi.getter(name="typeMachine")
    def type_machine(self) -> Optional[_builtins.str]:
        """
        Sets the machine type for the guest OS type (for example, pc-q35-2.10 or pc-i440fx-7.2), selecting the chipset and board model used by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#operating-system-booting>
        """
        return pulumi.get(self, "type_machine")


@pulumi.output_type
class DomainOsAcpi(dict):
    def __init__(__self__, *,
                 tables: Optional[Sequence['outputs.DomainOsAcpiTable']] = None):
        """
        :param Sequence['DomainOsAcpiTableArgs'] tables: Declares one or more custom ACPI tables to load into the guest, each with a required type and path specifying the table file. Multiple entries are allowed.
               
               See: <https://libvirt.org/formatdomain.html#common-os-element-configuration>
        """
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @_builtins.property
    @pulumi.getter
    def tables(self) -> Optional[Sequence['outputs.DomainOsAcpiTable']]:
        """
        Declares one or more custom ACPI tables to load into the guest, each with a required type and path specifying the table file. Multiple entries are allowed.

        See: <https://libvirt.org/formatdomain.html#common-os-element-configuration>
        """
        return pulumi.get(self, "tables")


@pulumi.output_type
class DomainOsAcpiTable(dict):
    def __init__(__self__, *,
                 path: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str path: Sets the fully-qualified path on the host to the ACPI table file that will be injected into the guest; the value is user-provided and must reference an accessible file. Example: "/usr/share/acpi/my_dsdt.bin".
               
               See: <https://libvirt.org/formatdomain.html#common-os-element-configuration>
        :param _builtins.str type: Sets the ACPI table type corresponding to the content of the referenced file (for example "dsdt" or another ACPI table identifier); the value is required and user-provided. Libvirt expects it to match the table contents.
               
               See: <https://libvirt.org/formatdomain.html#common-os-element-configuration>
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the fully-qualified path on the host to the ACPI table file that will be injected into the guest; the value is user-provided and must reference an accessible file. Example: "/usr/share/acpi/my_dsdt.bin".

        See: <https://libvirt.org/formatdomain.html#common-os-element-configuration>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets the ACPI table type corresponding to the content of the referenced file (for example "dsdt" or another ACPI table identifier); the value is required and user-provided. Libvirt expects it to match the table contents.

        See: <https://libvirt.org/formatdomain.html#common-os-element-configuration>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainOsBios(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rebootTimeout":
            suggest = "reboot_timeout"
        elif key == "useSerial":
            suggest = "use_serial"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsBios. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsBios.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsBios.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 reboot_timeout: Optional[_builtins.float] = None,
                 use_serial: Optional[_builtins.str] = None):
        """
        :param _builtins.float reboot_timeout: Sets the time in seconds that firmware waits in the boot menu before automatically rebooting or continuing boot; the value is a non-negative integer. Example: 5000.
               
               See: <https://libvirt.org/formatdomain.html#bios-bootloader>
        :param _builtins.str use_serial: Controls whether the BIOS uses the serial console for input/output; the value is a "yes"/"no" string flag. If unset, the hypervisor default is used.
               
               See: <https://libvirt.org/formatdomain.html#bios-bootloader>
        """
        if reboot_timeout is not None:
            pulumi.set(__self__, "reboot_timeout", reboot_timeout)
        if use_serial is not None:
            pulumi.set(__self__, "use_serial", use_serial)

    @_builtins.property
    @pulumi.getter(name="rebootTimeout")
    def reboot_timeout(self) -> Optional[_builtins.float]:
        """
        Sets the time in seconds that firmware waits in the boot menu before automatically rebooting or continuing boot; the value is a non-negative integer. Example: 5000.

        See: <https://libvirt.org/formatdomain.html#bios-bootloader>
        """
        return pulumi.get(self, "reboot_timeout")

    @_builtins.property
    @pulumi.getter(name="useSerial")
    def use_serial(self) -> Optional[_builtins.str]:
        """
        Controls whether the BIOS uses the serial console for input/output; the value is a "yes"/"no" string flag. If unset, the hypervisor default is used.

        See: <https://libvirt.org/formatdomain.html#bios-bootloader>
        """
        return pulumi.get(self, "use_serial")


@pulumi.output_type
class DomainOsBootDevice(dict):
    def __init__(__self__, *,
                 dev: _builtins.str):
        """
        :param _builtins.str dev: Defines a single boot target device type in the boot order; valid values include "hd", "cdrom", "fd", and "network" (and any additional values supported by the hypervisor). Example: "hd".
               
               See: <https://libvirt.org/formatdomain.html#bios-bootloader>
        """
        pulumi.set(__self__, "dev", dev)

    @_builtins.property
    @pulumi.getter
    def dev(self) -> _builtins.str:
        """
        Defines a single boot target device type in the boot order; valid values include "hd", "cdrom", "fd", and "network" (and any additional values supported by the hypervisor). Example: "hd".

        See: <https://libvirt.org/formatdomain.html#bios-bootloader>
        """
        return pulumi.get(self, "dev")


@pulumi.output_type
class DomainOsBootMenu(dict):
    def __init__(__self__, *,
                 enable: Optional[_builtins.str] = None,
                 timeout: Optional[_builtins.str] = None):
        """
        :param _builtins.str enable: Controls whether the firmware boot menu is enabled; the value is a "yes"/"no" string flag. Example: "yes" to show the boot menu at startup.
               
               See: <https://libvirt.org/formatdomain.html#bios-bootloader>
        :param _builtins.str timeout: Sets the boot menu timeout in milliseconds before the firmware automatically continues boot; the value is a non-negative integer. Example: 3000.
               
               See: <https://libvirt.org/formatdomain.html#bios-bootloader>
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[_builtins.str]:
        """
        Controls whether the firmware boot menu is enabled; the value is a "yes"/"no" string flag. Example: "yes" to show the boot menu at startup.

        See: <https://libvirt.org/formatdomain.html#bios-bootloader>
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.str]:
        """
        Sets the boot menu timeout in milliseconds before the firmware automatically continues boot; the value is a non-negative integer. Example: 3000.

        See: <https://libvirt.org/formatdomain.html#bios-bootloader>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainOsFirmwareInfo(dict):
    def __init__(__self__, *,
                 features: Optional[Sequence['outputs.DomainOsFirmwareInfoFeature']] = None):
        """
        :param Sequence['DomainOsFirmwareInfoFeatureArgs'] features: Configures one or more firmware features to be exposed to the guest firmware/boot environment; each entry corresponds to a single feature toggle, with semantics defined by the underlying firmware implementation.
               
               See: <https://libvirt.org/formatdomain.html#operating-system-booting>
        """
        if features is not None:
            pulumi.set(__self__, "features", features)

    @_builtins.property
    @pulumi.getter
    def features(self) -> Optional[Sequence['outputs.DomainOsFirmwareInfoFeature']]:
        """
        Configures one or more firmware features to be exposed to the guest firmware/boot environment; each entry corresponds to a single feature toggle, with semantics defined by the underlying firmware implementation.

        See: <https://libvirt.org/formatdomain.html#operating-system-booting>
        """
        return pulumi.get(self, "features")


@pulumi.output_type
class DomainOsFirmwareInfoFeature(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str enabled: Sets whether the given firmware feature entry is enabled, typically as a boolean-like flag (for example "yes"/"no" or "on"/"off") as required by the firmware.
               
               See: <https://libvirt.org/formatdomain.html#operating-system-booting>
        :param _builtins.str name: Specifies the name/identifier of the firmware feature to control (value is user-provided and must match a feature understood by the chosen firmware).
               
               See: <https://libvirt.org/formatdomain.html#operating-system-booting>
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.str]:
        """
        Sets whether the given firmware feature entry is enabled, typically as a boolean-like flag (for example "yes"/"no" or "on"/"off") as required by the firmware.

        See: <https://libvirt.org/formatdomain.html#operating-system-booting>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Specifies the name/identifier of the firmware feature to control (value is user-provided and must match a feature understood by the chosen firmware).

        See: <https://libvirt.org/formatdomain.html#operating-system-booting>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainOsInitEnv(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Sets the environment variable name for a container init environment entry (for example "PATH" or "HTTP_PROXY").
               
               See: <https://libvirt.org/formatdomain.html#container-boot>
        :param _builtins.str value: Sets the environment variable value for a container init environment entry (for example "/usr/bin:/bin" or "http://proxy:8080").
               
               See: <https://libvirt.org/formatdomain.html#container-boot>
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the environment variable name for a container init environment entry (for example "PATH" or "HTTP_PROXY").

        See: <https://libvirt.org/formatdomain.html#container-boot>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Sets the environment variable value for a container init environment entry (for example "/usr/bin:/bin" or "http://proxy:8080").

        See: <https://libvirt.org/formatdomain.html#container-boot>
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainOsNvRam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nvRam":
            suggest = "nv_ram"
        elif key == "templateFormat":
            suggest = "template_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 nv_ram: _builtins.str,
                 format: Optional[_builtins.str] = None,
                 source: Optional['outputs.DomainOsNvRamSource'] = None,
                 template: Optional[_builtins.str] = None,
                 template_format: Optional[_builtins.str] = None):
        """
        :param _builtins.str nv_ram: Sets the path or identifier of the NVRAM storage used by the guest firmware to persist UEFI/firmware variables.
               
               See: <https://libvirt.org/formatdomain.html#bios-bootloader>
        :param _builtins.str format: Sets the on-disk format of the NVRAM file backing the guest firmware state; the value is user-provided (for example, matching the firmwares expected format).
               
               See: <https://libvirt.org/formatdomain.html#bios-bootloader>
        :param 'DomainOsNvRamSourceArgs' source: Defines the data source for the mirror backing store, such as a block device or file path.
        :param _builtins.str template: Sets the path or volume name of the NVRAM template image from which the guests NVRAM is initially created; the value is user-provided (for example, pointing to an OVMF_VARS template).
               
               See: <https://libvirt.org/formatdomain.html#operating-system-booting>
        :param _builtins.str template_format: Sets the storage format of the NVRAM template (for example, raw or qcow2), controlling how the hypervisor interprets the template backing store.
               
               See: <https://libvirt.org/formatdomain.html#operating-system-booting>
        """
        pulumi.set(__self__, "nv_ram", nv_ram)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if template_format is not None:
            pulumi.set(__self__, "template_format", template_format)

    @_builtins.property
    @pulumi.getter(name="nvRam")
    def nv_ram(self) -> _builtins.str:
        """
        Sets the path or identifier of the NVRAM storage used by the guest firmware to persist UEFI/firmware variables.

        See: <https://libvirt.org/formatdomain.html#bios-bootloader>
        """
        return pulumi.get(self, "nv_ram")

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[_builtins.str]:
        """
        Sets the on-disk format of the NVRAM file backing the guest firmware state; the value is user-provided (for example, matching the firmwares expected format).

        See: <https://libvirt.org/formatdomain.html#bios-bootloader>
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainOsNvRamSource']:
        """
        Defines the data source for the mirror backing store, such as a block device or file path.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def template(self) -> Optional[_builtins.str]:
        """
        Sets the path or volume name of the NVRAM template image from which the guests NVRAM is initially created; the value is user-provided (for example, pointing to an OVMF_VARS template).

        See: <https://libvirt.org/formatdomain.html#operating-system-booting>
        """
        return pulumi.get(self, "template")

    @_builtins.property
    @pulumi.getter(name="templateFormat")
    def template_format(self) -> Optional[_builtins.str]:
        """
        Sets the storage format of the NVRAM template (for example, raw or qcow2), controlling how the hypervisor interprets the template backing store.

        See: <https://libvirt.org/formatdomain.html#operating-system-booting>
        """
        return pulumi.get(self, "template_format")


@pulumi.output_type
class DomainOsNvRamSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataStore":
            suggest = "data_store"
        elif key == "startupPolicy":
            suggest = "startup_policy"
        elif key == "vhostUser":
            suggest = "vhost_user"
        elif key == "vhostVdpa":
            suggest = "vhost_vdpa"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block: Optional['outputs.DomainOsNvRamSourceBlock'] = None,
                 cookies: Optional['outputs.DomainOsNvRamSourceCookies'] = None,
                 data_store: Optional['outputs.DomainOsNvRamSourceDataStore'] = None,
                 dir: Optional['outputs.DomainOsNvRamSourceDir'] = None,
                 encryption: Optional['outputs.DomainOsNvRamSourceEncryption'] = None,
                 file: Optional['outputs.DomainOsNvRamSourceFile'] = None,
                 index: Optional[_builtins.float] = None,
                 network: Optional['outputs.DomainOsNvRamSourceNetwork'] = None,
                 nvme: Optional['outputs.DomainOsNvRamSourceNvme'] = None,
                 readahead: Optional['outputs.DomainOsNvRamSourceReadahead'] = None,
                 reservations: Optional['outputs.DomainOsNvRamSourceReservations'] = None,
                 slices: Optional['outputs.DomainOsNvRamSourceSlices'] = None,
                 ssl: Optional['outputs.DomainOsNvRamSourceSsl'] = None,
                 startup_policy: Optional[_builtins.str] = None,
                 timeout: Optional['outputs.DomainOsNvRamSourceTimeout'] = None,
                 vhost_user: Optional['outputs.DomainOsNvRamSourceVhostUser'] = None,
                 vhost_vdpa: Optional['outputs.DomainOsNvRamSourceVhostVdpa'] = None,
                 volume: Optional['outputs.DomainOsNvRamSourceVolume'] = None):
        """
        :param 'DomainOsNvRamSourceBlockArgs' block: Describes a block device used as the source for the mirror backing store.
        :param 'DomainOsNvRamSourceCookiesArgs' cookies: Provides optional cookie data associated with the mirror backing store source (for example, auth or session data), with content treated as user-provided.
        :param 'DomainOsNvRamSourceDataStoreArgs' data_store: Configures a data store descriptor for the mirrored backing store, typically used with networked or advanced storage backends that expose format-specific options.
        :param 'DomainOsNvRamSourceDirArgs' dir: Configures a directory-based source for the mirrored backing store, pointing to a host directory used by the backing image.
        :param 'DomainOsNvRamSourceEncryptionArgs' encryption: Enables disk image encryption configuration for this disk and groups attributes defining the encryption engine, format, and secrets.
        :param 'DomainOsNvRamSourceFileArgs' file: Configures a file-based backing store source for the disk mirror, defining how the backing image is accessed from the host filesystem.
        :param _builtins.float index: Sets the index of this backing store within a backing chain, used when multiple backing layers are present; value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainOsNvRamSourceNetworkArgs' network: Configures a network-based backing store source (such as NBD, iSCSI, or RBD) for the disk mirror, including authentication and host endpoints.
        :param 'DomainOsNvRamSourceNvmeArgs' nvme: Enables using an NVMe-backed source for the mirrored disks backing store; when present, it selects an NVMe device or namespace as the source, with details defined by libvirt/QEMU for NVMe disks.
        :param 'DomainOsNvRamSourceReadaheadArgs' readahead: Configures read-ahead behavior for the mirrored disks backing-store source, allowing tuning of how much data is pre-fetched from the backend.
        :param 'DomainOsNvRamSourceReservationsArgs' reservations: Configures SCSI-style reservations or similar persistent reservation management for the mirrored disks backing-store source, controlling how access is coordinated across nodes.
        :param 'DomainOsNvRamSourceSlicesArgs' slices: Configures optional slice or segment information for the backing store source (for example, to describe which logical slices of a device are used); content is user-provided.
        :param 'DomainOsNvRamSourceSslArgs' ssl: Enables SSL/TLS parameters for accessing the mirrored backing-store source when it is provided over a secure transport.
        :param _builtins.str startup_policy: Specifies how strictly the mirrored backing-store source must be available during domain startup; valid values include "mandatory", "requisite", "optional" (userprovided string matched by libvirt).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainOsNvRamSourceTimeoutArgs' timeout: Configures a timeout for connecting to or initializing the mirrored backing-store source.
        :param 'DomainOsNvRamSourceVhostUserArgs' vhost_user: Selects a vhost-user backend as the transport for the mirrored backing-store source, allowing it to be provided via a userspace process.
        :param 'DomainOsNvRamSourceVhostVdpaArgs' vhost_vdpa: Selects a vhost-vDPA backend for the disk mirror backing store, allowing acceleration via a vDPA device; additional details are determined by libvirt and device configuration.
        :param 'DomainOsNvRamSourceVolumeArgs' volume: Configures the backingStore source as a libvirt storage volume reference instead of a raw file/block path for the mirrored disk.
        """
        if block is not None:
            pulumi.set(__self__, "block", block)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if data_store is not None:
            pulumi.set(__self__, "data_store", data_store)
        if dir is not None:
            pulumi.set(__self__, "dir", dir)
        if encryption is not None:
            pulumi.set(__self__, "encryption", encryption)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if nvme is not None:
            pulumi.set(__self__, "nvme", nvme)
        if readahead is not None:
            pulumi.set(__self__, "readahead", readahead)
        if reservations is not None:
            pulumi.set(__self__, "reservations", reservations)
        if slices is not None:
            pulumi.set(__self__, "slices", slices)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if startup_policy is not None:
            pulumi.set(__self__, "startup_policy", startup_policy)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if vhost_user is not None:
            pulumi.set(__self__, "vhost_user", vhost_user)
        if vhost_vdpa is not None:
            pulumi.set(__self__, "vhost_vdpa", vhost_vdpa)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional['outputs.DomainOsNvRamSourceBlock']:
        """
        Describes a block device used as the source for the mirror backing store.
        """
        return pulumi.get(self, "block")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.DomainOsNvRamSourceCookies']:
        """
        Provides optional cookie data associated with the mirror backing store source (for example, auth or session data), with content treated as user-provided.
        """
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="dataStore")
    def data_store(self) -> Optional['outputs.DomainOsNvRamSourceDataStore']:
        """
        Configures a data store descriptor for the mirrored backing store, typically used with networked or advanced storage backends that expose format-specific options.
        """
        return pulumi.get(self, "data_store")

    @_builtins.property
    @pulumi.getter
    def dir(self) -> Optional['outputs.DomainOsNvRamSourceDir']:
        """
        Configures a directory-based source for the mirrored backing store, pointing to a host directory used by the backing image.
        """
        return pulumi.get(self, "dir")

    @_builtins.property
    @pulumi.getter
    def encryption(self) -> Optional['outputs.DomainOsNvRamSourceEncryption']:
        """
        Enables disk image encryption configuration for this disk and groups attributes defining the encryption engine, format, and secrets.
        """
        return pulumi.get(self, "encryption")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.DomainOsNvRamSourceFile']:
        """
        Configures a file-based backing store source for the disk mirror, defining how the backing image is accessed from the host filesystem.
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.float]:
        """
        Sets the index of this backing store within a backing chain, used when multiple backing layers are present; value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "index")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional['outputs.DomainOsNvRamSourceNetwork']:
        """
        Configures a network-based backing store source (such as NBD, iSCSI, or RBD) for the disk mirror, including authentication and host endpoints.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def nvme(self) -> Optional['outputs.DomainOsNvRamSourceNvme']:
        """
        Enables using an NVMe-backed source for the mirrored disks backing store; when present, it selects an NVMe device or namespace as the source, with details defined by libvirt/QEMU for NVMe disks.
        """
        return pulumi.get(self, "nvme")

    @_builtins.property
    @pulumi.getter
    def readahead(self) -> Optional['outputs.DomainOsNvRamSourceReadahead']:
        """
        Configures read-ahead behavior for the mirrored disks backing-store source, allowing tuning of how much data is pre-fetched from the backend.
        """
        return pulumi.get(self, "readahead")

    @_builtins.property
    @pulumi.getter
    def reservations(self) -> Optional['outputs.DomainOsNvRamSourceReservations']:
        """
        Configures SCSI-style reservations or similar persistent reservation management for the mirrored disks backing-store source, controlling how access is coordinated across nodes.
        """
        return pulumi.get(self, "reservations")

    @_builtins.property
    @pulumi.getter
    def slices(self) -> Optional['outputs.DomainOsNvRamSourceSlices']:
        """
        Configures optional slice or segment information for the backing store source (for example, to describe which logical slices of a device are used); content is user-provided.
        """
        return pulumi.get(self, "slices")

    @_builtins.property
    @pulumi.getter
    def ssl(self) -> Optional['outputs.DomainOsNvRamSourceSsl']:
        """
        Enables SSL/TLS parameters for accessing the mirrored backing-store source when it is provided over a secure transport.
        """
        return pulumi.get(self, "ssl")

    @_builtins.property
    @pulumi.getter(name="startupPolicy")
    def startup_policy(self) -> Optional[_builtins.str]:
        """
        Specifies how strictly the mirrored backing-store source must be available during domain startup; valid values include "mandatory", "requisite", "optional" (userprovided string matched by libvirt).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "startup_policy")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.DomainOsNvRamSourceTimeout']:
        """
        Configures a timeout for connecting to or initializing the mirrored backing-store source.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="vhostUser")
    def vhost_user(self) -> Optional['outputs.DomainOsNvRamSourceVhostUser']:
        """
        Selects a vhost-user backend as the transport for the mirrored backing-store source, allowing it to be provided via a userspace process.
        """
        return pulumi.get(self, "vhost_user")

    @_builtins.property
    @pulumi.getter(name="vhostVdpa")
    def vhost_vdpa(self) -> Optional['outputs.DomainOsNvRamSourceVhostVdpa']:
        """
        Selects a vhost-vDPA backend for the disk mirror backing store, allowing acceleration via a vDPA device; additional details are determined by libvirt and device configuration.
        """
        return pulumi.get(self, "vhost_vdpa")

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional['outputs.DomainOsNvRamSourceVolume']:
        """
        Configures the backingStore source as a libvirt storage volume reference instead of a raw file/block path for the mirrored disk.
        """
        return pulumi.get(self, "volume")


@pulumi.output_type
class DomainOsNvRamSourceBlock(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceBlock. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceBlock.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceBlock.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dev: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainOsNvRamSourceBlockSecLabel']] = None):
        """
        :param _builtins.str dev: Sets the host block device path used as the mirror backing store source (for example "/dev/sdb1"); the value is user-provided and must reference an existing block device.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param Sequence['DomainOsNvRamSourceBlockSecLabelArgs'] sec_labels: Configures an optional security label for the block-device backing store of the mirror, controlling how security drivers label this source.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional[_builtins.str]:
        """
        Sets the host block device path used as the mirror backing store source (for example "/dev/sdb1"); the value is user-provided and must reference an existing block device.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainOsNvRamSourceBlockSecLabel']]:
        """
        Configures an optional security label for the block-device backing store of the mirror, controlling how security drivers label this source.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainOsNvRamSourceBlockSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceBlockSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceBlockSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceBlockSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainOsNvRamSourceCookies(dict):
    def __init__(__self__, *,
                 cookies: Optional[Sequence['outputs.DomainOsNvRamSourceCookiesCookie']] = None):
        """
        :param Sequence['DomainOsNvRamSourceCookiesCookieArgs'] cookies: Configures one or more HTTP cookies to be sent when accessing the mirrored backing store over a network protocol that supports cookies (for example, HTTPS or HTTP-based storage).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[Sequence['outputs.DomainOsNvRamSourceCookiesCookie']]:
        """
        Configures one or more HTTP cookies to be sent when accessing the mirrored backing store over a network protocol that supports cookies (for example, HTTPS or HTTP-based storage).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "cookies")


@pulumi.output_type
class DomainOsNvRamSourceCookiesCookie(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Sets the cookie name for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "sessionid").
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str value: Sets the cookie value for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "abc123").
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the cookie name for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "sessionid").

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Sets the cookie value for this backing store HTTP cookie; the value is user-provided and must be non-empty (for example, "abc123").

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainOsNvRamSourceDataStore(dict):
    def __init__(__self__, *,
                 format: Optional['outputs.DomainOsNvRamSourceDataStoreFormat'] = None):
        """
        :param 'DomainOsNvRamSourceDataStoreFormatArgs' format: Configures the on-disk format settings for the mirrored backing stores data store, including format type and optional metadata cache tuning.
        """
        if format is not None:
            pulumi.set(__self__, "format", format)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional['outputs.DomainOsNvRamSourceDataStoreFormat']:
        """
        Configures the on-disk format settings for the mirrored backing stores data store, including format type and optional metadata cache tuning.
        """
        return pulumi.get(self, "format")


@pulumi.output_type
class DomainOsNvRamSourceDataStoreFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataCache":
            suggest = "metadata_cache"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceDataStoreFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceDataStoreFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceDataStoreFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 metadata_cache: Optional['outputs.DomainOsNvRamSourceDataStoreFormatMetadataCache'] = None):
        """
        :param _builtins.str type: Sets the data store format type for the mirrored backing store (for example, "qcow2" or "raw"); the value is user-provided and must be a valid libvirt disk format name.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainOsNvRamSourceDataStoreFormatMetadataCacheArgs' metadata_cache: Configures metadata cache behavior for the mirrored backing stores data store format (for example, limiting the size of cached metadata).
        """
        pulumi.set(__self__, "type", type)
        if metadata_cache is not None:
            pulumi.set(__self__, "metadata_cache", metadata_cache)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets the data store format type for the mirrored backing store (for example, "qcow2" or "raw"); the value is user-provided and must be a valid libvirt disk format name.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="metadataCache")
    def metadata_cache(self) -> Optional['outputs.DomainOsNvRamSourceDataStoreFormatMetadataCache']:
        """
        Configures metadata cache behavior for the mirrored backing stores data store format (for example, limiting the size of cached metadata).
        """
        return pulumi.get(self, "metadata_cache")


@pulumi.output_type
class DomainOsNvRamSourceDataStoreFormatMetadataCache(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSize":
            suggest = "max_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceDataStoreFormatMetadataCache. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceDataStoreFormatMetadataCache.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceDataStoreFormatMetadataCache.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_size: Optional['outputs.DomainOsNvRamSourceDataStoreFormatMetadataCacheMaxSize'] = None):
        """
        :param 'DomainOsNvRamSourceDataStoreFormatMetadataCacheMaxSizeArgs' max_size: Sets the maximum size of the metadata cache used by the data store format; value and unit together define the limit (for example, 64 MiB).
        """
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional['outputs.DomainOsNvRamSourceDataStoreFormatMetadataCacheMaxSize']:
        """
        Sets the maximum size of the metadata cache used by the data store format; value and unit together define the limit (for example, 64 MiB).
        """
        return pulumi.get(self, "max_size")


@pulumi.output_type
class DomainOsNvRamSourceDataStoreFormatMetadataCacheMaxSize(dict):
    def __init__(__self__, *,
                 value: _builtins.float,
                 unit: Optional[_builtins.str] = None):
        """
        :param _builtins.float value: Sets the numeric value for the metadata cache maximum size in the specified unit; this must be a positive integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str unit: Sets the unit used for the metadata cache maximum size; valid units follow libvirt size units such as "B", "KiB", "MiB", "GiB" and are user-chosen.
               
               See: <https://libvirt.org/formatdomain.html#memory-allocation>
        """
        pulumi.set(__self__, "value", value)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.float:
        """
        Sets the numeric value for the metadata cache maximum size in the specified unit; this must be a positive integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        """
        Sets the unit used for the metadata cache maximum size; valid units follow libvirt size units such as "B", "KiB", "MiB", "GiB" and are user-chosen.

        See: <https://libvirt.org/formatdomain.html#memory-allocation>
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class DomainOsNvRamSourceDir(dict):
    def __init__(__self__, *,
                 dir: Optional[_builtins.str] = None):
        """
        :param _builtins.str dir: Sets the host directory path used as the mirrored backing store source; this must be an absolute path on the host (for example, "/var/lib/libvirt/images").
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if dir is not None:
            pulumi.set(__self__, "dir", dir)

    @_builtins.property
    @pulumi.getter
    def dir(self) -> Optional[_builtins.str]:
        """
        Sets the host directory path used as the mirrored backing store source; this must be an absolute path on the host (for example, "/var/lib/libvirt/images").

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "dir")


@pulumi.output_type
class DomainOsNvRamSourceEncryption(dict):
    def __init__(__self__, *,
                 engine: Optional[_builtins.str] = None,
                 format: Optional[_builtins.str] = None,
                 secrets: Optional[Sequence['outputs.DomainOsNvRamSourceEncryptionSecret']] = None):
        """
        :param _builtins.str engine: Sets the encryption engine/provider to use for the disk (user-provided string, e.g. implementation-specific engine name).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str format: Sets the disk encryption format, such as "luks" or another user-provided scheme supported by libvirt/qemu.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param Sequence['DomainOsNvRamSourceEncryptionSecretArgs'] secrets: Defines one or more secret references used to access the encrypted disk, each describing how libvirt locates the secret material.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if engine is not None:
            pulumi.set(__self__, "engine", engine)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def engine(self) -> Optional[_builtins.str]:
        """
        Sets the encryption engine/provider to use for the disk (user-provided string, e.g. implementation-specific engine name).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "engine")

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[_builtins.str]:
        """
        Sets the disk encryption format, such as "luks" or another user-provided scheme supported by libvirt/qemu.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[Sequence['outputs.DomainOsNvRamSourceEncryptionSecret']]:
        """
        Defines one or more secret references used to access the encrypted disk, each describing how libvirt locates the secret material.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class DomainOsNvRamSourceEncryptionSecret(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 usage: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str usage: Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str uuid: Exposes the UUID of the libvirt secret used for iSCSI authentication; this is computed from the referenced secret rather than configured directly.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def usage(self) -> Optional[_builtins.str]:
        """
        Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "usage")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        Exposes the UUID of the libvirt secret used for iSCSI authentication; this is computed from the referenced secret rather than configured directly.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class DomainOsNvRamSourceFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fdGroup":
            suggest = "fd_group"
        elif key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fd_group: Optional[_builtins.str] = None,
                 file: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainOsNvRamSourceFileSecLabel']] = None):
        """
        :param _builtins.str fd_group: Sets the name of an fdgroup whose pre-opened file descriptor is used for this backing store instead of opening the file path directly; value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str file: Sets the absolute path on the host to the backing file used as the source for this mirrored disk (for example, /var/lib/libvirt/images/base.qcow2).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param Sequence['DomainOsNvRamSourceFileSecLabelArgs'] sec_labels: Configures an explicit security label for the file backing store, overriding default security driver labeling for this file.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if fd_group is not None:
            pulumi.set(__self__, "fd_group", fd_group)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter(name="fdGroup")
    def fd_group(self) -> Optional[_builtins.str]:
        """
        Sets the name of an fdgroup whose pre-opened file descriptor is used for this backing store instead of opening the file path directly; value is user-provided.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "fd_group")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional[_builtins.str]:
        """
        Sets the absolute path on the host to the backing file used as the source for this mirrored disk (for example, /var/lib/libvirt/images/base.qcow2).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainOsNvRamSourceFileSecLabel']]:
        """
        Configures an explicit security label for the file backing store, overriding default security driver labeling for this file.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainOsNvRamSourceFileSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceFileSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceFileSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceFileSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainOsNvRamSourceNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "knownHosts":
            suggest = "known_hosts"
        elif key == "tlsHostname":
            suggest = "tls_hostname"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth: Optional['outputs.DomainOsNvRamSourceNetworkAuth'] = None,
                 config: Optional['outputs.DomainOsNvRamSourceNetworkConfig'] = None,
                 hosts: Optional[Sequence['outputs.DomainOsNvRamSourceNetworkHost']] = None,
                 identity: Optional['outputs.DomainOsNvRamSourceNetworkIdentity'] = None,
                 initiator: Optional['outputs.DomainOsNvRamSourceNetworkInitiator'] = None,
                 known_hosts: Optional['outputs.DomainOsNvRamSourceNetworkKnownHosts'] = None,
                 name: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 query: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainOsNvRamSourceNetworkReconnect'] = None,
                 snapshot: Optional['outputs.DomainOsNvRamSourceNetworkSnapshot'] = None,
                 tls: Optional[_builtins.str] = None,
                 tls_hostname: Optional[_builtins.str] = None):
        """
        :param 'DomainOsNvRamSourceNetworkAuthArgs' auth: Configures CHAP authentication parameters for the iSCSI source backing an assigned SCSI host device; include this block only when the target requires authentication.
        :param 'DomainOsNvRamSourceNetworkConfigArgs' config: Points to an external configuration source for the network backing store (for example, an RBD or Ceph config file) that libvirt passes to the backend.
        :param Sequence['DomainOsNvRamSourceNetworkHostArgs'] hosts: Declares one or more network endpoints (hosts) for the backing store server, each with its own name/address and possibly additional attributes.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainOsNvRamSourceNetworkIdentityArgs' identity: Configures authentication/identity parameters used when accessing the mirrored backing store over a network, such as user, group, keyfile, or agent socket, depending on the protocol.
        :param 'DomainOsNvRamSourceNetworkInitiatorArgs' initiator: Configures initiator identity information (typically for iSCSI-like protocols) used when accessing the mirrored network backing store.
        :param 'DomainOsNvRamSourceNetworkKnownHostsArgs' known_hosts: Enables use of a known-hosts file to validate the remote hosts identity when connecting to the mirrored network backing store.
        :param _builtins.str name: Sets a name for the network source of the mirrored backing store, typically used by certain protocols (such as RBD pool or NBD export names); value is user-provided and protocol-specific.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str protocol: Sets the network storage protocol used for the mirrored backing store; value is user-provided but must be a protocol supported by libvirt for network disks (for example, rbd, sheepdog, gluster, nbd).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str query: Sets an optional query string or subresource specifier for the network storage URL of the mirrored backing store; value is user-provided and protocol-specific.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param 'DomainOsNvRamSourceNetworkReconnectArgs' reconnect: Configures automatic reconnection behavior for the mirrored network backing store after a connection loss.
        :param 'DomainOsNvRamSourceNetworkSnapshotArgs' snapshot: Configures snapshot-related behavior for the network-based mirrored backing store, with semantics depending on the underlying protocol and storage implementation.
        :param _builtins.str tls: Controls whether TLS is used for the mirrored disks network backing-store connection; value is user-provided and typically enabled only when the chosen protocol and backend support TLS.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str tls_hostname: Sets the expected TLS hostname for the mirrored disks network backing-store connection, used for certificate verification; value is user-provided and should match the server certificates hostname (for example, "storage.example.com").
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if initiator is not None:
            pulumi.set(__self__, "initiator", initiator)
        if known_hosts is not None:
            pulumi.set(__self__, "known_hosts", known_hosts)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if snapshot is not None:
            pulumi.set(__self__, "snapshot", snapshot)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if tls_hostname is not None:
            pulumi.set(__self__, "tls_hostname", tls_hostname)

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional['outputs.DomainOsNvRamSourceNetworkAuth']:
        """
        Configures CHAP authentication parameters for the iSCSI source backing an assigned SCSI host device; include this block only when the target requires authentication.
        """
        return pulumi.get(self, "auth")

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional['outputs.DomainOsNvRamSourceNetworkConfig']:
        """
        Points to an external configuration source for the network backing store (for example, an RBD or Ceph config file) that libvirt passes to the backend.
        """
        return pulumi.get(self, "config")

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence['outputs.DomainOsNvRamSourceNetworkHost']]:
        """
        Declares one or more network endpoints (hosts) for the backing store server, each with its own name/address and possibly additional attributes.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter
    def identity(self) -> Optional['outputs.DomainOsNvRamSourceNetworkIdentity']:
        """
        Configures authentication/identity parameters used when accessing the mirrored backing store over a network, such as user, group, keyfile, or agent socket, depending on the protocol.
        """
        return pulumi.get(self, "identity")

    @_builtins.property
    @pulumi.getter
    def initiator(self) -> Optional['outputs.DomainOsNvRamSourceNetworkInitiator']:
        """
        Configures initiator identity information (typically for iSCSI-like protocols) used when accessing the mirrored network backing store.
        """
        return pulumi.get(self, "initiator")

    @_builtins.property
    @pulumi.getter(name="knownHosts")
    def known_hosts(self) -> Optional['outputs.DomainOsNvRamSourceNetworkKnownHosts']:
        """
        Enables use of a known-hosts file to validate the remote hosts identity when connecting to the mirrored network backing store.
        """
        return pulumi.get(self, "known_hosts")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets a name for the network source of the mirrored backing store, typically used by certain protocols (such as RBD pool or NBD export names); value is user-provided and protocol-specific.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        Sets the network storage protocol used for the mirrored backing store; value is user-provided but must be a protocol supported by libvirt for network disks (for example, rbd, sheepdog, gluster, nbd).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional[_builtins.str]:
        """
        Sets an optional query string or subresource specifier for the network storage URL of the mirrored backing store; value is user-provided and protocol-specific.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "query")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainOsNvRamSourceNetworkReconnect']:
        """
        Configures automatic reconnection behavior for the mirrored network backing store after a connection loss.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter
    def snapshot(self) -> Optional['outputs.DomainOsNvRamSourceNetworkSnapshot']:
        """
        Configures snapshot-related behavior for the network-based mirrored backing store, with semantics depending on the underlying protocol and storage implementation.
        """
        return pulumi.get(self, "snapshot")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[_builtins.str]:
        """
        Controls whether TLS is used for the mirrored disks network backing-store connection; value is user-provided and typically enabled only when the chosen protocol and backend support TLS.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "tls")

    @_builtins.property
    @pulumi.getter(name="tlsHostname")
    def tls_hostname(self) -> Optional[_builtins.str]:
        """
        Sets the expected TLS hostname for the mirrored disks network backing-store connection, used for certificate verification; value is user-provided and should match the server certificates hostname (for example, "storage.example.com").

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "tls_hostname")


@pulumi.output_type
class DomainOsNvRamSourceNetworkAuth(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.DomainOsNvRamSourceNetworkAuthSecret'] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param 'DomainOsNvRamSourceNetworkAuthSecretArgs' secret: Configures the libvirt secret object used to hold the iSCSI authentication password for this hostdev; this references an existing libvirt secret, not the clear-text secret.
        :param _builtins.str username: Sets the CHAP username used when authenticating to the iSCSI target for this SCSI hostdev; the value is user-provided (for example, "chapuser1").
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.DomainOsNvRamSourceNetworkAuthSecret']:
        """
        Configures the libvirt secret object used to hold the iSCSI authentication password for this hostdev; this references an existing libvirt secret, not the clear-text secret.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        Sets the CHAP username used when authenticating to the iSCSI target for this SCSI hostdev; the value is user-provided (for example, "chapuser1").

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class DomainOsNvRamSourceNetworkAuthSecret(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 usage: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str usage: Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str uuid: Exposes the UUID of the libvirt secret used for iSCSI authentication; this is computed from the referenced secret rather than configured directly.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Sets how the referenced secret is identified; typical values are user-provided strings such as "uuid" or "usage" depending on how the secret is looked up.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def usage(self) -> Optional[_builtins.str]:
        """
        Sets the libvirt secret usage name when referencing the iSCSI auth secret by usage; the value is a user-provided identifier such as an iSCSI target name.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "usage")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        Exposes the UUID of the libvirt secret used for iSCSI authentication; this is computed from the referenced secret rather than configured directly.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class DomainOsNvRamSourceNetworkConfig(dict):
    def __init__(__self__, *,
                 file: _builtins.str):
        """
        :param _builtins.str file: Sets the path to the configuration file used for the network backing store connection, such as a Ceph configuration file (/etc/ceph/ceph.conf).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "file", file)

    @_builtins.property
    @pulumi.getter
    def file(self) -> _builtins.str:
        """
        Sets the path to the configuration file used for the network backing store connection, such as a Ceph configuration file (/etc/ceph/ceph.conf).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "file")


@pulumi.output_type
class DomainOsNvRamSourceNetworkHost(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 socket: Optional[_builtins.str] = None,
                 transport: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Sets the hostname or IP address of the iSCSI target portal (for example, "10.0.0.10" or "iscsi.example.com").
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str port: Sets the TCP port of the iSCSI target portal; if omitted, libvirt/driver defaults (commonly 3260) are used.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str socket: Sets a UNIX domain socket path to connect to an iSCSI target via a local socket instead of TCP; value is a user-provided filesystem path.
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        :param _builtins.str transport: Sets the transport type used to reach the iSCSI target portal; valid values are user-provided strings as supported by the environment (for example, "tcp" or "iser").
               
               See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if socket is not None:
            pulumi.set(__self__, "socket", socket)
        if transport is not None:
            pulumi.set(__self__, "transport", transport)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the hostname or IP address of the iSCSI target portal (for example, "10.0.0.10" or "iscsi.example.com").

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        """
        Sets the TCP port of the iSCSI target portal; if omitted, libvirt/driver defaults (commonly 3260) are used.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def socket(self) -> Optional[_builtins.str]:
        """
        Sets a UNIX domain socket path to connect to an iSCSI target via a local socket instead of TCP; value is a user-provided filesystem path.

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "socket")

    @_builtins.property
    @pulumi.getter
    def transport(self) -> Optional[_builtins.str]:
        """
        Sets the transport type used to reach the iSCSI target portal; valid values are user-provided strings as supported by the environment (for example, "tcp" or "iser").

        See: <https://libvirt.org/formatdomain.html#host-device-assignment>
        """
        return pulumi.get(self, "transport")


@pulumi.output_type
class DomainOsNvRamSourceNetworkIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentSock":
            suggest = "agent_sock"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceNetworkIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceNetworkIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceNetworkIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_sock: Optional[_builtins.str] = None,
                 group: Optional[_builtins.str] = None,
                 keyfile: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str agent_sock: Sets the path to a local agent socket used for external authentication (for example, SASL or SSH agent) when connecting to the network backing store; value is a user-provided Unix socket path.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str group: Sets the group name to use for authentication or access control when connecting to the network backing store; value is user-provided and protocol-specific.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str keyfile: Sets the path to a private key file used for authenticating to the network backing store (for example, an SSH or TLS key); value is a user-provided filesystem path.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str user: Sets the user identifier used for authentication to the network backing store; value is user-provided and typically matches a remote account name.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str user_name: Sets an explicit username string used for authentication to the network backing store, separate from any other user identity settings; value is user-provided (for example, "backupuser").
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if agent_sock is not None:
            pulumi.set(__self__, "agent_sock", agent_sock)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if keyfile is not None:
            pulumi.set(__self__, "keyfile", keyfile)
        if user is not None:
            pulumi.set(__self__, "user", user)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="agentSock")
    def agent_sock(self) -> Optional[_builtins.str]:
        """
        Sets the path to a local agent socket used for external authentication (for example, SASL or SSH agent) when connecting to the network backing store; value is a user-provided Unix socket path.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "agent_sock")

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[_builtins.str]:
        """
        Sets the group name to use for authentication or access control when connecting to the network backing store; value is user-provided and protocol-specific.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter
    def keyfile(self) -> Optional[_builtins.str]:
        """
        Sets the path to a private key file used for authenticating to the network backing store (for example, an SSH or TLS key); value is a user-provided filesystem path.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "keyfile")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        Sets the user identifier used for authentication to the network backing store; value is user-provided and typically matches a remote account name.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "user")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        """
        Sets an explicit username string used for authentication to the network backing store, separate from any other user identity settings; value is user-provided (for example, "backupuser").

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class DomainOsNvRamSourceNetworkInitiator(dict):
    def __init__(__self__, *,
                 iqn: Optional['outputs.DomainOsNvRamSourceNetworkInitiatorIqn'] = None):
        """
        :param 'DomainOsNvRamSourceNetworkInitiatorIqnArgs' iqn: Configures the iSCSI initiator IQN block for the mirrored network backing store, defining the initiator name presented to the target.
        """
        if iqn is not None:
            pulumi.set(__self__, "iqn", iqn)

    @_builtins.property
    @pulumi.getter
    def iqn(self) -> Optional['outputs.DomainOsNvRamSourceNetworkInitiatorIqn']:
        """
        Configures the iSCSI initiator IQN block for the mirrored network backing store, defining the initiator name presented to the target.
        """
        return pulumi.get(self, "iqn")


@pulumi.output_type
class DomainOsNvRamSourceNetworkInitiatorIqn(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Sets the initiator IQN string used when logging into an iSCSI target backing the mirrored disk; value must be a valid IQN (for example, iqn.2020-01.com.example:host1).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the initiator IQN string used when logging into an iSCSI target backing the mirrored disk; value must be a valid IQN (for example, iqn.2020-01.com.example:host1).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainOsNvRamSourceNetworkKnownHosts(dict):
    def __init__(__self__, *,
                 path: _builtins.str):
        """
        :param _builtins.str path: Sets the path to the known-hosts file used to verify the identity of the remote storage host; value is a required user-provided filesystem path (for example, /etc/libvirt/known_hosts).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the path to the known-hosts file used to verify the identity of the remote storage host; value is a required user-provided filesystem path (for example, /etc/libvirt/known_hosts).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DomainOsNvRamSourceNetworkReconnect(dict):
    def __init__(__self__, *,
                 delay: _builtins.str):
        """
        :param _builtins.str delay: Sets the reconnection delay (in seconds) before retrying a failed connection to the mirrored network backing store; value is a required user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "delay", delay)

    @_builtins.property
    @pulumi.getter
    def delay(self) -> _builtins.str:
        """
        Sets the reconnection delay (in seconds) before retrying a failed connection to the mirrored network backing store; value is a required user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "delay")


@pulumi.output_type
class DomainOsNvRamSourceNetworkSnapshot(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the name of the network snapshot to use as the backing store for the mirrored disks network source; value is user-provided and must match an existing snapshot identifier on the storage backend.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the name of the network snapshot to use as the backing store for the mirrored disks network source; value is user-provided and must match an existing snapshot identifier on the storage backend.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainOsNvRamSourceNvme(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DomainOsNvRamSourceReadahead(dict):
    def __init__(__self__, *,
                 size: _builtins.str):
        """
        :param _builtins.str size: Sets the read-ahead size for the mirrored disks backing store; value is a user-provided positive integer in bytes (for example, 65536 for 64 KiB).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        """
        Sets the read-ahead size for the mirrored disks backing store; value is a user-provided positive integer in bytes (for example, 65536 for 64 KiB).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class DomainOsNvRamSourceReservations(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.str] = None,
                 managed: Optional[_builtins.bool] = None,
                 source: Optional['outputs.DomainOsNvRamSourceReservationsSource'] = None):
        """
        :param _builtins.str enabled: Controls whether persistent reservations are enabled for the mirrored disks backing-store source; value is user-provided and typically expects "yes" or "no" semantics per libvirt.
        :param _builtins.bool managed: Indicates whether reservations are managed by libvirt ("yes") or externally ("no"); value is provided as a string and translated to a boolean, with "yes" meaning true and "no" meaning false.
        :param 'DomainOsNvRamSourceReservationsSourceArgs' source: Selects the mechanism used to provide reservation control for the mirrored backing-store source, such as a D-Bus service or a device/file endpoint.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if managed is not None:
            pulumi.set(__self__, "managed", managed)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.str]:
        """
        Controls whether persistent reservations are enabled for the mirrored disks backing-store source; value is user-provided and typically expects "yes" or "no" semantics per libvirt.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def managed(self) -> Optional[_builtins.bool]:
        """
        Indicates whether reservations are managed by libvirt ("yes") or externally ("no"); value is provided as a string and translated to a boolean, with "yes" meaning true and "no" meaning false.
        """
        return pulumi.get(self, "managed")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.DomainOsNvRamSourceReservationsSource']:
        """
        Selects the mechanism used to provide reservation control for the mirrored backing-store source, such as a D-Bus service or a device/file endpoint.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class DomainOsNvRamSourceReservationsSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "qemuvdAgent":
            suggest = "qemuvd_agent"
        elif key == "spicePort":
            suggest = "spice_port"
        elif key == "spiceVmc":
            suggest = "spice_vmc"
        elif key == "stdIo":
            suggest = "std_io"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceReservationsSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceReservationsSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceReservationsSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbus: Optional['outputs.DomainOsNvRamSourceReservationsSourceDbus'] = None,
                 dev: Optional['outputs.DomainOsNvRamSourceReservationsSourceDev'] = None,
                 file: Optional['outputs.DomainOsNvRamSourceReservationsSourceFile'] = None,
                 nmdm: Optional['outputs.DomainOsNvRamSourceReservationsSourceNmdm'] = None,
                 null: Optional[_builtins.bool] = None,
                 pipe: Optional['outputs.DomainOsNvRamSourceReservationsSourcePipe'] = None,
                 pty: Optional['outputs.DomainOsNvRamSourceReservationsSourcePty'] = None,
                 qemuvd_agent: Optional['outputs.DomainOsNvRamSourceReservationsSourceQemuvdAgent'] = None,
                 spice_port: Optional['outputs.DomainOsNvRamSourceReservationsSourceSpicePort'] = None,
                 spice_vmc: Optional[_builtins.bool] = None,
                 std_io: Optional[_builtins.bool] = None,
                 tcp: Optional['outputs.DomainOsNvRamSourceReservationsSourceTcp'] = None,
                 udp: Optional['outputs.DomainOsNvRamSourceReservationsSourceUdp'] = None,
                 unix: Optional['outputs.DomainOsNvRamSourceReservationsSourceUnix'] = None,
                 vc: Optional[_builtins.bool] = None):
        """
        :param 'DomainOsNvRamSourceReservationsSourceDbusArgs' dbus: Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        :param 'DomainOsNvRamSourceReservationsSourceDevArgs' dev: Configures an EGD RNG backend that reads entropy from a host character device node.
        :param 'DomainOsNvRamSourceReservationsSourceFileArgs' file: Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        :param 'DomainOsNvRamSourceReservationsSourceNmdmArgs' nmdm: Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        :param _builtins.bool null: Enables use of a null character device as the reservation backing source; when this boolean is true, a Null source is emitted and all written data is discarded.
               
               See: <https://libvirt.org/formatdomain.html#null-device>
        :param 'DomainOsNvRamSourceReservationsSourcePipeArgs' pipe: Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        :param 'DomainOsNvRamSourceReservationsSourcePtyArgs' pty: Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        :param 'DomainOsNvRamSourceReservationsSourceQemuvdAgentArgs' qemuvd_agent: Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        :param 'DomainOsNvRamSourceReservationsSourceSpicePortArgs' spice_port: Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        :param _builtins.bool spice_vmc: Enables a SPICE VMC (SPICE management channel) backend for this backing-store source; when set true the element is emitted, when false or null it is omitted.
               
               See: <https://libvirt.org/formatdomain.html#spice-channel>
        :param _builtins.bool std_io: Connects the backing-store sources character channel to the domains standard I/O (stdin/stdout/stderr); when true the element is emitted, when false or null it is omitted.
               
               See: <https://libvirt.org/formatdomain.html#host-interface>
        :param 'DomainOsNvRamSourceReservationsSourceTcpArgs' tcp: Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        :param 'DomainOsNvRamSourceReservationsSourceUdpArgs' udp: Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        :param 'DomainOsNvRamSourceReservationsSourceUnixArgs' unix: Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        :param _builtins.bool vc: Enables use of a VC (virtual cluster or vendor-specific) reservation source when set; since this is presence-based, setting it to true emits the element and false/null omits it.
        """
        if dbus is not None:
            pulumi.set(__self__, "dbus", dbus)
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if nmdm is not None:
            pulumi.set(__self__, "nmdm", nmdm)
        if null is not None:
            pulumi.set(__self__, "null", null)
        if pipe is not None:
            pulumi.set(__self__, "pipe", pipe)
        if pty is not None:
            pulumi.set(__self__, "pty", pty)
        if qemuvd_agent is not None:
            pulumi.set(__self__, "qemuvd_agent", qemuvd_agent)
        if spice_port is not None:
            pulumi.set(__self__, "spice_port", spice_port)
        if spice_vmc is not None:
            pulumi.set(__self__, "spice_vmc", spice_vmc)
        if std_io is not None:
            pulumi.set(__self__, "std_io", std_io)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)
        if unix is not None:
            pulumi.set(__self__, "unix", unix)
        if vc is not None:
            pulumi.set(__self__, "vc", vc)

    @_builtins.property
    @pulumi.getter
    def dbus(self) -> Optional['outputs.DomainOsNvRamSourceReservationsSourceDbus']:
        """
        Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        """
        return pulumi.get(self, "dbus")

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional['outputs.DomainOsNvRamSourceReservationsSourceDev']:
        """
        Configures an EGD RNG backend that reads entropy from a host character device node.
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.DomainOsNvRamSourceReservationsSourceFile']:
        """
        Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def nmdm(self) -> Optional['outputs.DomainOsNvRamSourceReservationsSourceNmdm']:
        """
        Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        """
        return pulumi.get(self, "nmdm")

    @_builtins.property
    @pulumi.getter
    def null(self) -> Optional[_builtins.bool]:
        """
        Enables use of a null character device as the reservation backing source; when this boolean is true, a Null source is emitted and all written data is discarded.

        See: <https://libvirt.org/formatdomain.html#null-device>
        """
        return pulumi.get(self, "null")

    @_builtins.property
    @pulumi.getter
    def pipe(self) -> Optional['outputs.DomainOsNvRamSourceReservationsSourcePipe']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        """
        return pulumi.get(self, "pipe")

    @_builtins.property
    @pulumi.getter
    def pty(self) -> Optional['outputs.DomainOsNvRamSourceReservationsSourcePty']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        """
        return pulumi.get(self, "pty")

    @_builtins.property
    @pulumi.getter(name="qemuvdAgent")
    def qemuvd_agent(self) -> Optional['outputs.DomainOsNvRamSourceReservationsSourceQemuvdAgent']:
        """
        Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        """
        return pulumi.get(self, "qemuvd_agent")

    @_builtins.property
    @pulumi.getter(name="spicePort")
    def spice_port(self) -> Optional['outputs.DomainOsNvRamSourceReservationsSourceSpicePort']:
        """
        Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        """
        return pulumi.get(self, "spice_port")

    @_builtins.property
    @pulumi.getter(name="spiceVmc")
    def spice_vmc(self) -> Optional[_builtins.bool]:
        """
        Enables a SPICE VMC (SPICE management channel) backend for this backing-store source; when set true the element is emitted, when false or null it is omitted.

        See: <https://libvirt.org/formatdomain.html#spice-channel>
        """
        return pulumi.get(self, "spice_vmc")

    @_builtins.property
    @pulumi.getter(name="stdIo")
    def std_io(self) -> Optional[_builtins.bool]:
        """
        Connects the backing-store sources character channel to the domains standard I/O (stdin/stdout/stderr); when true the element is emitted, when false or null it is omitted.

        See: <https://libvirt.org/formatdomain.html#host-interface>
        """
        return pulumi.get(self, "std_io")

    @_builtins.property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.DomainOsNvRamSourceReservationsSourceTcp']:
        """
        Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        """
        return pulumi.get(self, "tcp")

    @_builtins.property
    @pulumi.getter
    def udp(self) -> Optional['outputs.DomainOsNvRamSourceReservationsSourceUdp']:
        """
        Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        """
        return pulumi.get(self, "udp")

    @_builtins.property
    @pulumi.getter
    def unix(self) -> Optional['outputs.DomainOsNvRamSourceReservationsSourceUnix']:
        """
        Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        """
        return pulumi.get(self, "unix")

    @_builtins.property
    @pulumi.getter
    def vc(self) -> Optional[_builtins.bool]:
        """
        Enables use of a VC (virtual cluster or vendor-specific) reservation source when set; since this is presence-based, setting it to true emits the element and false/null omits it.
        """
        return pulumi.get(self, "vc")


@pulumi.output_type
class DomainOsNvRamSourceReservationsSourceDbus(dict):
    def __init__(__self__, *,
                 channel: Optional[_builtins.str] = None):
        """
        :param _builtins.str channel: Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.str]:
        """
        Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainOsNvRamSourceReservationsSourceDev(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceReservationsSourceDev. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceReservationsSourceDev.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceReservationsSourceDev.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainOsNvRamSourceReservationsSourceDevSecLabel']] = None):
        """
        :param _builtins.str path: Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainOsNvRamSourceReservationsSourceDevSecLabelArgs'] sec_labels: Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainOsNvRamSourceReservationsSourceDevSecLabel']]:
        """
        Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainOsNvRamSourceReservationsSourceDevSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceReservationsSourceDevSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceReservationsSourceDevSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceReservationsSourceDevSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainOsNvRamSourceReservationsSourceFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceReservationsSourceFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceReservationsSourceFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceReservationsSourceFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 append: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainOsNvRamSourceReservationsSourceFileSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str append: Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
               
               See: <https://libvirt.org/formatdomain.html#device-logfile>
        :param Sequence['DomainOsNvRamSourceReservationsSourceFileSecLabelArgs'] sec_labels: Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def append(self) -> Optional[_builtins.str]:
        """
        Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.

        See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        return pulumi.get(self, "append")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainOsNvRamSourceReservationsSourceFileSecLabel']]:
        """
        Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainOsNvRamSourceReservationsSourceFileSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceReservationsSourceFileSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceReservationsSourceFileSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceReservationsSourceFileSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainOsNvRamSourceReservationsSourceNmdm(dict):
    def __init__(__self__, *,
                 master: _builtins.str,
                 slave: _builtins.str):
        """
        :param _builtins.str master: Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        :param _builtins.str slave: Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        pulumi.set(__self__, "master", master)
        pulumi.set(__self__, "slave", slave)

    @_builtins.property
    @pulumi.getter
    def master(self) -> _builtins.str:
        """
        Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "master")

    @_builtins.property
    @pulumi.getter
    def slave(self) -> _builtins.str:
        """
        Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "slave")


@pulumi.output_type
class DomainOsNvRamSourceReservationsSourcePipe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceReservationsSourcePipe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceReservationsSourcePipe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceReservationsSourcePipe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainOsNvRamSourceReservationsSourcePipeSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainOsNvRamSourceReservationsSourcePipeSecLabelArgs'] sec_labels: Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainOsNvRamSourceReservationsSourcePipeSecLabel']]:
        """
        Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainOsNvRamSourceReservationsSourcePipeSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceReservationsSourcePipeSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceReservationsSourcePipeSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceReservationsSourcePipeSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainOsNvRamSourceReservationsSourcePty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceReservationsSourcePty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceReservationsSourcePty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceReservationsSourcePty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainOsNvRamSourceReservationsSourcePtySecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainOsNvRamSourceReservationsSourcePtySecLabelArgs'] sec_labels: Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainOsNvRamSourceReservationsSourcePtySecLabel']]:
        """
        Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainOsNvRamSourceReservationsSourcePtySecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceReservationsSourcePtySecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceReservationsSourcePtySecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceReservationsSourcePtySecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainOsNvRamSourceReservationsSourceQemuvdAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clipBoard":
            suggest = "clip_board"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceReservationsSourceQemuvdAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceReservationsSourceQemuvdAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceReservationsSourceQemuvdAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clip_board: Optional['outputs.DomainOsNvRamSourceReservationsSourceQemuvdAgentClipBoard'] = None,
                 mouse: Optional['outputs.DomainOsNvRamSourceReservationsSourceQemuvdAgentMouse'] = None):
        """
        :param 'DomainOsNvRamSourceReservationsSourceQemuvdAgentClipBoardArgs' clip_board: Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        :param 'DomainOsNvRamSourceReservationsSourceQemuvdAgentMouseArgs' mouse: Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        if clip_board is not None:
            pulumi.set(__self__, "clip_board", clip_board)
        if mouse is not None:
            pulumi.set(__self__, "mouse", mouse)

    @_builtins.property
    @pulumi.getter(name="clipBoard")
    def clip_board(self) -> Optional['outputs.DomainOsNvRamSourceReservationsSourceQemuvdAgentClipBoard']:
        """
        Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        """
        return pulumi.get(self, "clip_board")

    @_builtins.property
    @pulumi.getter
    def mouse(self) -> Optional['outputs.DomainOsNvRamSourceReservationsSourceQemuvdAgentMouse']:
        """
        Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        return pulumi.get(self, "mouse")


@pulumi.output_type
class DomainOsNvRamSourceReservationsSourceQemuvdAgentClipBoard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyPaste":
            suggest = "copy_paste"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceReservationsSourceQemuvdAgentClipBoard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceReservationsSourceQemuvdAgentClipBoard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceReservationsSourceQemuvdAgentClipBoard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_paste: _builtins.str):
        """
        :param _builtins.str copy_paste: Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "copy_paste", copy_paste)

    @_builtins.property
    @pulumi.getter(name="copyPaste")
    def copy_paste(self) -> _builtins.str:
        """
        Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "copy_paste")


@pulumi.output_type
class DomainOsNvRamSourceReservationsSourceQemuvdAgentMouse(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DomainOsNvRamSourceReservationsSourceSpicePort(dict):
    def __init__(__self__, *,
                 channel: _builtins.str):
        """
        :param _builtins.str channel: Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainOsNvRamSourceReservationsSourceTcp(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainOsNvRamSourceReservationsSourceTcpReconnect'] = None,
                 service: Optional[_builtins.str] = None,
                 tls: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str mode: Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainOsNvRamSourceReservationsSourceTcpReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param _builtins.str service: Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str tls: Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainOsNvRamSourceReservationsSourceTcpReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[_builtins.str]:
        """
        Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class DomainOsNvRamSourceReservationsSourceTcpReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainOsNvRamSourceReservationsSourceUdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindHost":
            suggest = "bind_host"
        elif key == "bindService":
            suggest = "bind_service"
        elif key == "connectHost":
            suggest = "connect_host"
        elif key == "connectService":
            suggest = "connect_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceReservationsSourceUdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceReservationsSourceUdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceReservationsSourceUdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bind_host: _builtins.str,
                 bind_service: _builtins.str,
                 connect_host: _builtins.str,
                 connect_service: _builtins.str):
        """
        :param _builtins.str bind_host: Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str bind_service: Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_host: Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_service: Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "bind_host", bind_host)
        pulumi.set(__self__, "bind_service", bind_service)
        pulumi.set(__self__, "connect_host", connect_host)
        pulumi.set(__self__, "connect_service", connect_service)

    @_builtins.property
    @pulumi.getter(name="bindHost")
    def bind_host(self) -> _builtins.str:
        """
        Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_host")

    @_builtins.property
    @pulumi.getter(name="bindService")
    def bind_service(self) -> _builtins.str:
        """
        Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_service")

    @_builtins.property
    @pulumi.getter(name="connectHost")
    def connect_host(self) -> _builtins.str:
        """
        Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_host")

    @_builtins.property
    @pulumi.getter(name="connectService")
    def connect_service(self) -> _builtins.str:
        """
        Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_service")


@pulumi.output_type
class DomainOsNvRamSourceReservationsSourceUnix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceReservationsSourceUnix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceReservationsSourceUnix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceReservationsSourceUnix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainOsNvRamSourceReservationsSourceUnixReconnect'] = None,
                 sec_labels: Optional[Sequence['outputs.DomainOsNvRamSourceReservationsSourceUnixSecLabel']] = None):
        """
        :param _builtins.str mode: Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str path: Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainOsNvRamSourceReservationsSourceUnixReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param Sequence['DomainOsNvRamSourceReservationsSourceUnixSecLabelArgs'] sec_labels: Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainOsNvRamSourceReservationsSourceUnixReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainOsNvRamSourceReservationsSourceUnixSecLabel']]:
        """
        Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainOsNvRamSourceReservationsSourceUnixReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainOsNvRamSourceReservationsSourceUnixSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceReservationsSourceUnixSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceReservationsSourceUnixSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceReservationsSourceUnixSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainOsNvRamSourceSlices(dict):
    def __init__(__self__, *,
                 slices: Optional[Sequence['outputs.DomainOsNvRamSourceSlicesSlice']] = None):
        """
        :param Sequence['DomainOsNvRamSourceSlicesSliceArgs'] slices: Configures one or more slices of the backing-store source, each describing a contiguous portion of the underlying device or file that is exposed through this mirror backing store.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        if slices is not None:
            pulumi.set(__self__, "slices", slices)

    @_builtins.property
    @pulumi.getter
    def slices(self) -> Optional[Sequence['outputs.DomainOsNvRamSourceSlicesSlice']]:
        """
        Configures one or more slices of the backing-store source, each describing a contiguous portion of the underlying device or file that is exposed through this mirror backing store.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "slices")


@pulumi.output_type
class DomainOsNvRamSourceSlicesSlice(dict):
    def __init__(__self__, *,
                 offset: _builtins.float,
                 size: _builtins.float,
                 type: _builtins.str):
        """
        :param _builtins.float offset: Sets the starting offset (in bytes) of this slice within the underlying backing-store source; must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.float size: Sets the size (in bytes) of this slice within the underlying backing-store source; must be a positive integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        :param _builtins.str type: Specifies the type of slice mapping to use for this range; the value is userprovided and must match a type supported by the hypervisor (for example, a particular mapping or layout scheme).
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def offset(self) -> _builtins.float:
        """
        Sets the starting offset (in bytes) of this slice within the underlying backing-store source; must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "offset")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.float:
        """
        Sets the size (in bytes) of this slice within the underlying backing-store source; must be a positive integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of slice mapping to use for this range; the value is userprovided and must match a type supported by the hypervisor (for example, a particular mapping or layout scheme).

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainOsNvRamSourceSsl(dict):
    def __init__(__self__, *,
                 verify: _builtins.str):
        """
        :param _builtins.str verify: Controls certificate verification for SSL/TLS access to the mirrored backing-store source; typical values are "yes" or "no" to enable or disable verification.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "verify", verify)

    @_builtins.property
    @pulumi.getter
    def verify(self) -> _builtins.str:
        """
        Controls certificate verification for SSL/TLS access to the mirrored backing-store source; typical values are "yes" or "no" to enable or disable verification.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "verify")


@pulumi.output_type
class DomainOsNvRamSourceTimeout(dict):
    def __init__(__self__, *,
                 seconds: _builtins.str):
        """
        :param _builtins.str seconds: Sets the timeout duration in seconds for accessing the mirrored backing-store source; must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.str:
        """
        Sets the timeout duration in seconds for accessing the mirrored backing-store source; must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#hard-drives-floppy-disks-cdroms>
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class DomainOsNvRamSourceVhostUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "qemuvdAgent":
            suggest = "qemuvd_agent"
        elif key == "spicePort":
            suggest = "spice_port"
        elif key == "spiceVmc":
            suggest = "spice_vmc"
        elif key == "stdIo":
            suggest = "std_io"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceVhostUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceVhostUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceVhostUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbus: Optional['outputs.DomainOsNvRamSourceVhostUserDbus'] = None,
                 dev: Optional['outputs.DomainOsNvRamSourceVhostUserDev'] = None,
                 file: Optional['outputs.DomainOsNvRamSourceVhostUserFile'] = None,
                 nmdm: Optional['outputs.DomainOsNvRamSourceVhostUserNmdm'] = None,
                 null: Optional[_builtins.bool] = None,
                 pipe: Optional['outputs.DomainOsNvRamSourceVhostUserPipe'] = None,
                 pty: Optional['outputs.DomainOsNvRamSourceVhostUserPty'] = None,
                 qemuvd_agent: Optional['outputs.DomainOsNvRamSourceVhostUserQemuvdAgent'] = None,
                 spice_port: Optional['outputs.DomainOsNvRamSourceVhostUserSpicePort'] = None,
                 spice_vmc: Optional[_builtins.bool] = None,
                 std_io: Optional[_builtins.bool] = None,
                 tcp: Optional['outputs.DomainOsNvRamSourceVhostUserTcp'] = None,
                 udp: Optional['outputs.DomainOsNvRamSourceVhostUserUdp'] = None,
                 unix: Optional['outputs.DomainOsNvRamSourceVhostUserUnix'] = None,
                 vc: Optional[_builtins.bool] = None):
        """
        :param 'DomainOsNvRamSourceVhostUserDbusArgs' dbus: Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        :param 'DomainOsNvRamSourceVhostUserDevArgs' dev: Configures an EGD RNG backend that reads entropy from a host character device node.
        :param 'DomainOsNvRamSourceVhostUserFileArgs' file: Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        :param 'DomainOsNvRamSourceVhostUserNmdmArgs' nmdm: Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        :param _builtins.bool null: When set to true, uses a null character device as the vhost-user backing-store source, discarding all output and providing no input; when false or unset, the null device is not used.
               
               See: <https://libvirt.org/formatdomain.html#null-device>
        :param 'DomainOsNvRamSourceVhostUserPipeArgs' pipe: Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        :param 'DomainOsNvRamSourceVhostUserPtyArgs' pty: Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        :param 'DomainOsNvRamSourceVhostUserQemuvdAgentArgs' qemuvd_agent: Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        :param 'DomainOsNvRamSourceVhostUserSpicePortArgs' spice_port: Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        :param _builtins.bool spice_vmc: When set to true, exposes the vhost-user backing through a SPICE virtio-serial management channel (SpiceVMC); when false or unset, the element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#spice-channel>
        :param _builtins.bool std_io: When set to true, connects the vhost-user backing to the domains standard I/O character device; when false or unset, the StdIO element is omitted.
               
               See: <https://libvirt.org/formatdomain.html#host-interface>
        :param 'DomainOsNvRamSourceVhostUserTcpArgs' tcp: Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        :param 'DomainOsNvRamSourceVhostUserUdpArgs' udp: Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        :param 'DomainOsNvRamSourceVhostUserUnixArgs' unix: Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        :param _builtins.bool vc: Enables use of a vhost-user communication mechanism compatible with a VC-style (versioned capability) endpoint for the disk mirror backing store; when set true the VC element is emitted, when false or null it is omitted.
        """
        if dbus is not None:
            pulumi.set(__self__, "dbus", dbus)
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if nmdm is not None:
            pulumi.set(__self__, "nmdm", nmdm)
        if null is not None:
            pulumi.set(__self__, "null", null)
        if pipe is not None:
            pulumi.set(__self__, "pipe", pipe)
        if pty is not None:
            pulumi.set(__self__, "pty", pty)
        if qemuvd_agent is not None:
            pulumi.set(__self__, "qemuvd_agent", qemuvd_agent)
        if spice_port is not None:
            pulumi.set(__self__, "spice_port", spice_port)
        if spice_vmc is not None:
            pulumi.set(__self__, "spice_vmc", spice_vmc)
        if std_io is not None:
            pulumi.set(__self__, "std_io", std_io)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)
        if unix is not None:
            pulumi.set(__self__, "unix", unix)
        if vc is not None:
            pulumi.set(__self__, "vc", vc)

    @_builtins.property
    @pulumi.getter
    def dbus(self) -> Optional['outputs.DomainOsNvRamSourceVhostUserDbus']:
        """
        Configures a D-Bus based source for the EGD backend when using a D-Bus-capable entropy provider; the value is user-provided and backend-specific.
        """
        return pulumi.get(self, "dbus")

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional['outputs.DomainOsNvRamSourceVhostUserDev']:
        """
        Configures an EGD RNG backend that reads entropy from a host character device node.
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.DomainOsNvRamSourceVhostUserFile']:
        """
        Configures an EGD RNG backend that reads or writes entropy data via a regular host file.
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def nmdm(self) -> Optional['outputs.DomainOsNvRamSourceVhostUserNmdm']:
        """
        Configures an EGD RNG backend that uses a FreeBSD nmdm pseudo-serial pair as the entropy transport.
        """
        return pulumi.get(self, "nmdm")

    @_builtins.property
    @pulumi.getter
    def null(self) -> Optional[_builtins.bool]:
        """
        When set to true, uses a null character device as the vhost-user backing-store source, discarding all output and providing no input; when false or unset, the null device is not used.

        See: <https://libvirt.org/formatdomain.html#null-device>
        """
        return pulumi.get(self, "null")

    @_builtins.property
    @pulumi.getter
    def pipe(self) -> Optional['outputs.DomainOsNvRamSourceVhostUserPipe']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host named pipe (FIFO) rather than a socket or other backend types.
        """
        return pulumi.get(self, "pipe")

    @_builtins.property
    @pulumi.getter
    def pty(self) -> Optional['outputs.DomainOsNvRamSourceVhostUserPty']:
        """
        Configures an RNG EGD backend that connects to an entropy source via a host pseudo-TTY device.
        """
        return pulumi.get(self, "pty")

    @_builtins.property
    @pulumi.getter(name="qemuvdAgent")
    def qemuvd_agent(self) -> Optional['outputs.DomainOsNvRamSourceVhostUserQemuvdAgent']:
        """
        Configures an RNG EGD backend that uses the QEMU guest agent (QEMU vdagent) channel as the source of entropy.
        """
        return pulumi.get(self, "qemuvd_agent")

    @_builtins.property
    @pulumi.getter(name="spicePort")
    def spice_port(self) -> Optional['outputs.DomainOsNvRamSourceVhostUserSpicePort']:
        """
        Configures an RNG EGD backend that uses a SPICE port channel as the entropy source instead of direct host devices.
        """
        return pulumi.get(self, "spice_port")

    @_builtins.property
    @pulumi.getter(name="spiceVmc")
    def spice_vmc(self) -> Optional[_builtins.bool]:
        """
        When set to true, exposes the vhost-user backing through a SPICE virtio-serial management channel (SpiceVMC); when false or unset, the element is omitted.

        See: <https://libvirt.org/formatdomain.html#spice-channel>
        """
        return pulumi.get(self, "spice_vmc")

    @_builtins.property
    @pulumi.getter(name="stdIo")
    def std_io(self) -> Optional[_builtins.bool]:
        """
        When set to true, connects the vhost-user backing to the domains standard I/O character device; when false or unset, the StdIO element is omitted.

        See: <https://libvirt.org/formatdomain.html#host-interface>
        """
        return pulumi.get(self, "std_io")

    @_builtins.property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.DomainOsNvRamSourceVhostUserTcp']:
        """
        Configures a TCP connection as the entropy source for the EGD RNG backend; child attributes define host, port, mode, TLS, and optional reconnect behavior.
        """
        return pulumi.get(self, "tcp")

    @_builtins.property
    @pulumi.getter
    def udp(self) -> Optional['outputs.DomainOsNvRamSourceVhostUserUdp']:
        """
        Configures a UDP connection as the entropy source for the EGD RNG backend, with bind/connect endpoints defined by child elements.
        """
        return pulumi.get(self, "udp")

    @_builtins.property
    @pulumi.getter
    def unix(self) -> Optional['outputs.DomainOsNvRamSourceVhostUserUnix']:
        """
        Configures a UNIX domain socket as the entropy source for the EGD RNG backend; child attributes specify the socket path, mode, and optional reconnect policy.
        """
        return pulumi.get(self, "unix")

    @_builtins.property
    @pulumi.getter
    def vc(self) -> Optional[_builtins.bool]:
        """
        Enables use of a vhost-user communication mechanism compatible with a VC-style (versioned capability) endpoint for the disk mirror backing store; when set true the VC element is emitted, when false or null it is omitted.
        """
        return pulumi.get(self, "vc")


@pulumi.output_type
class DomainOsNvRamSourceVhostUserDbus(dict):
    def __init__(__self__, *,
                 channel: Optional[_builtins.str] = None):
        """
        :param _builtins.str channel: Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.str]:
        """
        Sets the D-Bus channel name used when the RNG backend connects to an EGD daemon over D-Bus; the value is user-provided (for example, a well-known D-Bus object or channel identifier).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainOsNvRamSourceVhostUserDev(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceVhostUserDev. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceVhostUserDev.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceVhostUserDev.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainOsNvRamSourceVhostUserDevSecLabel']] = None):
        """
        :param _builtins.str path: Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainOsNvRamSourceVhostUserDevSecLabelArgs'] sec_labels: Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the path to the host character device file used as the EGD entropy source (for example, /dev/urandom); this attribute is required when using a dev source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainOsNvRamSourceVhostUserDevSecLabel']]:
        """
        Configures an optional security label for the device-based EGD entropy source, controlling how host security drivers (e.g. SELinux, DAC) label or treat the device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainOsNvRamSourceVhostUserDevSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceVhostUserDevSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceVhostUserDevSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceVhostUserDevSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainOsNvRamSourceVhostUserFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceVhostUserFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceVhostUserFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceVhostUserFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 append: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainOsNvRamSourceVhostUserFileSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str append: Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.
               
               See: <https://libvirt.org/formatdomain.html#device-logfile>
        :param Sequence['DomainOsNvRamSourceVhostUserFileSecLabelArgs'] sec_labels: Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path of the host file used as the EGD entropy source or sink (for example, /var/run/egd.sock or a regular file); this attribute is required when using a file source.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def append(self) -> Optional[_builtins.str]:
        """
        Controls whether data is appended to the file used by the EGD entropy source instead of truncating it; accepts "on"/"off" or "yes"/"no" style values depending on libvirt/qemu expectations.

        See: <https://libvirt.org/formatdomain.html#device-logfile>
        """
        return pulumi.get(self, "append")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainOsNvRamSourceVhostUserFileSecLabel']]:
        """
        Configures an optional security label for the file used by the EGD entropy source, controlling how host security drivers label or constrain access to that file.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainOsNvRamSourceVhostUserFileSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceVhostUserFileSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceVhostUserFileSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceVhostUserFileSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainOsNvRamSourceVhostUserNmdm(dict):
    def __init__(__self__, *,
                 master: _builtins.str,
                 slave: _builtins.str):
        """
        :param _builtins.str master: Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        :param _builtins.str slave: Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.
               
               See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        pulumi.set(__self__, "master", master)
        pulumi.set(__self__, "slave", slave)

    @_builtins.property
    @pulumi.getter
    def master(self) -> _builtins.str:
        """
        Sets the master side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0A); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "master")

    @_builtins.property
    @pulumi.getter
    def slave(self) -> _builtins.str:
        """
        Sets the slave side device path of the nmdm pair used for the EGD entropy connection (for example, /dev/nmdm0B); this attribute is required for an nmdm source.

        See: <https://libvirt.org/formatdomain.html#nmdm-device>
        """
        return pulumi.get(self, "slave")


@pulumi.output_type
class DomainOsNvRamSourceVhostUserPipe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceVhostUserPipe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceVhostUserPipe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceVhostUserPipe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainOsNvRamSourceVhostUserPipeSecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainOsNvRamSourceVhostUserPipeSecLabelArgs'] sec_labels: Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host named pipe used as the EGD entropy source (user-provided absolute path, for example `/var/run/entropy.pipe`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainOsNvRamSourceVhostUserPipeSecLabel']]:
        """
        Configures an optional security label for the pipe-based EGD backend, controlling how security drivers (e.g. SELinux, DAC) label or treat this device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainOsNvRamSourceVhostUserPipeSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceVhostUserPipeSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceVhostUserPipeSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceVhostUserPipeSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainOsNvRamSourceVhostUserPty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceVhostUserPty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceVhostUserPty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceVhostUserPty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 sec_labels: Optional[Sequence['outputs.DomainOsNvRamSourceVhostUserPtySecLabel']] = None):
        """
        :param _builtins.str path: Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param Sequence['DomainOsNvRamSourceVhostUserPtySecLabelArgs'] sec_labels: Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        pulumi.set(__self__, "path", path)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the filesystem path to the host pseudo-TTY device used as the EGD entropy source (user-provided path, for example `/dev/pts/5`).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainOsNvRamSourceVhostUserPtySecLabel']]:
        """
        Configures an optional security label for the pty-based EGD backend, controlling how security drivers label or treat this character device.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainOsNvRamSourceVhostUserPtySecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceVhostUserPtySecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceVhostUserPtySecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceVhostUserPtySecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainOsNvRamSourceVhostUserQemuvdAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clipBoard":
            suggest = "clip_board"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceVhostUserQemuvdAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceVhostUserQemuvdAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceVhostUserQemuvdAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clip_board: Optional['outputs.DomainOsNvRamSourceVhostUserQemuvdAgentClipBoard'] = None,
                 mouse: Optional['outputs.DomainOsNvRamSourceVhostUserQemuvdAgentMouse'] = None):
        """
        :param 'DomainOsNvRamSourceVhostUserQemuvdAgentClipBoardArgs' clip_board: Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        :param 'DomainOsNvRamSourceVhostUserQemuvdAgentMouseArgs' mouse: Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        if clip_board is not None:
            pulumi.set(__self__, "clip_board", clip_board)
        if mouse is not None:
            pulumi.set(__self__, "mouse", mouse)

    @_builtins.property
    @pulumi.getter(name="clipBoard")
    def clip_board(self) -> Optional['outputs.DomainOsNvRamSourceVhostUserQemuvdAgentClipBoard']:
        """
        Configures clipboard-related behavior for the QEMU vdagentbased EGD source, controlling whether clipboard data exchange is allowed.
        """
        return pulumi.get(self, "clip_board")

    @_builtins.property
    @pulumi.getter
    def mouse(self) -> Optional['outputs.DomainOsNvRamSourceVhostUserQemuvdAgentMouse']:
        """
        Configures mouse integration options for the QEMU vdagentbased EGD source, such as how mouse events are handled.
        """
        return pulumi.get(self, "mouse")


@pulumi.output_type
class DomainOsNvRamSourceVhostUserQemuvdAgentClipBoard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyPaste":
            suggest = "copy_paste"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceVhostUserQemuvdAgentClipBoard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceVhostUserQemuvdAgentClipBoard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceVhostUserQemuvdAgentClipBoard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_paste: _builtins.str):
        """
        :param _builtins.str copy_paste: Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "copy_paste", copy_paste)

    @_builtins.property
    @pulumi.getter(name="copyPaste")
    def copy_paste(self) -> _builtins.str:
        """
        Enables or disables clipboard copy/paste via the QEMU vdagent for this EGD source; this is typically a yes/no or on/off style flag.

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "copy_paste")


@pulumi.output_type
class DomainOsNvRamSourceVhostUserQemuvdAgentMouse(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).
               
               See: <https://libvirt.org/formatdomain.html#channel>
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets the mouse integration mode for the QEMU vdagent channel (value is user-provided and backend-specific, for example absolute vs relative).

        See: <https://libvirt.org/formatdomain.html#channel>
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DomainOsNvRamSourceVhostUserSpicePort(dict):
    def __init__(__self__, *,
                 channel: _builtins.str):
        """
        :param _builtins.str channel: Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "channel", channel)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        Sets the SPICE channel name used by the EGD RNG backend when the entropy source is a SPICE port; the value is user-provided (for example, a named SPICE channel).

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "channel")


@pulumi.output_type
class DomainOsNvRamSourceVhostUserTcp(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainOsNvRamSourceVhostUserTcpReconnect'] = None,
                 service: Optional[_builtins.str] = None,
                 tls: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str mode: Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainOsNvRamSourceVhostUserTcpReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param _builtins.str service: Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str tls: Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Sets the remote hostname or IP address for the TCP-based EGD entropy source; the value is user-provided (for example, "rng.example.com" or "192.0.2.10").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the TCP connection mode for the EGD entropy source; valid values are user-provided but typically "client" or "server" depending on whether QEMU connects out or listens.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainOsNvRamSourceVhostUserTcpReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Sets the TCP service or port number for the EGD entropy source (for example, "egdsock" or "7040"); the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[_builtins.str]:
        """
        Enables or disables TLS for the TCP-based EGD entropy source; the value is user-provided, typically "yes" or "no" depending on desired encryption.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class DomainOsNvRamSourceVhostUserTcpReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainOsNvRamSourceVhostUserUdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindHost":
            suggest = "bind_host"
        elif key == "bindService":
            suggest = "bind_service"
        elif key == "connectHost":
            suggest = "connect_host"
        elif key == "connectService":
            suggest = "connect_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceVhostUserUdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceVhostUserUdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceVhostUserUdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bind_host: _builtins.str,
                 bind_service: _builtins.str,
                 connect_host: _builtins.str,
                 connect_service: _builtins.str):
        """
        :param _builtins.str bind_host: Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str bind_service: Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_host: Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str connect_service: Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "bind_host", bind_host)
        pulumi.set(__self__, "bind_service", bind_service)
        pulumi.set(__self__, "connect_host", connect_host)
        pulumi.set(__self__, "connect_service", connect_service)

    @_builtins.property
    @pulumi.getter(name="bindHost")
    def bind_host(self) -> _builtins.str:
        """
        Sets the local host address or hostname to which the UDP socket for the EGD entropy source binds; the value is user-provided (for example, "0.0.0.0" or "::").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_host")

    @_builtins.property
    @pulumi.getter(name="bindService")
    def bind_service(self) -> _builtins.str:
        """
        Sets the local UDP port or service name to which the EGD entropy source binds; the value is a user-provided port or service string (for example, "7040").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "bind_service")

    @_builtins.property
    @pulumi.getter(name="connectHost")
    def connect_host(self) -> _builtins.str:
        """
        Sets the remote host address or hostname that the UDP-based EGD entropy source sends packets to; the value is user-provided.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_host")

    @_builtins.property
    @pulumi.getter(name="connectService")
    def connect_service(self) -> _builtins.str:
        """
        Sets the remote UDP port or service name for the EGD entropy sink; the value is a user-provided port or service string.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "connect_service")


@pulumi.output_type
class DomainOsNvRamSourceVhostUserUnix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceVhostUserUnix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceVhostUserUnix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceVhostUserUnix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 reconnect: Optional['outputs.DomainOsNvRamSourceVhostUserUnixReconnect'] = None,
                 sec_labels: Optional[Sequence['outputs.DomainOsNvRamSourceVhostUserUnixSecLabel']] = None):
        """
        :param _builtins.str mode: Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.str path: Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param 'DomainOsNvRamSourceVhostUserUnixReconnectArgs' reconnect: Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        :param Sequence['DomainOsNvRamSourceVhostUserUnixSecLabelArgs'] sec_labels: Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if reconnect is not None:
            pulumi.set(__self__, "reconnect", reconnect)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets whether the UNIX domain socket for the EGD entropy source operates as a client or server; the value is user-provided, typically "client" or "server".

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Sets the filesystem path to the UNIX domain socket used by the EGD entropy source; the value is a user-provided absolute or relative path (for example, "/var/run/egd.sock").

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def reconnect(self) -> Optional['outputs.DomainOsNvRamSourceVhostUserUnixReconnect']:
        """
        Enables and configures automatic reconnection behavior for a UNIX socketbased EGD entropy source; the content and attributes are user-provided according to desired policy.
        """
        return pulumi.get(self, "reconnect")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainOsNvRamSourceVhostUserUnixSecLabel']]:
        """
        Configures an optional security label on the UNIX socket used by the EGD RNG backend, controlling how security drivers treat this socket.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")


@pulumi.output_type
class DomainOsNvRamSourceVhostUserUnixReconnect(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        :param _builtins.float timeout: Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Sets whether the UNIX socket connection to the EGD RNG backend is automatically re-established when it drops; accepts "yes" or "no" as a required value.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        Sets the reconnect timeout (in seconds) for the UNIX socket connection to the EGD RNG backend; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#random-number-generator-device>
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainOsNvRamSourceVhostUserUnixSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceVhostUserUnixSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceVhostUserUnixSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceVhostUserUnixSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainOsNvRamSourceVhostVdpa(dict):
    def __init__(__self__, *,
                 dev: _builtins.str):
        """
        :param _builtins.str dev: Sets the host vDPA character device path used as the backingStore source for the mirrored disk when using a vhost-vdpa backend; the value is user-provided and must reference an existing device node (for example, /dev/vhost-vdpa0).
        """
        pulumi.set(__self__, "dev", dev)

    @_builtins.property
    @pulumi.getter
    def dev(self) -> _builtins.str:
        """
        Sets the host vDPA character device path used as the backingStore source for the mirrored disk when using a vhost-vdpa backend; the value is user-provided and must reference an existing device node (for example, /dev/vhost-vdpa0).
        """
        return pulumi.get(self, "dev")


@pulumi.output_type
class DomainOsNvRamSourceVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secLabels":
            suggest = "sec_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 pool: Optional[_builtins.str] = None,
                 sec_labels: Optional[Sequence['outputs.DomainOsNvRamSourceVolumeSecLabel']] = None,
                 volume: Optional[_builtins.str] = None):
        """
        :param _builtins.str mode: Sets the access mode with which the storage volume is used as the backingStore source (for example, "readOnly" or "readWrite" depending on driver support); the value is user-provided.
        :param _builtins.str pool: Names the storage pool that contains the backing storage volume used as the mirror backingStore source; must match an existing libvirt storage pool name.
        :param Sequence['DomainOsNvRamSourceVolumeSecLabelArgs'] sec_labels: Configures an optional security label override applied to the backing storage volume used as the mirror backingStore source.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str volume: Sets the name of the storage volume within the specified pool that is used as the backingStore source for the mirrored disk.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if pool is not None:
            pulumi.set(__self__, "pool", pool)
        if sec_labels is not None:
            pulumi.set(__self__, "sec_labels", sec_labels)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the access mode with which the storage volume is used as the backingStore source (for example, "readOnly" or "readWrite" depending on driver support); the value is user-provided.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def pool(self) -> Optional[_builtins.str]:
        """
        Names the storage pool that contains the backing storage volume used as the mirror backingStore source; must match an existing libvirt storage pool name.
        """
        return pulumi.get(self, "pool")

    @_builtins.property
    @pulumi.getter(name="secLabels")
    def sec_labels(self) -> Optional[Sequence['outputs.DomainOsNvRamSourceVolumeSecLabel']]:
        """
        Configures an optional security label override applied to the backing storage volume used as the mirror backingStore source.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "sec_labels")

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional[_builtins.str]:
        """
        Sets the name of the storage volume within the specified pool that is used as the backingStore source for the mirrored disk.
        """
        return pulumi.get(self, "volume")


@pulumi.output_type
class DomainOsNvRamSourceVolumeSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSkip":
            suggest = "label_skip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOsNvRamSourceVolumeSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOsNvRamSourceVolumeSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOsNvRamSourceVolumeSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 label_skip: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None):
        """
        :param _builtins.str label: Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label_skip: Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if label_skip is not None:
            pulumi.set(__self__, "label_skip", label_skip)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the explicit security label to apply to the UNIX socket for the EGD RNG backend; the value is user-provided (for example, an SELinux context string).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="labelSkip")
    def label_skip(self) -> Optional[_builtins.str]:
        """
        Controls whether application of the security label is skipped for the UNIX socket, using a "yes"/"no" flag equivalent to the seclabel labelskip attribute.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label_skip")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects the security labeling model used for the UNIX socket backing the EGD RNG backend (for example "selinux" or "dac"); the value is user-provided but should match a supported security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether the security driver is allowed to change (relabel) the UNIX socket for the EGD RNG backend, using a "yes"/"no" flag.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")


@pulumi.output_type
class DomainOsSmBios(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: Sets the SMBIOS mode, controlling the source of SMBIOS information presented to the guest; valid values are driver-specific (commonly host, sysinfo, emulate, or none) and must follow libvirts smbios mode semantics.
               
               See: <https://libvirt.org/formatdomain.html#operating-system-booting>
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets the SMBIOS mode, controlling the source of SMBIOS information presented to the guest; valid values are driver-specific (commonly host, sysinfo, emulate, or none) and must follow libvirts smbios mode semantics.

        See: <https://libvirt.org/formatdomain.html#operating-system-booting>
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DomainPerf(dict):
    def __init__(__self__, *,
                 events: Optional[Sequence['outputs.DomainPerfEvent']] = None):
        """
        :param Sequence['DomainPerfEventArgs'] events: Defines one or more performance monitoring events to track for the guest, each identified by a name and an enabled flag.
               
               See: <https://libvirt.org/formatdomain.html#performance-monitoring-events>
        """
        if events is not None:
            pulumi.set(__self__, "events", events)

    @_builtins.property
    @pulumi.getter
    def events(self) -> Optional[Sequence['outputs.DomainPerfEvent']]:
        """
        Defines one or more performance monitoring events to track for the guest, each identified by a name and an enabled flag.

        See: <https://libvirt.org/formatdomain.html#performance-monitoring-events>
        """
        return pulumi.get(self, "events")


@pulumi.output_type
class DomainPerfEvent(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str enabled: Controls whether the given perf event is active; valid values are yes or no, enabling or disabling collection of that event.
               
               See: <https://libvirt.org/formatdomain.html#performance-monitoring-events>
        :param _builtins.str name: Sets the name of the performance event to monitor, which must be one of the libvirt-supported perf event identifiers (for example, perf.cpu_cycles, perf.instructions).
               
               See: <https://libvirt.org/formatdomain.html#performance-monitoring-events>
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Controls whether the given perf event is active; valid values are yes or no, enabling or disabling collection of that event.

        See: <https://libvirt.org/formatdomain.html#performance-monitoring-events>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the name of the performance event to monitor, which must be one of the libvirt-supported perf event identifiers (for example, perf.cpu_cycles, perf.instructions).

        See: <https://libvirt.org/formatdomain.html#performance-monitoring-events>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DomainPm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "suspendToDisk":
            suggest = "suspend_to_disk"
        elif key == "suspendToMem":
            suggest = "suspend_to_mem"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainPm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainPm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainPm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 suspend_to_disk: Optional['outputs.DomainPmSuspendToDisk'] = None,
                 suspend_to_mem: Optional['outputs.DomainPmSuspendToMem'] = None):
        """
        :param 'DomainPmSuspendToDiskArgs' suspend_to_disk: Configures whether the guest firmware advertises S4 (suspend-to-disk / hibernate) capability to the guest OS.
        :param 'DomainPmSuspendToMemArgs' suspend_to_mem: Configures whether the guest firmware advertises S4 (suspend-to-disk / hibernate) capability to the guest OS.
        """
        if suspend_to_disk is not None:
            pulumi.set(__self__, "suspend_to_disk", suspend_to_disk)
        if suspend_to_mem is not None:
            pulumi.set(__self__, "suspend_to_mem", suspend_to_mem)

    @_builtins.property
    @pulumi.getter(name="suspendToDisk")
    def suspend_to_disk(self) -> Optional['outputs.DomainPmSuspendToDisk']:
        """
        Configures whether the guest firmware advertises S4 (suspend-to-disk / hibernate) capability to the guest OS.
        """
        return pulumi.get(self, "suspend_to_disk")

    @_builtins.property
    @pulumi.getter(name="suspendToMem")
    def suspend_to_mem(self) -> Optional['outputs.DomainPmSuspendToMem']:
        """
        Configures whether the guest firmware advertises S4 (suspend-to-disk / hibernate) capability to the guest OS.
        """
        return pulumi.get(self, "suspend_to_mem")


@pulumi.output_type
class DomainPmSuspendToDisk(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str):
        """
        :param _builtins.str enabled: Controls whether suspend-to-disk (S4) is exposed to the guest; valid values are yes or no.
               
               See: <https://libvirt.org/formatdomain.html#power-management>
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Controls whether suspend-to-disk (S4) is exposed to the guest; valid values are yes or no.

        See: <https://libvirt.org/formatdomain.html#power-management>
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DomainPmSuspendToMem(dict):
    def __init__(__self__, *,
                 enabled: _builtins.str):
        """
        :param _builtins.str enabled: Controls whether suspend-to-disk (S4) is exposed to the guest; valid values are yes or no.
               
               See: <https://libvirt.org/formatdomain.html#power-management>
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.str:
        """
        Controls whether suspend-to-disk (S4) is exposed to the guest; valid values are yes or no.

        See: <https://libvirt.org/formatdomain.html#power-management>
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DomainResource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fibreChannel":
            suggest = "fibre_channel"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fibre_channel: Optional['outputs.DomainResourceFibreChannel'] = None,
                 partition: Optional[_builtins.str] = None):
        """
        :param 'DomainResourceFibreChannelArgs' fibre_channel: Configures the Fibre Channel VMID (appid) used by FC/NVMe-FC storage fabrics for QoS and telemetry associated with this domain.
        :param _builtins.str partition: Sets the resource partition name/path that the hypervisor should place this domain into for host-level resource accounting or control; the value is user-provided and may be a hierarchical partition identifier (for example, "/machine/qemu/production").
               
               See: <https://libvirt.org/formatdomain.html#resource-partitioning>
        """
        if fibre_channel is not None:
            pulumi.set(__self__, "fibre_channel", fibre_channel)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)

    @_builtins.property
    @pulumi.getter(name="fibreChannel")
    def fibre_channel(self) -> Optional['outputs.DomainResourceFibreChannel']:
        """
        Configures the Fibre Channel VMID (appid) used by FC/NVMe-FC storage fabrics for QoS and telemetry associated with this domain.
        """
        return pulumi.get(self, "fibre_channel")

    @_builtins.property
    @pulumi.getter
    def partition(self) -> Optional[_builtins.str]:
        """
        Sets the resource partition name/path that the hypervisor should place this domain into for host-level resource accounting or control; the value is user-provided and may be a hierarchical partition identifier (for example, "/machine/qemu/production").

        See: <https://libvirt.org/formatdomain.html#resource-partitioning>
        """
        return pulumi.get(self, "partition")


@pulumi.output_type
class DomainResourceFibreChannel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainResourceFibreChannel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainResourceFibreChannel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainResourceFibreChannel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: _builtins.str):
        """
        :param _builtins.str app_id: Sets the Fibre Channel VMID (appid) used by SAN/NVMe-FC infrastructure for per-VM QoS, access control, and telemetry; the value is user-provided and must match the storage fabrics expected VMID format.
               
               See: <https://libvirt.org/formatdomain.html#fibre-channel-vmid>
        """
        pulumi.set(__self__, "app_id", app_id)

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> _builtins.str:
        """
        Sets the Fibre Channel VMID (appid) used by SAN/NVMe-FC infrastructure for per-VM QoS, access control, and telemetry; the value is user-provided and must match the storage fabrics expected VMID format.

        See: <https://libvirt.org/formatdomain.html#fibre-channel-vmid>
        """
        return pulumi.get(self, "app_id")


@pulumi.output_type
class DomainSecLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseLabel":
            suggest = "base_label"
        elif key == "imageLabel":
            suggest = "image_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainSecLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainSecLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainSecLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_label: Optional[_builtins.str] = None,
                 image_label: Optional[_builtins.str] = None,
                 label: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 relabel: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str base_label: Sets the base label template that libvirt may use as a starting point when generating dynamic security labels for the domain; the value is user-provided (for example, "system_u:system_r:svirt_t:s0").
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str image_label: Sets the security label that should be applied to guest image files associated with this domain; the value is user-provided and must be compatible with the selected security model.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str label: Sets the domains own security label (for example SELinux or DAC label) when using static or explicit labeling; the value is user-provided and must be valid for the chosen security driver.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str model: Selects which security driver/model to use for labeling this domain, typically "selinux" or "dac"; other values are driver-specific and must match a security driver enabled on the host.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str relabel: Controls whether libvirt is allowed to change labels on associated resources at start time, using yes/no string values ("yes" to relabel resources automatically, "no" to leave existing labels unchanged).
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        :param _builtins.str type: Sets the seclabel mode, typically "dynamic", "static", or "none", which determines whether libvirt auto-generates labels, uses explicitly provided labels, or disables security labeling for this domain.
               
               See: <https://libvirt.org/formatdomain.html#security-label>
        """
        if base_label is not None:
            pulumi.set(__self__, "base_label", base_label)
        if image_label is not None:
            pulumi.set(__self__, "image_label", image_label)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if relabel is not None:
            pulumi.set(__self__, "relabel", relabel)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="baseLabel")
    def base_label(self) -> Optional[_builtins.str]:
        """
        Sets the base label template that libvirt may use as a starting point when generating dynamic security labels for the domain; the value is user-provided (for example, "system_u:system_r:svirt_t:s0").

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "base_label")

    @_builtins.property
    @pulumi.getter(name="imageLabel")
    def image_label(self) -> Optional[_builtins.str]:
        """
        Sets the security label that should be applied to guest image files associated with this domain; the value is user-provided and must be compatible with the selected security model.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "image_label")

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets the domains own security label (for example SELinux or DAC label) when using static or explicit labeling; the value is user-provided and must be valid for the chosen security driver.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Selects which security driver/model to use for labeling this domain, typically "selinux" or "dac"; other values are driver-specific and must match a security driver enabled on the host.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def relabel(self) -> Optional[_builtins.str]:
        """
        Controls whether libvirt is allowed to change labels on associated resources at start time, using yes/no string values ("yes" to relabel resources automatically, "no" to leave existing labels unchanged).

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "relabel")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Sets the seclabel mode, typically "dynamic", "static", or "none", which determines whether libvirt auto-generates labels, uses explicitly provided labels, or disables security labeling for this domain.

        See: <https://libvirt.org/formatdomain.html#security-label>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainSysInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fwCfg":
            suggest = "fw_cfg"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainSysInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainSysInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainSysInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fw_cfg: Optional['outputs.DomainSysInfoFwCfg'] = None,
                 smbios: Optional['outputs.DomainSysInfoSmbios'] = None):
        """
        :param 'DomainSysInfoFwCfgArgs' fw_cfg: Configures a set of fw_cfg entries that firmware or the guest can read, used to inject arbitrary configuration data or files into the guest at boot.
        :param 'DomainSysInfoSmbiosArgs' smbios: Configures SMBIOS-related system information blocks that the hypervisor exposes to the guest (system, base board, chassis, etc.).
        """
        if fw_cfg is not None:
            pulumi.set(__self__, "fw_cfg", fw_cfg)
        if smbios is not None:
            pulumi.set(__self__, "smbios", smbios)

    @_builtins.property
    @pulumi.getter(name="fwCfg")
    def fw_cfg(self) -> Optional['outputs.DomainSysInfoFwCfg']:
        """
        Configures a set of fw_cfg entries that firmware or the guest can read, used to inject arbitrary configuration data or files into the guest at boot.
        """
        return pulumi.get(self, "fw_cfg")

    @_builtins.property
    @pulumi.getter
    def smbios(self) -> Optional['outputs.DomainSysInfoSmbios']:
        """
        Configures SMBIOS-related system information blocks that the hypervisor exposes to the guest (system, base board, chassis, etc.).
        """
        return pulumi.get(self, "smbios")


@pulumi.output_type
class DomainSysInfoFwCfg(dict):
    def __init__(__self__, *,
                 entries: Optional[Sequence['outputs.DomainSysInfoFwCfgEntry']] = None):
        """
        :param Sequence['DomainSysInfoFwCfgEntryArgs'] entries: Defines a single fw_cfg item to expose to the guest firmware, either as an inlined value or as data loaded from a file.
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        if entries is not None:
            pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> Optional[Sequence['outputs.DomainSysInfoFwCfgEntry']]:
        """
        Defines a single fw_cfg item to expose to the guest firmware, either as an inlined value or as data loaded from a file.

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "entries")


@pulumi.output_type
class DomainSysInfoFwCfgEntry(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str,
                 file: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Sets the fw_cfg key name used to identify this entry to the guest/firmware; the string is user-provided and typically follows firmware-expected naming (for example, "opt/org.example/config").
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        :param _builtins.str value: Sets the literal string value for this fw_cfg entry when no file is specified, providing small configuration blobs directly to the guest.
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        :param _builtins.str file: Sets the host file path whose contents should be provided to the guest via this fw_cfg entry instead of an inline value; the path is user-provided and must be readable by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if file is not None:
            pulumi.set(__self__, "file", file)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the fw_cfg key name used to identify this entry to the guest/firmware; the string is user-provided and typically follows firmware-expected naming (for example, "opt/org.example/config").

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Sets the literal string value for this fw_cfg entry when no file is specified, providing small configuration blobs directly to the guest.

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional[_builtins.str]:
        """
        Sets the host file path whose contents should be provided to the guest via this fw_cfg entry instead of an inline value; the path is user-provided and must be readable by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "file")


@pulumi.output_type
class DomainSysInfoSmbios(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseBoards":
            suggest = "base_boards"
        elif key == "oemStrings":
            suggest = "oem_strings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainSysInfoSmbios. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainSysInfoSmbios.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainSysInfoSmbios.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_boards: Optional[Sequence['outputs.DomainSysInfoSmbiosBaseBoard']] = None,
                 bios: Optional['outputs.DomainSysInfoSmbiosBios'] = None,
                 chassis: Optional['outputs.DomainSysInfoSmbiosChassis'] = None,
                 memories: Optional[Sequence['outputs.DomainSysInfoSmbiosMemory']] = None,
                 oem_strings: Optional['outputs.DomainSysInfoSmbiosOemStrings'] = None,
                 processors: Optional[Sequence['outputs.DomainSysInfoSmbiosProcessor']] = None,
                 system: Optional['outputs.DomainSysInfoSmbiosSystem'] = None):
        """
        :param Sequence['DomainSysInfoSmbiosBaseBoardArgs'] base_boards: Configures the SMBIOS base board (motherboard) section, allowing customization of board-level fields presented to the guest.
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        :param 'DomainSysInfoSmbiosBiosArgs' bios: Configures the SMBIOS BIOS information block, enabling you to override individual BIOS-related fields exposed to the guest.
        :param 'DomainSysInfoSmbiosChassisArgs' chassis: Configures the SMBIOS chassis information block, allowing overrides for how the guest sees chassis-related system information.
        :param Sequence['DomainSysInfoSmbiosMemoryArgs'] memories: Configures the SMBIOS memory information block, allowing customized memory-related fields to be exposed to the guest.
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        :param 'DomainSysInfoSmbiosOemStringsArgs' oem_strings: Configures the SMBIOS OEM strings block, allowing arbitrary vendor-specific strings to be presented to the guest.
        :param Sequence['DomainSysInfoSmbiosProcessorArgs'] processors: Configures the SMBIOS processor information block, enabling overrides of CPU-related identification fields.
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        :param 'DomainSysInfoSmbiosSystemArgs' system: Enables configuration of custom SMBIOS system table fields presented to the guest, such as product name, version, serial, and UUID.
        """
        if base_boards is not None:
            pulumi.set(__self__, "base_boards", base_boards)
        if bios is not None:
            pulumi.set(__self__, "bios", bios)
        if chassis is not None:
            pulumi.set(__self__, "chassis", chassis)
        if memories is not None:
            pulumi.set(__self__, "memories", memories)
        if oem_strings is not None:
            pulumi.set(__self__, "oem_strings", oem_strings)
        if processors is not None:
            pulumi.set(__self__, "processors", processors)
        if system is not None:
            pulumi.set(__self__, "system", system)

    @_builtins.property
    @pulumi.getter(name="baseBoards")
    def base_boards(self) -> Optional[Sequence['outputs.DomainSysInfoSmbiosBaseBoard']]:
        """
        Configures the SMBIOS base board (motherboard) section, allowing customization of board-level fields presented to the guest.

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "base_boards")

    @_builtins.property
    @pulumi.getter
    def bios(self) -> Optional['outputs.DomainSysInfoSmbiosBios']:
        """
        Configures the SMBIOS BIOS information block, enabling you to override individual BIOS-related fields exposed to the guest.
        """
        return pulumi.get(self, "bios")

    @_builtins.property
    @pulumi.getter
    def chassis(self) -> Optional['outputs.DomainSysInfoSmbiosChassis']:
        """
        Configures the SMBIOS chassis information block, allowing overrides for how the guest sees chassis-related system information.
        """
        return pulumi.get(self, "chassis")

    @_builtins.property
    @pulumi.getter
    def memories(self) -> Optional[Sequence['outputs.DomainSysInfoSmbiosMemory']]:
        """
        Configures the SMBIOS memory information block, allowing customized memory-related fields to be exposed to the guest.

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "memories")

    @_builtins.property
    @pulumi.getter(name="oemStrings")
    def oem_strings(self) -> Optional['outputs.DomainSysInfoSmbiosOemStrings']:
        """
        Configures the SMBIOS OEM strings block, allowing arbitrary vendor-specific strings to be presented to the guest.
        """
        return pulumi.get(self, "oem_strings")

    @_builtins.property
    @pulumi.getter
    def processors(self) -> Optional[Sequence['outputs.DomainSysInfoSmbiosProcessor']]:
        """
        Configures the SMBIOS processor information block, enabling overrides of CPU-related identification fields.

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "processors")

    @_builtins.property
    @pulumi.getter
    def system(self) -> Optional['outputs.DomainSysInfoSmbiosSystem']:
        """
        Enables configuration of custom SMBIOS system table fields presented to the guest, such as product name, version, serial, and UUID.
        """
        return pulumi.get(self, "system")


@pulumi.output_type
class DomainSysInfoSmbiosBaseBoard(dict):
    def __init__(__self__, *,
                 entries: Optional[Sequence['outputs.DomainSysInfoSmbiosBaseBoardEntry']] = None):
        """
        :param Sequence['DomainSysInfoSmbiosBaseBoardEntryArgs'] entries: Defines one SMBIOS base board field/value pair (for example, product name or serial) that will be visible to the guest via tools like dmidecode.
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        if entries is not None:
            pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> Optional[Sequence['outputs.DomainSysInfoSmbiosBaseBoardEntry']]:
        """
        Defines one SMBIOS base board field/value pair (for example, product name or serial) that will be visible to the guest via tools like dmidecode.

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "entries")


@pulumi.output_type
class DomainSysInfoSmbiosBaseBoardEntry(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str,
                 file: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Sets the fw_cfg key name used to identify this entry to the guest/firmware; the string is user-provided and typically follows firmware-expected naming (for example, "opt/org.example/config").
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        :param _builtins.str value: Sets the literal string value for this fw_cfg entry when no file is specified, providing small configuration blobs directly to the guest.
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        :param _builtins.str file: Sets the host file path whose contents should be provided to the guest via this fw_cfg entry instead of an inline value; the path is user-provided and must be readable by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if file is not None:
            pulumi.set(__self__, "file", file)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the fw_cfg key name used to identify this entry to the guest/firmware; the string is user-provided and typically follows firmware-expected naming (for example, "opt/org.example/config").

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Sets the literal string value for this fw_cfg entry when no file is specified, providing small configuration blobs directly to the guest.

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional[_builtins.str]:
        """
        Sets the host file path whose contents should be provided to the guest via this fw_cfg entry instead of an inline value; the path is user-provided and must be readable by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "file")


@pulumi.output_type
class DomainSysInfoSmbiosBios(dict):
    def __init__(__self__, *,
                 entries: Optional[Sequence['outputs.DomainSysInfoSmbiosBiosEntry']] = None):
        """
        :param Sequence['DomainSysInfoSmbiosBiosEntryArgs'] entries: Defines a single SMBIOS BIOS field override, identified by its required name and either an inline value or a file containing the value.
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        if entries is not None:
            pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> Optional[Sequence['outputs.DomainSysInfoSmbiosBiosEntry']]:
        """
        Defines a single SMBIOS BIOS field override, identified by its required name and either an inline value or a file containing the value.

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "entries")


@pulumi.output_type
class DomainSysInfoSmbiosBiosEntry(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str,
                 file: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Sets the fw_cfg key name used to identify this entry to the guest/firmware; the string is user-provided and typically follows firmware-expected naming (for example, "opt/org.example/config").
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        :param _builtins.str value: Sets the literal string value for this fw_cfg entry when no file is specified, providing small configuration blobs directly to the guest.
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        :param _builtins.str file: Sets the host file path whose contents should be provided to the guest via this fw_cfg entry instead of an inline value; the path is user-provided and must be readable by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if file is not None:
            pulumi.set(__self__, "file", file)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the fw_cfg key name used to identify this entry to the guest/firmware; the string is user-provided and typically follows firmware-expected naming (for example, "opt/org.example/config").

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Sets the literal string value for this fw_cfg entry when no file is specified, providing small configuration blobs directly to the guest.

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional[_builtins.str]:
        """
        Sets the host file path whose contents should be provided to the guest via this fw_cfg entry instead of an inline value; the path is user-provided and must be readable by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "file")


@pulumi.output_type
class DomainSysInfoSmbiosChassis(dict):
    def __init__(__self__, *,
                 entries: Optional[Sequence['outputs.DomainSysInfoSmbiosChassisEntry']] = None):
        """
        :param Sequence['DomainSysInfoSmbiosChassisEntryArgs'] entries: Defines a single SMBIOS chassis field override, identified by its required name and supplied via an inline value or a file.
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        if entries is not None:
            pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> Optional[Sequence['outputs.DomainSysInfoSmbiosChassisEntry']]:
        """
        Defines a single SMBIOS chassis field override, identified by its required name and supplied via an inline value or a file.

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "entries")


@pulumi.output_type
class DomainSysInfoSmbiosChassisEntry(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str,
                 file: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Sets the fw_cfg key name used to identify this entry to the guest/firmware; the string is user-provided and typically follows firmware-expected naming (for example, "opt/org.example/config").
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        :param _builtins.str value: Sets the literal string value for this fw_cfg entry when no file is specified, providing small configuration blobs directly to the guest.
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        :param _builtins.str file: Sets the host file path whose contents should be provided to the guest via this fw_cfg entry instead of an inline value; the path is user-provided and must be readable by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if file is not None:
            pulumi.set(__self__, "file", file)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the fw_cfg key name used to identify this entry to the guest/firmware; the string is user-provided and typically follows firmware-expected naming (for example, "opt/org.example/config").

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Sets the literal string value for this fw_cfg entry when no file is specified, providing small configuration blobs directly to the guest.

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional[_builtins.str]:
        """
        Sets the host file path whose contents should be provided to the guest via this fw_cfg entry instead of an inline value; the path is user-provided and must be readable by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "file")


@pulumi.output_type
class DomainSysInfoSmbiosMemory(dict):
    def __init__(__self__, *,
                 entries: Optional[Sequence['outputs.DomainSysInfoSmbiosMemoryEntry']] = None):
        """
        :param Sequence['DomainSysInfoSmbiosMemoryEntryArgs'] entries: Defines a single SMBIOS memory information field override, identified by its required name and provided via value or file.
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        if entries is not None:
            pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> Optional[Sequence['outputs.DomainSysInfoSmbiosMemoryEntry']]:
        """
        Defines a single SMBIOS memory information field override, identified by its required name and provided via value or file.

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "entries")


@pulumi.output_type
class DomainSysInfoSmbiosMemoryEntry(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str,
                 file: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Sets the fw_cfg key name used to identify this entry to the guest/firmware; the string is user-provided and typically follows firmware-expected naming (for example, "opt/org.example/config").
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        :param _builtins.str value: Sets the literal string value for this fw_cfg entry when no file is specified, providing small configuration blobs directly to the guest.
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        :param _builtins.str file: Sets the host file path whose contents should be provided to the guest via this fw_cfg entry instead of an inline value; the path is user-provided and must be readable by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if file is not None:
            pulumi.set(__self__, "file", file)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the fw_cfg key name used to identify this entry to the guest/firmware; the string is user-provided and typically follows firmware-expected naming (for example, "opt/org.example/config").

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Sets the literal string value for this fw_cfg entry when no file is specified, providing small configuration blobs directly to the guest.

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional[_builtins.str]:
        """
        Sets the host file path whose contents should be provided to the guest via this fw_cfg entry instead of an inline value; the path is user-provided and must be readable by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "file")


@pulumi.output_type
class DomainSysInfoSmbiosOemStrings(dict):
    def __init__(__self__, *,
                 entries: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] entries: Defines a single OEM string entry, each being an arbitrary user-provided string (for example, "Cluster=prod" or "Owner=teamX").
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        if entries is not None:
            pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> Optional[Sequence[_builtins.str]]:
        """
        Defines a single OEM string entry, each being an arbitrary user-provided string (for example, "Cluster=prod" or "Owner=teamX").

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "entries")


@pulumi.output_type
class DomainSysInfoSmbiosProcessor(dict):
    def __init__(__self__, *,
                 entries: Optional[Sequence['outputs.DomainSysInfoSmbiosProcessorEntry']] = None):
        """
        :param Sequence['DomainSysInfoSmbiosProcessorEntryArgs'] entries: Defines a single SMBIOS processor field override, identified by its required name and a user-provided value or file-backed value (for example, customizing processor version or manufacturer).
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        if entries is not None:
            pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> Optional[Sequence['outputs.DomainSysInfoSmbiosProcessorEntry']]:
        """
        Defines a single SMBIOS processor field override, identified by its required name and a user-provided value or file-backed value (for example, customizing processor version or manufacturer).

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "entries")


@pulumi.output_type
class DomainSysInfoSmbiosProcessorEntry(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str,
                 file: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Sets the fw_cfg key name used to identify this entry to the guest/firmware; the string is user-provided and typically follows firmware-expected naming (for example, "opt/org.example/config").
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        :param _builtins.str value: Sets the literal string value for this fw_cfg entry when no file is specified, providing small configuration blobs directly to the guest.
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        :param _builtins.str file: Sets the host file path whose contents should be provided to the guest via this fw_cfg entry instead of an inline value; the path is user-provided and must be readable by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if file is not None:
            pulumi.set(__self__, "file", file)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the fw_cfg key name used to identify this entry to the guest/firmware; the string is user-provided and typically follows firmware-expected naming (for example, "opt/org.example/config").

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Sets the literal string value for this fw_cfg entry when no file is specified, providing small configuration blobs directly to the guest.

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional[_builtins.str]:
        """
        Sets the host file path whose contents should be provided to the guest via this fw_cfg entry instead of an inline value; the path is user-provided and must be readable by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "file")


@pulumi.output_type
class DomainSysInfoSmbiosSystem(dict):
    def __init__(__self__, *,
                 entries: Optional[Sequence['outputs.DomainSysInfoSmbiosSystemEntry']] = None):
        """
        :param Sequence['DomainSysInfoSmbiosSystemEntryArgs'] entries: Defines one custom SMBIOS system field entry; each entry specifies a field `name` and either an inline `value` or a `file` to read the value from.
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        if entries is not None:
            pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> Optional[Sequence['outputs.DomainSysInfoSmbiosSystemEntry']]:
        """
        Defines one custom SMBIOS system field entry; each entry specifies a field `name` and either an inline `value` or a `file` to read the value from.

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "entries")


@pulumi.output_type
class DomainSysInfoSmbiosSystemEntry(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str,
                 file: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Sets the fw_cfg key name used to identify this entry to the guest/firmware; the string is user-provided and typically follows firmware-expected naming (for example, "opt/org.example/config").
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        :param _builtins.str value: Sets the literal string value for this fw_cfg entry when no file is specified, providing small configuration blobs directly to the guest.
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        :param _builtins.str file: Sets the host file path whose contents should be provided to the guest via this fw_cfg entry instead of an inline value; the path is user-provided and must be readable by the hypervisor.
               
               See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if file is not None:
            pulumi.set(__self__, "file", file)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the fw_cfg key name used to identify this entry to the guest/firmware; the string is user-provided and typically follows firmware-expected naming (for example, "opt/org.example/config").

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Sets the literal string value for this fw_cfg entry when no file is specified, providing small configuration blobs directly to the guest.

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional[_builtins.str]:
        """
        Sets the host file path whose contents should be provided to the guest via this fw_cfg entry instead of an inline value; the path is user-provided and must be readable by the hypervisor.

        See: <https://libvirt.org/formatdomain.html#smbios-system-information>
        """
        return pulumi.get(self, "file")


@pulumi.output_type
class DomainThrottleGroups(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "throttleGroups":
            suggest = "throttle_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainThrottleGroups. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainThrottleGroups.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainThrottleGroups.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 throttle_groups: Optional[Sequence['outputs.DomainThrottleGroupsThrottleGroup']] = None):
        """
        :param Sequence['DomainThrottleGroupsThrottleGroupArgs'] throttle_groups: Defines a single disk throttle group, including its group name and optional aggregate byte and IOPS limits used by disks that join this group.
               
               See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        """
        if throttle_groups is not None:
            pulumi.set(__self__, "throttle_groups", throttle_groups)

    @_builtins.property
    @pulumi.getter(name="throttleGroups")
    def throttle_groups(self) -> Optional[Sequence['outputs.DomainThrottleGroupsThrottleGroup']]:
        """
        Defines a single disk throttle group, including its group name and optional aggregate byte and IOPS limits used by disks that join this group.

        See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        """
        return pulumi.get(self, "throttle_groups")


@pulumi.output_type
class DomainThrottleGroupsThrottleGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupName":
            suggest = "group_name"
        elif key == "readBytesSec":
            suggest = "read_bytes_sec"
        elif key == "readBytesSecMax":
            suggest = "read_bytes_sec_max"
        elif key == "readBytesSecMaxLength":
            suggest = "read_bytes_sec_max_length"
        elif key == "readIopsSec":
            suggest = "read_iops_sec"
        elif key == "readIopsSecMax":
            suggest = "read_iops_sec_max"
        elif key == "readIopsSecMaxLength":
            suggest = "read_iops_sec_max_length"
        elif key == "sizeIopsSec":
            suggest = "size_iops_sec"
        elif key == "totalBytesSec":
            suggest = "total_bytes_sec"
        elif key == "totalBytesSecMax":
            suggest = "total_bytes_sec_max"
        elif key == "totalBytesSecMaxLength":
            suggest = "total_bytes_sec_max_length"
        elif key == "totalIopsSec":
            suggest = "total_iops_sec"
        elif key == "totalIopsSecMax":
            suggest = "total_iops_sec_max"
        elif key == "totalIopsSecMaxLength":
            suggest = "total_iops_sec_max_length"
        elif key == "writeBytesSec":
            suggest = "write_bytes_sec"
        elif key == "writeBytesSecMax":
            suggest = "write_bytes_sec_max"
        elif key == "writeBytesSecMaxLength":
            suggest = "write_bytes_sec_max_length"
        elif key == "writeIopsSec":
            suggest = "write_iops_sec"
        elif key == "writeIopsSecMax":
            suggest = "write_iops_sec_max"
        elif key == "writeIopsSecMaxLength":
            suggest = "write_iops_sec_max_length"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainThrottleGroupsThrottleGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainThrottleGroupsThrottleGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainThrottleGroupsThrottleGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_name: Optional[_builtins.str] = None,
                 read_bytes_sec: Optional[_builtins.float] = None,
                 read_bytes_sec_max: Optional[_builtins.float] = None,
                 read_bytes_sec_max_length: Optional[_builtins.float] = None,
                 read_iops_sec: Optional[_builtins.float] = None,
                 read_iops_sec_max: Optional[_builtins.float] = None,
                 read_iops_sec_max_length: Optional[_builtins.float] = None,
                 size_iops_sec: Optional[_builtins.float] = None,
                 total_bytes_sec: Optional[_builtins.float] = None,
                 total_bytes_sec_max: Optional[_builtins.float] = None,
                 total_bytes_sec_max_length: Optional[_builtins.float] = None,
                 total_iops_sec: Optional[_builtins.float] = None,
                 total_iops_sec_max: Optional[_builtins.float] = None,
                 total_iops_sec_max_length: Optional[_builtins.float] = None,
                 write_bytes_sec: Optional[_builtins.float] = None,
                 write_bytes_sec_max: Optional[_builtins.float] = None,
                 write_bytes_sec_max_length: Optional[_builtins.float] = None,
                 write_iops_sec: Optional[_builtins.float] = None,
                 write_iops_sec_max: Optional[_builtins.float] = None,
                 write_iops_sec_max_length: Optional[_builtins.float] = None):
        """
        :param _builtins.str group_name: Sets the unique name of this throttle group, which must match the `group_name` used by disk `throttlefilters` to attach a disk to the group; the name string is user-provided.
               
               See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        :param _builtins.float read_bytes_sec: Sets the sustained read bandwidth limit for the group in bytes per second; value is a non-negative integer, for example `10485760` for 10 MiB/s.
               
               See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        :param _builtins.float read_bytes_sec_max: Sets the maximum burst read bandwidth limit for the group in bytes per second; value is a non-negative integer and is used together with `read_bytes_sec_max_length`.
               
               See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        :param _builtins.float read_bytes_sec_max_length: Sets the time window in seconds over which the `read_bytes_sec_max` burst limit applies; value is a non-negative integer number of seconds.
               
               See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        :param _builtins.float read_iops_sec: Sets the sustained read IOPS limit for the group; value is a non-negative integer specifying maximum read operations per second.
               
               See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        :param _builtins.float read_iops_sec_max: Sets the maximum burst read IOPS limit for the group; value is a non-negative integer and is used together with `read_iops_sec_max_length`.
               
               See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        :param _builtins.float read_iops_sec_max_length: Sets the time window in seconds over which the `read_iops_sec_max` burst IOPS limit applies; value is a non-negative integer number of seconds.
               
               See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        :param _builtins.float size_iops_sec: Sets the I/O size in bytes used when converting between size-based and operation-based limits for this group; value is a positive integer, typically a block size such as `4096`.
               
               See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        :param _builtins.float total_bytes_sec: Sets the sustained aggregate bandwidth limit (read + write) for the group in bytes per second; value is a non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        :param _builtins.float total_bytes_sec_max: Sets the maximum burst aggregate bandwidth limit (read + write) for the group in bytes per second; value is a non-negative integer and is typically paired with a corresponding `*_max_length` window.
               
               See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        :param _builtins.float total_bytes_sec_max_length: Sets the I/O burst length, in bytes, over which the total_bytes_sec_max limit is measured for the throttle group; the value is user-provided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        :param _builtins.float total_iops_sec: Sets the steadystate limit on the total number of I/O operations per second (reads + writes) allowed for disks in this throttle group; the value is userprovided and must be a nonnegative integer (IOPS).
               
               See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        :param _builtins.float total_iops_sec_max: Sets the maximum burst IOPS limit (reads + writes) for the throttle group, above the steady total_iops_sec value; the value is userprovided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        :param _builtins.float total_iops_sec_max_length: Sets the I/O burst length, in number of requests, over which the total_iops_sec_max limit is measured for the throttle group; the value is userprovided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        :param _builtins.float write_bytes_sec: Sets the steadystate limit on write throughput in bytes per second for disks in this throttle group; the value is userprovided and must be a nonnegative integer (e.g. 104857600 for 100 MiB/s).
               
               See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        :param _builtins.float write_bytes_sec_max: Sets the maximum burst write throughput in bytes per second for the throttle group, above the steady write_bytes_sec limit; the value is userprovided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        :param _builtins.float write_bytes_sec_max_length: Sets the I/O burst length, in bytes, over which the write_bytes_sec_max limit is measured for the throttle group; the value is userprovided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        :param _builtins.float write_iops_sec: Sets the steadystate limit on write IOPS for disks in this throttle group; the value is userprovided and must be a nonnegative integer (number of write requests per second).
               
               See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        :param _builtins.float write_iops_sec_max: Sets the maximum burst write IOPS limit for the throttle group, above the steady write_iops_sec value; the value is userprovided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        :param _builtins.float write_iops_sec_max_length: Sets the I/O burst length, in number of write requests, over which the write_iops_sec_max limit is measured for the throttle group; the value is userprovided and must be a nonnegative integer.
               
               See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        """
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if read_bytes_sec is not None:
            pulumi.set(__self__, "read_bytes_sec", read_bytes_sec)
        if read_bytes_sec_max is not None:
            pulumi.set(__self__, "read_bytes_sec_max", read_bytes_sec_max)
        if read_bytes_sec_max_length is not None:
            pulumi.set(__self__, "read_bytes_sec_max_length", read_bytes_sec_max_length)
        if read_iops_sec is not None:
            pulumi.set(__self__, "read_iops_sec", read_iops_sec)
        if read_iops_sec_max is not None:
            pulumi.set(__self__, "read_iops_sec_max", read_iops_sec_max)
        if read_iops_sec_max_length is not None:
            pulumi.set(__self__, "read_iops_sec_max_length", read_iops_sec_max_length)
        if size_iops_sec is not None:
            pulumi.set(__self__, "size_iops_sec", size_iops_sec)
        if total_bytes_sec is not None:
            pulumi.set(__self__, "total_bytes_sec", total_bytes_sec)
        if total_bytes_sec_max is not None:
            pulumi.set(__self__, "total_bytes_sec_max", total_bytes_sec_max)
        if total_bytes_sec_max_length is not None:
            pulumi.set(__self__, "total_bytes_sec_max_length", total_bytes_sec_max_length)
        if total_iops_sec is not None:
            pulumi.set(__self__, "total_iops_sec", total_iops_sec)
        if total_iops_sec_max is not None:
            pulumi.set(__self__, "total_iops_sec_max", total_iops_sec_max)
        if total_iops_sec_max_length is not None:
            pulumi.set(__self__, "total_iops_sec_max_length", total_iops_sec_max_length)
        if write_bytes_sec is not None:
            pulumi.set(__self__, "write_bytes_sec", write_bytes_sec)
        if write_bytes_sec_max is not None:
            pulumi.set(__self__, "write_bytes_sec_max", write_bytes_sec_max)
        if write_bytes_sec_max_length is not None:
            pulumi.set(__self__, "write_bytes_sec_max_length", write_bytes_sec_max_length)
        if write_iops_sec is not None:
            pulumi.set(__self__, "write_iops_sec", write_iops_sec)
        if write_iops_sec_max is not None:
            pulumi.set(__self__, "write_iops_sec_max", write_iops_sec_max)
        if write_iops_sec_max_length is not None:
            pulumi.set(__self__, "write_iops_sec_max_length", write_iops_sec_max_length)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[_builtins.str]:
        """
        Sets the unique name of this throttle group, which must match the `group_name` used by disk `throttlefilters` to attach a disk to the group; the name string is user-provided.

        See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        """
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter(name="readBytesSec")
    def read_bytes_sec(self) -> Optional[_builtins.float]:
        """
        Sets the sustained read bandwidth limit for the group in bytes per second; value is a non-negative integer, for example `10485760` for 10 MiB/s.

        See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        """
        return pulumi.get(self, "read_bytes_sec")

    @_builtins.property
    @pulumi.getter(name="readBytesSecMax")
    def read_bytes_sec_max(self) -> Optional[_builtins.float]:
        """
        Sets the maximum burst read bandwidth limit for the group in bytes per second; value is a non-negative integer and is used together with `read_bytes_sec_max_length`.

        See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        """
        return pulumi.get(self, "read_bytes_sec_max")

    @_builtins.property
    @pulumi.getter(name="readBytesSecMaxLength")
    def read_bytes_sec_max_length(self) -> Optional[_builtins.float]:
        """
        Sets the time window in seconds over which the `read_bytes_sec_max` burst limit applies; value is a non-negative integer number of seconds.

        See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        """
        return pulumi.get(self, "read_bytes_sec_max_length")

    @_builtins.property
    @pulumi.getter(name="readIopsSec")
    def read_iops_sec(self) -> Optional[_builtins.float]:
        """
        Sets the sustained read IOPS limit for the group; value is a non-negative integer specifying maximum read operations per second.

        See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        """
        return pulumi.get(self, "read_iops_sec")

    @_builtins.property
    @pulumi.getter(name="readIopsSecMax")
    def read_iops_sec_max(self) -> Optional[_builtins.float]:
        """
        Sets the maximum burst read IOPS limit for the group; value is a non-negative integer and is used together with `read_iops_sec_max_length`.

        See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        """
        return pulumi.get(self, "read_iops_sec_max")

    @_builtins.property
    @pulumi.getter(name="readIopsSecMaxLength")
    def read_iops_sec_max_length(self) -> Optional[_builtins.float]:
        """
        Sets the time window in seconds over which the `read_iops_sec_max` burst IOPS limit applies; value is a non-negative integer number of seconds.

        See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        """
        return pulumi.get(self, "read_iops_sec_max_length")

    @_builtins.property
    @pulumi.getter(name="sizeIopsSec")
    def size_iops_sec(self) -> Optional[_builtins.float]:
        """
        Sets the I/O size in bytes used when converting between size-based and operation-based limits for this group; value is a positive integer, typically a block size such as `4096`.

        See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        """
        return pulumi.get(self, "size_iops_sec")

    @_builtins.property
    @pulumi.getter(name="totalBytesSec")
    def total_bytes_sec(self) -> Optional[_builtins.float]:
        """
        Sets the sustained aggregate bandwidth limit (read + write) for the group in bytes per second; value is a non-negative integer.

        See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        """
        return pulumi.get(self, "total_bytes_sec")

    @_builtins.property
    @pulumi.getter(name="totalBytesSecMax")
    def total_bytes_sec_max(self) -> Optional[_builtins.float]:
        """
        Sets the maximum burst aggregate bandwidth limit (read + write) for the group in bytes per second; value is a non-negative integer and is typically paired with a corresponding `*_max_length` window.

        See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        """
        return pulumi.get(self, "total_bytes_sec_max")

    @_builtins.property
    @pulumi.getter(name="totalBytesSecMaxLength")
    def total_bytes_sec_max_length(self) -> Optional[_builtins.float]:
        """
        Sets the I/O burst length, in bytes, over which the total_bytes_sec_max limit is measured for the throttle group; the value is user-provided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        """
        return pulumi.get(self, "total_bytes_sec_max_length")

    @_builtins.property
    @pulumi.getter(name="totalIopsSec")
    def total_iops_sec(self) -> Optional[_builtins.float]:
        """
        Sets the steadystate limit on the total number of I/O operations per second (reads + writes) allowed for disks in this throttle group; the value is userprovided and must be a nonnegative integer (IOPS).

        See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        """
        return pulumi.get(self, "total_iops_sec")

    @_builtins.property
    @pulumi.getter(name="totalIopsSecMax")
    def total_iops_sec_max(self) -> Optional[_builtins.float]:
        """
        Sets the maximum burst IOPS limit (reads + writes) for the throttle group, above the steady total_iops_sec value; the value is userprovided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        """
        return pulumi.get(self, "total_iops_sec_max")

    @_builtins.property
    @pulumi.getter(name="totalIopsSecMaxLength")
    def total_iops_sec_max_length(self) -> Optional[_builtins.float]:
        """
        Sets the I/O burst length, in number of requests, over which the total_iops_sec_max limit is measured for the throttle group; the value is userprovided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        """
        return pulumi.get(self, "total_iops_sec_max_length")

    @_builtins.property
    @pulumi.getter(name="writeBytesSec")
    def write_bytes_sec(self) -> Optional[_builtins.float]:
        """
        Sets the steadystate limit on write throughput in bytes per second for disks in this throttle group; the value is userprovided and must be a nonnegative integer (e.g. 104857600 for 100 MiB/s).

        See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        """
        return pulumi.get(self, "write_bytes_sec")

    @_builtins.property
    @pulumi.getter(name="writeBytesSecMax")
    def write_bytes_sec_max(self) -> Optional[_builtins.float]:
        """
        Sets the maximum burst write throughput in bytes per second for the throttle group, above the steady write_bytes_sec limit; the value is userprovided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        """
        return pulumi.get(self, "write_bytes_sec_max")

    @_builtins.property
    @pulumi.getter(name="writeBytesSecMaxLength")
    def write_bytes_sec_max_length(self) -> Optional[_builtins.float]:
        """
        Sets the I/O burst length, in bytes, over which the write_bytes_sec_max limit is measured for the throttle group; the value is userprovided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        """
        return pulumi.get(self, "write_bytes_sec_max_length")

    @_builtins.property
    @pulumi.getter(name="writeIopsSec")
    def write_iops_sec(self) -> Optional[_builtins.float]:
        """
        Sets the steadystate limit on write IOPS for disks in this throttle group; the value is userprovided and must be a nonnegative integer (number of write requests per second).

        See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        """
        return pulumi.get(self, "write_iops_sec")

    @_builtins.property
    @pulumi.getter(name="writeIopsSecMax")
    def write_iops_sec_max(self) -> Optional[_builtins.float]:
        """
        Sets the maximum burst write IOPS limit for the throttle group, above the steady write_iops_sec value; the value is userprovided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        """
        return pulumi.get(self, "write_iops_sec_max")

    @_builtins.property
    @pulumi.getter(name="writeIopsSecMaxLength")
    def write_iops_sec_max_length(self) -> Optional[_builtins.float]:
        """
        Sets the I/O burst length, in number of write requests, over which the write_iops_sec_max limit is measured for the throttle group; the value is userprovided and must be a nonnegative integer.

        See: <https://libvirt.org/formatdomain.html#disk-throttle-group-management>
        """
        return pulumi.get(self, "write_iops_sec_max_length")


@pulumi.output_type
class DomainVcpus(dict):
    def __init__(__self__, *,
                 vcpus: Optional[Sequence['outputs.DomainVcpusVcpus']] = None):
        """
        :param Sequence['DomainVcpusVcpusArgs'] vcpus: Defines a single vCPU entry in the vcpus list, typically identified by an id attribute and optionally configured for pinning or hotplug behavior; the id and other attributes are userprovided.
               
               See: <https://libvirt.org/formatdomain.html#cpu-allocation>
        """
        if vcpus is not None:
            pulumi.set(__self__, "vcpus", vcpus)

    @_builtins.property
    @pulumi.getter
    def vcpus(self) -> Optional[Sequence['outputs.DomainVcpusVcpus']]:
        """
        Defines a single vCPU entry in the vcpus list, typically identified by an id attribute and optionally configured for pinning or hotplug behavior; the id and other attributes are userprovided.

        See: <https://libvirt.org/formatdomain.html#cpu-allocation>
        """
        return pulumi.get(self, "vcpus")


@pulumi.output_type
class DomainVcpusVcpus(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.str] = None,
                 hotpluggable: Optional[_builtins.str] = None,
                 id: Optional[_builtins.float] = None,
                 order: Optional[_builtins.float] = None):
        """
        :param _builtins.str enabled: Controls whether this specific vCPU is online at startup, using a booleanlike string value "yes" or "no" in the vcpu elements enabled attribute.
               
               See: <https://libvirt.org/formatdomain.html#cpu-allocation>
        :param _builtins.str hotpluggable: Sets whether this individual vCPU can be hotplugged on or off while the guest is running; accepts the strings "yes" or "no".
               
               See: <https://libvirt.org/formatdomain.html#cpu-allocation>
        :param _builtins.float id: Reports the index of this vCPU within the guest (0-based, computed by libvirt and not configurable).
               
               See: <https://libvirt.org/formatdomain.html#cpu-allocation>
        :param _builtins.float order: Sets the boot-time activation order for this vCPU relative to other vCPUs; the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatdomain.html#cpu-allocation>
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if hotpluggable is not None:
            pulumi.set(__self__, "hotpluggable", hotpluggable)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.str]:
        """
        Controls whether this specific vCPU is online at startup, using a booleanlike string value "yes" or "no" in the vcpu elements enabled attribute.

        See: <https://libvirt.org/formatdomain.html#cpu-allocation>
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def hotpluggable(self) -> Optional[_builtins.str]:
        """
        Sets whether this individual vCPU can be hotplugged on or off while the guest is running; accepts the strings "yes" or "no".

        See: <https://libvirt.org/formatdomain.html#cpu-allocation>
        """
        return pulumi.get(self, "hotpluggable")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.float]:
        """
        Reports the index of this vCPU within the guest (0-based, computed by libvirt and not configurable).

        See: <https://libvirt.org/formatdomain.html#cpu-allocation>
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def order(self) -> Optional[_builtins.float]:
        """
        Sets the boot-time activation order for this vCPU relative to other vCPUs; the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatdomain.html#cpu-allocation>
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class NetworkBandwidth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classId":
            suggest = "class_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkBandwidth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkBandwidth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkBandwidth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 class_id: Optional[_builtins.float] = None,
                 inbound: Optional['outputs.NetworkBandwidthInbound'] = None,
                 outbound: Optional['outputs.NetworkBandwidthOutbound'] = None):
        """
        :param _builtins.float class_id: Sets an optional traffic classification identifier (classID) for the network's bandwidth rules; value is user-provided and format is not constrained by libvirt.
               
               See: <https://libvirt.org/formatnetwork.html#quality-of-service>
        :param 'NetworkBandwidthInboundArgs' inbound: Configures QoS limits for outgoing traffic from the network, with child attributes controlling average rate and related parameters.
        :param 'NetworkBandwidthOutboundArgs' outbound: Configures QoS limits for outgoing traffic from the network, with child attributes controlling average rate and related parameters.
        """
        if class_id is not None:
            pulumi.set(__self__, "class_id", class_id)
        if inbound is not None:
            pulumi.set(__self__, "inbound", inbound)
        if outbound is not None:
            pulumi.set(__self__, "outbound", outbound)

    @_builtins.property
    @pulumi.getter(name="classId")
    def class_id(self) -> Optional[_builtins.float]:
        """
        Sets an optional traffic classification identifier (classID) for the network's bandwidth rules; value is user-provided and format is not constrained by libvirt.

        See: <https://libvirt.org/formatnetwork.html#quality-of-service>
        """
        return pulumi.get(self, "class_id")

    @_builtins.property
    @pulumi.getter
    def inbound(self) -> Optional['outputs.NetworkBandwidthInbound']:
        """
        Configures QoS limits for outgoing traffic from the network, with child attributes controlling average rate and related parameters.
        """
        return pulumi.get(self, "inbound")

    @_builtins.property
    @pulumi.getter
    def outbound(self) -> Optional['outputs.NetworkBandwidthOutbound']:
        """
        Configures QoS limits for outgoing traffic from the network, with child attributes controlling average rate and related parameters.
        """
        return pulumi.get(self, "outbound")


@pulumi.output_type
class NetworkBandwidthInbound(dict):
    def __init__(__self__, *,
                 average: Optional[_builtins.float] = None,
                 burst: Optional[_builtins.float] = None,
                 floor: Optional[_builtins.float] = None,
                 peak: Optional[_builtins.float] = None):
        """
        :param _builtins.float average: Sets the long-term average outbound bandwidth limit in kilobytes per second; value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatnetwork.html#quality-of-service>
        :param _builtins.float burst: Sets the maximum instantaneous outbound bandwidth burst size in kilobytes per second that may temporarily exceed the average; value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatnetwork.html#quality-of-service>
        :param _builtins.float floor: Sets a minimum guaranteed outbound bandwidth in kilobytes per second when supported by the backend; value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatnetwork.html#quality-of-service>
        :param _builtins.float peak: Sets an upper cap on outbound bandwidth in kilobytes per second, typically higher than average but not exceeding burst; value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatnetwork.html#quality-of-service>
        """
        if average is not None:
            pulumi.set(__self__, "average", average)
        if burst is not None:
            pulumi.set(__self__, "burst", burst)
        if floor is not None:
            pulumi.set(__self__, "floor", floor)
        if peak is not None:
            pulumi.set(__self__, "peak", peak)

    @_builtins.property
    @pulumi.getter
    def average(self) -> Optional[_builtins.float]:
        """
        Sets the long-term average outbound bandwidth limit in kilobytes per second; value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatnetwork.html#quality-of-service>
        """
        return pulumi.get(self, "average")

    @_builtins.property
    @pulumi.getter
    def burst(self) -> Optional[_builtins.float]:
        """
        Sets the maximum instantaneous outbound bandwidth burst size in kilobytes per second that may temporarily exceed the average; value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatnetwork.html#quality-of-service>
        """
        return pulumi.get(self, "burst")

    @_builtins.property
    @pulumi.getter
    def floor(self) -> Optional[_builtins.float]:
        """
        Sets a minimum guaranteed outbound bandwidth in kilobytes per second when supported by the backend; value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatnetwork.html#quality-of-service>
        """
        return pulumi.get(self, "floor")

    @_builtins.property
    @pulumi.getter
    def peak(self) -> Optional[_builtins.float]:
        """
        Sets an upper cap on outbound bandwidth in kilobytes per second, typically higher than average but not exceeding burst; value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatnetwork.html#quality-of-service>
        """
        return pulumi.get(self, "peak")


@pulumi.output_type
class NetworkBandwidthOutbound(dict):
    def __init__(__self__, *,
                 average: Optional[_builtins.float] = None,
                 burst: Optional[_builtins.float] = None,
                 floor: Optional[_builtins.float] = None,
                 peak: Optional[_builtins.float] = None):
        """
        :param _builtins.float average: Sets the long-term average outbound bandwidth limit in kilobytes per second; value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatnetwork.html#quality-of-service>
        :param _builtins.float burst: Sets the maximum instantaneous outbound bandwidth burst size in kilobytes per second that may temporarily exceed the average; value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatnetwork.html#quality-of-service>
        :param _builtins.float floor: Sets a minimum guaranteed outbound bandwidth in kilobytes per second when supported by the backend; value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatnetwork.html#quality-of-service>
        :param _builtins.float peak: Sets an upper cap on outbound bandwidth in kilobytes per second, typically higher than average but not exceeding burst; value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatnetwork.html#quality-of-service>
        """
        if average is not None:
            pulumi.set(__self__, "average", average)
        if burst is not None:
            pulumi.set(__self__, "burst", burst)
        if floor is not None:
            pulumi.set(__self__, "floor", floor)
        if peak is not None:
            pulumi.set(__self__, "peak", peak)

    @_builtins.property
    @pulumi.getter
    def average(self) -> Optional[_builtins.float]:
        """
        Sets the long-term average outbound bandwidth limit in kilobytes per second; value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatnetwork.html#quality-of-service>
        """
        return pulumi.get(self, "average")

    @_builtins.property
    @pulumi.getter
    def burst(self) -> Optional[_builtins.float]:
        """
        Sets the maximum instantaneous outbound bandwidth burst size in kilobytes per second that may temporarily exceed the average; value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatnetwork.html#quality-of-service>
        """
        return pulumi.get(self, "burst")

    @_builtins.property
    @pulumi.getter
    def floor(self) -> Optional[_builtins.float]:
        """
        Sets a minimum guaranteed outbound bandwidth in kilobytes per second when supported by the backend; value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatnetwork.html#quality-of-service>
        """
        return pulumi.get(self, "floor")

    @_builtins.property
    @pulumi.getter
    def peak(self) -> Optional[_builtins.float]:
        """
        Sets an upper cap on outbound bandwidth in kilobytes per second, typically higher than average but not exceeding burst; value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatnetwork.html#quality-of-service>
        """
        return pulumi.get(self, "peak")


@pulumi.output_type
class NetworkBridge(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "macTableManager":
            suggest = "mac_table_manager"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkBridge. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkBridge.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkBridge.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delay: Optional[_builtins.str] = None,
                 mac_table_manager: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 stp: Optional[_builtins.str] = None,
                 zone: Optional[_builtins.str] = None):
        """
        :param _builtins.str delay: Sets the forwarding delay (in seconds) for the bridge, controlling how long ports stay in the listening/learning states when STP is enabled; value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        :param _builtins.str mac_table_manager: Selects the MAC address table manager implementation for the bridge (e.g. "kernel" or "libvirt" when supported); value is a user-provided string constrained to backend-supported options.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        :param _builtins.str name: Bridge name (generated by libvirt if not specified)
        :param _builtins.str stp: Enables or disables Spanning Tree Protocol on the bridge; accepts the strings "on" or "off".
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        :param _builtins.str zone: Sets the DNS zone name associated with the bridged network, used as the default domain for DNS records served by this network. The value is user-provided and should typically be a valid DNS domain name (e.g. "example.local").
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        if delay is not None:
            pulumi.set(__self__, "delay", delay)
        if mac_table_manager is not None:
            pulumi.set(__self__, "mac_table_manager", mac_table_manager)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if stp is not None:
            pulumi.set(__self__, "stp", stp)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter
    def delay(self) -> Optional[_builtins.str]:
        """
        Sets the forwarding delay (in seconds) for the bridge, controlling how long ports stay in the listening/learning states when STP is enabled; value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "delay")

    @_builtins.property
    @pulumi.getter(name="macTableManager")
    def mac_table_manager(self) -> Optional[_builtins.str]:
        """
        Selects the MAC address table manager implementation for the bridge (e.g. "kernel" or "libvirt" when supported); value is a user-provided string constrained to backend-supported options.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "mac_table_manager")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Bridge name (generated by libvirt if not specified)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def stp(self) -> Optional[_builtins.str]:
        """
        Enables or disables Spanning Tree Protocol on the bridge; accepts the strings "on" or "off".

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "stp")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[_builtins.str]:
        """
        Sets the DNS zone name associated with the bridged network, used as the default domain for DNS records served by this network. The value is user-provided and should typically be a valid DNS domain name (e.g. "example.local").

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class NetworkDns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forwardPlainNames":
            suggest = "forward_plain_names"
        elif key == "srVs":
            suggest = "sr_vs"
        elif key == "txTs":
            suggest = "tx_ts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkDns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkDns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkDns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable: Optional[_builtins.str] = None,
                 forward_plain_names: Optional[_builtins.str] = None,
                 forwarders: Optional[Sequence['outputs.NetworkDnsForwarder']] = None,
                 hosts: Optional[Sequence['outputs.NetworkDnsHost']] = None,
                 sr_vs: Optional[Sequence['outputs.NetworkDnsSrV']] = None,
                 tx_ts: Optional[Sequence['outputs.NetworkDnsTxT']] = None):
        """
        :param _builtins.str enable: Controls whether the libvirt-managed DNS service for this network is enabled; accepts "yes" or "no". If omitted, libvirts default behavior applies.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param _builtins.str forward_plain_names: Controls whether plain hostnames (without a domain suffix) are forwarded to upstream DNS servers; accepts "yes" or "no". If unset, libvirt uses its default for forwarding plain names.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param Sequence['NetworkDnsForwarderArgs'] forwarders: Defines one or more upstream DNS forwarders that this networks DNS server queries when resolving names. Each block configures a single <forwarder> entry.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param Sequence['NetworkDnsHostArgs'] hosts: Defines a static DNS host entry mapping one IP address to one or more hostnames within this virtual network. Multiple host blocks may be used to configure several fixed name-to-address mappings.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param Sequence['NetworkDnsSrVArgs'] sr_vs: Configures DNS SRV records served by this networks DNS, describing services available under specific domains. Each block represents a single SRV record.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param Sequence['NetworkDnsTxTArgs'] tx_ts: Configures DNS TXT records served by this networks DNS, allowing arbitrary text data to be associated with names. Each block represents a single TXT record.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if forward_plain_names is not None:
            pulumi.set(__self__, "forward_plain_names", forward_plain_names)
        if forwarders is not None:
            pulumi.set(__self__, "forwarders", forwarders)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if sr_vs is not None:
            pulumi.set(__self__, "sr_vs", sr_vs)
        if tx_ts is not None:
            pulumi.set(__self__, "tx_ts", tx_ts)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[_builtins.str]:
        """
        Controls whether the libvirt-managed DNS service for this network is enabled; accepts "yes" or "no". If omitted, libvirts default behavior applies.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter(name="forwardPlainNames")
    def forward_plain_names(self) -> Optional[_builtins.str]:
        """
        Controls whether plain hostnames (without a domain suffix) are forwarded to upstream DNS servers; accepts "yes" or "no". If unset, libvirt uses its default for forwarding plain names.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "forward_plain_names")

    @_builtins.property
    @pulumi.getter
    def forwarders(self) -> Optional[Sequence['outputs.NetworkDnsForwarder']]:
        """
        Defines one or more upstream DNS forwarders that this networks DNS server queries when resolving names. Each block configures a single <forwarder> entry.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "forwarders")

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence['outputs.NetworkDnsHost']]:
        """
        Defines a static DNS host entry mapping one IP address to one or more hostnames within this virtual network. Multiple host blocks may be used to configure several fixed name-to-address mappings.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter(name="srVs")
    def sr_vs(self) -> Optional[Sequence['outputs.NetworkDnsSrV']]:
        """
        Configures DNS SRV records served by this networks DNS, describing services available under specific domains. Each block represents a single SRV record.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "sr_vs")

    @_builtins.property
    @pulumi.getter(name="txTs")
    def tx_ts(self) -> Optional[Sequence['outputs.NetworkDnsTxT']]:
        """
        Configures DNS TXT records served by this networks DNS, allowing arbitrary text data to be associated with names. Each block represents a single TXT record.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "tx_ts")


@pulumi.output_type
class NetworkDnsForwarder(dict):
    def __init__(__self__, *,
                 addr: Optional[_builtins.str] = None,
                 domain: Optional[_builtins.str] = None):
        """
        :param _builtins.str addr: Sets the IP address of an upstream DNS forwarder. The value is user-provided and should be a valid IPv4 or IPv6 address (e.g. "8.8.8.8" or "2001:4860:4860::8888").
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param _builtins.str domain: Restricts the forwarder to queries for a specific DNS domain suffix. The value is user-provided and should be a valid DNS domain (e.g. "example.com").
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        if addr is not None:
            pulumi.set(__self__, "addr", addr)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def addr(self) -> Optional[_builtins.str]:
        """
        Sets the IP address of an upstream DNS forwarder. The value is user-provided and should be a valid IPv4 or IPv6 address (e.g. "8.8.8.8" or "2001:4860:4860::8888").

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "addr")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[_builtins.str]:
        """
        Restricts the forwarder to queries for a specific DNS domain suffix. The value is user-provided and should be a valid DNS domain (e.g. "example.com").

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class NetworkDnsHost(dict):
    def __init__(__self__, *,
                 ip: _builtins.str,
                 hostnames: Optional[Sequence['outputs.NetworkDnsHostHostname']] = None):
        """
        :param _builtins.str ip: Sets the IP address for the static host mapping used by all associated hostnames. The value is required and must be a valid IPv4 or IPv6 address.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param Sequence['NetworkDnsHostHostnameArgs'] hostnames: Lists one or more hostnames associated with a single static DNS host entry. Each block represents a single hostname record for the given IP.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        pulumi.set(__self__, "ip", ip)
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        """
        Sets the IP address for the static host mapping used by all associated hostnames. The value is required and must be a valid IPv4 or IPv6 address.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def hostnames(self) -> Optional[Sequence['outputs.NetworkDnsHostHostname']]:
        """
        Lists one or more hostnames associated with a single static DNS host entry. Each block represents a single hostname record for the given IP.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "hostnames")


@pulumi.output_type
class NetworkDnsHostHostname(dict):
    def __init__(__self__, *,
                 hostname: _builtins.str):
        """
        :param _builtins.str hostname: Sets a hostname to be mapped to the parent hosts IP address in DNS. The value is user-provided and should be a valid host label or FQDN (e.g. "web1" or "web1.example.local").
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        pulumi.set(__self__, "hostname", hostname)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        Sets a hostname to be mapped to the parent hosts IP address in DNS. The value is user-provided and should be a valid host label or FQDN (e.g. "web1" or "web1.example.local").

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "hostname")


@pulumi.output_type
class NetworkDnsSrV(dict):
    def __init__(__self__, *,
                 domain: Optional[_builtins.str] = None,
                 port: Optional[_builtins.float] = None,
                 priority: Optional[_builtins.float] = None,
                 protocol: Optional[_builtins.str] = None,
                 service: Optional[_builtins.str] = None,
                 target: Optional[_builtins.str] = None,
                 weight: Optional[_builtins.float] = None):
        """
        :param _builtins.str domain: Sets the DNS domain in which the SRV record applies (the owner names domain part). The value is user-provided and should be a valid domain (e.g. "example.local").
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param _builtins.float port: Sets the TCP or UDP port number on which the advertised service listens. The value should be an integer between 1 and 65535 (e.g. 80 or 443).
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param _builtins.float priority: Sets the SRV record priority, used to order multiple records for the same service; lower values have higher priority. The value is an integer, typically non-negative (e.g. 0 or 10).
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param _builtins.str protocol: Sets the transport protocol for the SRV record, typically "tcp" or "udp". The value is user-provided but should match the services actual protocol.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param _builtins.str service: Sets the service name part of the SRV record, without the leading underscore (e.g. "http", "ldap"). The value is user-provided and should be a valid service identifier.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param _builtins.str target: Sets the hostname of the server providing the advertised service, as returned in the SRV record. The value is user-provided and should be a resolvable hostname within or outside the virtual network.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param _builtins.float weight: Sets the SRV record weight used to distribute traffic among records of the same priority. The value is an integer, typically non-negative (e.g. 0 or 50).
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[_builtins.str]:
        """
        Sets the DNS domain in which the SRV record applies (the owner names domain part). The value is user-provided and should be a valid domain (e.g. "example.local").

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.float]:
        """
        Sets the TCP or UDP port number on which the advertised service listens. The value should be an integer between 1 and 65535 (e.g. 80 or 443).

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.float]:
        """
        Sets the SRV record priority, used to order multiple records for the same service; lower values have higher priority. The value is an integer, typically non-negative (e.g. 0 or 10).

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        Sets the transport protocol for the SRV record, typically "tcp" or "udp". The value is user-provided but should match the services actual protocol.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Sets the service name part of the SRV record, without the leading underscore (e.g. "http", "ldap"). The value is user-provided and should be a valid service identifier.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[_builtins.str]:
        """
        Sets the hostname of the server providing the advertised service, as returned in the SRV record. The value is user-provided and should be a resolvable hostname within or outside the virtual network.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.float]:
        """
        Sets the SRV record weight used to distribute traffic among records of the same priority. The value is an integer, typically non-negative (e.g. 0 or 50).

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class NetworkDnsTxT(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Sets the DNS TXT record name advertised by the virtual networks builtin DNS server; the value is userprovided (for example, a hostname or arbitrary label).
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param _builtins.str value: Sets the DNS TXT record value string returned for the given TXT record name; the value is userprovided and may contain any text permitted by DNS TXT records.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the DNS TXT record name advertised by the virtual networks builtin DNS server; the value is userprovided (for example, a hostname or arbitrary label).

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Sets the DNS TXT record value string returned for the given TXT record name; the value is userprovided and may contain any text permitted by DNS TXT records.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NetworkDomain(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localOnly":
            suggest = "local_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkDomain. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkDomain.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkDomain.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 local_only: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str local_only: Controls whether the network domain is used only for local name resolution inside libvirts DNS (\\"yes\\" for local-only, \\"no\\" to allow external registration), with the value stored as a string flag.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param _builtins.str name: Sets the DNS domain name associated with this virtual network (for example, \\"virt.example.com\\") that is appended to hostnames and exposed via DHCP/DNS.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        if local_only is not None:
            pulumi.set(__self__, "local_only", local_only)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="localOnly")
    def local_only(self) -> Optional[_builtins.str]:
        """
        Controls whether the network domain is used only for local name resolution inside libvirts DNS (\\"yes\\" for local-only, \\"no\\" to allow external registration), with the value stored as a string flag.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "local_only")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the DNS domain name associated with this virtual network (for example, \\"virt.example.com\\") that is appended to hostnames and exposed via DHCP/DNS.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkForward(dict):
    def __init__(__self__, *,
                 addresses: Optional[Sequence['outputs.NetworkForwardAddress']] = None,
                 dev: Optional[_builtins.str] = None,
                 driver: Optional['outputs.NetworkForwardDriver'] = None,
                 interfaces: Optional[Sequence['outputs.NetworkForwardInterface']] = None,
                 managed: Optional[_builtins.bool] = None,
                 mode: Optional[_builtins.str] = None,
                 nat: Optional['outputs.NetworkForwardNat'] = None,
                 pfs: Optional[Sequence['outputs.NetworkForwardPf']] = None):
        """
        :param Sequence['NetworkForwardAddressArgs'] addresses: Lists one or more forwarding endpoint addresses (typically physical devices or PCI addresses) used when the network is in a passthrough/hostdev style forward mode.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        :param _builtins.str dev: Specifies a single host network interface name (e.g. \\"eth0\\", \\"br0\\") that this virtual network forwards through; used by several forward modes such as \\"route\\", \\"nat\\", or \\"bridge\\".
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        :param 'NetworkForwardDriverArgs' driver: Configures driver-specific settings for the network forward, allowing selection or tuning of the underlying forwarding implementation.
        :param Sequence['NetworkForwardInterfaceArgs'] interfaces: Lists one or more host interfaces that participate in this networks forwarding (for multiNIC or aggregated configurations).
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        :param _builtins.str mode: Sets the forwarding mode of the virtual network, with valid values including \\"nat\\", \\"route\\", \\"bridge\\", \\"open\\", \\"vepa\\", \\"passthrough\\", or \\"private\\" depending on the desired connectivity model.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        :param 'NetworkForwardNatArgs' nat: Configures NAT-specific options for the networks forward mode, including address and port ranges used for translation.
        :param Sequence['NetworkForwardPfArgs'] pfs: Declares one or more physical forwarding interfaces (port forwarding devices) used by the networks forward mode.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if interfaces is not None:
            pulumi.set(__self__, "interfaces", interfaces)
        if managed is not None:
            pulumi.set(__self__, "managed", managed)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if nat is not None:
            pulumi.set(__self__, "nat", nat)
        if pfs is not None:
            pulumi.set(__self__, "pfs", pfs)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Optional[Sequence['outputs.NetworkForwardAddress']]:
        """
        Lists one or more forwarding endpoint addresses (typically physical devices or PCI addresses) used when the network is in a passthrough/hostdev style forward mode.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "addresses")

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional[_builtins.str]:
        """
        Specifies a single host network interface name (e.g. \\"eth0\\", \\"br0\\") that this virtual network forwards through; used by several forward modes such as \\"route\\", \\"nat\\", or \\"bridge\\".

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter
    def driver(self) -> Optional['outputs.NetworkForwardDriver']:
        """
        Configures driver-specific settings for the network forward, allowing selection or tuning of the underlying forwarding implementation.
        """
        return pulumi.get(self, "driver")

    @_builtins.property
    @pulumi.getter
    def interfaces(self) -> Optional[Sequence['outputs.NetworkForwardInterface']]:
        """
        Lists one or more host interfaces that participate in this networks forwarding (for multiNIC or aggregated configurations).

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "interfaces")

    @_builtins.property
    @pulumi.getter
    def managed(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "managed")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the forwarding mode of the virtual network, with valid values including \\"nat\\", \\"route\\", \\"bridge\\", \\"open\\", \\"vepa\\", \\"passthrough\\", or \\"private\\" depending on the desired connectivity model.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def nat(self) -> Optional['outputs.NetworkForwardNat']:
        """
        Configures NAT-specific options for the networks forward mode, including address and port ranges used for translation.
        """
        return pulumi.get(self, "nat")

    @_builtins.property
    @pulumi.getter
    def pfs(self) -> Optional[Sequence['outputs.NetworkForwardPf']]:
        """
        Declares one or more physical forwarding interfaces (port forwarding devices) used by the networks forward mode.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "pfs")


@pulumi.output_type
class NetworkForwardAddress(dict):
    def __init__(__self__, *,
                 pci: Optional['outputs.NetworkForwardAddressPci'] = None):
        """
        :param 'NetworkForwardAddressPciArgs' pci: Declares a PCI address used as a forwarding target, identifying a specific host PCI device through which the network is connected.
        """
        if pci is not None:
            pulumi.set(__self__, "pci", pci)

    @_builtins.property
    @pulumi.getter
    def pci(self) -> Optional['outputs.NetworkForwardAddressPci']:
        """
        Declares a PCI address used as a forwarding target, identifying a specific host PCI device through which the network is connected.
        """
        return pulumi.get(self, "pci")


@pulumi.output_type
class NetworkForwardAddressPci(dict):
    def __init__(__self__, *,
                 bus: Optional[_builtins.float] = None,
                 domain: Optional[_builtins.float] = None,
                 function: Optional[_builtins.float] = None,
                 slot: Optional[_builtins.float] = None):
        """
        :param _builtins.float bus: Sets the PCI bus number (in hexadecimal) of the forwarding device; the value must match the hosts PCI topology (e.g. \\"03\\").
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        :param _builtins.float domain: Sets the PCI domain number (in hexadecimal, usually \\"0000\\") of the forwarding device; the value must match the hosts PCI topology.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        :param _builtins.float function: Sets the PCI function number (in hexadecimal, 07) of the forwarding device, completing the BDF identifier.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        :param _builtins.float slot: Sets the PCI slot number (in hexadecimal) of the forwarding device; together with domain, bus, and function it uniquely identifies the PCI device.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        if bus is not None:
            pulumi.set(__self__, "bus", bus)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if function is not None:
            pulumi.set(__self__, "function", function)
        if slot is not None:
            pulumi.set(__self__, "slot", slot)

    @_builtins.property
    @pulumi.getter
    def bus(self) -> Optional[_builtins.float]:
        """
        Sets the PCI bus number (in hexadecimal) of the forwarding device; the value must match the hosts PCI topology (e.g. \\"03\\").

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "bus")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[_builtins.float]:
        """
        Sets the PCI domain number (in hexadecimal, usually \\"0000\\") of the forwarding device; the value must match the hosts PCI topology.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter
    def function(self) -> Optional[_builtins.float]:
        """
        Sets the PCI function number (in hexadecimal, 07) of the forwarding device, completing the BDF identifier.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "function")

    @_builtins.property
    @pulumi.getter
    def slot(self) -> Optional[_builtins.float]:
        """
        Sets the PCI slot number (in hexadecimal) of the forwarding device; together with domain, bus, and function it uniquely identifies the PCI device.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "slot")


@pulumi.output_type
class NetworkForwardDriver(dict):
    def __init__(__self__, *,
                 model: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str model: Sets the driver model used for forwarding (for example, a specific macvtap or SRIOV mode), with the exact string value being driver-specific and userprovided.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        :param _builtins.str name: Sets the forwarding driver backend name (e.g. a specific implementation used by the hypervisor), with the value being userprovided.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        Sets the driver model used for forwarding (for example, a specific macvtap or SRIOV mode), with the exact string value being driver-specific and userprovided.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the forwarding driver backend name (e.g. a specific implementation used by the hypervisor), with the value being userprovided.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkForwardInterface(dict):
    def __init__(__self__, *,
                 dev: Optional[_builtins.str] = None):
        """
        :param _builtins.str dev: Specifies the name of a host interface (e.g. \\"eth1\\") used as an individual forwarding endpoint within the virtual network.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        if dev is not None:
            pulumi.set(__self__, "dev", dev)

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional[_builtins.str]:
        """
        Specifies the name of a host interface (e.g. \\"eth1\\") used as an individual forwarding endpoint within the virtual network.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "dev")


@pulumi.output_type
class NetworkForwardNat(dict):
    def __init__(__self__, *,
                 addresses: Optional[Sequence['outputs.NetworkForwardNatAddress']] = None,
                 ipv6: Optional[_builtins.str] = None,
                 ports: Optional[Sequence['outputs.NetworkForwardNatPort']] = None):
        """
        :param Sequence['NetworkForwardNatAddressArgs'] addresses: Sets one or more address ranges used as the external source addresses for NAT, each defined by a start and end IP.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        :param _builtins.str ipv6: Controls whether this NAT configuration applies to IPv6 traffic; value is user-provided and typically "yes" or "no".
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        :param Sequence['NetworkForwardNatPortArgs'] ports: Sets one or more port ranges to be used for NAT translation, each defined by a start and end port.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Optional[Sequence['outputs.NetworkForwardNatAddress']]:
        """
        Sets one or more address ranges used as the external source addresses for NAT, each defined by a start and end IP.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "addresses")

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[_builtins.str]:
        """
        Controls whether this NAT configuration applies to IPv6 traffic; value is user-provided and typically "yes" or "no".

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "ipv6")

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[Sequence['outputs.NetworkForwardNatPort']]:
        """
        Sets one or more port ranges to be used for NAT translation, each defined by a start and end port.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class NetworkForwardNatAddress(dict):
    def __init__(__self__, *,
                 end: _builtins.str,
                 start: _builtins.str):
        """
        :param _builtins.str end: Sets the last IP address in the NAT external address range; must be in the same family and >= the start address (e.g. "192.168.122.254").
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        :param _builtins.str start: Sets the first IP address in the NAT external address range; must be a valid IPv4 or IPv6 address (e.g. "192.168.122.1").
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> _builtins.str:
        """
        Sets the last IP address in the NAT external address range; must be in the same family and >= the start address (e.g. "192.168.122.254").

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter
    def start(self) -> _builtins.str:
        """
        Sets the first IP address in the NAT external address range; must be a valid IPv4 or IPv6 address (e.g. "192.168.122.1").

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class NetworkForwardNatPort(dict):
    def __init__(__self__, *,
                 end: _builtins.float,
                 start: _builtins.float):
        """
        :param _builtins.float end: Sets the last port number in the NAT port range; must be an integer between 1 and 65535 and >= the start port.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        :param _builtins.float start: Sets the first port number in the NAT port range; must be an integer between 1 and 65535 (e.g. 1024).
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> _builtins.float:
        """
        Sets the last port number in the NAT port range; must be an integer between 1 and 65535 and >= the start port.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter
    def start(self) -> _builtins.float:
        """
        Sets the first port number in the NAT port range; must be an integer between 1 and 65535 (e.g. 1024).

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class NetworkForwardPf(dict):
    def __init__(__self__, *,
                 dev: _builtins.str):
        """
        :param _builtins.str dev: Sets the name of the underlying physical network device to be used by this forwarding interface (e.g. "eth0").
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        pulumi.set(__self__, "dev", dev)

    @_builtins.property
    @pulumi.getter
    def dev(self) -> _builtins.str:
        """
        Sets the name of the underlying physical network device to be used by this forwarding interface (e.g. "eth0").

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "dev")


@pulumi.output_type
class NetworkIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localPtr":
            suggest = "local_ptr"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 dhcp: Optional['outputs.NetworkIpDhcp'] = None,
                 family: Optional[_builtins.str] = None,
                 local_ptr: Optional[_builtins.str] = None,
                 netmask: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.float] = None,
                 tftp: Optional['outputs.NetworkIpTftp'] = None):
        """
        :param _builtins.str address: Sets the IP address assigned to the network bridge for this family; must be a valid IPv4 or IPv6 address (e.g. "192.168.122.1").
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param 'NetworkIpDhcpArgs' dhcp: Enables and configures DHCP service for this IP configuration, including BOOTP and static host entries.
        :param _builtins.str family: Selects the IP address family for this address, typically `ipv4` or `ipv6`; if omitted, libvirt infers it from the address format.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param _builtins.str local_ptr: Controls whether DNS PTR records for addresses in this subnet are generated only for this network (`yes`) or can be forwarded (`no`); value is `yes` or `no`.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param _builtins.str netmask: Sets the IPv4 netmask for this subnet; must be a dotted-quad such as `255.255.255.0` and is mutually exclusive with `prefix`.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param _builtins.float prefix: Sets the CIDR prefix length for this subnet (commonly used for IPv6, e.g. `64`, but also valid for IPv4); mutually exclusive with `netmask`.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param 'NetworkIpTftpArgs' tftp: Enables optional TFTP service for this network IP and configures its parameters.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if dhcp is not None:
            pulumi.set(__self__, "dhcp", dhcp)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if local_ptr is not None:
            pulumi.set(__self__, "local_ptr", local_ptr)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if tftp is not None:
            pulumi.set(__self__, "tftp", tftp)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Sets the IP address assigned to the network bridge for this family; must be a valid IPv4 or IPv6 address (e.g. "192.168.122.1").

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def dhcp(self) -> Optional['outputs.NetworkIpDhcp']:
        """
        Enables and configures DHCP service for this IP configuration, including BOOTP and static host entries.
        """
        return pulumi.get(self, "dhcp")

    @_builtins.property
    @pulumi.getter
    def family(self) -> Optional[_builtins.str]:
        """
        Selects the IP address family for this address, typically `ipv4` or `ipv6`; if omitted, libvirt infers it from the address format.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "family")

    @_builtins.property
    @pulumi.getter(name="localPtr")
    def local_ptr(self) -> Optional[_builtins.str]:
        """
        Controls whether DNS PTR records for addresses in this subnet are generated only for this network (`yes`) or can be forwarded (`no`); value is `yes` or `no`.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "local_ptr")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> Optional[_builtins.str]:
        """
        Sets the IPv4 netmask for this subnet; must be a dotted-quad such as `255.255.255.0` and is mutually exclusive with `prefix`.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.float]:
        """
        Sets the CIDR prefix length for this subnet (commonly used for IPv6, e.g. `64`, but also valid for IPv4); mutually exclusive with `netmask`.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def tftp(self) -> Optional['outputs.NetworkIpTftp']:
        """
        Enables optional TFTP service for this network IP and configures its parameters.
        """
        return pulumi.get(self, "tftp")


@pulumi.output_type
class NetworkIpDhcp(dict):
    def __init__(__self__, *,
                 bootps: Optional[Sequence['outputs.NetworkIpDhcpBootp']] = None,
                 hosts: Optional[Sequence['outputs.NetworkIpDhcpHost']] = None,
                 ranges: Optional[Sequence['outputs.NetworkIpDhcpRange']] = None):
        """
        :param Sequence['NetworkIpDhcpBootpArgs'] bootps: Configures BOOTP options for this DHCP range, such as the boot file and TFTP server used by PXE/BOOTP clients.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param Sequence['NetworkIpDhcpHostArgs'] hosts: Defines one or more static DHCP host entries that map specific clients to fixed IP and lease settings.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param Sequence['NetworkIpDhcpRangeArgs'] ranges: Configures one or more dynamic DHCP address ranges associated with this IP subnet.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        if bootps is not None:
            pulumi.set(__self__, "bootps", bootps)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if ranges is not None:
            pulumi.set(__self__, "ranges", ranges)

    @_builtins.property
    @pulumi.getter
    def bootps(self) -> Optional[Sequence['outputs.NetworkIpDhcpBootp']]:
        """
        Configures BOOTP options for this DHCP range, such as the boot file and TFTP server used by PXE/BOOTP clients.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "bootps")

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence['outputs.NetworkIpDhcpHost']]:
        """
        Defines one or more static DHCP host entries that map specific clients to fixed IP and lease settings.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter
    def ranges(self) -> Optional[Sequence['outputs.NetworkIpDhcpRange']]:
        """
        Configures one or more dynamic DHCP address ranges associated with this IP subnet.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "ranges")


@pulumi.output_type
class NetworkIpDhcpBootp(dict):
    def __init__(__self__, *,
                 file: Optional[_builtins.str] = None,
                 server: Optional[_builtins.str] = None):
        """
        :param _builtins.str file: Sets the boot file name advertised via BOOTP/PXE (for example "pxelinux.0" or "bootx64.efi").
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param _builtins.str server: Sets the IP address of the TFTP/boot server advertised via BOOTP; must be a valid IPv4 or IPv6 address.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        if file is not None:
            pulumi.set(__self__, "file", file)
        if server is not None:
            pulumi.set(__self__, "server", server)

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional[_builtins.str]:
        """
        Sets the boot file name advertised via BOOTP/PXE (for example "pxelinux.0" or "bootx64.efi").

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def server(self) -> Optional[_builtins.str]:
        """
        Sets the IP address of the TFTP/boot server advertised via BOOTP; must be a valid IPv4 or IPv6 address.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "server")


@pulumi.output_type
class NetworkIpDhcpHost(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 ip: Optional[_builtins.str] = None,
                 lease: Optional['outputs.NetworkIpDhcpHostLease'] = None,
                 mac: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Represents the client identifier or DUID for a static DHCP host entry; when omitted it is computed from other host attributes.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param _builtins.str ip: Sets the fixed IP address that the DHCP server always assigns to this host; must be within the networks address range.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param 'NetworkIpDhcpHostLeaseArgs' lease: Configures the lease parameters for this static DHCP host entry, such as expiry; the structure and values are user-provided.
        :param _builtins.str mac: Sets the MAC address for a static DHCP host entry; must be a valid MAC such as `52:54:00:12:34:56`.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param _builtins.str name: Sets the hostname to be handed out via DHCP for this static host entry; the value is user-provided.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if lease is not None:
            pulumi.set(__self__, "lease", lease)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Represents the client identifier or DUID for a static DHCP host entry; when omitted it is computed from other host attributes.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        """
        Sets the fixed IP address that the DHCP server always assigns to this host; must be within the networks address range.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def lease(self) -> Optional['outputs.NetworkIpDhcpHostLease']:
        """
        Configures the lease parameters for this static DHCP host entry, such as expiry; the structure and values are user-provided.
        """
        return pulumi.get(self, "lease")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> Optional[_builtins.str]:
        """
        Sets the MAC address for a static DHCP host entry; must be a valid MAC such as `52:54:00:12:34:56`.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the hostname to be handed out via DHCP for this static host entry; the value is user-provided.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkIpDhcpHostLease(dict):
    def __init__(__self__, *,
                 expiry: _builtins.float,
                 unit: Optional[_builtins.str] = None):
        """
        :param _builtins.float expiry: Sets the DHCP lease time for a static host entry, as a numeric duration value whose interpretation depends on `unit` (for example, `3600` when `unit` is `seconds`).
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param _builtins.str unit: Sets the time unit used for the host DHCP lease `expiry`, with valid values `seconds`, `minutes`, or `hours`.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        pulumi.set(__self__, "expiry", expiry)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def expiry(self) -> _builtins.float:
        """
        Sets the DHCP lease time for a static host entry, as a numeric duration value whose interpretation depends on `unit` (for example, `3600` when `unit` is `seconds`).

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "expiry")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        """
        Sets the time unit used for the host DHCP lease `expiry`, with valid values `seconds`, `minutes`, or `hours`.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class NetworkIpDhcpRange(dict):
    def __init__(__self__, *,
                 end: Optional[_builtins.str] = None,
                 lease: Optional['outputs.NetworkIpDhcpRangeLease'] = None,
                 start: Optional[_builtins.str] = None):
        """
        :param _builtins.str end: Sets the end address (inclusive) of a DHCP range; must be an IP in the same subnet as the parent `ip`.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param 'NetworkIpDhcpRangeLeaseArgs' lease: Configures the lease parameters for this static DHCP host entry, such as expiry; the structure and values are user-provided.
        :param _builtins.str start: Sets the starting address of a DHCP range; must be an IP in the same subnet as the parent `ip`.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        if end is not None:
            pulumi.set(__self__, "end", end)
        if lease is not None:
            pulumi.set(__self__, "lease", lease)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[_builtins.str]:
        """
        Sets the end address (inclusive) of a DHCP range; must be an IP in the same subnet as the parent `ip`.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter
    def lease(self) -> Optional['outputs.NetworkIpDhcpRangeLease']:
        """
        Configures the lease parameters for this static DHCP host entry, such as expiry; the structure and values are user-provided.
        """
        return pulumi.get(self, "lease")

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[_builtins.str]:
        """
        Sets the starting address of a DHCP range; must be an IP in the same subnet as the parent `ip`.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class NetworkIpDhcpRangeLease(dict):
    def __init__(__self__, *,
                 expiry: _builtins.float,
                 unit: Optional[_builtins.str] = None):
        """
        :param _builtins.float expiry: Sets the DHCP lease time for a static host entry, as a numeric duration value whose interpretation depends on `unit` (for example, `3600` when `unit` is `seconds`).
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        :param _builtins.str unit: Sets the time unit used for the host DHCP lease `expiry`, with valid values `seconds`, `minutes`, or `hours`.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        pulumi.set(__self__, "expiry", expiry)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def expiry(self) -> _builtins.float:
        """
        Sets the DHCP lease time for a static host entry, as a numeric duration value whose interpretation depends on `unit` (for example, `3600` when `unit` is `seconds`).

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "expiry")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        """
        Sets the time unit used for the host DHCP lease `expiry`, with valid values `seconds`, `minutes`, or `hours`.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class NetworkIpTftp(dict):
    def __init__(__self__, *,
                 root: Optional[_builtins.str] = None):
        """
        :param _builtins.str root: Sets the filesystem directory that TFTP will expose as its root for this network IP; value is a host path such as `/var/lib/tftpboot`.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        if root is not None:
            pulumi.set(__self__, "root", root)

    @_builtins.property
    @pulumi.getter
    def root(self) -> Optional[_builtins.str]:
        """
        Sets the filesystem directory that TFTP will expose as its root for this network IP; value is a host path such as `/var/lib/tftpboot`.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "root")


@pulumi.output_type
class NetworkMac(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: Sets the MAC address of the bridge associated with this virtual network; must be a valid MAC such as `52:54:00:ab:cd:ef`.
               
               See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        if address is not None:
            pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Sets the MAC address of the bridge associated with this virtual network; must be a valid MAC such as `52:54:00:ab:cd:ef`.

        See: <https://libvirt.org/formatnetwork.html#addressing>
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class NetworkMetadata(dict):
    def __init__(__self__, *,
                 xml: _builtins.str):
        """
        :param _builtins.str xml: Sets arbitrary user-defined XML metadata attached to the network; libvirt stores it verbatim and does not interpret its contents.
               
               See: <https://libvirt.org/formatnetwork.html#general-metadata>
        """
        pulumi.set(__self__, "xml", xml)

    @_builtins.property
    @pulumi.getter
    def xml(self) -> _builtins.str:
        """
        Sets arbitrary user-defined XML metadata attached to the network; libvirt stores it verbatim and does not interpret its contents.

        See: <https://libvirt.org/formatnetwork.html#general-metadata>
        """
        return pulumi.get(self, "xml")


@pulumi.output_type
class NetworkMtu(dict):
    def __init__(__self__, *,
                 size: _builtins.float):
        """
        :param _builtins.float size: Sets the MTU size (non-negative integer, in bytes) for the networks bridge or interface, e.g. 1500 or 9000.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.float:
        """
        Sets the MTU size (non-negative integer, in bytes) for the networks bridge or interface, e.g. 1500 or 9000.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class NetworkPortGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustGuestRxFilters":
            suggest = "trust_guest_rx_filters"
        elif key == "virtualPort":
            suggest = "virtual_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkPortGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkPortGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkPortGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 trust_guest_rx_filters: Optional[_builtins.str] = None,
                 virtual_port: Optional['outputs.NetworkPortGroupVirtualPort'] = None,
                 vlan: Optional['outputs.NetworkPortGroupVlan'] = None):
        """
        :param _builtins.str default: Marks this port group as the default when guests do not explicitly select a port group; value is a yes/no style flag (typically "yes" or "no").
               
               See: <https://libvirt.org/formatnetwork.html#portgroups>
        :param _builtins.str name: Sets the name of the port group, used by guest interfaces to select this group by reference; value is user-provided and must be unique within the network.
               
               See: <https://libvirt.org/formatnetwork.html#portgroups>
        :param _builtins.str trust_guest_rx_filters: Controls whether the network trusts receive-filter programming from guests attached via this port group; value is a yes/no style flag ("yes" to trust, "no" to ignore).
               
               See: <https://libvirt.org/formatnetwork.html#portgroups>
        :param 'NetworkPortGroupVirtualPortArgs' virtual_port: Configures virtual port profile information for this port group, enabling integration with external network switching or SDN systems.
        :param 'NetworkPortGroupVlanArgs' vlan: Configures VLAN tagging behavior for this portgroup, allowing one or more VLAN tags to be applied to guest connections when the underlying network supports VLAN offload.
        """
        if default is not None:
            pulumi.set(__self__, "default", default)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if trust_guest_rx_filters is not None:
            pulumi.set(__self__, "trust_guest_rx_filters", trust_guest_rx_filters)
        if virtual_port is not None:
            pulumi.set(__self__, "virtual_port", virtual_port)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.str]:
        """
        Marks this port group as the default when guests do not explicitly select a port group; value is a yes/no style flag (typically "yes" or "no").

        See: <https://libvirt.org/formatnetwork.html#portgroups>
        """
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the name of the port group, used by guest interfaces to select this group by reference; value is user-provided and must be unique within the network.

        See: <https://libvirt.org/formatnetwork.html#portgroups>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="trustGuestRxFilters")
    def trust_guest_rx_filters(self) -> Optional[_builtins.str]:
        """
        Controls whether the network trusts receive-filter programming from guests attached via this port group; value is a yes/no style flag ("yes" to trust, "no" to ignore).

        See: <https://libvirt.org/formatnetwork.html#portgroups>
        """
        return pulumi.get(self, "trust_guest_rx_filters")

    @_builtins.property
    @pulumi.getter(name="virtualPort")
    def virtual_port(self) -> Optional['outputs.NetworkPortGroupVirtualPort']:
        """
        Configures virtual port profile information for this port group, enabling integration with external network switching or SDN systems.
        """
        return pulumi.get(self, "virtual_port")

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> Optional['outputs.NetworkPortGroupVlan']:
        """
        Configures VLAN tagging behavior for this portgroup, allowing one or more VLAN tags to be applied to guest connections when the underlying network supports VLAN offload.
        """
        return pulumi.get(self, "vlan")


@pulumi.output_type
class NetworkPortGroupVirtualPort(dict):
    def __init__(__self__, *,
                 params: Optional['outputs.NetworkPortGroupVirtualPortParams'] = None):
        """
        :param 'NetworkPortGroupVirtualPortParamsArgs' params: Provides backend-specific virtual port profile parameters for this port group, with one child element per backend type (e.g. Any, MidoNet, OpenVSwitch).
        """
        if params is not None:
            pulumi.set(__self__, "params", params)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional['outputs.NetworkPortGroupVirtualPortParams']:
        """
        Provides backend-specific virtual port profile parameters for this port group, with one child element per backend type (e.g. Any, MidoNet, OpenVSwitch).
        """
        return pulumi.get(self, "params")


@pulumi.output_type
class NetworkPortGroupVirtualPortParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "midoNet":
            suggest = "mido_net"
        elif key == "openVSwitch":
            suggest = "open_v_switch"
        elif key == "vnTag8011qbh":
            suggest = "vn_tag8011qbh"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkPortGroupVirtualPortParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkPortGroupVirtualPortParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkPortGroupVirtualPortParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any: Optional['outputs.NetworkPortGroupVirtualPortParamsAny'] = None,
                 mido_net: Optional['outputs.NetworkPortGroupVirtualPortParamsMidoNet'] = None,
                 open_v_switch: Optional['outputs.NetworkPortGroupVirtualPortParamsOpenVSwitch'] = None,
                 vepa8021qbg: Optional['outputs.NetworkPortGroupVirtualPortParamsVepa8021qbg'] = None,
                 vn_tag8011qbh: Optional['outputs.NetworkPortGroupVirtualPortParamsVnTag8011qbh'] = None):
        """
        :param 'NetworkPortGroupVirtualPortParamsAnyArgs' any: Configures a generic (IEEE 802.1Qbg-style) port profile, using opaque identifiers understood by an external network manager.
        :param 'NetworkPortGroupVirtualPortParamsMidoNetArgs' mido_net: Configures MidoNet-specific virtual port parameters for this port group, enabling integration with a MidoNet SDN controller.
        :param 'NetworkPortGroupVirtualPortParamsOpenVSwitchArgs' open_v_switch: Configures Open vSwitch-specific virtual port parameters for this port group, enabling OVS-aware port profiling; all values are user-provided and interpreted by OVS tooling.
        :param 'NetworkPortGroupVirtualPortParamsVepa8021qbgArgs' vepa8021qbg: Enables configuration of IEEE 802.1Qbg VEPA virtual port profile parameters for this portgroup, allowing association with an external Edge Virtual Bridging (EVB) manager.
        :param 'NetworkPortGroupVirtualPortParamsVnTag8011qbhArgs' vn_tag8011qbh: Enables configuration of IEEE 802.1Qbh VN-Tag virtual port profile parameters for this portgroup, used with hardware that supports Cisco VN-Tag or similar tagging.
        """
        if any is not None:
            pulumi.set(__self__, "any", any)
        if mido_net is not None:
            pulumi.set(__self__, "mido_net", mido_net)
        if open_v_switch is not None:
            pulumi.set(__self__, "open_v_switch", open_v_switch)
        if vepa8021qbg is not None:
            pulumi.set(__self__, "vepa8021qbg", vepa8021qbg)
        if vn_tag8011qbh is not None:
            pulumi.set(__self__, "vn_tag8011qbh", vn_tag8011qbh)

    @_builtins.property
    @pulumi.getter
    def any(self) -> Optional['outputs.NetworkPortGroupVirtualPortParamsAny']:
        """
        Configures a generic (IEEE 802.1Qbg-style) port profile, using opaque identifiers understood by an external network manager.
        """
        return pulumi.get(self, "any")

    @_builtins.property
    @pulumi.getter(name="midoNet")
    def mido_net(self) -> Optional['outputs.NetworkPortGroupVirtualPortParamsMidoNet']:
        """
        Configures MidoNet-specific virtual port parameters for this port group, enabling integration with a MidoNet SDN controller.
        """
        return pulumi.get(self, "mido_net")

    @_builtins.property
    @pulumi.getter(name="openVSwitch")
    def open_v_switch(self) -> Optional['outputs.NetworkPortGroupVirtualPortParamsOpenVSwitch']:
        """
        Configures Open vSwitch-specific virtual port parameters for this port group, enabling OVS-aware port profiling; all values are user-provided and interpreted by OVS tooling.
        """
        return pulumi.get(self, "open_v_switch")

    @_builtins.property
    @pulumi.getter
    def vepa8021qbg(self) -> Optional['outputs.NetworkPortGroupVirtualPortParamsVepa8021qbg']:
        """
        Enables configuration of IEEE 802.1Qbg VEPA virtual port profile parameters for this portgroup, allowing association with an external Edge Virtual Bridging (EVB) manager.
        """
        return pulumi.get(self, "vepa8021qbg")

    @_builtins.property
    @pulumi.getter(name="vnTag8011qbh")
    def vn_tag8011qbh(self) -> Optional['outputs.NetworkPortGroupVirtualPortParamsVnTag8011qbh']:
        """
        Enables configuration of IEEE 802.1Qbh VN-Tag virtual port profile parameters for this portgroup, used with hardware that supports Cisco VN-Tag or similar tagging.
        """
        return pulumi.get(self, "vn_tag8011qbh")


@pulumi.output_type
class NetworkPortGroupVirtualPortParamsAny(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceId":
            suggest = "instance_id"
        elif key == "interfaceId":
            suggest = "interface_id"
        elif key == "managerId":
            suggest = "manager_id"
        elif key == "profileId":
            suggest = "profile_id"
        elif key == "typeId":
            suggest = "type_id"
        elif key == "typeIdVersion":
            suggest = "type_id_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkPortGroupVirtualPortParamsAny. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkPortGroupVirtualPortParamsAny.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkPortGroupVirtualPortParamsAny.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_id: Optional[_builtins.str] = None,
                 interface_id: Optional[_builtins.str] = None,
                 manager_id: Optional[_builtins.float] = None,
                 profile_id: Optional[_builtins.str] = None,
                 type_id: Optional[_builtins.float] = None,
                 type_id_version: Optional[_builtins.float] = None):
        """
        :param _builtins.str instance_id: Sets the instance identifier for the generic port profile, typically a UUID string unique per attached interface instance.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        :param _builtins.str interface_id: Sets the interface identifier for the generic port profile, usually a stable ID used by the external switch to identify the virtual NIC.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        :param _builtins.float manager_id: Sets the manager identifier for the generic port profile, typically a numeric or string ID identifying the external network management system.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        :param _builtins.str profile_id: Sets the profile identifier for the generic port profile, referencing a logical port profile defined in the external network manager.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        :param _builtins.float type_id: Sets the type identifier for the generic port profile, defining the semantic type of the profile as expected by the external switch; value is user-provided.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        :param _builtins.float type_id_version: Sets the version of the type identifier for the generic port profile, allowing the external manager to distinguish revisions; value is user-provided.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if interface_id is not None:
            pulumi.set(__self__, "interface_id", interface_id)
        if manager_id is not None:
            pulumi.set(__self__, "manager_id", manager_id)
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)
        if type_id is not None:
            pulumi.set(__self__, "type_id", type_id)
        if type_id_version is not None:
            pulumi.set(__self__, "type_id_version", type_id_version)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[_builtins.str]:
        """
        Sets the instance identifier for the generic port profile, typically a UUID string unique per attached interface instance.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="interfaceId")
    def interface_id(self) -> Optional[_builtins.str]:
        """
        Sets the interface identifier for the generic port profile, usually a stable ID used by the external switch to identify the virtual NIC.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "interface_id")

    @_builtins.property
    @pulumi.getter(name="managerId")
    def manager_id(self) -> Optional[_builtins.float]:
        """
        Sets the manager identifier for the generic port profile, typically a numeric or string ID identifying the external network management system.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "manager_id")

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[_builtins.str]:
        """
        Sets the profile identifier for the generic port profile, referencing a logical port profile defined in the external network manager.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "profile_id")

    @_builtins.property
    @pulumi.getter(name="typeId")
    def type_id(self) -> Optional[_builtins.float]:
        """
        Sets the type identifier for the generic port profile, defining the semantic type of the profile as expected by the external switch; value is user-provided.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "type_id")

    @_builtins.property
    @pulumi.getter(name="typeIdVersion")
    def type_id_version(self) -> Optional[_builtins.float]:
        """
        Sets the version of the type identifier for the generic port profile, allowing the external manager to distinguish revisions; value is user-provided.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "type_id_version")


@pulumi.output_type
class NetworkPortGroupVirtualPortParamsMidoNet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "interfaceId":
            suggest = "interface_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkPortGroupVirtualPortParamsMidoNet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkPortGroupVirtualPortParamsMidoNet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkPortGroupVirtualPortParamsMidoNet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interface_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str interface_id: Sets the MidoNet interface identifier, typically a UUID or opaque string that MidoNet uses to match the guest interface to a virtual port.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        if interface_id is not None:
            pulumi.set(__self__, "interface_id", interface_id)

    @_builtins.property
    @pulumi.getter(name="interfaceId")
    def interface_id(self) -> Optional[_builtins.str]:
        """
        Sets the MidoNet interface identifier, typically a UUID or opaque string that MidoNet uses to match the guest interface to a virtual port.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "interface_id")


@pulumi.output_type
class NetworkPortGroupVirtualPortParamsOpenVSwitch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "interfaceId":
            suggest = "interface_id"
        elif key == "profileId":
            suggest = "profile_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkPortGroupVirtualPortParamsOpenVSwitch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkPortGroupVirtualPortParamsOpenVSwitch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkPortGroupVirtualPortParamsOpenVSwitch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interface_id: Optional[_builtins.str] = None,
                 profile_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str interface_id: Sets the Open vSwitch interface identifier (interfaceid) for ports in this portgroup; value is user-provided and typically matches the UUID or name expected by the OVS integration on the host.
               
               See: <https://libvirt.org/formatdomain.html#virtual-network>
        :param _builtins.str profile_id: Sets the Open vSwitch profile identifier (profileid) for ports in this portgroup; value is user-provided and used by OVS or higher-level controllers to apply a specific port profile.
               
               See: <https://libvirt.org/formatdomain.html#virtual-network>
        """
        if interface_id is not None:
            pulumi.set(__self__, "interface_id", interface_id)
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)

    @_builtins.property
    @pulumi.getter(name="interfaceId")
    def interface_id(self) -> Optional[_builtins.str]:
        """
        Sets the Open vSwitch interface identifier (interfaceid) for ports in this portgroup; value is user-provided and typically matches the UUID or name expected by the OVS integration on the host.

        See: <https://libvirt.org/formatdomain.html#virtual-network>
        """
        return pulumi.get(self, "interface_id")

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[_builtins.str]:
        """
        Sets the Open vSwitch profile identifier (profileid) for ports in this portgroup; value is user-provided and used by OVS or higher-level controllers to apply a specific port profile.

        See: <https://libvirt.org/formatdomain.html#virtual-network>
        """
        return pulumi.get(self, "profile_id")


@pulumi.output_type
class NetworkPortGroupVirtualPortParamsVepa8021qbg(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceId":
            suggest = "instance_id"
        elif key == "managerId":
            suggest = "manager_id"
        elif key == "typeId":
            suggest = "type_id"
        elif key == "typeIdVersion":
            suggest = "type_id_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkPortGroupVirtualPortParamsVepa8021qbg. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkPortGroupVirtualPortParamsVepa8021qbg.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkPortGroupVirtualPortParamsVepa8021qbg.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_id: Optional[_builtins.str] = None,
                 manager_id: Optional[_builtins.float] = None,
                 type_id: Optional[_builtins.float] = None,
                 type_id_version: Optional[_builtins.float] = None):
        """
        :param _builtins.str instance_id: Sets the 802.1Qbg VEPA instance identifier (instanceid) for this port profile; value is user-provided and usually a unique identifier (often UUID-like) assigned by the EVB manager.
               
               See: <https://libvirt.org/formatdomain.html#direct-attachment-to-physical-interface>
        :param _builtins.float manager_id: Sets the 802.1Qbg VEPA manager identifier (managerid) that identifies the external EVB manager controlling this profile; value is user-provided numeric or string ID.
               
               See: <https://libvirt.org/formatdomain.html#direct-attachment-to-physical-interface>
        :param _builtins.float type_id: Sets the 802.1Qbg VEPA type identifier (typeid) indicating what kind of profile is referenced; value is user-provided and must match the EVB managers expectations.
               
               See: <https://libvirt.org/formatdomain.html#direct-attachment-to-physical-interface>
        :param _builtins.float type_id_version: Sets the 802.1Qbg VEPA type identifier version (typeidversion) for this profile; value is user-provided and typically a small integer version understood by the EVB manager.
               
               See: <https://libvirt.org/formatdomain.html#direct-attachment-to-physical-interface>
        """
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if manager_id is not None:
            pulumi.set(__self__, "manager_id", manager_id)
        if type_id is not None:
            pulumi.set(__self__, "type_id", type_id)
        if type_id_version is not None:
            pulumi.set(__self__, "type_id_version", type_id_version)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[_builtins.str]:
        """
        Sets the 802.1Qbg VEPA instance identifier (instanceid) for this port profile; value is user-provided and usually a unique identifier (often UUID-like) assigned by the EVB manager.

        See: <https://libvirt.org/formatdomain.html#direct-attachment-to-physical-interface>
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="managerId")
    def manager_id(self) -> Optional[_builtins.float]:
        """
        Sets the 802.1Qbg VEPA manager identifier (managerid) that identifies the external EVB manager controlling this profile; value is user-provided numeric or string ID.

        See: <https://libvirt.org/formatdomain.html#direct-attachment-to-physical-interface>
        """
        return pulumi.get(self, "manager_id")

    @_builtins.property
    @pulumi.getter(name="typeId")
    def type_id(self) -> Optional[_builtins.float]:
        """
        Sets the 802.1Qbg VEPA type identifier (typeid) indicating what kind of profile is referenced; value is user-provided and must match the EVB managers expectations.

        See: <https://libvirt.org/formatdomain.html#direct-attachment-to-physical-interface>
        """
        return pulumi.get(self, "type_id")

    @_builtins.property
    @pulumi.getter(name="typeIdVersion")
    def type_id_version(self) -> Optional[_builtins.float]:
        """
        Sets the 802.1Qbg VEPA type identifier version (typeidversion) for this profile; value is user-provided and typically a small integer version understood by the EVB manager.

        See: <https://libvirt.org/formatdomain.html#direct-attachment-to-physical-interface>
        """
        return pulumi.get(self, "type_id_version")


@pulumi.output_type
class NetworkPortGroupVirtualPortParamsVnTag8011qbh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "profileId":
            suggest = "profile_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkPortGroupVirtualPortParamsVnTag8011qbh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkPortGroupVirtualPortParamsVnTag8011qbh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkPortGroupVirtualPortParamsVnTag8011qbh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 profile_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str profile_id: Sets the 802.1Qbh VN-Tag profile identifier (profileid) for this portgroup; value is user-provided and should match the profile configured on the VN-Tagaware switch.
               
               See: <https://libvirt.org/formatdomain.html#direct-attachment-to-physical-interface>
        """
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[_builtins.str]:
        """
        Sets the 802.1Qbh VN-Tag profile identifier (profileid) for this portgroup; value is user-provided and should match the profile configured on the VN-Tagaware switch.

        See: <https://libvirt.org/formatdomain.html#direct-attachment-to-physical-interface>
        """
        return pulumi.get(self, "profile_id")


@pulumi.output_type
class NetworkPortGroupVlan(dict):
    def __init__(__self__, *,
                 tags: Optional[Sequence['outputs.NetworkPortGroupVlanTag']] = None,
                 trunk: Optional[_builtins.str] = None):
        """
        :param Sequence['NetworkPortGroupVlanTagArgs'] tags: Defines one or more VLAN tag entries for this portgroup; each tag specifies a VLAN ID, and optionally native-mode behavior, applied to guest traffic.
               
               See: <https://libvirt.org/formatnetwork.html#setting-vlan-tag-on-supported-network-types-only>
        :param _builtins.str trunk: Controls whether this portgroups VLAN configuration operates in trunk mode, allowing multiple VLAN tags; value is a yes/no string flag, where "yes" enables trunk mode.
               
               See: <https://libvirt.org/formatnetwork.html#setting-vlan-tag-on-supported-network-types-only>
        """
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if trunk is not None:
            pulumi.set(__self__, "trunk", trunk)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.NetworkPortGroupVlanTag']]:
        """
        Defines one or more VLAN tag entries for this portgroup; each tag specifies a VLAN ID, and optionally native-mode behavior, applied to guest traffic.

        See: <https://libvirt.org/formatnetwork.html#setting-vlan-tag-on-supported-network-types-only>
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def trunk(self) -> Optional[_builtins.str]:
        """
        Controls whether this portgroups VLAN configuration operates in trunk mode, allowing multiple VLAN tags; value is a yes/no string flag, where "yes" enables trunk mode.

        See: <https://libvirt.org/formatnetwork.html#setting-vlan-tag-on-supported-network-types-only>
        """
        return pulumi.get(self, "trunk")


@pulumi.output_type
class NetworkPortGroupVlanTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nativeMode":
            suggest = "native_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkPortGroupVlanTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkPortGroupVlanTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkPortGroupVlanTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[_builtins.float] = None,
                 native_mode: Optional[_builtins.str] = None):
        """
        :param _builtins.float id: Reports the VLAN ID associated with this tag; when managed by libvirt it is computed from the backing XML and corresponds to the 802.1Q VLAN identifier (14094).
               
               See: <https://libvirt.org/formatnetwork.html#setting-vlan-tag-on-supported-network-types-only>
        :param _builtins.str native_mode: Sets whether this VLAN tag is treated as native on the trunk for this portgroup; valid values are user-provided strings such as "tagged" or "untagged" as supported by libvirt/qemu.
               
               See: <https://libvirt.org/formatnetwork.html#setting-vlan-tag-on-supported-network-types-only>
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if native_mode is not None:
            pulumi.set(__self__, "native_mode", native_mode)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.float]:
        """
        Reports the VLAN ID associated with this tag; when managed by libvirt it is computed from the backing XML and corresponds to the 802.1Q VLAN identifier (14094).

        See: <https://libvirt.org/formatnetwork.html#setting-vlan-tag-on-supported-network-types-only>
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="nativeMode")
    def native_mode(self) -> Optional[_builtins.str]:
        """
        Sets whether this VLAN tag is treated as native on the trunk for this portgroup; valid values are user-provided strings such as "tagged" or "untagged" as supported by libvirt/qemu.

        See: <https://libvirt.org/formatnetwork.html#setting-vlan-tag-on-supported-network-types-only>
        """
        return pulumi.get(self, "native_mode")


@pulumi.output_type
class NetworkPortOptions(dict):
    def __init__(__self__, *,
                 isolated: Optional[_builtins.str] = None):
        """
        :param _builtins.str isolated: Controls whether each guest port on this network is isolated from all other guest ports on the same network; valid values are "yes" or "no" (default is "no" when omitted).
               
               See: <https://libvirt.org/formatnetwork.html#isolating-ports-from-one-another>
        """
        if isolated is not None:
            pulumi.set(__self__, "isolated", isolated)

    @_builtins.property
    @pulumi.getter
    def isolated(self) -> Optional[_builtins.str]:
        """
        Controls whether each guest port on this network is isolated from all other guest ports on the same network; valid values are "yes" or "no" (default is "no" when omitted).

        See: <https://libvirt.org/formatnetwork.html#isolating-ports-from-one-another>
        """
        return pulumi.get(self, "isolated")


@pulumi.output_type
class NetworkRoute(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 family: Optional[_builtins.str] = None,
                 gateway: Optional[_builtins.str] = None,
                 metric: Optional[_builtins.str] = None,
                 netmask: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.float] = None):
        """
        :param _builtins.str address: Sets the destination network address (in IPv4 or IPv6 form) for this static route; value is user-provided and should match the routes prefix (e.g. "192.168.2.0/24" or "2001:db8::/64").
               
               See: <https://libvirt.org/formatnetwork.html#static-routes>
        :param _builtins.str family: Specifies the address family for this static route; valid values are "ipv4" or "ipv6".
               
               See: <https://libvirt.org/formatnetwork.html#static-routes>
        :param _builtins.str gateway: Sets the next-hop gateway IP address for this static route, pointing to a guest-accessible router; value is user-provided and must be in the family specified by family.
               
               See: <https://libvirt.org/formatnetwork.html#static-routes>
        :param _builtins.str metric: Sets the routing metric for this static route; lower values have higher priority, and the value is a user-provided non-negative integer.
               
               See: <https://libvirt.org/formatnetwork.html#static-routes>
        :param _builtins.str netmask: Sets the IPv4 netmask for the destination of this static route as a dotted-quad string (for example, "255.255.255.0"); use this instead of prefix for netmask-based routes.
               
               See: <https://libvirt.org/formatnetwork.html#static-routes>
        :param _builtins.float prefix: Sets the CIDR prefix length for the destination of this static route as a user-provided integer between 0 and 128 (depending on IPv4/IPv6); use this instead of netmask for prefix-based routes.
               
               See: <https://libvirt.org/formatnetwork.html#static-routes>
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Sets the destination network address (in IPv4 or IPv6 form) for this static route; value is user-provided and should match the routes prefix (e.g. "192.168.2.0/24" or "2001:db8::/64").

        See: <https://libvirt.org/formatnetwork.html#static-routes>
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def family(self) -> Optional[_builtins.str]:
        """
        Specifies the address family for this static route; valid values are "ipv4" or "ipv6".

        See: <https://libvirt.org/formatnetwork.html#static-routes>
        """
        return pulumi.get(self, "family")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[_builtins.str]:
        """
        Sets the next-hop gateway IP address for this static route, pointing to a guest-accessible router; value is user-provided and must be in the family specified by family.

        See: <https://libvirt.org/formatnetwork.html#static-routes>
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[_builtins.str]:
        """
        Sets the routing metric for this static route; lower values have higher priority, and the value is a user-provided non-negative integer.

        See: <https://libvirt.org/formatnetwork.html#static-routes>
        """
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> Optional[_builtins.str]:
        """
        Sets the IPv4 netmask for the destination of this static route as a dotted-quad string (for example, "255.255.255.0"); use this instead of prefix for netmask-based routes.

        See: <https://libvirt.org/formatnetwork.html#static-routes>
        """
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.float]:
        """
        Sets the CIDR prefix length for the destination of this static route as a user-provided integer between 0 and 128 (depending on IPv4/IPv6); use this instead of netmask for prefix-based routes.

        See: <https://libvirt.org/formatnetwork.html#static-routes>
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class NetworkVirtualPort(dict):
    def __init__(__self__, *,
                 params: Optional['outputs.NetworkVirtualPortParams'] = None):
        """
        :param 'NetworkVirtualPortParamsArgs' params: Provides backend-specific virtual port profile parameters for this port group, with one child element per backend type (e.g. Any, MidoNet, OpenVSwitch).
        """
        if params is not None:
            pulumi.set(__self__, "params", params)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional['outputs.NetworkVirtualPortParams']:
        """
        Provides backend-specific virtual port profile parameters for this port group, with one child element per backend type (e.g. Any, MidoNet, OpenVSwitch).
        """
        return pulumi.get(self, "params")


@pulumi.output_type
class NetworkVirtualPortParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "midoNet":
            suggest = "mido_net"
        elif key == "openVSwitch":
            suggest = "open_v_switch"
        elif key == "vnTag8011qbh":
            suggest = "vn_tag8011qbh"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkVirtualPortParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkVirtualPortParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkVirtualPortParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any: Optional['outputs.NetworkVirtualPortParamsAny'] = None,
                 mido_net: Optional['outputs.NetworkVirtualPortParamsMidoNet'] = None,
                 open_v_switch: Optional['outputs.NetworkVirtualPortParamsOpenVSwitch'] = None,
                 vepa8021qbg: Optional['outputs.NetworkVirtualPortParamsVepa8021qbg'] = None,
                 vn_tag8011qbh: Optional['outputs.NetworkVirtualPortParamsVnTag8011qbh'] = None):
        """
        :param 'NetworkVirtualPortParamsAnyArgs' any: Configures a generic (IEEE 802.1Qbg-style) port profile, using opaque identifiers understood by an external network manager.
        :param 'NetworkVirtualPortParamsMidoNetArgs' mido_net: Configures MidoNet-specific virtual port parameters for this port group, enabling integration with a MidoNet SDN controller.
        :param 'NetworkVirtualPortParamsOpenVSwitchArgs' open_v_switch: Configures Open vSwitch-specific virtual port parameters for this port group, enabling OVS-aware port profiling; all values are user-provided and interpreted by OVS tooling.
        :param 'NetworkVirtualPortParamsVepa8021qbgArgs' vepa8021qbg: Enables configuration of IEEE 802.1Qbg VEPA virtual port profile parameters for this portgroup, allowing association with an external Edge Virtual Bridging (EVB) manager.
        :param 'NetworkVirtualPortParamsVnTag8011qbhArgs' vn_tag8011qbh: Enables configuration of IEEE 802.1Qbh VN-Tag virtual port profile parameters for this portgroup, used with hardware that supports Cisco VN-Tag or similar tagging.
        """
        if any is not None:
            pulumi.set(__self__, "any", any)
        if mido_net is not None:
            pulumi.set(__self__, "mido_net", mido_net)
        if open_v_switch is not None:
            pulumi.set(__self__, "open_v_switch", open_v_switch)
        if vepa8021qbg is not None:
            pulumi.set(__self__, "vepa8021qbg", vepa8021qbg)
        if vn_tag8011qbh is not None:
            pulumi.set(__self__, "vn_tag8011qbh", vn_tag8011qbh)

    @_builtins.property
    @pulumi.getter
    def any(self) -> Optional['outputs.NetworkVirtualPortParamsAny']:
        """
        Configures a generic (IEEE 802.1Qbg-style) port profile, using opaque identifiers understood by an external network manager.
        """
        return pulumi.get(self, "any")

    @_builtins.property
    @pulumi.getter(name="midoNet")
    def mido_net(self) -> Optional['outputs.NetworkVirtualPortParamsMidoNet']:
        """
        Configures MidoNet-specific virtual port parameters for this port group, enabling integration with a MidoNet SDN controller.
        """
        return pulumi.get(self, "mido_net")

    @_builtins.property
    @pulumi.getter(name="openVSwitch")
    def open_v_switch(self) -> Optional['outputs.NetworkVirtualPortParamsOpenVSwitch']:
        """
        Configures Open vSwitch-specific virtual port parameters for this port group, enabling OVS-aware port profiling; all values are user-provided and interpreted by OVS tooling.
        """
        return pulumi.get(self, "open_v_switch")

    @_builtins.property
    @pulumi.getter
    def vepa8021qbg(self) -> Optional['outputs.NetworkVirtualPortParamsVepa8021qbg']:
        """
        Enables configuration of IEEE 802.1Qbg VEPA virtual port profile parameters for this portgroup, allowing association with an external Edge Virtual Bridging (EVB) manager.
        """
        return pulumi.get(self, "vepa8021qbg")

    @_builtins.property
    @pulumi.getter(name="vnTag8011qbh")
    def vn_tag8011qbh(self) -> Optional['outputs.NetworkVirtualPortParamsVnTag8011qbh']:
        """
        Enables configuration of IEEE 802.1Qbh VN-Tag virtual port profile parameters for this portgroup, used with hardware that supports Cisco VN-Tag or similar tagging.
        """
        return pulumi.get(self, "vn_tag8011qbh")


@pulumi.output_type
class NetworkVirtualPortParamsAny(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceId":
            suggest = "instance_id"
        elif key == "interfaceId":
            suggest = "interface_id"
        elif key == "managerId":
            suggest = "manager_id"
        elif key == "profileId":
            suggest = "profile_id"
        elif key == "typeId":
            suggest = "type_id"
        elif key == "typeIdVersion":
            suggest = "type_id_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkVirtualPortParamsAny. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkVirtualPortParamsAny.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkVirtualPortParamsAny.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_id: Optional[_builtins.str] = None,
                 interface_id: Optional[_builtins.str] = None,
                 manager_id: Optional[_builtins.float] = None,
                 profile_id: Optional[_builtins.str] = None,
                 type_id: Optional[_builtins.float] = None,
                 type_id_version: Optional[_builtins.float] = None):
        """
        :param _builtins.str instance_id: Sets the instance identifier for the generic port profile, typically a UUID string unique per attached interface instance.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        :param _builtins.str interface_id: Sets the interface identifier for the generic port profile, usually a stable ID used by the external switch to identify the virtual NIC.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        :param _builtins.float manager_id: Sets the manager identifier for the generic port profile, typically a numeric or string ID identifying the external network management system.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        :param _builtins.str profile_id: Sets the profile identifier for the generic port profile, referencing a logical port profile defined in the external network manager.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        :param _builtins.float type_id: Sets the type identifier for the generic port profile, defining the semantic type of the profile as expected by the external switch; value is user-provided.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        :param _builtins.float type_id_version: Sets the version of the type identifier for the generic port profile, allowing the external manager to distinguish revisions; value is user-provided.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if interface_id is not None:
            pulumi.set(__self__, "interface_id", interface_id)
        if manager_id is not None:
            pulumi.set(__self__, "manager_id", manager_id)
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)
        if type_id is not None:
            pulumi.set(__self__, "type_id", type_id)
        if type_id_version is not None:
            pulumi.set(__self__, "type_id_version", type_id_version)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[_builtins.str]:
        """
        Sets the instance identifier for the generic port profile, typically a UUID string unique per attached interface instance.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="interfaceId")
    def interface_id(self) -> Optional[_builtins.str]:
        """
        Sets the interface identifier for the generic port profile, usually a stable ID used by the external switch to identify the virtual NIC.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "interface_id")

    @_builtins.property
    @pulumi.getter(name="managerId")
    def manager_id(self) -> Optional[_builtins.float]:
        """
        Sets the manager identifier for the generic port profile, typically a numeric or string ID identifying the external network management system.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "manager_id")

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[_builtins.str]:
        """
        Sets the profile identifier for the generic port profile, referencing a logical port profile defined in the external network manager.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "profile_id")

    @_builtins.property
    @pulumi.getter(name="typeId")
    def type_id(self) -> Optional[_builtins.float]:
        """
        Sets the type identifier for the generic port profile, defining the semantic type of the profile as expected by the external switch; value is user-provided.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "type_id")

    @_builtins.property
    @pulumi.getter(name="typeIdVersion")
    def type_id_version(self) -> Optional[_builtins.float]:
        """
        Sets the version of the type identifier for the generic port profile, allowing the external manager to distinguish revisions; value is user-provided.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "type_id_version")


@pulumi.output_type
class NetworkVirtualPortParamsMidoNet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "interfaceId":
            suggest = "interface_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkVirtualPortParamsMidoNet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkVirtualPortParamsMidoNet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkVirtualPortParamsMidoNet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interface_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str interface_id: Sets the MidoNet interface identifier, typically a UUID or opaque string that MidoNet uses to match the guest interface to a virtual port.
               
               See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        if interface_id is not None:
            pulumi.set(__self__, "interface_id", interface_id)

    @_builtins.property
    @pulumi.getter(name="interfaceId")
    def interface_id(self) -> Optional[_builtins.str]:
        """
        Sets the MidoNet interface identifier, typically a UUID or opaque string that MidoNet uses to match the guest interface to a virtual port.

        See: <https://libvirt.org/formatnetwork.html#connectivity>
        """
        return pulumi.get(self, "interface_id")


@pulumi.output_type
class NetworkVirtualPortParamsOpenVSwitch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "interfaceId":
            suggest = "interface_id"
        elif key == "profileId":
            suggest = "profile_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkVirtualPortParamsOpenVSwitch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkVirtualPortParamsOpenVSwitch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkVirtualPortParamsOpenVSwitch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interface_id: Optional[_builtins.str] = None,
                 profile_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str interface_id: Sets the Open vSwitch interface identifier (interfaceid) for ports in this portgroup; value is user-provided and typically matches the UUID or name expected by the OVS integration on the host.
               
               See: <https://libvirt.org/formatdomain.html#virtual-network>
        :param _builtins.str profile_id: Sets the Open vSwitch profile identifier (profileid) for ports in this portgroup; value is user-provided and used by OVS or higher-level controllers to apply a specific port profile.
               
               See: <https://libvirt.org/formatdomain.html#virtual-network>
        """
        if interface_id is not None:
            pulumi.set(__self__, "interface_id", interface_id)
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)

    @_builtins.property
    @pulumi.getter(name="interfaceId")
    def interface_id(self) -> Optional[_builtins.str]:
        """
        Sets the Open vSwitch interface identifier (interfaceid) for ports in this portgroup; value is user-provided and typically matches the UUID or name expected by the OVS integration on the host.

        See: <https://libvirt.org/formatdomain.html#virtual-network>
        """
        return pulumi.get(self, "interface_id")

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[_builtins.str]:
        """
        Sets the Open vSwitch profile identifier (profileid) for ports in this portgroup; value is user-provided and used by OVS or higher-level controllers to apply a specific port profile.

        See: <https://libvirt.org/formatdomain.html#virtual-network>
        """
        return pulumi.get(self, "profile_id")


@pulumi.output_type
class NetworkVirtualPortParamsVepa8021qbg(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceId":
            suggest = "instance_id"
        elif key == "managerId":
            suggest = "manager_id"
        elif key == "typeId":
            suggest = "type_id"
        elif key == "typeIdVersion":
            suggest = "type_id_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkVirtualPortParamsVepa8021qbg. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkVirtualPortParamsVepa8021qbg.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkVirtualPortParamsVepa8021qbg.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_id: Optional[_builtins.str] = None,
                 manager_id: Optional[_builtins.float] = None,
                 type_id: Optional[_builtins.float] = None,
                 type_id_version: Optional[_builtins.float] = None):
        """
        :param _builtins.str instance_id: Sets the 802.1Qbg VEPA instance identifier (instanceid) for this port profile; value is user-provided and usually a unique identifier (often UUID-like) assigned by the EVB manager.
               
               See: <https://libvirt.org/formatdomain.html#direct-attachment-to-physical-interface>
        :param _builtins.float manager_id: Sets the 802.1Qbg VEPA manager identifier (managerid) that identifies the external EVB manager controlling this profile; value is user-provided numeric or string ID.
               
               See: <https://libvirt.org/formatdomain.html#direct-attachment-to-physical-interface>
        :param _builtins.float type_id: Sets the 802.1Qbg VEPA type identifier (typeid) indicating what kind of profile is referenced; value is user-provided and must match the EVB managers expectations.
               
               See: <https://libvirt.org/formatdomain.html#direct-attachment-to-physical-interface>
        :param _builtins.float type_id_version: Sets the 802.1Qbg VEPA type identifier version (typeidversion) for this profile; value is user-provided and typically a small integer version understood by the EVB manager.
               
               See: <https://libvirt.org/formatdomain.html#direct-attachment-to-physical-interface>
        """
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if manager_id is not None:
            pulumi.set(__self__, "manager_id", manager_id)
        if type_id is not None:
            pulumi.set(__self__, "type_id", type_id)
        if type_id_version is not None:
            pulumi.set(__self__, "type_id_version", type_id_version)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[_builtins.str]:
        """
        Sets the 802.1Qbg VEPA instance identifier (instanceid) for this port profile; value is user-provided and usually a unique identifier (often UUID-like) assigned by the EVB manager.

        See: <https://libvirt.org/formatdomain.html#direct-attachment-to-physical-interface>
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="managerId")
    def manager_id(self) -> Optional[_builtins.float]:
        """
        Sets the 802.1Qbg VEPA manager identifier (managerid) that identifies the external EVB manager controlling this profile; value is user-provided numeric or string ID.

        See: <https://libvirt.org/formatdomain.html#direct-attachment-to-physical-interface>
        """
        return pulumi.get(self, "manager_id")

    @_builtins.property
    @pulumi.getter(name="typeId")
    def type_id(self) -> Optional[_builtins.float]:
        """
        Sets the 802.1Qbg VEPA type identifier (typeid) indicating what kind of profile is referenced; value is user-provided and must match the EVB managers expectations.

        See: <https://libvirt.org/formatdomain.html#direct-attachment-to-physical-interface>
        """
        return pulumi.get(self, "type_id")

    @_builtins.property
    @pulumi.getter(name="typeIdVersion")
    def type_id_version(self) -> Optional[_builtins.float]:
        """
        Sets the 802.1Qbg VEPA type identifier version (typeidversion) for this profile; value is user-provided and typically a small integer version understood by the EVB manager.

        See: <https://libvirt.org/formatdomain.html#direct-attachment-to-physical-interface>
        """
        return pulumi.get(self, "type_id_version")


@pulumi.output_type
class NetworkVirtualPortParamsVnTag8011qbh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "profileId":
            suggest = "profile_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkVirtualPortParamsVnTag8011qbh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkVirtualPortParamsVnTag8011qbh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkVirtualPortParamsVnTag8011qbh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 profile_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str profile_id: Sets the 802.1Qbh VN-Tag profile identifier (profileid) for this portgroup; value is user-provided and should match the profile configured on the VN-Tagaware switch.
               
               See: <https://libvirt.org/formatdomain.html#direct-attachment-to-physical-interface>
        """
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[_builtins.str]:
        """
        Sets the 802.1Qbh VN-Tag profile identifier (profileid) for this portgroup; value is user-provided and should match the profile configured on the VN-Tagaware switch.

        See: <https://libvirt.org/formatdomain.html#direct-attachment-to-physical-interface>
        """
        return pulumi.get(self, "profile_id")


@pulumi.output_type
class NetworkVlan(dict):
    def __init__(__self__, *,
                 tags: Optional[Sequence['outputs.NetworkVlanTag']] = None,
                 trunk: Optional[_builtins.str] = None):
        """
        :param Sequence['NetworkVlanTagArgs'] tags: Defines one or more VLAN tag entries for this portgroup; each tag specifies a VLAN ID, and optionally native-mode behavior, applied to guest traffic.
               
               See: <https://libvirt.org/formatnetwork.html#setting-vlan-tag-on-supported-network-types-only>
        :param _builtins.str trunk: Controls whether this portgroups VLAN configuration operates in trunk mode, allowing multiple VLAN tags; value is a yes/no string flag, where "yes" enables trunk mode.
               
               See: <https://libvirt.org/formatnetwork.html#setting-vlan-tag-on-supported-network-types-only>
        """
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if trunk is not None:
            pulumi.set(__self__, "trunk", trunk)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.NetworkVlanTag']]:
        """
        Defines one or more VLAN tag entries for this portgroup; each tag specifies a VLAN ID, and optionally native-mode behavior, applied to guest traffic.

        See: <https://libvirt.org/formatnetwork.html#setting-vlan-tag-on-supported-network-types-only>
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def trunk(self) -> Optional[_builtins.str]:
        """
        Controls whether this portgroups VLAN configuration operates in trunk mode, allowing multiple VLAN tags; value is a yes/no string flag, where "yes" enables trunk mode.

        See: <https://libvirt.org/formatnetwork.html#setting-vlan-tag-on-supported-network-types-only>
        """
        return pulumi.get(self, "trunk")


@pulumi.output_type
class NetworkVlanTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nativeMode":
            suggest = "native_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkVlanTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkVlanTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkVlanTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[_builtins.float] = None,
                 native_mode: Optional[_builtins.str] = None):
        """
        :param _builtins.float id: Reports the VLAN ID associated with this tag; when managed by libvirt it is computed from the backing XML and corresponds to the 802.1Q VLAN identifier (14094).
               
               See: <https://libvirt.org/formatnetwork.html#setting-vlan-tag-on-supported-network-types-only>
        :param _builtins.str native_mode: Sets whether this VLAN tag is treated as native on the trunk for this portgroup; valid values are user-provided strings such as "tagged" or "untagged" as supported by libvirt/qemu.
               
               See: <https://libvirt.org/formatnetwork.html#setting-vlan-tag-on-supported-network-types-only>
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if native_mode is not None:
            pulumi.set(__self__, "native_mode", native_mode)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.float]:
        """
        Reports the VLAN ID associated with this tag; when managed by libvirt it is computed from the backing XML and corresponds to the 802.1Q VLAN identifier (14094).

        See: <https://libvirt.org/formatnetwork.html#setting-vlan-tag-on-supported-network-types-only>
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="nativeMode")
    def native_mode(self) -> Optional[_builtins.str]:
        """
        Sets whether this VLAN tag is treated as native on the trunk for this portgroup; valid values are user-provided strings such as "tagged" or "untagged" as supported by libvirt/qemu.

        See: <https://libvirt.org/formatnetwork.html#setting-vlan-tag-on-supported-network-types-only>
        """
        return pulumi.get(self, "native_mode")


@pulumi.output_type
class PoolFeatures(dict):
    def __init__(__self__, *,
                 cow: Optional['outputs.PoolFeaturesCow'] = None):
        """
        :param 'PoolFeaturesCowArgs' cow: Enables configuration of the copy-on-write (COW) feature for filesystems that support it in this storage pool.
        """
        if cow is not None:
            pulumi.set(__self__, "cow", cow)

    @_builtins.property
    @pulumi.getter
    def cow(self) -> Optional['outputs.PoolFeaturesCow']:
        """
        Enables configuration of the copy-on-write (COW) feature for filesystems that support it in this storage pool.
        """
        return pulumi.get(self, "cow")


@pulumi.output_type
class PoolFeaturesCow(dict):
    def __init__(__self__, *,
                 state: _builtins.str):
        """
        :param _builtins.str state: Sets whether filesystem-level copy-on-write is enabled for images in the pool; valid values are "on" or "off".
               
               See: <https://libvirt.org/formatstorage.html#features>
        """
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        Sets whether filesystem-level copy-on-write is enabled for images in the pool; valid values are "on" or "off".

        See: <https://libvirt.org/formatstorage.html#features>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class PoolRefresh(dict):
    def __init__(__self__, *,
                 volume: Optional['outputs.PoolRefreshVolume'] = None):
        """
        :param 'PoolRefreshVolumeArgs' volume: Configures per-volume refresh behavior for the pool, including how each volumes allocation is calculated.
        """
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional['outputs.PoolRefreshVolume']:
        """
        Configures per-volume refresh behavior for the pool, including how each volumes allocation is calculated.
        """
        return pulumi.get(self, "volume")


@pulumi.output_type
class PoolRefreshVolume(dict):
    def __init__(__self__, *,
                 allocation: _builtins.str):
        """
        :param _builtins.str allocation: Sets the method used to compute volume allocation during refresh; valid values are those supported by libvirt for the pool type (user-provided, e.g. "physical" vs "logical" where applicable).
               
               See: <https://libvirt.org/formatstorage.html#refresh-overrides>
        """
        pulumi.set(__self__, "allocation", allocation)

    @_builtins.property
    @pulumi.getter
    def allocation(self) -> _builtins.str:
        """
        Sets the method used to compute volume allocation during refresh; valid values are those supported by libvirt for the pool type (user-provided, e.g. "physical" vs "logical" where applicable).

        See: <https://libvirt.org/formatstorage.html#refresh-overrides>
        """
        return pulumi.get(self, "allocation")


@pulumi.output_type
class PoolSource(dict):
    def __init__(__self__, *,
                 adapter: Optional['outputs.PoolSourceAdapter'] = None,
                 auth: Optional['outputs.PoolSourceAuth'] = None,
                 devices: Optional[Sequence['outputs.PoolSourceDevice']] = None,
                 dir: Optional['outputs.PoolSourceDir'] = None,
                 format: Optional['outputs.PoolSourceFormat'] = None,
                 hosts: Optional[Sequence['outputs.PoolSourceHost']] = None,
                 initiator: Optional['outputs.PoolSourceInitiator'] = None,
                 name: Optional[_builtins.str] = None,
                 product: Optional['outputs.PoolSourceProduct'] = None,
                 protocol: Optional['outputs.PoolSourceProtocol'] = None,
                 vendor: Optional['outputs.PoolSourceVendor'] = None):
        """
        :param 'PoolSourceAdapterArgs' adapter: Configures an HBA/adapter description for pools that use host adapters (e.g., iSCSI or SCSI pools), including addressing and management attributes.
        :param 'PoolSourceAuthArgs' auth: Configures optional authentication for the pool source (e.g., user/secret for iSCSI, RBD, or other networked storage), with credentials defined according to the backend.
        :param Sequence['PoolSourceDeviceArgs'] devices: Configures a source block device used by the storage pool (for example, for disk, logical, iscsi, or scsi pools), including its path and optional partitioning/extents metadata.
               
               See: <https://libvirt.org/formatstorage.html#source-elements>
        :param 'PoolSourceDirArgs' dir: Configures a source directory used by the storage pool backend (for example, for dir, fs, netfs, or vstorage-style pools).
        :param 'PoolSourceFormatArgs' format: Declares the low-level format of the pool source, where supported (for example, the filesystem type or protocol-specific format).
        :param Sequence['PoolSourceHostArgs'] hosts: Configures a remote host used as the source of the storage pool, including hostname and optional port (for example, an NFS or iSCSI server).
               
               See: <https://libvirt.org/formatstorage.html#source-elements>
        :param 'PoolSourceInitiatorArgs' initiator: Configures iSCSI initiator information for the pool source, allowing the host to identify itself to an iSCSI target.
        :param _builtins.str name: Sets an optional human-readable name for the storage pool source, whose semantics depend on the specific pool type and are otherwise user-provided.
               
               See: <https://libvirt.org/formatstorage.html#source-elements>
        :param 'PoolSourceProductArgs' product: Enables specifying a product descriptor for the storage pool source, typically used together with vendor information for device-based pools.
        :param 'PoolSourceProtocolArgs' protocol: Enables defining a network storage protocol block for the pool source (for example, RBD, Gluster, or other supported protocols), with details provided by its child attributes.
        :param 'PoolSourceVendorArgs' vendor: Enables specifying a vendor descriptor for the storage pool source, typically paired with a product to identify the backing storage hardware.
        """
        if adapter is not None:
            pulumi.set(__self__, "adapter", adapter)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if devices is not None:
            pulumi.set(__self__, "devices", devices)
        if dir is not None:
            pulumi.set(__self__, "dir", dir)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if initiator is not None:
            pulumi.set(__self__, "initiator", initiator)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if product is not None:
            pulumi.set(__self__, "product", product)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if vendor is not None:
            pulumi.set(__self__, "vendor", vendor)

    @_builtins.property
    @pulumi.getter
    def adapter(self) -> Optional['outputs.PoolSourceAdapter']:
        """
        Configures an HBA/adapter description for pools that use host adapters (e.g., iSCSI or SCSI pools), including addressing and management attributes.
        """
        return pulumi.get(self, "adapter")

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional['outputs.PoolSourceAuth']:
        """
        Configures optional authentication for the pool source (e.g., user/secret for iSCSI, RBD, or other networked storage), with credentials defined according to the backend.
        """
        return pulumi.get(self, "auth")

    @_builtins.property
    @pulumi.getter
    def devices(self) -> Optional[Sequence['outputs.PoolSourceDevice']]:
        """
        Configures a source block device used by the storage pool (for example, for disk, logical, iscsi, or scsi pools), including its path and optional partitioning/extents metadata.

        See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        return pulumi.get(self, "devices")

    @_builtins.property
    @pulumi.getter
    def dir(self) -> Optional['outputs.PoolSourceDir']:
        """
        Configures a source directory used by the storage pool backend (for example, for dir, fs, netfs, or vstorage-style pools).
        """
        return pulumi.get(self, "dir")

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional['outputs.PoolSourceFormat']:
        """
        Declares the low-level format of the pool source, where supported (for example, the filesystem type or protocol-specific format).
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence['outputs.PoolSourceHost']]:
        """
        Configures a remote host used as the source of the storage pool, including hostname and optional port (for example, an NFS or iSCSI server).

        See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter
    def initiator(self) -> Optional['outputs.PoolSourceInitiator']:
        """
        Configures iSCSI initiator information for the pool source, allowing the host to identify itself to an iSCSI target.
        """
        return pulumi.get(self, "initiator")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets an optional human-readable name for the storage pool source, whose semantics depend on the specific pool type and are otherwise user-provided.

        See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def product(self) -> Optional['outputs.PoolSourceProduct']:
        """
        Enables specifying a product descriptor for the storage pool source, typically used together with vendor information for device-based pools.
        """
        return pulumi.get(self, "product")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional['outputs.PoolSourceProtocol']:
        """
        Enables defining a network storage protocol block for the pool source (for example, RBD, Gluster, or other supported protocols), with details provided by its child attributes.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def vendor(self) -> Optional['outputs.PoolSourceVendor']:
        """
        Enables specifying a vendor descriptor for the storage pool source, typically paired with a product to identify the backing storage hardware.
        """
        return pulumi.get(self, "vendor")


@pulumi.output_type
class PoolSourceAdapter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parentAddr":
            suggest = "parent_addr"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PoolSourceAdapter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PoolSourceAdapter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PoolSourceAdapter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 managed: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 parent: Optional[_builtins.str] = None,
                 parent_addr: Optional['outputs.PoolSourceAdapterParentAddr'] = None,
                 type: Optional[_builtins.str] = None,
                 wwnn: Optional[_builtins.str] = None,
                 wwpn: Optional[_builtins.str] = None):
        """
        :param _builtins.bool managed: Controls whether libvirt manages the adapters login/session; accepts "yes" or "no" and is interpreted as a boolean.
               
               See: <https://libvirt.org/formatstorage.html#source-elements>
        :param _builtins.str name: Sets the adapter name for the pool source, typically the host HBA or interface identifier (user-provided string, such as "host0").
               
               See: <https://libvirt.org/formatstorage.html#source-elements>
        :param _builtins.str parent: Sets an optional parent adapter identifier if the specified adapter is a child of another adapter (user-provided string).
               
               See: <https://libvirt.org/formatstorage.html#source-elements>
        :param 'PoolSourceAdapterParentAddrArgs' parent_addr: Configures the PCI-style address and unique ID of the parent adapter for the storage pool source.
        :param _builtins.str type: Sets the adapter type for the pool source (e.g., HBA type); value is user-provided and must be supported by the chosen pool backend.
               
               See: <https://libvirt.org/formatstorage.html#source-elements>
        :param _builtins.str wwnn: Sets the World Wide Node Name (WWNN) for a Fibre Channel adapter; value is a user-provided FC WWN string (e.g., "5005076802401234").
               
               See: <https://libvirt.org/formatstorage.html#source-elements>
        :param _builtins.str wwpn: Sets the World Wide Port Name (WWPN) for a Fibre Channel adapter; value is a user-provided FC WWN string (e.g., "5005076802456789").
               
               See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        if managed is not None:
            pulumi.set(__self__, "managed", managed)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parent is not None:
            pulumi.set(__self__, "parent", parent)
        if parent_addr is not None:
            pulumi.set(__self__, "parent_addr", parent_addr)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if wwnn is not None:
            pulumi.set(__self__, "wwnn", wwnn)
        if wwpn is not None:
            pulumi.set(__self__, "wwpn", wwpn)

    @_builtins.property
    @pulumi.getter
    def managed(self) -> Optional[_builtins.bool]:
        """
        Controls whether libvirt manages the adapters login/session; accepts "yes" or "no" and is interpreted as a boolean.

        See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        return pulumi.get(self, "managed")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the adapter name for the pool source, typically the host HBA or interface identifier (user-provided string, such as "host0").

        See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def parent(self) -> Optional[_builtins.str]:
        """
        Sets an optional parent adapter identifier if the specified adapter is a child of another adapter (user-provided string).

        See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        return pulumi.get(self, "parent")

    @_builtins.property
    @pulumi.getter(name="parentAddr")
    def parent_addr(self) -> Optional['outputs.PoolSourceAdapterParentAddr']:
        """
        Configures the PCI-style address and unique ID of the parent adapter for the storage pool source.
        """
        return pulumi.get(self, "parent_addr")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Sets the adapter type for the pool source (e.g., HBA type); value is user-provided and must be supported by the chosen pool backend.

        See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def wwnn(self) -> Optional[_builtins.str]:
        """
        Sets the World Wide Node Name (WWNN) for a Fibre Channel adapter; value is a user-provided FC WWN string (e.g., "5005076802401234").

        See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        return pulumi.get(self, "wwnn")

    @_builtins.property
    @pulumi.getter
    def wwpn(self) -> Optional[_builtins.str]:
        """
        Sets the World Wide Port Name (WWPN) for a Fibre Channel adapter; value is a user-provided FC WWN string (e.g., "5005076802456789").

        See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        return pulumi.get(self, "wwpn")


@pulumi.output_type
class PoolSourceAdapterParentAddr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "uniqueId":
            suggest = "unique_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PoolSourceAdapterParentAddr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PoolSourceAdapterParentAddr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PoolSourceAdapterParentAddr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 unique_id: _builtins.float,
                 address: Optional['outputs.PoolSourceAdapterParentAddrAddress'] = None):
        """
        :param _builtins.float unique_id: Sets the required unique identifier for the parent adapter address, used by libvirt to distinguish this adapter instance (user-provided string).
               
               See: <https://libvirt.org/formatstorage.html#source-elements>
        :param 'PoolSourceAdapterParentAddrAddressArgs' address: Provides the structured PCI address of the parent adapter (domain, bus, slot, function).
        """
        pulumi.set(__self__, "unique_id", unique_id)
        if address is not None:
            pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter(name="uniqueId")
    def unique_id(self) -> _builtins.float:
        """
        Sets the required unique identifier for the parent adapter address, used by libvirt to distinguish this adapter instance (user-provided string).

        See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        return pulumi.get(self, "unique_id")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional['outputs.PoolSourceAdapterParentAddrAddress']:
        """
        Provides the structured PCI address of the parent adapter (domain, bus, slot, function).
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class PoolSourceAdapterParentAddrAddress(dict):
    def __init__(__self__, *,
                 bus: Optional[_builtins.float] = None,
                 domain: Optional[_builtins.float] = None,
                 function: Optional[_builtins.float] = None,
                 slot: Optional[_builtins.float] = None):
        """
        :param _builtins.float bus: Sets the PCI bus number of the parent adapter; value is user-provided, typically in decimal (e.g., "0", "3").
               
               See: <https://libvirt.org/formatstorage.html#source-elements>
        :param _builtins.float domain: Sets the PCI domain number of the parent adapter; value is user-provided, typically "0" on most systems.
               
               See: <https://libvirt.org/formatstorage.html#source-elements>
        :param _builtins.float function: Sets the PCI function number of the parent adapter; value is user-provided, typically 07 (e.g., "0").
               
               See: <https://libvirt.org/formatstorage.html#source-elements>
        :param _builtins.float slot: Sets the PCI slot number of the parent adapter; value is user-provided, typically in decimal (e.g., "0", "1", "10").
               
               See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        if bus is not None:
            pulumi.set(__self__, "bus", bus)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if function is not None:
            pulumi.set(__self__, "function", function)
        if slot is not None:
            pulumi.set(__self__, "slot", slot)

    @_builtins.property
    @pulumi.getter
    def bus(self) -> Optional[_builtins.float]:
        """
        Sets the PCI bus number of the parent adapter; value is user-provided, typically in decimal (e.g., "0", "3").

        See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        return pulumi.get(self, "bus")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[_builtins.float]:
        """
        Sets the PCI domain number of the parent adapter; value is user-provided, typically "0" on most systems.

        See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter
    def function(self) -> Optional[_builtins.float]:
        """
        Sets the PCI function number of the parent adapter; value is user-provided, typically 07 (e.g., "0").

        See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        return pulumi.get(self, "function")

    @_builtins.property
    @pulumi.getter
    def slot(self) -> Optional[_builtins.float]:
        """
        Sets the PCI slot number of the parent adapter; value is user-provided, typically in decimal (e.g., "0", "1", "10").

        See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        return pulumi.get(self, "slot")


@pulumi.output_type
class PoolSourceAuth(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 username: _builtins.str,
                 secret: Optional['outputs.PoolSourceAuthSecret'] = None):
        """
        :param _builtins.str type: Sets the authentication type used by the pool source, for example "ceph" for RBD pools or other backend-specific values; the value is user-provided but must match what the storage backend expects.
               
               See: <https://libvirt.org/formatstorage.html#source-elements>
        :param _builtins.str username: Sets the username or client identifier used when authenticating to the storage backend (for example, a Ceph client name like "client.admin" or an iSCSI user).
               
               See: <https://libvirt.org/formatstorage.html#source-elements>
        :param 'PoolSourceAuthSecretArgs' secret: Configures the libvirt secret used for authenticating access to the storage pool source (for example, an RBD or iSCSI password); either a secret UUID or a usage name must be provided via child attributes.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "username", username)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets the authentication type used by the pool source, for example "ceph" for RBD pools or other backend-specific values; the value is user-provided but must match what the storage backend expects.

        See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Sets the username or client identifier used when authenticating to the storage backend (for example, a Ceph client name like "client.admin" or an iSCSI user).

        See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.PoolSourceAuthSecret']:
        """
        Configures the libvirt secret used for authenticating access to the storage pool source (for example, an RBD or iSCSI password); either a secret UUID or a usage name must be provided via child attributes.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class PoolSourceAuthSecret(dict):
    def __init__(__self__, *,
                 usage: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str usage: Sets the application-specific usage name of the secret to use for pool authentication, as defined in the corresponding libvirt secret object (user-provided string such as "ceph-secret").
               
               See: <https://libvirt.org/formatstorage.html#source-elements>
        :param _builtins.str uuid: Exposes the UUID of the libvirt secret used for pool authentication; this is computed from the referenced secret and must be a valid libvirt UUID string when set.
               
               See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        if usage is not None:
            pulumi.set(__self__, "usage", usage)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def usage(self) -> Optional[_builtins.str]:
        """
        Sets the application-specific usage name of the secret to use for pool authentication, as defined in the corresponding libvirt secret object (user-provided string such as "ceph-secret").

        See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        return pulumi.get(self, "usage")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        Exposes the UUID of the libvirt secret used for pool authentication; this is computed from the referenced secret and must be a valid libvirt UUID string when set.

        See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class PoolSourceDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freeExtents":
            suggest = "free_extents"
        elif key == "partSeparator":
            suggest = "part_separator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PoolSourceDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PoolSourceDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PoolSourceDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 free_extents: Optional[Sequence['outputs.PoolSourceDeviceFreeExtent']] = None,
                 part_separator: Optional[_builtins.str] = None):
        """
        :param _builtins.str path: Sets the absolute path of the source block device used by the pool, such as "/dev/sdb" or "/dev/mapper/mpath0".
               
               See: <https://libvirt.org/formatstorage.html#source-elements>
        :param Sequence['PoolSourceDeviceFreeExtentArgs'] free_extents: Describes one or more free extents on the source device that are available for allocation by the pool, each defined by a start and end offset.
               
               See: <https://libvirt.org/formatstorage.html#device-extents>
        :param _builtins.str part_separator: Sets the character used to separate the base device name from partition numbers (for example, "p" for devices like "/dev/nvme0n1p1"); the value is user-provided and backend-specific.
               
               See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        pulumi.set(__self__, "path", path)
        if free_extents is not None:
            pulumi.set(__self__, "free_extents", free_extents)
        if part_separator is not None:
            pulumi.set(__self__, "part_separator", part_separator)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the absolute path of the source block device used by the pool, such as "/dev/sdb" or "/dev/mapper/mpath0".

        See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="freeExtents")
    def free_extents(self) -> Optional[Sequence['outputs.PoolSourceDeviceFreeExtent']]:
        """
        Describes one or more free extents on the source device that are available for allocation by the pool, each defined by a start and end offset.

        See: <https://libvirt.org/formatstorage.html#device-extents>
        """
        return pulumi.get(self, "free_extents")

    @_builtins.property
    @pulumi.getter(name="partSeparator")
    def part_separator(self) -> Optional[_builtins.str]:
        """
        Sets the character used to separate the base device name from partition numbers (for example, "p" for devices like "/dev/nvme0n1p1"); the value is user-provided and backend-specific.

        See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        return pulumi.get(self, "part_separator")


@pulumi.output_type
class PoolSourceDeviceFreeExtent(dict):
    def __init__(__self__, *,
                 end: _builtins.float,
                 start: _builtins.float):
        """
        :param _builtins.float end: Sets the end offset of a free extent on the device, expressed in bytes as an integer greater than the start offset.
               
               See: <https://libvirt.org/formatstorage.html#device-extents>
        :param _builtins.float start: Sets the start offset of a free extent on the device, expressed in bytes as a non-negative integer.
               
               See: <https://libvirt.org/formatstorage.html#device-extents>
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> _builtins.float:
        """
        Sets the end offset of a free extent on the device, expressed in bytes as an integer greater than the start offset.

        See: <https://libvirt.org/formatstorage.html#device-extents>
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter
    def start(self) -> _builtins.float:
        """
        Sets the start offset of a free extent on the device, expressed in bytes as a non-negative integer.

        See: <https://libvirt.org/formatstorage.html#device-extents>
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class PoolSourceDir(dict):
    def __init__(__self__, *,
                 path: _builtins.str):
        """
        :param _builtins.str path: Sets the absolute path to the source directory for the pool, such as "/var/lib/libvirt/images" or a mounted filesystem root.
               
               See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the absolute path to the source directory for the pool, such as "/var/lib/libvirt/images" or a mounted filesystem root.

        See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class PoolSourceFormat(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: Sets the source format type string, such as "ext4", "xfs", "nfs", or other backend-specific formats; the value is user-provided but must be valid for the chosen pool type.
               
               See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets the source format type string, such as "ext4", "xfs", "nfs", or other backend-specific formats; the value is user-provided but must be valid for the chosen pool type.

        See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class PoolSourceHost(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 port: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Sets the hostname or IP address of the remote storage server, such as "storage.example.com" or "192.0.2.10".
               
               See: <https://libvirt.org/formatstorage.html#source-elements>
        :param _builtins.str port: Optionally sets the TCP port used to connect to the remote storage server; if omitted, the backends default port is used.
               
               See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the hostname or IP address of the remote storage server, such as "storage.example.com" or "192.0.2.10".

        See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        """
        Optionally sets the TCP port used to connect to the remote storage server; if omitted, the backends default port is used.

        See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class PoolSourceInitiator(dict):
    def __init__(__self__, *,
                 iqn: Optional['outputs.PoolSourceInitiatorIqn'] = None):
        """
        :param 'PoolSourceInitiatorIqnArgs' iqn: Sets the iSCSI Qualified Name (IQN) of the initiator, such as "iqn.1993-08.org.debian:01:123456789"; the value must be a valid IQN string.
        """
        if iqn is not None:
            pulumi.set(__self__, "iqn", iqn)

    @_builtins.property
    @pulumi.getter
    def iqn(self) -> Optional['outputs.PoolSourceInitiatorIqn']:
        """
        Sets the iSCSI Qualified Name (IQN) of the initiator, such as "iqn.1993-08.org.debian:01:123456789"; the value must be a valid IQN string.
        """
        return pulumi.get(self, "iqn")


@pulumi.output_type
class PoolSourceInitiatorIqn(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Sets the iSCSI initiator IQN name used by the storage pool when authenticating to an iSCSI target; the value is user-provided and should be a valid IQN string (for example, "iqn.1994-05.com.redhat:client1").
               
               See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Sets the iSCSI initiator IQN name used by the storage pool when authenticating to an iSCSI target; the value is user-provided and should be a valid IQN string (for example, "iqn.1994-05.com.redhat:client1").

        See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PoolSourceProduct(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the required product name string for the storage pool source (for example, a storage array or disk product identifier); the value is user-provided.
               
               See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the required product name string for the storage pool source (for example, a storage array or disk product identifier); the value is user-provided.

        See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PoolSourceProtocol(dict):
    def __init__(__self__, *,
                 version: _builtins.str):
        """
        :param _builtins.str version: Sets the required protocol version string used by the storage pool source (for example, an RBD or protocol-specific version); the value is user-provided.
               
               See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Sets the required protocol version string used by the storage pool source (for example, an RBD or protocol-specific version); the value is user-provided.

        See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class PoolSourceVendor(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Sets the required vendor name string for the storage pool source (for example, "Red Hat" or a storage vendor identifier); the value is user-provided.
               
               See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the required vendor name string for the storage pool source (for example, "Red Hat" or a storage vendor identifier); the value is user-provided.

        See: <https://libvirt.org/formatstorage.html#source-elements>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PoolTarget(dict):
    def __init__(__self__, *,
                 encryption: Optional['outputs.PoolTargetEncryption'] = None,
                 path: Optional[_builtins.str] = None,
                 permissions: Optional['outputs.PoolTargetPermissions'] = None,
                 timestamps: Optional['outputs.PoolTargetTimestamps'] = None):
        """
        :param 'PoolTargetEncryptionArgs' encryption: Enables and configures encryption for the volumes data, defining the cipher parameters for an encrypted image.
        :param _builtins.str path: Sets the host path where the pool target is mapped, such as a directory for a dir/fs/netfs pool or a block device for a disk/logical pool (for example, "/var/lib/libvirt/images" or "/dev/sdb").
               
               See: <https://libvirt.org/formatstorage.html#storage-pool-target-elements>
        :param 'PoolTargetPermissionsArgs' permissions: Sets ownership and permission metadata applied to the pool target path, controlling which user/group and mode bits are used on the backing directory or device.
        :param 'PoolTargetTimestampsArgs' timestamps: Sets explicit access, change, and modification timestamps on the pool target path when supported by the backend.
        """
        if encryption is not None:
            pulumi.set(__self__, "encryption", encryption)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if timestamps is not None:
            pulumi.set(__self__, "timestamps", timestamps)

    @_builtins.property
    @pulumi.getter
    def encryption(self) -> Optional['outputs.PoolTargetEncryption']:
        """
        Enables and configures encryption for the volumes data, defining the cipher parameters for an encrypted image.
        """
        return pulumi.get(self, "encryption")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Sets the host path where the pool target is mapped, such as a directory for a dir/fs/netfs pool or a block device for a disk/logical pool (for example, "/var/lib/libvirt/images" or "/dev/sdb").

        See: <https://libvirt.org/formatstorage.html#storage-pool-target-elements>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Optional['outputs.PoolTargetPermissions']:
        """
        Sets ownership and permission metadata applied to the pool target path, controlling which user/group and mode bits are used on the backing directory or device.
        """
        return pulumi.get(self, "permissions")

    @_builtins.property
    @pulumi.getter
    def timestamps(self) -> Optional['outputs.PoolTargetTimestamps']:
        """
        Sets explicit access, change, and modification timestamps on the pool target path when supported by the backend.
        """
        return pulumi.get(self, "timestamps")


@pulumi.output_type
class PoolTargetEncryption(dict):
    def __init__(__self__, *,
                 format: _builtins.str,
                 cipher: Optional['outputs.PoolTargetEncryptionCipher'] = None,
                 ivgen: Optional['outputs.PoolTargetEncryptionIvgen'] = None,
                 secret: Optional['outputs.PoolTargetEncryptionSecret'] = None):
        """
        :param _builtins.str format: Sets the encryption format used for the volume; for LUKS volumes this is typically set to "luks".
               
               See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        :param 'PoolTargetEncryptionCipherArgs' cipher: Defines the encryption cipher parameters used for the volume, such as algorithm name, mode, and hash.
        :param 'PoolTargetEncryptionIvgenArgs' ivgen: Configures the initialization vector (IV) generation method for the encrypted volume; when present, both name and hash must be specified.
        :param 'PoolTargetEncryptionSecretArgs' secret: Configures the libvirt secret used to supply the encryption key material for the volume.
        """
        pulumi.set(__self__, "format", format)
        if cipher is not None:
            pulumi.set(__self__, "cipher", cipher)
        if ivgen is not None:
            pulumi.set(__self__, "ivgen", ivgen)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def format(self) -> _builtins.str:
        """
        Sets the encryption format used for the volume; for LUKS volumes this is typically set to "luks".

        See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter
    def cipher(self) -> Optional['outputs.PoolTargetEncryptionCipher']:
        """
        Defines the encryption cipher parameters used for the volume, such as algorithm name, mode, and hash.
        """
        return pulumi.get(self, "cipher")

    @_builtins.property
    @pulumi.getter
    def ivgen(self) -> Optional['outputs.PoolTargetEncryptionIvgen']:
        """
        Configures the initialization vector (IV) generation method for the encrypted volume; when present, both name and hash must be specified.
        """
        return pulumi.get(self, "ivgen")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.PoolTargetEncryptionSecret']:
        """
        Configures the libvirt secret used to supply the encryption key material for the volume.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class PoolTargetEncryptionCipher(dict):
    def __init__(__self__, *,
                 hash: _builtins.str,
                 mode: _builtins.str,
                 name: _builtins.str,
                 size: _builtins.float):
        """
        :param _builtins.str hash: Sets the hash algorithm used with the encryption cipher (for example `sha256`), with the exact value being user-provided but expected to be supported by the chosen encryption format.
               
               See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        :param _builtins.str mode: Sets the cipher mode of operation (for example `cbc` or `xts`), with the value user-provided and constrained by the encryption backends supported modes.
               
               See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        :param _builtins.str name: Sets the base cipher algorithm name (for example `aes`), with the value user-provided and expected to be a valid algorithm for the images encryption format.
               
               See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        :param _builtins.float size: Sets the cipher key size in bits for the encrypted storage volume (user-provided integer such as 128, 256, etc.).
               
               See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        pulumi.set(__self__, "hash", hash)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def hash(self) -> _builtins.str:
        """
        Sets the hash algorithm used with the encryption cipher (for example `sha256`), with the exact value being user-provided but expected to be supported by the chosen encryption format.

        See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        return pulumi.get(self, "hash")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets the cipher mode of operation (for example `cbc` or `xts`), with the value user-provided and constrained by the encryption backends supported modes.

        See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the base cipher algorithm name (for example `aes`), with the value user-provided and expected to be a valid algorithm for the images encryption format.

        See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.float:
        """
        Sets the cipher key size in bits for the encrypted storage volume (user-provided integer such as 128, 256, etc.).

        See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class PoolTargetEncryptionIvgen(dict):
    def __init__(__self__, *,
                 hash: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str hash: Sets the hash algorithm used by the IV generator (for example "sha1" or "sha256"); value is user-provided.
               
               See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        :param _builtins.str name: Sets the IV generation scheme name used by the encryption layer (for example "plain", "essiv", etc.); value is user-provided.
               
               See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        pulumi.set(__self__, "hash", hash)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def hash(self) -> _builtins.str:
        """
        Sets the hash algorithm used by the IV generator (for example "sha1" or "sha256"); value is user-provided.

        See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        return pulumi.get(self, "hash")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the IV generation scheme name used by the encryption layer (for example "plain", "essiv", etc.); value is user-provided.

        See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PoolTargetEncryptionSecret(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Sets how the secret is referenced, typically "uuid" to reference a libvirt secret by its UUID.
               
               See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        :param _builtins.str uuid: Exposes the UUID of the libvirt secret object providing the encryption key; this is filled from the referenced secret and is read-only.
               
               See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        pulumi.set(__self__, "type", type)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets how the secret is referenced, typically "uuid" to reference a libvirt secret by its UUID.

        See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        Exposes the UUID of the libvirt secret object providing the encryption key; this is filled from the referenced secret and is read-only.

        See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class PoolTargetPermissions(dict):
    def __init__(__self__, *,
                 group: Optional[_builtins.str] = None,
                 label: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 owner: Optional[_builtins.str] = None):
        """
        :param _builtins.str group: Sets the numeric group ID or group name that owns the pool target path (for example, "107" or "libvirt-qemu").
               
               See: <https://libvirt.org/formatstorage.html#storage-pool-target-elements>
        :param _builtins.str label: Sets an optional security label (such as an SELinux context) to apply to the pool target path; the value is user-provided and backend-specific.
               
               See: <https://libvirt.org/formatstorage.html#storage-pool-target-elements>
        :param _builtins.str mode: Sets the Unix permission bits for the pool target path, as an octal string such as "0755" or "0700".
               
               See: <https://libvirt.org/formatstorage.html#storage-pool-target-elements>
        :param _builtins.str owner: Sets the numeric user ID or username that owns the pool target path (for example, "107" or "qemu").
               
               See: <https://libvirt.org/formatstorage.html#storage-pool-target-elements>
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[_builtins.str]:
        """
        Sets the numeric group ID or group name that owns the pool target path (for example, "107" or "libvirt-qemu").

        See: <https://libvirt.org/formatstorage.html#storage-pool-target-elements>
        """
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets an optional security label (such as an SELinux context) to apply to the pool target path; the value is user-provided and backend-specific.

        See: <https://libvirt.org/formatstorage.html#storage-pool-target-elements>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the Unix permission bits for the pool target path, as an octal string such as "0755" or "0700".

        See: <https://libvirt.org/formatstorage.html#storage-pool-target-elements>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> Optional[_builtins.str]:
        """
        Sets the numeric user ID or username that owns the pool target path (for example, "107" or "qemu").

        See: <https://libvirt.org/formatstorage.html#storage-pool-target-elements>
        """
        return pulumi.get(self, "owner")


@pulumi.output_type
class PoolTargetTimestamps(dict):
    def __init__(__self__, *,
                 atime: _builtins.str,
                 ctime: _builtins.str,
                 mtime: _builtins.str):
        """
        :param _builtins.str atime: Sets the last access time for the pool target path; the value is user-provided (for example, a seconds or seconds.nanoseconds timestamp as supported by libvirt).
        :param _builtins.str ctime: Sets the last metadata change time for the pool target path; the value is user-provided in the timestamp format expected by libvirt.
        :param _builtins.str mtime: Sets the last data modification time for the pool target path; the value is user-provided in the timestamp format expected by libvirt.
        """
        pulumi.set(__self__, "atime", atime)
        pulumi.set(__self__, "ctime", ctime)
        pulumi.set(__self__, "mtime", mtime)

    @_builtins.property
    @pulumi.getter
    def atime(self) -> _builtins.str:
        """
        Sets the last access time for the pool target path; the value is user-provided (for example, a seconds or seconds.nanoseconds timestamp as supported by libvirt).
        """
        return pulumi.get(self, "atime")

    @_builtins.property
    @pulumi.getter
    def ctime(self) -> _builtins.str:
        """
        Sets the last metadata change time for the pool target path; the value is user-provided in the timestamp format expected by libvirt.
        """
        return pulumi.get(self, "ctime")

    @_builtins.property
    @pulumi.getter
    def mtime(self) -> _builtins.str:
        """
        Sets the last data modification time for the pool target path; the value is user-provided in the timestamp format expected by libvirt.
        """
        return pulumi.get(self, "mtime")


@pulumi.output_type
class VolumeBackingStore(dict):
    def __init__(__self__, *,
                 path: _builtins.str,
                 format: Optional['outputs.VolumeBackingStoreFormat'] = None,
                 permissions: Optional['outputs.VolumeBackingStorePermissions'] = None):
        """
        :param _builtins.str path: Sets the path to the backing image used by this volume, either as an absolute host path or a pool-relative path (for example, "/var/lib/libvirt/images/base.qcow2").
               
               See: <https://libvirt.org/formatstorage.html#backing-store-elements>
        :param 'VolumeBackingStoreFormatArgs' format: Sets the on-disk format metadata for the backing store volume; this must match the actual format of the backing image.
        :param 'VolumeBackingStorePermissionsArgs' permissions: Configures POSIX ownership and SELinux label metadata for the backing store volume, controlling how the backing file is labeled and accessed on the host.
        """
        pulumi.set(__self__, "path", path)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Sets the path to the backing image used by this volume, either as an absolute host path or a pool-relative path (for example, "/var/lib/libvirt/images/base.qcow2").

        See: <https://libvirt.org/formatstorage.html#backing-store-elements>
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional['outputs.VolumeBackingStoreFormat']:
        """
        Sets the on-disk format metadata for the backing store volume; this must match the actual format of the backing image.
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Optional['outputs.VolumeBackingStorePermissions']:
        """
        Configures POSIX ownership and SELinux label metadata for the backing store volume, controlling how the backing file is labeled and accessed on the host.
        """
        return pulumi.get(self, "permissions")


@pulumi.output_type
class VolumeBackingStoreFormat(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: Specifies the backing store format type string (for example, "raw" or "qcow2"), which must be a format supported by the hypervisor.
               
               See: <https://libvirt.org/formatstorage.html#backing-store-elements>
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the backing store format type string (for example, "raw" or "qcow2"), which must be a format supported by the hypervisor.

        See: <https://libvirt.org/formatstorage.html#backing-store-elements>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class VolumeBackingStorePermissions(dict):
    def __init__(__self__, *,
                 group: Optional[_builtins.str] = None,
                 label: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 owner: Optional[_builtins.str] = None):
        """
        :param _builtins.str group: Sets the numeric group ID (gid) that owns the backing store file or device; the value is user-provided, for example `107`.
               
               See: <https://libvirt.org/formatstorage.html#backing-store-elements>
        :param _builtins.str label: Sets an SELinux security label for the backing store, when SELinux labeling is in use; the value is user-provided.
               
               See: <https://libvirt.org/formatstorage.html#backing-store-elements>
        :param _builtins.str mode: Sets the numeric file mode (permission bits) for the backing store, typically as an octal value such as `0640`.
               
               See: <https://libvirt.org/formatstorage.html#backing-store-elements>
        :param _builtins.str owner: Sets the numeric user ID (uid) that owns the backing store file or device; the value is user-provided, for example `107`.
               
               See: <https://libvirt.org/formatstorage.html#backing-store-elements>
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[_builtins.str]:
        """
        Sets the numeric group ID (gid) that owns the backing store file or device; the value is user-provided, for example `107`.

        See: <https://libvirt.org/formatstorage.html#backing-store-elements>
        """
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets an SELinux security label for the backing store, when SELinux labeling is in use; the value is user-provided.

        See: <https://libvirt.org/formatstorage.html#backing-store-elements>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the numeric file mode (permission bits) for the backing store, typically as an octal value such as `0640`.

        See: <https://libvirt.org/formatstorage.html#backing-store-elements>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> Optional[_builtins.str]:
        """
        Sets the numeric user ID (uid) that owns the backing store file or device; the value is user-provided, for example `107`.

        See: <https://libvirt.org/formatstorage.html#backing-store-elements>
        """
        return pulumi.get(self, "owner")


@pulumi.output_type
class VolumeCreate(dict):
    def __init__(__self__, *,
                 content: 'outputs.VolumeCreateContent'):
        """
        :param 'VolumeCreateContentArgs' content: Upload content from a URL or local file
        """
        pulumi.set(__self__, "content", content)

    @_builtins.property
    @pulumi.getter
    def content(self) -> 'outputs.VolumeCreateContent':
        """
        Upload content from a URL or local file
        """
        return pulumi.get(self, "content")


@pulumi.output_type
class VolumeCreateContent(dict):
    def __init__(__self__, *,
                 url: _builtins.str):
        """
        :param _builtins.str url: URL to download content from
        """
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        URL to download content from
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class VolumeTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterSize":
            suggest = "cluster_size"
        elif key == "clusterSizeUnit":
            suggest = "cluster_size_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_size: Optional[_builtins.float] = None,
                 cluster_size_unit: Optional[_builtins.str] = None,
                 compat: Optional[_builtins.str] = None,
                 encryption: Optional['outputs.VolumeTargetEncryption'] = None,
                 features: Optional[Sequence['outputs.VolumeTargetFeature']] = None,
                 format: Optional['outputs.VolumeTargetFormat'] = None,
                 path: Optional[_builtins.str] = None,
                 permissions: Optional['outputs.VolumeTargetPermissions'] = None,
                 timestamps: Optional['outputs.VolumeTargetTimestamps'] = None):
        """
        :param _builtins.float cluster_size: Sets the cluster size for qcow2 volumes, controlling the allocation granularity on disk; value is a size with the unit given by `cluster_size_unit`.
               
               See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        :param _builtins.str cluster_size_unit: Sets the unit for `cluster_size` (for example `bytes`, `KiB`, `MiB`), matching libvirts clusterSize `unit` attribute semantics.
               
               See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        :param _builtins.str compat: Sets the qcow2 compatibility level for the volume (for example `0.10` or `1.1`), controlling which qemu feature set the image uses.
               
               See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        :param 'VolumeTargetEncryptionArgs' encryption: Enables and configures encryption for the volumes data, defining the cipher parameters for an encrypted image.
        :param Sequence['VolumeTargetFeatureArgs'] features: Configures per-volume feature flags for the target format (such as qcow2 features); contents are user-provided according to the image format.
               
               See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        :param 'VolumeTargetFormatArgs' format: Sets the on-disk format metadata for the backing store volume; this must match the actual format of the backing image.
        :param _builtins.str path: Volume path on the host filesystem
        :param 'VolumeTargetPermissionsArgs' permissions: Configures POSIX ownership and SELinux label metadata for the backing store volume, controlling how the backing file is labeled and accessed on the host.
        :param 'VolumeTargetTimestampsArgs' timestamps: Configures stored timestamps for the volume target, such as access and change times.
        """
        if cluster_size is not None:
            pulumi.set(__self__, "cluster_size", cluster_size)
        if cluster_size_unit is not None:
            pulumi.set(__self__, "cluster_size_unit", cluster_size_unit)
        if compat is not None:
            pulumi.set(__self__, "compat", compat)
        if encryption is not None:
            pulumi.set(__self__, "encryption", encryption)
        if features is not None:
            pulumi.set(__self__, "features", features)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if timestamps is not None:
            pulumi.set(__self__, "timestamps", timestamps)

    @_builtins.property
    @pulumi.getter(name="clusterSize")
    def cluster_size(self) -> Optional[_builtins.float]:
        """
        Sets the cluster size for qcow2 volumes, controlling the allocation granularity on disk; value is a size with the unit given by `cluster_size_unit`.

        See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        return pulumi.get(self, "cluster_size")

    @_builtins.property
    @pulumi.getter(name="clusterSizeUnit")
    def cluster_size_unit(self) -> Optional[_builtins.str]:
        """
        Sets the unit for `cluster_size` (for example `bytes`, `KiB`, `MiB`), matching libvirts clusterSize `unit` attribute semantics.

        See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        return pulumi.get(self, "cluster_size_unit")

    @_builtins.property
    @pulumi.getter
    def compat(self) -> Optional[_builtins.str]:
        """
        Sets the qcow2 compatibility level for the volume (for example `0.10` or `1.1`), controlling which qemu feature set the image uses.

        See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        return pulumi.get(self, "compat")

    @_builtins.property
    @pulumi.getter
    def encryption(self) -> Optional['outputs.VolumeTargetEncryption']:
        """
        Enables and configures encryption for the volumes data, defining the cipher parameters for an encrypted image.
        """
        return pulumi.get(self, "encryption")

    @_builtins.property
    @pulumi.getter
    def features(self) -> Optional[Sequence['outputs.VolumeTargetFeature']]:
        """
        Configures per-volume feature flags for the target format (such as qcow2 features); contents are user-provided according to the image format.

        See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        return pulumi.get(self, "features")

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional['outputs.VolumeTargetFormat']:
        """
        Sets the on-disk format metadata for the backing store volume; this must match the actual format of the backing image.
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Volume path on the host filesystem
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Optional['outputs.VolumeTargetPermissions']:
        """
        Configures POSIX ownership and SELinux label metadata for the backing store volume, controlling how the backing file is labeled and accessed on the host.
        """
        return pulumi.get(self, "permissions")

    @_builtins.property
    @pulumi.getter
    def timestamps(self) -> Optional['outputs.VolumeTargetTimestamps']:
        """
        Configures stored timestamps for the volume target, such as access and change times.
        """
        return pulumi.get(self, "timestamps")


@pulumi.output_type
class VolumeTargetEncryption(dict):
    def __init__(__self__, *,
                 format: _builtins.str,
                 cipher: Optional['outputs.VolumeTargetEncryptionCipher'] = None,
                 ivgen: Optional['outputs.VolumeTargetEncryptionIvgen'] = None,
                 secret: Optional['outputs.VolumeTargetEncryptionSecret'] = None):
        """
        :param _builtins.str format: Sets the encryption format used for the volume; for LUKS volumes this is typically set to "luks".
               
               See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        :param 'VolumeTargetEncryptionCipherArgs' cipher: Defines the encryption cipher parameters used for the volume, such as algorithm name, mode, and hash.
        :param 'VolumeTargetEncryptionIvgenArgs' ivgen: Configures the initialization vector (IV) generation method for the encrypted volume; when present, both name and hash must be specified.
        :param 'VolumeTargetEncryptionSecretArgs' secret: Configures the libvirt secret used to supply the encryption key material for the volume.
        """
        pulumi.set(__self__, "format", format)
        if cipher is not None:
            pulumi.set(__self__, "cipher", cipher)
        if ivgen is not None:
            pulumi.set(__self__, "ivgen", ivgen)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def format(self) -> _builtins.str:
        """
        Sets the encryption format used for the volume; for LUKS volumes this is typically set to "luks".

        See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter
    def cipher(self) -> Optional['outputs.VolumeTargetEncryptionCipher']:
        """
        Defines the encryption cipher parameters used for the volume, such as algorithm name, mode, and hash.
        """
        return pulumi.get(self, "cipher")

    @_builtins.property
    @pulumi.getter
    def ivgen(self) -> Optional['outputs.VolumeTargetEncryptionIvgen']:
        """
        Configures the initialization vector (IV) generation method for the encrypted volume; when present, both name and hash must be specified.
        """
        return pulumi.get(self, "ivgen")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.VolumeTargetEncryptionSecret']:
        """
        Configures the libvirt secret used to supply the encryption key material for the volume.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class VolumeTargetEncryptionCipher(dict):
    def __init__(__self__, *,
                 hash: _builtins.str,
                 mode: _builtins.str,
                 name: _builtins.str,
                 size: _builtins.float):
        """
        :param _builtins.str hash: Sets the hash algorithm used with the encryption cipher (for example `sha256`), with the exact value being user-provided but expected to be supported by the chosen encryption format.
               
               See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        :param _builtins.str mode: Sets the cipher mode of operation (for example `cbc` or `xts`), with the value user-provided and constrained by the encryption backends supported modes.
               
               See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        :param _builtins.str name: Sets the base cipher algorithm name (for example `aes`), with the value user-provided and expected to be a valid algorithm for the images encryption format.
               
               See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        :param _builtins.float size: Sets the cipher key size in bits for the encrypted storage volume (user-provided integer such as 128, 256, etc.).
               
               See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        pulumi.set(__self__, "hash", hash)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def hash(self) -> _builtins.str:
        """
        Sets the hash algorithm used with the encryption cipher (for example `sha256`), with the exact value being user-provided but expected to be supported by the chosen encryption format.

        See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        return pulumi.get(self, "hash")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Sets the cipher mode of operation (for example `cbc` or `xts`), with the value user-provided and constrained by the encryption backends supported modes.

        See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the base cipher algorithm name (for example `aes`), with the value user-provided and expected to be a valid algorithm for the images encryption format.

        See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.float:
        """
        Sets the cipher key size in bits for the encrypted storage volume (user-provided integer such as 128, 256, etc.).

        See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class VolumeTargetEncryptionIvgen(dict):
    def __init__(__self__, *,
                 hash: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str hash: Sets the hash algorithm used by the IV generator (for example "sha1" or "sha256"); value is user-provided.
               
               See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        :param _builtins.str name: Sets the IV generation scheme name used by the encryption layer (for example "plain", "essiv", etc.); value is user-provided.
               
               See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        pulumi.set(__self__, "hash", hash)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def hash(self) -> _builtins.str:
        """
        Sets the hash algorithm used by the IV generator (for example "sha1" or "sha256"); value is user-provided.

        See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        return pulumi.get(self, "hash")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Sets the IV generation scheme name used by the encryption layer (for example "plain", "essiv", etc.); value is user-provided.

        See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class VolumeTargetEncryptionSecret(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Sets how the secret is referenced, typically "uuid" to reference a libvirt secret by its UUID.
               
               See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        :param _builtins.str uuid: Exposes the UUID of the libvirt secret object providing the encryption key; this is filled from the referenced secret and is read-only.
               
               See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        pulumi.set(__self__, "type", type)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Sets how the secret is referenced, typically "uuid" to reference a libvirt secret by its UUID.

        See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        Exposes the UUID of the libvirt secret object providing the encryption key; this is filled from the referenced secret and is read-only.

        See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class VolumeTargetFeature(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class VolumeTargetFormat(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: Specifies the backing store format type string (for example, "raw" or "qcow2"), which must be a format supported by the hypervisor.
               
               See: <https://libvirt.org/formatstorage.html#backing-store-elements>
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the backing store format type string (for example, "raw" or "qcow2"), which must be a format supported by the hypervisor.

        See: <https://libvirt.org/formatstorage.html#backing-store-elements>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class VolumeTargetPermissions(dict):
    def __init__(__self__, *,
                 group: Optional[_builtins.str] = None,
                 label: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 owner: Optional[_builtins.str] = None):
        """
        :param _builtins.str group: Sets the numeric group ID (gid) that owns the backing store file or device; the value is user-provided, for example `107`.
               
               See: <https://libvirt.org/formatstorage.html#backing-store-elements>
        :param _builtins.str label: Sets an SELinux security label for the backing store, when SELinux labeling is in use; the value is user-provided.
               
               See: <https://libvirt.org/formatstorage.html#backing-store-elements>
        :param _builtins.str mode: Sets the numeric file mode (permission bits) for the backing store, typically as an octal value such as `0640`.
               
               See: <https://libvirt.org/formatstorage.html#backing-store-elements>
        :param _builtins.str owner: Sets the numeric user ID (uid) that owns the backing store file or device; the value is user-provided, for example `107`.
               
               See: <https://libvirt.org/formatstorage.html#backing-store-elements>
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[_builtins.str]:
        """
        Sets the numeric group ID (gid) that owns the backing store file or device; the value is user-provided, for example `107`.

        See: <https://libvirt.org/formatstorage.html#backing-store-elements>
        """
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Sets an SELinux security label for the backing store, when SELinux labeling is in use; the value is user-provided.

        See: <https://libvirt.org/formatstorage.html#backing-store-elements>
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Sets the numeric file mode (permission bits) for the backing store, typically as an octal value such as `0640`.

        See: <https://libvirt.org/formatstorage.html#backing-store-elements>
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> Optional[_builtins.str]:
        """
        Sets the numeric user ID (uid) that owns the backing store file or device; the value is user-provided, for example `107`.

        See: <https://libvirt.org/formatstorage.html#backing-store-elements>
        """
        return pulumi.get(self, "owner")


@pulumi.output_type
class VolumeTargetTimestamps(dict):
    def __init__(__self__, *,
                 atime: _builtins.str,
                 ctime: _builtins.str,
                 mtime: _builtins.str):
        """
        :param _builtins.str atime: Sets the last access time of the volume, typically as a UNIX timestamp in seconds (and optional nanoseconds) since the epoch.
               
               See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        :param _builtins.str ctime: Sets the last metadata change time of the volume, typically as a UNIX timestamp in seconds (and optional nanoseconds) since the epoch.
               
               See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        :param _builtins.str mtime: Sets the last modification time (mtime) metadata for the volume target, using a user-provided timestamp value (seconds plus optional nanoseconds) that must be present for the volume definition. Examples: `seconds = 1716900000`, `seconds = 1716900000`, `nanoseconds = 123456789`.
               
               See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        pulumi.set(__self__, "atime", atime)
        pulumi.set(__self__, "ctime", ctime)
        pulumi.set(__self__, "mtime", mtime)

    @_builtins.property
    @pulumi.getter
    def atime(self) -> _builtins.str:
        """
        Sets the last access time of the volume, typically as a UNIX timestamp in seconds (and optional nanoseconds) since the epoch.

        See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        return pulumi.get(self, "atime")

    @_builtins.property
    @pulumi.getter
    def ctime(self) -> _builtins.str:
        """
        Sets the last metadata change time of the volume, typically as a UNIX timestamp in seconds (and optional nanoseconds) since the epoch.

        See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        return pulumi.get(self, "ctime")

    @_builtins.property
    @pulumi.getter
    def mtime(self) -> _builtins.str:
        """
        Sets the last modification time (mtime) metadata for the volume target, using a user-provided timestamp value (seconds plus optional nanoseconds) that must be present for the volume definition. Examples: `seconds = 1716900000`, `seconds = 1716900000`, `nanoseconds = 123456789`.

        See: <https://libvirt.org/formatstorage.html#storage-volume-target-elements>
        """
        return pulumi.get(self, "mtime")


@pulumi.output_type
class GetDomainInterfaceAddressesInterfaceResult(dict):
    def __init__(__self__, *,
                 addrs: Sequence['outputs.GetDomainInterfaceAddressesInterfaceAddrResult'],
                 hwaddr: _builtins.str,
                 name: _builtins.str):
        """
        :param Sequence['GetDomainInterfaceAddressesInterfaceAddrArgs'] addrs: List of IP addresses assigned to this interface.
        :param _builtins.str hwaddr: MAC address of the interface.
        :param _builtins.str name: Interface name on the host (e.g., `vnet0`).
        """
        pulumi.set(__self__, "addrs", addrs)
        pulumi.set(__self__, "hwaddr", hwaddr)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def addrs(self) -> Sequence['outputs.GetDomainInterfaceAddressesInterfaceAddrResult']:
        """
        List of IP addresses assigned to this interface.
        """
        return pulumi.get(self, "addrs")

    @_builtins.property
    @pulumi.getter
    def hwaddr(self) -> _builtins.str:
        """
        MAC address of the interface.
        """
        return pulumi.get(self, "hwaddr")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Interface name on the host (e.g., `vnet0`).
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDomainInterfaceAddressesInterfaceAddrResult(dict):
    def __init__(__self__, *,
                 addr: _builtins.str,
                 prefix: _builtins.float,
                 type: _builtins.str):
        """
        :param _builtins.str addr: IP address.
        :param _builtins.float prefix: Network prefix length (e.g., 24 for 255.255.255.0).
        :param _builtins.str type: Address type: `ipv4` or `ipv6`.
        """
        pulumi.set(__self__, "addr", addr)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def addr(self) -> _builtins.str:
        """
        IP address.
        """
        return pulumi.get(self, "addr")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> _builtins.float:
        """
        Network prefix length (e.g., 24 for 255.255.255.0).
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Address type: `ipv4` or `ipv6`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNodeDeviceInfoCapabilityResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 block: _builtins.str,
                 bus: _builtins.float,
                 class_: _builtins.str,
                 device_number: _builtins.float,
                 domain: _builtins.float,
                 drive_type: _builtins.str,
                 function: _builtins.float,
                 host: _builtins.float,
                 interface: _builtins.str,
                 iommu_group: _builtins.float,
                 link_speed: _builtins.str,
                 link_state: _builtins.str,
                 logical_block_size: _builtins.float,
                 lun: _builtins.float,
                 model: _builtins.str,
                 num_blocks: _builtins.float,
                 product_id: _builtins.str,
                 product_name: _builtins.str,
                 scsi_type: _builtins.str,
                 serial: _builtins.str,
                 size: _builtins.float,
                 slot: _builtins.float,
                 target: _builtins.float,
                 type: _builtins.str,
                 vendor_id: _builtins.str,
                 vendor_name: _builtins.str):
        """
        :param _builtins.str address: MAC address or device address.
        :param _builtins.str block: Block device path (e.g., `/dev/sda`).
        :param _builtins.float bus: PCI/USB bus number.
        :param _builtins.str class_: PCI class code (e.g., `0x030000` for VGA).
        :param _builtins.float device_number: USB device number.
        :param _builtins.float domain: PCI domain number.
        :param _builtins.str drive_type: Drive type (e.g., `disk`, `cdrom`).
        :param _builtins.float function: PCI function number.
        :param _builtins.float host: SCSI host number.
        :param _builtins.str interface: Network interface name (e.g., `eth0`).
        :param _builtins.float iommu_group: IOMMU group number (for PCI passthrough).
        :param _builtins.str link_speed: Network link speed.
        :param _builtins.str link_state: Network link state (e.g., `up`, `down`).
        :param _builtins.float logical_block_size: Logical block size in bytes.
        :param _builtins.float lun: SCSI LUN (Logical Unit Number).
        :param _builtins.str model: Device model name.
        :param _builtins.float num_blocks: Number of blocks.
        :param _builtins.str product_id: Product ID (vendor-specific identifier).
        :param _builtins.str product_name: Product name or description.
        :param _builtins.str scsi_type: SCSI device type.
        :param _builtins.str serial: Device serial number.
        :param _builtins.float size: Storage capacity in bytes.
        :param _builtins.float slot: PCI slot number.
        :param _builtins.float target: SCSI target number.
        :param _builtins.str type: Capability type (e.g., `pci`, `usb_device`, `net`, `storage`).
        :param _builtins.str vendor_id: Vendor ID.
        :param _builtins.str vendor_name: Vendor name.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "block", block)
        pulumi.set(__self__, "bus", bus)
        pulumi.set(__self__, "class_", class_)
        pulumi.set(__self__, "device_number", device_number)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "drive_type", drive_type)
        pulumi.set(__self__, "function", function)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "interface", interface)
        pulumi.set(__self__, "iommu_group", iommu_group)
        pulumi.set(__self__, "link_speed", link_speed)
        pulumi.set(__self__, "link_state", link_state)
        pulumi.set(__self__, "logical_block_size", logical_block_size)
        pulumi.set(__self__, "lun", lun)
        pulumi.set(__self__, "model", model)
        pulumi.set(__self__, "num_blocks", num_blocks)
        pulumi.set(__self__, "product_id", product_id)
        pulumi.set(__self__, "product_name", product_name)
        pulumi.set(__self__, "scsi_type", scsi_type)
        pulumi.set(__self__, "serial", serial)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "slot", slot)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vendor_id", vendor_id)
        pulumi.set(__self__, "vendor_name", vendor_name)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        MAC address or device address.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def block(self) -> _builtins.str:
        """
        Block device path (e.g., `/dev/sda`).
        """
        return pulumi.get(self, "block")

    @_builtins.property
    @pulumi.getter
    def bus(self) -> _builtins.float:
        """
        PCI/USB bus number.
        """
        return pulumi.get(self, "bus")

    @_builtins.property
    @pulumi.getter(name="class")
    def class_(self) -> _builtins.str:
        """
        PCI class code (e.g., `0x030000` for VGA).
        """
        return pulumi.get(self, "class_")

    @_builtins.property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> _builtins.float:
        """
        USB device number.
        """
        return pulumi.get(self, "device_number")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.float:
        """
        PCI domain number.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="driveType")
    def drive_type(self) -> _builtins.str:
        """
        Drive type (e.g., `disk`, `cdrom`).
        """
        return pulumi.get(self, "drive_type")

    @_builtins.property
    @pulumi.getter
    def function(self) -> _builtins.float:
        """
        PCI function number.
        """
        return pulumi.get(self, "function")

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.float:
        """
        SCSI host number.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def interface(self) -> _builtins.str:
        """
        Network interface name (e.g., `eth0`).
        """
        return pulumi.get(self, "interface")

    @_builtins.property
    @pulumi.getter(name="iommuGroup")
    def iommu_group(self) -> _builtins.float:
        """
        IOMMU group number (for PCI passthrough).
        """
        return pulumi.get(self, "iommu_group")

    @_builtins.property
    @pulumi.getter(name="linkSpeed")
    def link_speed(self) -> _builtins.str:
        """
        Network link speed.
        """
        return pulumi.get(self, "link_speed")

    @_builtins.property
    @pulumi.getter(name="linkState")
    def link_state(self) -> _builtins.str:
        """
        Network link state (e.g., `up`, `down`).
        """
        return pulumi.get(self, "link_state")

    @_builtins.property
    @pulumi.getter(name="logicalBlockSize")
    def logical_block_size(self) -> _builtins.float:
        """
        Logical block size in bytes.
        """
        return pulumi.get(self, "logical_block_size")

    @_builtins.property
    @pulumi.getter
    def lun(self) -> _builtins.float:
        """
        SCSI LUN (Logical Unit Number).
        """
        return pulumi.get(self, "lun")

    @_builtins.property
    @pulumi.getter
    def model(self) -> _builtins.str:
        """
        Device model name.
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter(name="numBlocks")
    def num_blocks(self) -> _builtins.float:
        """
        Number of blocks.
        """
        return pulumi.get(self, "num_blocks")

    @_builtins.property
    @pulumi.getter(name="productId")
    def product_id(self) -> _builtins.str:
        """
        Product ID (vendor-specific identifier).
        """
        return pulumi.get(self, "product_id")

    @_builtins.property
    @pulumi.getter(name="productName")
    def product_name(self) -> _builtins.str:
        """
        Product name or description.
        """
        return pulumi.get(self, "product_name")

    @_builtins.property
    @pulumi.getter(name="scsiType")
    def scsi_type(self) -> _builtins.str:
        """
        SCSI device type.
        """
        return pulumi.get(self, "scsi_type")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        """
        Device serial number.
        """
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.float:
        """
        Storage capacity in bytes.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def slot(self) -> _builtins.float:
        """
        PCI slot number.
        """
        return pulumi.get(self, "slot")

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.float:
        """
        SCSI target number.
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Capability type (e.g., `pci`, `usb_device`, `net`, `storage`).
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vendorId")
    def vendor_id(self) -> _builtins.str:
        """
        Vendor ID.
        """
        return pulumi.get(self, "vendor_id")

    @_builtins.property
    @pulumi.getter(name="vendorName")
    def vendor_name(self) -> _builtins.str:
        """
        Vendor name.
        """
        return pulumi.get(self, "vendor_name")


